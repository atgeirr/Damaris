!<arch>
adv5.F/         1298670057  19071 8000  100644  49064     `


      subroutine adv5s(bflag,bsq,xh,rxh,uh,ruh,xf,vh,rvh,gz,mh,rmh,          &
                       rho0,rr0,rf0,rrf0,advx,advy,advz,dum,divx,mass,   &
                       rru,rrv,rrw,s1,s,sten,pdef,dt)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      integer bflag
      real*8 bsq
      real, dimension(ib:ie) :: xh,rxh,uh,ruh
      real, dimension(ib:ie+1) :: xf
      real, dimension(jb:je) :: vh,rvh
      real, dimension(itb:ite,jtb:jte) :: gz
      real, dimension(ib:ie,jb:je,kb:ke) :: mh,rmh,rho0,rr0,rf0,rrf0
      real, dimension(ib:ie,jb:je,kb:ke) :: advx,advy,advz,dum,divx,mass
      real, dimension(ib:ie+1,jb:je,kb:ke) :: rru
      real, dimension(ib:ie,jb:je+1,kb:ke) :: rrv
      real, dimension(ib:ie,jb:je,kb:ke+1) :: rrw
      real, dimension(ib:ie,jb:je,kb:ke) :: s1,s,sten
      integer pdef
      real dt
 
      integer i,j,k,i1,i2,j1,j2
      real, parameter :: tem = 1.0/60.0
      real, parameter :: tem2 = 1.0/6.0

!----------------------------------------------------------------
! Advection in x-direction

      i1 = 1
      i2 = ni+1

      if(wbc.eq.2 .and. ibw.eq.1)then
        i1=4
      endif

      if(ebc.eq.2 .and. ibe.eq.1)then
        i2=ni-2
      endif

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=i1,i2
#ifdef SGN
        ! this form of code is used for IBM/xlf compiler:
        dum(i,j,k)=rru(i,j,k)*( 37.0*(s(i  ,j,k)+s(i-1,j,k))     &
                                -8.0*(s(i+1,j,k)+s(i-2,j,k))     &
                                    +(s(i+2,j,k)+s(i-3,j,k))     &
        -sign(1.0,rru(i,j,k))*( 10.0*(s(i  ,j,k)-s(i-1,j,k))     &
                                -5.0*(s(i+1,j,k)-s(i-2,j,k))     &
                                    +(s(i+2,j,k)-s(i-3,j,k)) ) )*tem
#else
        ! this seems to be faster on most other platforms:
        if(rru(i,j,k).ge.0.)then
          dum(i,j,k)=rru(i,j,k)*( 2.*s(i-3,j,k)-13.*s(i-2,j,k)   &
                +47.*s(i-1,j,k)+27.*s(i,j,k)-3.*s(i+1,j,k) )*tem
        else
          dum(i,j,k)=rru(i,j,k)*( 2.*s(i+2,j,k)-13.*s(i+1,j,k)   &
                +47.*s(i,j,k)+27.*s(i-1,j,k)-3.*s(i-2,j,k) )*tem
        endif
#endif
      enddo
      enddo
      enddo

      IF(wbc.eq.2 .and. ibw.eq.1) call advbcsw(dum,rru,s)

      IF(ebc.eq.2 .and. ibe.eq.1) call advbcse(xf,dum,rru,s)

    IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        advx(i,j,k)=-(dum(i+1,j,k)-dum(i,j,k))*rdx*uh(i)
      enddo
      enddo
      enddo

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        advx(i,j,k)=-(xf(i+1)*dum(i+1,j,k)-xf(i)*dum(i,j,k))*rdx*uh(i)*rxh(i)
      enddo
      enddo
      enddo

    ENDIF

      IF(stat_qsrc.eq.1.and.(wbc.eq.2.or.ebc.eq.2).and.bflag.eq.1)THEN
        if(timestats.ge.1) time_advs=time_advs+mytime()
        call bsx(dt,bsq,rvh,rmh,dum)
      ENDIF

      IF(pdscheme.eq.1 .and. pdef.eq.1)THEN
        if(timestats.ge.1) time_advs=time_advs+mytime()
        call pdefx(xh,rho0,advx,dum,mass,s1,dt)
      ENDIF

      IF(wbc.eq.2 .and. ibw.eq.1)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
          i=1
          if(rru(i,j,k).ge.0.0)then
            advx(i,j,k)=advx(i,j,k)-s(i,j,k)*(rru(i+1,j,k)-rru(i,j,k))*rdx*uh(i)
          endif
        enddo
        enddo
      ENDIF

      IF(ebc.eq.2 .and. ibe.eq.1)THEN

      IF(axisymm.eq.0)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
          i=ni+1
          if(rru(i,j,k).lt.0.0)then
            i=ni
            advx(i,j,k)=advx(i,j,k)-s(i,j,k)*(rru(i+1,j,k)-rru(i,j,k))*rdx*uh(i)
          endif
        enddo
        enddo
      ELSE
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
          i=ni+1
          if(rru(i,j,k).lt.0.0)then
            i=ni
            advx(i,j,k)=advx(i,j,k)-s(i,j,k)*(xf(i+1)*rru(i+1,j,k)-xf(i)*rru(i,j,k))*rdx*uh(i)*rxh(i)
          endif
        enddo
        enddo
      ENDIF

      ENDIF

!----------------------------------------------------------------
! Advection in y-direction

    IF(axisymm.eq.0)THEN

      j1 = 1
      j2 = nj+1

      if(sbc.eq.2 .and. ibs.eq.1)then
        j1=4
      endif

      if(nbc.eq.2 .and. ibn.eq.1)then
        j2=nj-2
      endif

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=j1,j2
      do i=1,ni
#ifdef SGN
        ! this form of code is used for IBM/xlf compiler:
        dum(i,j,k)=rrv(i,j,k)*( 37.0*(s(i,j  ,k)+s(i,j-1,k))     &
                                -8.0*(s(i,j+1,k)+s(i,j-2,k))     &
                                    +(s(i,j+2,k)+s(i,j-3,k))     &
        -sign(1.0,rrv(i,j,k))*( 10.0*(s(i,j  ,k)-s(i,j-1,k))     &
                                -5.0*(s(i,j+1,k)-s(i,j-2,k))     &
                                    +(s(i,j+2,k)-s(i,j-3,k)) ) )*tem
#else
        ! this seems to be faster on most other platforms:
        if(rrv(i,j,k).ge.0.)then
          dum(i,j,k)=rrv(i,j,k)*( 2.*s(i,j-3,k)-13.*s(i,j-2,k)   &
                +47.*s(i,j-1,k)+27.*s(i,j,k)-3.*s(i,j+1,k) )*tem
        else
          dum(i,j,k)=rrv(i,j,k)*( 2.*s(i,j+2,k)-13.*s(i,j+1,k)   &
                +47.*s(i,j,k)+27.*s(i,j-1,k)-3.*s(i,j-2,k) )*tem
        endif
#endif
      enddo
      enddo
      enddo

      IF(sbc.eq.2 .and. ibs.eq.1) call advbcss(dum,rrv,s)

      IF(nbc.eq.2 .and. ibn.eq.1) call advbcsn(dum,rrv,s)

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        advy(i,j,k)=-(dum(i,j+1,k)-dum(i,j,k))*rdy*vh(j)
      enddo
      enddo
      enddo

      IF(stat_qsrc.eq.1.and.(sbc.eq.2.or.nbc.eq.2).and.bflag.eq.1)THEN
        if(timestats.ge.1) time_advs=time_advs+mytime()
        call bsy(dt,bsq,ruh,rmh,dum)
      ENDIF

      IF(pdscheme.eq.1 .and. pdef.eq.1)THEN
        if(timestats.ge.1) time_advs=time_advs+mytime()
        call pdefy(rho0,advy,dum,mass,s1,dt)
      ENDIF

      IF(sbc.eq.2 .and. ibs.eq.1)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do i=1,ni
          j=1
          if(rrv(i,j,k).ge.0.0)then
            advy(i,j,k)=advy(i,j,k)-s(i,j,k)*(rrv(i,j+1,k)-rrv(i,j,k))*rdy*vh(j)
          endif
        enddo
        enddo
      ENDIF

      IF(nbc.eq.2 .and. ibn.eq.1)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do i=1,ni
          j=nj+1
          if(rrv(i,j,k).lt.0.0)then
            j=nj
            advy(i,j,k)=advy(i,j,k)-s(i,j,k)*(rrv(i,j+1,k)-rrv(i,j,k))*rdy*vh(j)
          endif
        enddo
        enddo
      ENDIF

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        advy(i,j,k)=0.0
      enddo
      enddo
      enddo

    ENDIF

!----------------------------------------------------------------

      if(vadvorder.eq.5)then
        call vadv5s(gz,mh,rho0,advz,dum,mass,rrw,s1,s,pdef,dt)
      elseif(vadvorder.eq.6)then
        call vadv6s(gz,mh,rho0,advz,dum,mass,rrw,s1,s,pdef,dt)
      endif

!----------------------------------------------------------------

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        sten(i,j,k)=sten(i,j,k)+( advx(i,j,k)+advy(i,j,k)+advz(i,j,k)    &
                                 +s(i,j,k)*divx(i,j,k) )*rr0(i,j,k)
      enddo
      enddo
      enddo

!----------------------------------------------------------------
 
      if(timestats.ge.1) time_advs=time_advs+mytime()
 
      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine vadv5s(gz,mh,rho0,advz,dum,mass,rrw,s1,s,pdef,dt)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, dimension(itb:ite,jtb:jte) :: gz
      real, dimension(ib:ie,jb:je,kb:ke) :: mh,rho0
      real, dimension(ib:ie,jb:je,kb:ke) :: advz,dum,mass
      real, dimension(ib:ie,jb:je,kb:ke+1) :: rrw
      real, dimension(ib:ie,jb:je,kb:ke) :: s1,s
      integer pdef
      real dt

      integer i,j,k
      real, parameter :: tem1 = 1.0/60.0
      real, parameter :: tem2 = 1.0/6.0
      real, parameter :: tem3 = 1.0/12.0

!----------------------------------------------------------------
! Advection in z-direction

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=4,nk-2
      do j=1,nj
      do i=1,ni
#ifdef SGN
        ! this form of code is used for IBM/xlf compiler:
        dum(i,j,k)=rrw(i,j,k)*( 37.0*(s(i,j,k  )+s(i,j,k-1))     &
                                -8.0*(s(i,j,k+1)+s(i,j,k-2))     &
                                    +(s(i,j,k+2)+s(i,j,k-3))     &
        -sign(1.0,rrw(i,j,k))*( 10.0*(s(i,j,k  )-s(i,j,k-1))     &
                                -5.0*(s(i,j,k+1)-s(i,j,k-2))     &
                                    +(s(i,j,k+2)-s(i,j,k-3)) ) )*tem1
#else
        ! this seems to be faster on most other platforms:
        if(rrw(i,j,k).ge.0.)then
          dum(i,j,k)=rrw(i,j,k)*( 2.*s(i,j,k-3)-13.*s(i,j,k-2)      &
                +47.*s(i,j,k-1)+27.*s(i,j,k)-3.*s(i,j,k+1) )*tem1
        else
          dum(i,j,k)=rrw(i,j,k)*( 2.*s(i,j,k+2)-13.*s(i,j,k+1)      &
                +47.*s(i,j,k)+27.*s(i,j,k-1)-3.*s(i,j,k-2) )*tem1
        endif
#endif
      enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=3,(nk-1),(nk-4)
      do j=1,nj
      do i=1,ni
#ifdef SGN
        ! this form of code is used for IBM/xlf compiler:
        dum(i,j,k)=rrw(i,j,k)*( 7.0*(s(i,j,k  )+s(i,j,k-1))          &
                                   -(s(i,j,k+1)+s(i,j,k-2))          &
        -sign(1.0,rrw(i,j,k))*( 3.0*(s(i,j,k  )-s(i,j,k-1))          &
                                   -(s(i,j,k+1)-s(i,j,k-2)) ) )*tem3
#else
        ! this seems to be faster on most other platforms:
        if(rrw(i,j,k).ge.0.)then
          dum(i,j,k)=rrw(i,j,k)    &
                    *(-s(i,j,k-2)+5.*s(i,j,k-1)+2.*s(i,j,k))*tem2
        else
          dum(i,j,k)=rrw(i,j,k)    &
                    *(-s(i,j,k+1)+5.*s(i,j,k)+2.*s(i,j,k-1))*tem2
        endif
#endif
      enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk,(nk-2)
      do j=1,nj
      do i=1,ni
        dum(i,j,k)=rrw(i,j,k)*0.5*(s(i,j,k-1)+s(i,j,k))
      enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,(nk+1),nk
      do j=1,nj
      do i=1,ni
        dum(i,j,k)=0.0
      enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        advz(i,j,k)=-(dum(i,j,k+1)-dum(i,j,k))*rdz*mh(i,j,k)
      enddo
      enddo
      enddo

      IF(terrain_flag)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          advz(i,j,k)=advz(i,j,k)/gz(i,j)
        enddo
        enddo
        enddo

      ENDIF

      IF(pdscheme.eq.1 .and. pdef.eq.1)THEN
        if(timestats.ge.1) time_advs=time_advs+mytime()
        call pdefz(rho0,advz,dum,mass,s1,dt)
      ENDIF

!----------------------------------------------------------------
 
      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine adv5u(xf,rxf,uf,vh,gz,mh,rho0,rr0,rf0,rrf0,rru0,dum,advx,advy,advz,divx, &
                       rru,u3d,uten,rrv,rrw)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real, dimension(ib:ie+1) :: xf,rxf,uf
      real, dimension(jb:je) :: vh
      real, dimension(itb:ite,jtb:jte) :: gz
      real, dimension(ib:ie,jb:je,kb:ke) :: mh,rho0,rr0,rf0,rrf0,rru0
      real, dimension(ib:ie,jb:je,kb:ke) :: dum,advx,advy,advz,divx
      real, dimension(ib:ie+1,jb:je,kb:ke) :: rru,u3d,uten
      real, dimension(ib:ie,jb:je+1,kb:ke) :: rrv
      real, dimension(ib:ie,jb:je,kb:ke+1) :: rrw
 
      integer i,j,k,i1,i2,j1,j2,id1,id2
      real, parameter :: tem = 1.0/120.0

!------------------------------------------------------------

      if(ibw.eq.1)then
        i1=2
      else
        i1=1
      endif
 
      if(ibe.eq.1)then
        i2=ni+1-1
      else
        i2=ni+1
      endif
 
!----------------------------------------------------------------
! Advection in x-direction

      id1 = i1-1
      id2 = i2

      if(wbc.eq.2 .and. ibw.eq.1)then
        id1 = 3
      endif

      if(ebc.eq.2 .and. ibe.eq.1)then
        id2 = ni-2
      endif

    IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=id1,id2
#ifdef SGN
        ! this form of code is used for IBM/xlf compiler:
        dum(i,j,k)=(rru(i,j,k)+rru(i+1,j,k))                         &
                             *( 37.0*(u3d(i+1,j,k)+u3d(i  ,j,k))     &
                                -8.0*(u3d(i+2,j,k)+u3d(i-1,j,k))     &
                                    +(u3d(i+3,j,k)+u3d(i-2,j,k))     &
        -sign(1.0,(rru(i,j,k)+rru(i+1,j,k)))                         &
                             *( 10.0*(u3d(i+1,j,k)-u3d(i  ,j,k))     &
                                -5.0*(u3d(i+2,j,k)-u3d(i-1,j,k))     &
                                    +(u3d(i+3,j,k)-u3d(i-2,j,k)) ) )*tem
#else
        ! this seems to be faster on most other platforms:
        if((rru(i,j,k)+rru(i+1,j,k)).ge.0.)then
          dum(i,j,k)=(rru(i,j,k)+rru(i+1,j,k))*                     &
                 ( 2.*u3d(i-2,j,k)-13.*u3d(i-1,j,k)+47.*u3d(i,j,k)   &
                  +27.*u3d(i+1,j,k)-3.*u3d(i+2,j,k) )*tem
        else
          dum(i,j,k)=(rru(i,j,k)+rru(i+1,j,k))*                       &
                 ( 2.*u3d(i+3,j,k)-13.*u3d(i+2,j,k)+47.*u3d(i+1,j,k)   &
                  +27.*u3d(i,j,k)-3.*u3d(i-1,j,k) )*tem
        endif
#endif
      enddo
      enddo
      enddo

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=id1,id2
#ifdef SGN
        ! this form of code is used for IBM/xlf compiler:
        dum(i,j,k)=(xf(i)*rru(i,j,k)+xf(i+1)*rru(i+1,j,k))           &
                             *( 37.0*(u3d(i+1,j,k)+u3d(i  ,j,k))     &
                                -8.0*(u3d(i+2,j,k)+u3d(i-1,j,k))     &
                                    +(u3d(i+3,j,k)+u3d(i-2,j,k))     &
        -sign(1.0,(rru(i,j,k)+rru(i+1,j,k)))                         &
                             *( 10.0*(u3d(i+1,j,k)-u3d(i  ,j,k))     &
                                -5.0*(u3d(i+2,j,k)-u3d(i-1,j,k))     &
                                    +(u3d(i+3,j,k)-u3d(i-2,j,k)) ) )*tem
#else
        ! this seems to be faster on most other platforms:
        if((rru(i,j,k)+rru(i+1,j,k)).ge.0.)then
          dum(i,j,k)=(xf(i)*rru(i,j,k)+xf(i+1)*rru(i+1,j,k))*                     &
                 ( 2.*u3d(i-2,j,k)-13.*u3d(i-1,j,k)+47.*u3d(i,j,k)   &
                  +27.*u3d(i+1,j,k)-3.*u3d(i+2,j,k) )*tem
        else
          dum(i,j,k)=(xf(i)*rru(i,j,k)+xf(i+1)*rru(i+1,j,k))*                       &
                 ( 2.*u3d(i+3,j,k)-13.*u3d(i+2,j,k)+47.*u3d(i+1,j,k)   &
                  +27.*u3d(i,j,k)-3.*u3d(i-1,j,k) )*tem
        endif
#endif
      enddo
      enddo
      enddo

    ENDIF

      IF(wbc.eq.2 .and. ibw.eq.1) call advbcuw(dum,rru,u3d)

      IF(ebc.eq.2 .and. ibe.eq.1) call advbcue(xf,dum,rru,u3d)

    IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=i1,i2
        advx(i,j,k)=-(dum(i,j,k)-dum(i-1,j,k))*rdx*uf(i)
      enddo
      enddo
      enddo

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=i1,i2
        advx(i,j,k)=-(dum(i,j,k)-dum(i-1,j,k))*rdx*uf(i)*rxf(i)
      enddo
      enddo
      enddo

    ENDIF

!----------------------------------------------------------------
! Advection in y-direction

    IF(axisymm.eq.0)THEN

      j1 = 1
      j2 = nj+1

      if(sbc.eq.2 .and. ibs.eq.1)then
        j1=4
      endif

      if(nbc.eq.2 .and. ibn.eq.1)then
        j2=nj-2
      endif

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=j1,j2
      do i=i1,i2
#ifdef SGN
        ! this form of code is used for IBM/xlf compiler:
        dum(i,j,k)=(rrv(i,j,k)+rrv(i-1,j,k))                         &
                             *( 37.0*(u3d(i,j  ,k)+u3d(i,j-1,k))     &
                                -8.0*(u3d(i,j+1,k)+u3d(i,j-2,k))     &
                                    +(u3d(i,j+2,k)+u3d(i,j-3,k))     &
        -sign(1.0,(rrv(i,j,k)+rrv(i-1,j,k)))                         &
                             *( 10.0*(u3d(i,j  ,k)-u3d(i,j-1,k))     &
                                -5.0*(u3d(i,j+1,k)-u3d(i,j-2,k))     &
                                    +(u3d(i,j+2,k)-u3d(i,j-3,k)) ) )*tem
#else
        ! this seems to be faster on most other platforms:
        if((rrv(i,j,k)+rrv(i-1,j,k)).ge.0.)then
          dum(i,j,k)=(rrv(i,j,k)+rrv(i-1,j,k))*                       &
                 ( 2.*u3d(i,j-3,k)-13.*u3d(i,j-2,k)+47.*u3d(i,j-1,k)   &
                  +27.*u3d(i,j,k)-3.*u3d(i,j+1,k) )*tem
        else
          dum(i,j,k)=(rrv(i,j,k)+rrv(i-1,j,k))*                     &
                 ( 2.*u3d(i,j+2,k)-13.*u3d(i,j+1,k)+47.*u3d(i,j,k)   &
                  +27.*u3d(i,j-1,k)-3.*u3d(i,j-2,k) )*tem
        endif
#endif
      enddo
      enddo
      enddo

      IF(sbc.eq.2 .and. ibs.eq.1) call advbcus(dum,u3d,rrv,i1,i2)

      IF(nbc.eq.2 .and. ibn.eq.1) call advbcun(dum,u3d,rrv,i1,i2)

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=i1,i2
        advy(i,j,k)=-(dum(i,j+1,k)-dum(i,j,k))*rdy*vh(j)
      enddo
      enddo
      enddo

      IF(sbc.eq.2 .and. ibs.eq.1)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do i=i1,i2
          j=1
          if((rrv(i,j,k)+rrv(i-1,j,k)).ge.0.0)then
            advy(i,j,k)=advy(i,j,k)-u3d(i,j,k)*0.5*(                    &
                            (rrv(i-1,j+1,k)-rrv(i-1,j,k))               &
                           +(rrv(i  ,j+1,k)-rrv(i  ,j,k)) )*rdy*vh(j)
          endif
        enddo
        enddo
      ENDIF

      IF(nbc.eq.2 .and. ibn.eq.1)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do i=i1,i2
          j=nj+1
          if((rrv(i,j,k)+rrv(i-1,j,k)).lt.0.0)then
            j=nj
            advy(i,j,k)=advy(i,j,k)-u3d(i,j,k)*0.5*(                    &
                            (rrv(i-1,j+1,k)-rrv(i-1,j,k))               &
                           +(rrv(i  ,j+1,k)-rrv(i  ,j,k)) )*rdy*vh(j)
          endif
        enddo
        enddo
      ENDIF

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=i1,i2
        advy(i,j,k)=0.0
      enddo
      enddo
      enddo

    ENDIF

!----------------------------------------------------------------

      if(vadvorder.eq.5)then
        call vadv5u(gz,mh,dum,advz,u3d,rrw,i1,i2)
      elseif(vadvorder.eq.6)then
        call vadv6u(gz,mh,dum,advz,u3d,rrw,i1,i2)
      endif

!----------------------------------------------------------------

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=i1,i2
        uten(i,j,k)=uten(i,j,k)+( advx(i,j,k)+advy(i,j,k)+advz(i,j,k)    &
                   +u3d(i,j,k)*0.5*(divx(i,j,k)+divx(i-1,j,k)) )*rru0(i,j,k)
      enddo
      enddo
      enddo
!----------------------------------------------------------------
 
      if(timestats.ge.1) time_advu=time_advu+mytime()
 
      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine vadv5u(gz,mh,dum,advz,u3d,rrw,i1,i2)
      implicit none

      include 'input.incl'
      include 'constants.incl'

      real, dimension(itb:ite,jtb:jte) :: gz
      real, dimension(ib:ie,jb:je,kb:ke) :: mh
      real, dimension(ib:ie,jb:je,kb:ke) :: dum,advz
      real, dimension(ib:ie+1,jb:je,kb:ke) :: u3d
      real, dimension(ib:ie,jb:je,kb:ke+1) :: rrw
      integer :: i1,i2

      integer i,j,k
      real, parameter :: tem1 = 1.0/120.0
      real, parameter :: tem2 = 1.0/12.0
      real, parameter :: tem3 = 1.0/24.0

!----------------------------------------------------------------
! Advection in z-direction

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=4,nk-2
      do j=1,nj
      do i=i1,i2
#ifdef SGN
        ! this form of code is used for IBM/xlf compiler:
        dum(i,j,k)=(rrw(i,j,k)+rrw(i-1,j,k))                         &
                             *( 37.0*(u3d(i,j,k  )+u3d(i,j,k-1))     &
                                -8.0*(u3d(i,j,k+1)+u3d(i,j,k-2))     &
                                    +(u3d(i,j,k+2)+u3d(i,j,k-3))     &
        -sign(1.0,(rrw(i,j,k)+rrw(i-1,j,k)))                         &
                             *( 10.0*(u3d(i,j,k  )-u3d(i,j,k-1))     &
                                -5.0*(u3d(i,j,k+1)-u3d(i,j,k-2))     &
                                    +(u3d(i,j,k+2)-u3d(i,j,k-3)) ) )*tem1
#else
        ! this seems to be faster on most other platforms:
        if((rrw(i,j,k)+rrw(i-1,j,k)).ge.0.)then
          dum(i,j,k)=(rrw(i,j,k)+rrw(i-1,j,k))*                       &
                 ( 2.*u3d(i,j,k-3)-13.*u3d(i,j,k-2)+47.*u3d(i,j,k-1)   &
                  +27.*u3d(i,j,k)-3.*u3d(i,j,k+1) )*tem1
        else
          dum(i,j,k)=(rrw(i,j,k)+rrw(i-1,j,k))*                     &
                 ( 2.*u3d(i,j,k+2)-13.*u3d(i,j,k+1)+47.*u3d(i,j,k)   &
                  +27.*u3d(i,j,k-1)-3.*u3d(i,j,k-2) )*tem1
        endif
#endif
      enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=3,(nk-1),(nk-4)
      do j=1,nj
      do i=i1,i2
#ifdef SGN
        ! this form of code is used for IBM/xlf compiler:
        dum(i,j,k)=(rrw(i,j,k)+rrw(i-1,j,k))                             &
                             *( 7.0*(u3d(i,j,k  )+u3d(i,j,k-1))          &
                                   -(u3d(i,j,k+1)+u3d(i,j,k-2))          &
        -sign(1.0,(rrw(i,j,k)+rrw(i-1,j,k)))                             &
                             *( 3.0*(u3d(i,j,k  )-u3d(i,j,k-1))          &
                                   -(u3d(i,j,k+1)-u3d(i,j,k-2)) ) )*tem3
#else
        ! this seems to be faster on most other platforms:
        if((rrw(i,j,k)+rrw(i-1,j,k)).ge.0.)then
          dum(i,j,k)=(rrw(i,j,k)+rrw(i-1,j,k))*   &
                 (-u3d(i,j,k-2)+5.*u3d(i,j,k-1)+2.*u3d(i,j,k  ))*tem2
        else
          dum(i,j,k)=(rrw(i,j,k)+rrw(i-1,j,k))*   &
                 (-u3d(i,j,k+1)+5.*u3d(i,j,k  )+2.*u3d(i,j,k-1))*tem2
        endif
#endif
      enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk,(nk-2)
      do j=1,nj
      do i=i1,i2
        dum(i,j,k)=0.25*(rrw(i,j,k)+rrw(i-1,j,k))    &
                       *(u3d(i,j,k-1)+u3d(i,j,k))
      enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,(nk+1),nk
      do j=1,nj
      do i=i1,i2
        dum(i,j,k)=0.0
      enddo
      enddo
      enddo

      IF(terrain_flag)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=i1,i2
          advz(i,j,k)=-(dum(i,j,k+1)-dum(i,j,k))*rdz*0.5*(mh(i-1,j,k)/gz(i-1,j)+mh(i,j,k)/gz(i,j))
        enddo
        enddo
        enddo

      ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=i1,i2
          advz(i,j,k)=-(dum(i,j,k+1)-dum(i,j,k))*rdz*0.5*(mh(i-1,j,k)+mh(i,j,k))
        enddo
        enddo
        enddo

      ENDIF

!----------------------------------------------------------------
 
      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine adv5v(xh,rxh,uh,xf,vf,gz,mh,rho0,rr0,rf0,rrf0,rrv0,dum,advx,advy,advz,divx, &
                       rru,rrv,v3d,vten,rrw)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real, dimension(ib:ie) :: xh,rxh,uh
      real, dimension(ib:ie+1) :: xf
      real, dimension(jb:je+1) :: vf
      real, dimension(itb:ite,jtb:jte) :: gz
      real, dimension(ib:ie,jb:je,kb:ke) :: mh,rho0,rr0,rf0,rrf0,rrv0
      real, dimension(ib:ie,jb:je,kb:ke) :: dum,advx,advy,advz,divx
      real, dimension(ib:ie+1,jb:je,kb:ke) :: rru
      real, dimension(ib:ie,jb:je+1,kb:ke) :: rrv,v3d,vten
      real, dimension(ib:ie,jb:je,kb:ke+1) :: rrw
 
      integer i,j,k,i1,i2,j1,j2,jd1,jd2
      real, parameter :: tem = 1.0/120.0
 
!------------------------------------------------------------

      if(ibs.eq.1)then
        j1=2
      else
        j1=1
      endif
 
      if(ibn.eq.1)then
        j2=nj+1-1
      else
        j2=nj+1
      endif
 
!----------------------------------------------------------------
! Advection in x-direction

      i1 = 1
      i2 = ni+1

      if(wbc.eq.2 .and. ibw.eq.1)then
        i1=4
      endif

      if(ebc.eq.2 .and. ibe.eq.1)then
        i2=ni-2
      endif

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=j1,j2
      do i=i1,i2
#ifdef SGN
        ! this form of code is used for IBM/xlf compiler:
        dum(i,j,k)=(rru(i,j,k)+rru(i,j-1,k))                         &
                             *( 37.0*(v3d(i  ,j,k)+v3d(i-1,j,k))     &
                                -8.0*(v3d(i+1,j,k)+v3d(i-2,j,k))     &
                                    +(v3d(i+2,j,k)+v3d(i-3,j,k))     &
        -sign(1.0,(rru(i,j,k)+rru(i,j-1,k)))                         &
                             *( 10.0*(v3d(i  ,j,k)-v3d(i-1,j,k))     &
                                -5.0*(v3d(i+1,j,k)-v3d(i-2,j,k))     &
                                    +(v3d(i+2,j,k)-v3d(i-3,j,k)) ) )*tem
#else
        ! this seems to be faster on most other platforms:
        if((rru(i,j,k)+rru(i,j-1,k)).ge.0.)then
          dum(i,j,k)=(rru(i,j,k)+rru(i,j-1,k))*                        &
                 ( 2.*v3d(i-3,j,k)-13.*v3d(i-2,j,k)+47.*v3d(i-1,j,k)    &
                  +27.*v3d(i,j,k)-3.*v3d(i+1,j,k) )*tem
        else
          dum(i,j,k)=(rru(i,j,k)+rru(i,j-1,k))*                      &
                 ( 2.*v3d(i+2,j,k)-13.*v3d(i+1,j,k)+47.*v3d(i,j,k)    &
                  +27.*v3d(i-1,j,k)-3.*v3d(i-2,j,k) )*tem
        endif
#endif
      enddo
      enddo
      enddo

      IF(wbc.eq.2 .and. ibw.eq.1) call advbcvw(dum,rru,v3d,j1,j2)

      IF(ebc.eq.2 .and. ibe.eq.1) call advbcve(xf,dum,rru,v3d,j1,j2)

    IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=j1,j2
      do i=1,ni
        advx(i,j,k)=-(dum(i+1,j,k)-dum(i,j,k))*rdx*uh(i)
      enddo
      enddo
      enddo

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=j1,j2
      do i=1,ni
        advx(i,j,k)=-(xf(i+1)*dum(i+1,j,k)-xf(i)*dum(i,j,k))*rdx*uh(i)*rxh(i)
      enddo
      enddo
      enddo

    ENDIF

      IF(wbc.eq.2 .and. ibw.eq.1)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=j1,j2
          i=1
          if((rru(i,j,k)+rru(i,j-1,k)).ge.0.0)then
            advx(i,j,k)=advx(i,j,k)-v3d(i,j,k)*0.5*(            &
                    (rru(i+1,j-1,k)-rru(i,j-1,k))               &
                   +(rru(i+1,j  ,k)-rru(i,j  ,k)) )*rdx*uh(i)
          endif
        enddo
        enddo
      ENDIF

      IF(ebc.eq.2 .and. ibe.eq.1)THEN

      IF(axisymm.eq.0)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=j1,j2
          i=ni+1
          if((rru(i,j,k)+rru(i,j-1,k)).lt.0.0)then
            i=ni
            advx(i,j,k)=advx(i,j,k)-v3d(i,j,k)*0.5*(            &
                    (rru(i+1,j-1,k)-rru(i,j-1,k))               &
                   +(rru(i+1,j  ,k)-rru(i,j  ,k)) )*rdx*uh(i)
          endif
        enddo
        enddo
      ELSE
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=j1,j2
          i=ni+1
          if((rru(i,j,k)+rru(i,j-1,k)).lt.0.0)then
            i=ni
            advx(i,j,k)=advx(i,j,k)-v3d(i,j,k)*0.5*(            &
                    (xf(i+1)*rru(i+1,j-1,k)-xf(i)*rru(i,j-1,k))               &
                   +(xf(i+1)*rru(i+1,j  ,k)-xf(i)*rru(i,j  ,k)) )*rdx*uh(i)*rxh(i)
          endif
        enddo
        enddo
      ENDIF

      ENDIF

!----------------------------------------------------------------
! Advection in y-direction

    IF(axisymm.eq.0)THEN

      jd1 = j1-1
      jd2 = j2

      if(sbc.eq.2 .and. ibs.eq.1)then
        jd1 = 3
      endif

      if(nbc.eq.2 .and. ibn.eq.1)then
        jd2 = nj-2
      endif

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=jd1,jd2
      do i=1,ni
#ifdef SGN
        ! this form of code is used for IBM/xlf compiler:
        dum(i,j,k)=(rrv(i,j,k)+rrv(i,j+1,k))                         &
                             *( 37.0*(v3d(i,j+1,k)+v3d(i,j  ,k))     &
                                -8.0*(v3d(i,j+2,k)+v3d(i,j-1,k))     &
                                    +(v3d(i,j+3,k)+v3d(i,j-2,k))     &
        -sign(1.0,(rrv(i,j,k)+rrv(i,j+1,k)))                         &
                             *( 10.0*(v3d(i,j+1,k)-v3d(i,j  ,k))     &
                                -5.0*(v3d(i,j+2,k)-v3d(i,j-1,k))     &
                                    +(v3d(i,j+3,k)-v3d(i,j-2,k)) ) )*tem
#else
        ! this seems to be faster on most other platforms:
        if((rrv(i,j,k)+rrv(i,j+1,k)).ge.0.)then
          dum(i,j,k)=(rrv(i,j,k)+rrv(i,j+1,k))*                      &
                 ( 2.*v3d(i,j-2,k)-13.*v3d(i,j-1,k)+47.*v3d(i,j,k)    &
                  +27.*v3d(i,j+1,k)-3.*v3d(i,j+2,k) )*tem
        else
          dum(i,j,k)=(rrv(i,j,k)+rrv(i,j+1,k))*                        &
                 ( 2.*v3d(i,j+3,k)-13.*v3d(i,j+2,k)+47.*v3d(i,j+1,k)    &
                  +27.*v3d(i,j,k)-3.*v3d(i,j-1,k) )*tem
        endif
#endif
      enddo
      enddo
      enddo

      IF(sbc.eq.2 .and. ibs.eq.1) call advbcvs(dum,rrv,v3d)

      IF(nbc.eq.2 .and. ibn.eq.1) call advbcvn(dum,rrv,v3d)

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=j1,j2
      do i=1,ni
        advy(i,j,k)=-(dum(i,j,k)-dum(i,j-1,k))*rdy*vf(j)
      enddo
      enddo
      enddo

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=j1,j2
      do i=1,ni
        advy(i,j,k)=0.0
      enddo
      enddo
      enddo

    ENDIF

!----------------------------------------------------------------

      if(vadvorder.eq.5)then
        call vadv5v(gz,mh,dum,advz,v3d,rrw,j1,j2)
      elseif(vadvorder.eq.6)then
        call vadv6v(gz,mh,dum,advz,v3d,rrw,j1,j2)
      endif

!----------------------------------------------------------------

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=j1,j2
      do i=1,ni
        vten(i,j,k)=vten(i,j,k)+( advx(i,j,k)+advy(i,j,k)+advz(i,j,k)    &
                   +v3d(i,j,k)*0.5*(divx(i,j,k)+divx(i,j-1,k)) )*rrv0(i,j,k)
      enddo
      enddo
      enddo

!----------------------------------------------------------------
 
      if(timestats.ge.1) time_advv=time_advv+mytime()
 
      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine vadv5v(gz,mh,dum,advz,v3d,rrw,j1,j2)
      implicit none

      include 'input.incl'
      include 'constants.incl'

      real, dimension(itb:ite,jtb:jte) :: gz
      real, dimension(ib:ie,jb:je,kb:ke) :: mh
      real, dimension(ib:ie,jb:je,kb:ke) :: dum,advz
      real, dimension(ib:ie,jb:je+1,kb:ke) :: v3d
      real, dimension(ib:ie,jb:je,kb:ke+1) :: rrw
      integer :: j1,j2

      integer i,j,k
      real, parameter :: tem1 = 1.0/120.0
      real, parameter :: tem2 = 1.0/12.0
      real, parameter :: tem3 = 1.0/24.0

!----------------------------------------------------------------
! Advection in z-direction

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=4,nk-2
      do j=j1,j2
      do i=1,ni
#ifdef SGN
        ! this form of code is used for IBM/xlf compiler:
        dum(i,j,k)=(rrw(i,j,k)+rrw(i,j-1,k))                         &
                             *( 37.0*(v3d(i,j,k  )+v3d(i,j,k-1))     &
                                -8.0*(v3d(i,j,k+1)+v3d(i,j,k-2))     &
                                    +(v3d(i,j,k+2)+v3d(i,j,k-3))     &
        -sign(1.0,(rrw(i,j,k)+rrw(i,j-1,k)))                         &
                             *( 10.0*(v3d(i,j,k  )-v3d(i,j,k-1))     &
                                -5.0*(v3d(i,j,k+1)-v3d(i,j,k-2))     &
                                    +(v3d(i,j,k+2)-v3d(i,j,k-3)) ) )*tem1
#else
        ! this seems to be faster on most other platforms:
        if((rrw(i,j,k)+rrw(i,j-1,k)).ge.0.)then
          dum(i,j,k)=(rrw(i,j,k)+rrw(i,j-1,k))*                        &
                 ( 2.*v3d(i,j,k-3)-13.*v3d(i,j,k-2)+47.*v3d(i,j,k-1)    &
                  +27.*v3d(i,j,k)-3.*v3d(i,j,k+1) )*tem1
        else
          dum(i,j,k)=(rrw(i,j,k)+rrw(i,j-1,k))*                      &
                 ( 2.*v3d(i,j,k+2)-13.*v3d(i,j,k+1)+47.*v3d(i,j,k)    &
                  +27.*v3d(i,j,k-1)-3.*v3d(i,j,k-2) )*tem1
        endif
#endif
      enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=3,(nk-1),(nk-4)
      do j=j1,j2
      do i=1,ni
#ifdef SGN
        ! this form of code is used for IBM/xlf compiler:
        dum(i,j,k)=(rrw(i,j,k)+rrw(i,j-1,k))                             &
                             *( 7.0*(v3d(i,j,k  )+v3d(i,j,k-1))          &
                                   -(v3d(i,j,k+1)+v3d(i,j,k-2))          &
        -sign(1.0,(rrw(i,j,k)+rrw(i,j-1,k)))                             &
                             *( 3.0*(v3d(i,j,k  )-v3d(i,j,k-1))          &
                                   -(v3d(i,j,k+1)-v3d(i,j,k-2)) ) )*tem3
#else
        ! this seems to be faster on most other platforms:
        if((rrw(i,j,k)+rrw(i,j-1,k)).ge.0.)then
          dum(i,j,k)=(rrw(i,j,k)+rrw(i,j-1,k))*    &
                 (-v3d(i,j,k-2)+5.*v3d(i,j,k-1)+2.*v3d(i,j,k  ))*tem2
        else
          dum(i,j,k)=(rrw(i,j,k)+rrw(i,j-1,k))*    &
                 (-v3d(i,j,k+1)+5.*v3d(i,j,k  )+2.*v3d(i,j,k-1))*tem2
        endif
#endif
      enddo
      enddo
      enddo
 
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk,(nk-2)
      do j=j1,j2
      do i=1,ni
        dum(i,j,k)=0.25*(rrw(i,j,k)+rrw(i,j-1,k))    &
                       *(v3d(i,j,k-1)+v3d(i,j,k))
      enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,(nk+1),nk
      do j=j1,j2
      do i=1,ni
        dum(i,j,k)=0.0
      enddo
      enddo
      enddo

      IF(terrain_flag)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=j1,j2
        do i=1,ni
          advz(i,j,k)=-(dum(i,j,k+1)-dum(i,j,k))*rdz*0.5*(mh(i,j-1,k)/gz(i,j-1)+mh(i,j,k)/gz(i,j))
        enddo
        enddo
        enddo

      ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=j1,j2
        do i=1,ni
          advz(i,j,k)=-(dum(i,j,k+1)-dum(i,j,k))*rdz*0.5*(mh(i,j-1,k)+mh(i,j,k))
        enddo
        enddo
        enddo

      ENDIF

!----------------------------------------------------------------
 
      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine adv5w(xh,rxh,uh,xf,vh,gz,mf,rho0,rr0,rf0,rrf0,dum,advx,advy,advz,divx, &
                       rru,rrv,rrw,w3d,wten)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real, dimension(ib:ie) :: xh,rxh,uh
      real, dimension(ib:ie+1) :: xf
      real, dimension(jb:je) :: vh
      real, dimension(itb:ite,jtb:jte) :: gz
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, dimension(ib:ie,jb:je,kb:ke) :: rho0,rr0,rf0,rrf0
      real, dimension(ib:ie,jb:je,kb:ke) :: dum,advx,advy,advz,divx
      real, dimension(ib:ie+1,jb:je,kb:ke) :: rru
      real, dimension(ib:ie,jb:je+1,kb:ke) :: rrv
      real, dimension(ib:ie,jb:je,kb:ke+1) :: rrw,w3d,wten
 
      integer i,j,k,i1,i2,j1,j2
      real, parameter :: tem = 1.0/120.0

!----------------------------------------------------------------
! Advection in x-direction

      i1 = 1
      i2 = ni+1

      if(wbc.eq.2 .and. ibw.eq.1)then
        i1=4
      endif

      if(ebc.eq.2 .and. ibe.eq.1)then
        i2=ni-2
      endif

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=i1,i2
#ifdef SGN
        ! this form of code is used for IBM/xlf compiler:
        dum(i,j,k)=(rru(i,j,k)+rru(i,j,k-1))                         &
                             *( 37.0*(w3d(i  ,j,k)+w3d(i-1,j,k))     &
                                -8.0*(w3d(i+1,j,k)+w3d(i-2,j,k))     &
                                    +(w3d(i+2,j,k)+w3d(i-3,j,k))     &
        -sign(1.0,(rru(i,j,k)+rru(i,j,k-1)))                         &
                             *( 10.0*(w3d(i  ,j,k)-w3d(i-1,j,k))     &
                                -5.0*(w3d(i+1,j,k)-w3d(i-2,j,k))     &
                                    +(w3d(i+2,j,k)-w3d(i-3,j,k)) ) )*tem
#else
        ! this seems to be faster on most other platforms:
        if((rru(i,j,k)+rru(i,j,k-1)).ge.0.)then
          dum(i,j,k)=(rru(i,j,k)+rru(i,j,k-1))*                        &
                 ( 2.*w3d(i-3,j,k)-13.*w3d(i-2,j,k)+47.*w3d(i-1,j,k)    &
                  +27.*w3d(i,j,k)-3.*w3d(i+1,j,k) )*tem
        else
          dum(i,j,k)=(rru(i,j,k)+rru(i,j,k-1))*                      &
                 ( 2.*w3d(i+2,j,k)-13.*w3d(i+1,j,k)+47.*w3d(i,j,k)    &
                  +27.*w3d(i-1,j,k)-3.*w3d(i-2,j,k) )*tem
        endif
#endif
      enddo
      enddo
      enddo

      IF(wbc.eq.2 .and. ibw.eq.1) call advbcww(dum,rru,w3d)

      IF(ebc.eq.2 .and. ibe.eq.1) call advbcwe(xf,dum,rru,w3d)

    IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni
        advx(i,j,k)=-(dum(i+1,j,k)-dum(i,j,k))*rdx*uh(i)
      enddo
      enddo
      enddo

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni
        advx(i,j,k)=-(xf(i+1)*dum(i+1,j,k)-xf(i)*dum(i,j,k))*rdx*uh(i)*rxh(i)
      enddo
      enddo
      enddo

    ENDIF

      IF(wbc.eq.2 .and. ibw.eq.1)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
          i=1
          if((rru(i,j,k)+rru(i,j,k-1)).ge.0.0)then
            advx(i,j,k)=advx(i,j,k)-w3d(i,j,k)*0.5*(      &
                    (rru(i+1,j,k-1)-rru(i,j,k-1))         &
                   +(rru(i+1,j,k  )-rru(i,j,k  )) )*rdx*uh(i)
          endif
        enddo
        enddo
      ENDIF

      IF(ebc.eq.2 .and. ibe.eq.1)THEN

      IF(axisymm.eq.0)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
          i=ni+1
          if((rru(i,j,k)+rru(i,j,k-1)).lt.0.0)then
            i=ni
            advx(i,j,k)=advx(i,j,k)-w3d(i,j,k)*0.5*(      &
                    (rru(i+1,j,k-1)-rru(i,j,k-1))         &
                   +(rru(i+1,j,k  )-rru(i,j,k  )) )*rdx*uh(i)
          endif
        enddo
        enddo
      ELSE
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
          i=ni+1
          if((rru(i,j,k)+rru(i,j,k-1)).lt.0.0)then
            i=ni
            advx(i,j,k)=advx(i,j,k)-w3d(i,j,k)*0.5*(      &
                    (xf(i+1)*rru(i+1,j,k-1)-xf(i)*rru(i,j,k-1))         &
                   +(xf(i+1)*rru(i+1,j,k  )-xf(i)*rru(i,j,k  )) )*rdx*uh(i)*rxh(i)
          endif
        enddo
        enddo
      ENDIF

      ENDIF

!----------------------------------------------------------------
! Advection in y-direction

    IF(axisymm.eq.0)THEN

      j1 = 1
      j2 = nj+1

      if(sbc.eq.2 .and. ibs.eq.1)then
        j1=4
      endif

      if(nbc.eq.2 .and. ibn.eq.1)then
        j2=nj-2
      endif

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=j1,j2
      do i=1,ni
#ifdef SGN
        ! this form of code is used for IBM/xlf compiler:
        dum(i,j,k)=(rrv(i,j,k)+rrv(i,j,k-1))                         &
                             *( 37.0*(w3d(i,j  ,k)+w3d(i,j-1,k))     &
                                -8.0*(w3d(i,j+1,k)+w3d(i,j-2,k))     &
                                    +(w3d(i,j+2,k)+w3d(i,j-3,k))     &
        -sign(1.0,(rrv(i,j,k)+rrv(i,j,k-1)))                         &
                             *( 10.0*(w3d(i,j  ,k)-w3d(i,j-1,k))     &
                                -5.0*(w3d(i,j+1,k)-w3d(i,j-2,k))     &
                                    +(w3d(i,j+2,k)-w3d(i,j-3,k)) ) )*tem
#else
        ! this seems to be faster on most other platforms:
        if((rrv(i,j,k)+rrv(i,j,k-1)).ge.0.)then
          dum(i,j,k)=(rrv(i,j,k)+rrv(i,j,k-1))*                        &
                 ( 2.*w3d(i,j-3,k)-13.*w3d(i,j-2,k)+47.*w3d(i,j-1,k)    &
                  +27.*w3d(i,j,k)-3.*w3d(i,j+1,k) )*tem
        else
          dum(i,j,k)=(rrv(i,j,k)+rrv(i,j,k-1))*                      &
                 ( 2.*w3d(i,j+2,k)-13.*w3d(i,j+1,k)+47.*w3d(i,j,k)    &
                  +27.*w3d(i,j-1,k)-3.*w3d(i,j-2,k) )*tem
        endif
#endif
      enddo
      enddo
      enddo

      IF(sbc.eq.2 .and. ibs.eq.1) call advbcws(dum,rrv,w3d)

      IF(nbc.eq.2 .and. ibn.eq.1) call advbcwn(dum,rrv,w3d)

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni
        advy(i,j,k)=-(dum(i,j+1,k)-dum(i,j,k))*rdy*vh(j)
      enddo
      enddo
      enddo

      IF(sbc.eq.2 .and. ibs.eq.1)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do i=1,ni
          j=1
          if((rrv(i,j,k)+rrv(i,j,k-1)).ge.0.0)then
            advy(i,j,k)=advy(i,j,k)-w3d(i,j,k)*0.5*(       &
                           (rrv(i,j+1,k-1)-rrv(i,j,k-1))   &
                          +(rrv(i,j+1,k  )-rrv(i,j,k  )) )*rdy*vh(j)
          endif
        enddo
        enddo
      ENDIF

      IF(nbc.eq.2 .and. ibn.eq.1)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do i=1,ni
          j=nj+1
          if((rrv(i,j,k)+rrv(i,j,k-1)).lt.0.0)then
            j=nj
            advy(i,j,k)=advy(i,j,k)-w3d(i,j,k)*0.5*(       &
                           (rrv(i,j+1,k-1)-rrv(i,j,k-1))   &
                          +(rrv(i,j+1,k  )-rrv(i,j,k  )) )*rdy*vh(j)
          endif
        enddo
        enddo
      ENDIF

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni
        advy(i,j,k)=0.0
      enddo
      enddo
      enddo

    ENDIF
 
!----------------------------------------------------------------

      if(vadvorder.eq.5)then
        call vadv5w(gz,mf,dum,advz,rrw,w3d)
      elseif(vadvorder.eq.6)then
        call vadv6w(gz,mf,dum,advz,rrw,w3d)
      endif

!----------------------------------------------------------------

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni
        wten(i,j,k)=wten(i,j,k)+( advx(i,j,k)+advy(i,j,k)+advz(i,j,k)    &
                   +w3d(i,j,k)*0.5*(divx(i,j,k)+divx(i,j,k-1)) )*rrf0(i,j,k)
      enddo
      enddo
      enddo

!----------------------------------------------------------------
 
      if(timestats.ge.1) time_advw=time_advw+mytime()
 
      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine vadv5w(gz,mf,dum,advz,rrw,w3d)
      implicit none

      include 'input.incl'
      include 'constants.incl'

      real, dimension(itb:ite,jtb:jte) :: gz
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, dimension(ib:ie,jb:je,kb:ke) :: dum,advz
      real, dimension(ib:ie,jb:je,kb:ke+1) :: rrw,w3d

      integer i,j,k
      real, parameter :: tem1 = 1.0/120.0
      real, parameter :: tem2 = 1.0/12.0
      real, parameter :: tem3 = 1.0/24.0

!----------------------------------------------------------------
! Advection in z-direction

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=3,nk-2
      do j=1,nj
      do i=1,ni
#ifdef SGN
        ! this form of code is used for IBM/xlf compiler:
        dum(i,j,k)=(rrw(i,j,k)+rrw(i,j,k+1))                         &
                             *( 37.0*(w3d(i,j,k+1)+w3d(i,j,k  ))     &
                                -8.0*(w3d(i,j,k+2)+w3d(i,j,k-1))     &
                                    +(w3d(i,j,k+3)+w3d(i,j,k-2))     &
        -sign(1.0,(rrw(i,j,k)+rrw(i,j,k+1)))                         &
                             *( 10.0*(w3d(i,j,k+1)-w3d(i,j,k  ))     &
                                -5.0*(w3d(i,j,k+2)-w3d(i,j,k-1))     &
                                    +(w3d(i,j,k+3)-w3d(i,j,k-2)) ) )*tem1
#else
        ! this seems to be faster on most other platforms:
        if((rrw(i,j,k)+rrw(i,j,k+1)).ge.0.)then
          dum(i,j,k)=(rrw(i,j,k)+rrw(i,j,k+1))*       &
                 ( 2.*w3d(i,j,k-2)-13.*w3d(i,j,k-1)+47.*w3d(i,j,k)    &
                  +27.*w3d(i,j,k+1)-3.*w3d(i,j,k+2) )*tem1
        else
          dum(i,j,k)=(rrw(i,j,k)+rrw(i,j,k+1))*       &
                 ( 2.*w3d(i,j,k+3)-13.*w3d(i,j,k+2)+47.*w3d(i,j,k+1)  &
                  +27.*w3d(i,j,k)-3.*w3d(i,j,k-1) )*tem1
        endif
#endif
      enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,(nk-1),(nk-3)
      do j=1,nj
      do i=1,ni
#ifdef SGN
        ! this form of code is used for IBM/xlf compiler:
        dum(i,j,k)=(rrw(i,j,k)+rrw(i,j,k+1))                             &
                             *( 7.0*(w3d(i,j,k+1)+w3d(i,j,k  ))          &
                                   -(w3d(i,j,k+2)+w3d(i,j,k-1))          &
        -sign(1.0,(rrw(i,j,k)+rrw(i,j,k+1)))                             &
                             *( 3.0*(w3d(i,j,k+1)-w3d(i,j,k  ))          &
                                   -(w3d(i,j,k+2)-w3d(i,j,k-1)) ) )*tem3
#else
        ! this seems to be faster on most other platforms:
        if((rrw(i,j,k)+rrw(i,j,k+1)).ge.0.)then
          dum(i,j,k)=(rrw(i,j,k)+rrw(i,j,k+1))*    &
                 (-w3d(i,j,k-1)+5.*w3d(i,j,k  )+2.*w3d(i,j,k+1))*tem2
        else
          dum(i,j,k)=(rrw(i,j,k)+rrw(i,j,k+1))*    &
                 (-w3d(i,j,k+2)+5.*w3d(i,j,k+1)+2.*w3d(i,j,k  ))*tem2
        endif
#endif
      enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk,(nk-1)
      do j=1,nj
      do i=1,ni
        dum(i,j,k)=0.25*(rrw(i,j,k)+rrw(i,j,k+1))    &
                       *(w3d(i,j,k)+w3d(i,j,k+1))
      enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni
        advz(i,j,k)=-(dum(i,j,k)-dum(i,j,k-1))*rdz*mf(i,j,k)
      enddo
      enddo
      enddo

      IF(terrain_flag)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=1,ni
          advz(i,j,k)=advz(i,j,k)/gz(i,j)
        enddo
        enddo
        enddo

      ENDIF

!----------------------------------------------------------------
 
      return
      end


adv6.F/         1298670057  19071 8000  100644  71641     `


      subroutine adv6s(bflag,bsq,xh,rxh,uh,ruh,xf,vh,rvh,gz,mh,rmh,      &
                       rho0,rr0,rf0,rrf0,advx,advy,advz,dum,divx,mass,   &
                       rru,rrv,rrw,s1,s,sten,pdef,dt)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      integer bflag
      real*8 bsq
      real, dimension(ib:ie) :: xh,rxh,uh,ruh
      real, dimension(ib:ie+1) :: xf
      real, dimension(jb:je) :: vh,rvh
      real, dimension(itb:ite,jtb:jte) :: gz
      real, dimension(ib:ie,jb:je,kb:ke) :: mh,rmh,rho0,rr0,rf0,rrf0
      real, dimension(ib:ie,jb:je,kb:ke) :: advx,advy,advz,dum,divx,mass
      real, dimension(ib:ie+1,jb:je,kb:ke) :: rru
      real, dimension(ib:ie,jb:je+1,kb:ke) :: rrv
      real, dimension(ib:ie,jb:je,kb:ke+1) :: rrw
      real, dimension(ib:ie,jb:je,kb:ke) :: s1,s,sten
      integer pdef
      real dt
 
      integer i,j,k,i1,i2,j1,j2
      real, parameter :: tem = 1.0/60.0

!----------------------------------------------------------------
! Advection in x-direction

      i1 = 1
      i2 = ni+1

      if(wbc.eq.2 .and. ibw.eq.1)then
        i1=4
      endif

      if(ebc.eq.2 .and. ibe.eq.1)then
        i2=ni-2
      endif

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=i1,i2
        dum(i,j,k)=rru(i,j,k)*( 37.0*(s(i  ,j,k)+s(i-1,j,k))     &
                               -8.0*(s(i+1,j,k)+s(i-2,j,k))     &
                                   +(s(i+2,j,k)+s(i-3,j,k)) )*tem
      enddo
      enddo
      enddo

      IF(wbc.eq.2 .and. ibw.eq.1) call advbcsw(dum,rru,s)

      IF(ebc.eq.2 .and. ibe.eq.1) call advbcse(xf,dum,rru,s)

    IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        advx(i,j,k)=-(dum(i+1,j,k)-dum(i,j,k))*rdx*uh(i)
      enddo
      enddo
      enddo

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        advx(i,j,k)=-(xf(i+1)*dum(i+1,j,k)-xf(i)*dum(i,j,k))*rdx*uh(i)*rxh(i)
      enddo
      enddo
      enddo

    ENDIF

      IF(stat_qsrc.eq.1.and.(wbc.eq.2.or.ebc.eq.2).and.bflag.eq.1)THEN
        if(timestats.ge.1) time_advs=time_advs+mytime()
        call bsx(dt,bsq,rvh,rmh,dum)
      ENDIF

      IF(pdscheme.eq.1 .and. pdef.eq.1)then
        if(timestats.ge.1) time_advs=time_advs+mytime()
        call pdefx(xh,rho0,advx,dum,mass,s1,dt)
      ENDIF

      IF(wbc.eq.2 .and. ibw.eq.1)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
          i=1
          if(rru(i,j,k).ge.0.0)then
            advx(i,j,k)=advx(i,j,k)-s(i,j,k)*(rru(i+1,j,k)-rru(i,j,k))*rdx*uh(i)
          endif
        enddo
        enddo
      ENDIF

      IF(ebc.eq.2 .and. ibe.eq.1)THEN

      IF(axisymm.eq.0)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
          i=ni+1
          if(rru(i,j,k).lt.0.0)then
            i=ni
            advx(i,j,k)=advx(i,j,k)-s(i,j,k)*(rru(i+1,j,k)-rru(i,j,k))*rdx*uh(i)
          endif
        enddo
        enddo
      ELSE
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
          i=ni+1
          if(rru(i,j,k).lt.0.0)then
            i=ni
            advx(i,j,k)=advx(i,j,k)-s(i,j,k)*(xf(i+1)*rru(i+1,j,k)-xf(i)*rru(i,j,k))*rdx*uh(i)*rxh(i)
          endif
        enddo
        enddo
      ENDIF

      ENDIF

!----------------------------------------------------------------
! Advection in y-direction

    IF(axisymm.eq.0)THEN

      j1 = 1
      j2 = nj+1

      if(sbc.eq.2 .and. ibs.eq.1)then
        j1=4
      endif

      if(nbc.eq.2 .and. ibn.eq.1)then
        j2=nj-2
      endif

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=j1,j2
      do i=1,ni
        dum(i,j,k)=rrv(i,j,k)*( 37.0*(s(i,j  ,k)+s(i,j-1,k))     &
                               -8.0*(s(i,j+1,k)+s(i,j-2,k))     &
                                   +(s(i,j+2,k)+s(i,j-3,k)) )*tem
      enddo
      enddo
      enddo

      IF(sbc.eq.2 .and. ibs.eq.1) call advbcss(dum,rrv,s)

      IF(nbc.eq.2 .and. ibn.eq.1) call advbcsn(dum,rrv,s)

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        advy(i,j,k)=-(dum(i,j+1,k)-dum(i,j,k))*rdy*vh(j)
      enddo
      enddo
      enddo

      IF(stat_qsrc.eq.1.and.(sbc.eq.2.or.nbc.eq.2).and.bflag.eq.1)THEN
        if(timestats.ge.1) time_advs=time_advs+mytime()
        call bsy(dt,bsq,ruh,rmh,dum)
      ENDIF

      IF(pdscheme.eq.1 .and. pdef.eq.1)THEN
        if(timestats.ge.1) time_advs=time_advs+mytime()
        call pdefy(rho0,advy,dum,mass,s1,dt)
      ENDIF

      IF(sbc.eq.2 .and. ibs.eq.1)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do i=1,ni
          j=1
          if(rrv(i,j,k).ge.0.0)then
            advy(i,j,k)=advy(i,j,k)-s(i,j,k)*(rrv(i,j+1,k)-rrv(i,j,k))*rdy*vh(j)
          endif
        enddo
        enddo
      ENDIF

      IF(nbc.eq.2 .and. ibn.eq.1)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do i=1,ni
          j=nj+1
          if(rrv(i,j,k).lt.0.0)then
            j=nj
            advy(i,j,k)=advy(i,j,k)-s(i,j,k)*(rrv(i,j+1,k)-rrv(i,j,k))*rdy*vh(j)
          endif
        enddo
        enddo
      ENDIF

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        advy(i,j,k)=0.0
      enddo
      enddo
      enddo

    ENDIF

!----------------------------------------------------------------

      if(vadvorder.eq.5)then
        call vadv5s(gz,mh,rho0,advz,dum,mass,rrw,s1,s,pdef,dt)
      elseif(vadvorder.eq.6)then
        call vadv6s(gz,mh,rho0,advz,dum,mass,rrw,s1,s,pdef,dt)
      endif

!----------------------------------------------------------------

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        sten(i,j,k)=sten(i,j,k)+( advx(i,j,k)+advy(i,j,k)+advz(i,j,k)    &
                                 +s(i,j,k)*divx(i,j,k) )*rr0(i,j,k)
      enddo
      enddo
      enddo

!----------------------------------------------------------------
 
      if(timestats.ge.1) time_advs=time_advs+mytime()
 
      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine vadv6s(gz,mh,rho0,advz,dum,mass,rrw,s1,s,pdef,dt)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, dimension(itb:ite,jtb:jte) :: gz
      real, dimension(ib:ie,jb:je,kb:ke) :: mh,rho0
      real, dimension(ib:ie,jb:je,kb:ke) :: advz,dum,mass
      real, dimension(ib:ie,jb:je,kb:ke+1) :: rrw
      real, dimension(ib:ie,jb:je,kb:ke) :: s1,s
      integer pdef
      real dt

      integer i,j,k
      real, parameter :: tem1 = 1.0/60.0
      real, parameter :: tem2 = 1.0/12.0

!----------------------------------------------------------------
! Advection in z-direction

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=4,nk-2
      do j=1,nj
      do i=1,ni
        dum(i,j,k)=rrw(i,j,k)                                 &
                            *( 37.0*(s(i,j,k  )+s(i,j,k-1))          &
                               -8.0*(s(i,j,k+1)+s(i,j,k-2))          &
                                   +(s(i,j,k+2)+s(i,j,k-3)) )*tem1
      enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=3,(nk-1),(nk-4)
      do j=1,nj
      do i=1,ni
        dum(i,j,k)=rrw(i,j,k)                                &
                            *( 7.0*(s(i,j,k  )+s(i,j,k-1))          &
                                  -(s(i,j,k+1)+s(i,j,k-2)) )*tem2
      enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk,(nk-2)
      do j=1,nj
      do i=1,ni
        dum(i,j,k)=rrw(i,j,k)*0.5*(s(i,j,k-1)+s(i,j,k))
      enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,(nk+1),nk
      do j=1,nj
      do i=1,ni
        dum(i,j,k)=0.0
      enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        advz(i,j,k)=-(dum(i,j,k+1)-dum(i,j,k))*rdz*mh(i,j,k)
      enddo
      enddo
      enddo

      IF(terrain_flag)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          advz(i,j,k)=advz(i,j,k)/gz(i,j)
        enddo
        enddo
        enddo

      ENDIF

      IF(pdscheme.eq.1 .and. pdef.eq.1)THEN
        if(timestats.ge.1) time_advs=time_advs+mytime()
        call pdefz(rho0,advz,dum,mass,s1,dt)
      ENDIF

!----------------------------------------------------------------
 
      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine adv6u(xf,rxf,uf,vh,gz,mh,rho0,rr0,rf0,rrf0,rru0,dum,advx,advy,advz,divx, &
                       rru,u3d,uten,rrv,rrw)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real, dimension(ib:ie+1) :: xf,rxf,uf
      real, dimension(jb:je) :: vh
      real, dimension(itb:ite,jtb:jte) :: gz
      real, dimension(ib:ie,jb:je,kb:ke) :: mh,rho0,rr0,rf0,rrf0,rru0
      real, dimension(ib:ie,jb:je,kb:ke) :: dum,advx,advy,advz,divx
      real, dimension(ib:ie+1,jb:je,kb:ke) :: rru,u3d,uten
      real, dimension(ib:ie,jb:je+1,kb:ke) :: rrv
      real, dimension(ib:ie,jb:je,kb:ke+1) :: rrw
 
      integer i,j,k,i1,i2,j1,j2,id1,id2
      real, parameter :: tem = 1.0/120.0

!------------------------------------------------------------

      if(ibw.eq.1)then
        i1=2
      else
        i1=1
      endif
 
      if(ibe.eq.1)then
        i2=ni+1-1
      else
        i2=ni+1
      endif
 
!----------------------------------------------------------------
! Advection in x-direction

      id1 = i1-1
      id2 = i2

      if(wbc.eq.2 .and. ibw.eq.1)then
        id1 = 3
      endif

      if(ebc.eq.2 .and. ibe.eq.1)then
        id2 = ni-2
      endif

    IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=id1,id2
        dum(i,j,k)=(rru(i,j,k)+rru(i+1,j,k))*             &
                   ( 37.0*(u3d(i+1,j,k)+u3d(i  ,j,k))     &
                     -8.0*(u3d(i+2,j,k)+u3d(i-1,j,k))     &
                         +(u3d(i+3,j,k)+u3d(i-2,j,k)) )*tem
      enddo
      enddo
      enddo

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=id1,id2
        dum(i,j,k)=(xf(i)*rru(i,j,k)+xf(i+1)*rru(i+1,j,k))*             &
                   ( 37.0*(u3d(i+1,j,k)+u3d(i  ,j,k))     &
                     -8.0*(u3d(i+2,j,k)+u3d(i-1,j,k))     &
                         +(u3d(i+3,j,k)+u3d(i-2,j,k)) )*tem
      enddo
      enddo
      enddo

    ENDIF

      IF(wbc.eq.2 .and. ibw.eq.1) call advbcuw(dum,rru,u3d)

      IF(ebc.eq.2 .and. ibe.eq.1) call advbcue(xf,dum,rru,u3d)

    IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=i1,i2
        advx(i,j,k)=-(dum(i,j,k)-dum(i-1,j,k))*rdx*uf(i)
      enddo
      enddo
      enddo

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=i1,i2
        advx(i,j,k)=-(dum(i,j,k)-dum(i-1,j,k))*rdx*uf(i)*rxf(i)
      enddo
      enddo
      enddo

    ENDIF

!----------------------------------------------------------------
! Advection in y-direction

    IF(axisymm.eq.0)THEN

      j1 = 1
      j2 = nj+1

      if(sbc.eq.2 .and. ibs.eq.1)then
        j1=4
      endif

      if(nbc.eq.2 .and. ibn.eq.1)then
        j2=nj-2
      endif

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=j1,j2
      do i=i1,i2
        dum(i,j,k)=(rrv(i,j,k)+rrv(i-1,j,k))*             &
                   ( 37.0*(u3d(i,j  ,k)+u3d(i,j-1,k))     &
                     -8.0*(u3d(i,j+1,k)+u3d(i,j-2,k))     &
                         +(u3d(i,j+2,k)+u3d(i,j-3,k)) )*tem
      enddo
      enddo
      enddo

      IF(sbc.eq.2 .and. ibs.eq.1) call advbcus(dum,u3d,rrv,i1,i2)

      IF(nbc.eq.2 .and. ibn.eq.1) call advbcun(dum,u3d,rrv,i1,i2)

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=i1,i2
        advy(i,j,k)=-(dum(i,j+1,k)-dum(i,j,k))*rdy*vh(j)
      enddo
      enddo
      enddo

      IF(sbc.eq.2 .and. ibs.eq.1)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do i=i1,i2
          j=1
          if((rrv(i,j,k)+rrv(i-1,j,k)).ge.0.0)then
            advy(i,j,k)=advy(i,j,k)-u3d(i,j,k)*0.5*(                    &
                            (rrv(i-1,j+1,k)-rrv(i-1,j,k))               &
                           +(rrv(i  ,j+1,k)-rrv(i  ,j,k)) )*rdy*vh(j)
          endif
        enddo
        enddo
      ENDIF

      IF(nbc.eq.2 .and. ibn.eq.1)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do i=i1,i2
          j=nj+1
          if((rrv(i,j,k)+rrv(i-1,j,k)).lt.0.0)then
            j=nj
            advy(i,j,k)=advy(i,j,k)-u3d(i,j,k)*0.5*(                    &
                            (rrv(i-1,j+1,k)-rrv(i-1,j,k))               &
                           +(rrv(i  ,j+1,k)-rrv(i  ,j,k)) )*rdy*vh(j)
          endif
        enddo
        enddo
      ENDIF

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=i1,i2
        advy(i,j,k)=0.0
      enddo
      enddo
      enddo

    ENDIF

!----------------------------------------------------------------

      if(vadvorder.eq.5)then
        call vadv5u(gz,mh,dum,advz,u3d,rrw,i1,i2)
      elseif(vadvorder.eq.6)then
        call vadv6u(gz,mh,dum,advz,u3d,rrw,i1,i2)
      endif

!----------------------------------------------------------------

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=i1,i2
        uten(i,j,k)=uten(i,j,k)+( advx(i,j,k)+advy(i,j,k)+advz(i,j,k)    &
                   +u3d(i,j,k)*0.5*(divx(i,j,k)+divx(i-1,j,k)) )*rru0(i,j,k)
      enddo
      enddo
      enddo

!----------------------------------------------------------------
 
      if(timestats.ge.1) time_advu=time_advu+mytime()
 
      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine vadv6u(gz,mh,dum,advz,u3d,rrw,i1,i2)
      implicit none

      include 'input.incl'
      include 'constants.incl'

      real, dimension(itb:ite,jtb:jte) :: gz
      real, dimension(ib:ie,jb:je,kb:ke) :: mh
      real, dimension(ib:ie,jb:je,kb:ke) :: dum,advz
      real, dimension(ib:ie+1,jb:je,kb:ke) :: u3d
      real, dimension(ib:ie,jb:je,kb:ke+1) :: rrw
      integer :: i1,i2

      integer i,j,k
      real, parameter :: tem1 = 1.0/120.0
      real, parameter :: tem2 = 1.0/24.0

!----------------------------------------------------------------
! Advection in z-direction

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=4,nk-2
      do j=1,nj
      do i=i1,i2
        dum(i,j,k)=(rrw(i,j,k)+rrw(i-1,j,k))*           &
                   ( 37.0*(u3d(i,j,k  )+u3d(i,j,k-1))          &
                     -8.0*(u3d(i,j,k+1)+u3d(i,j,k-2))          &
                         +(u3d(i,j,k+2)+u3d(i,j,k-3)) )*tem1
      enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=3,(nk-1),(nk-4)
      do j=1,nj
      do i=i1,i2
        dum(i,j,k)=(rrw(i,j,k)+rrw(i-1,j,k))*          &
                   ( 7.0*(u3d(i,j,k  )+u3d(i,j,k-1))          &
                        -(u3d(i,j,k+1)+u3d(i,j,k-2)) )*tem2
      enddo
      enddo
      enddo
 
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk,(nk-2)
      do j=1,nj
      do i=i1,i2
        dum(i,j,k)=0.25*(rrw(i,j,k)+rrw(i-1,j,k))    &
                       *(u3d(i,j,k-1)+u3d(i,j,k))
      enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,(nk+1),nk
      do j=1,nj
      do i=i1,i2
        dum(i,j,k)=0.0
      enddo
      enddo
      enddo

      IF(terrain_flag)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=i1,i2
          advz(i,j,k)=-(dum(i,j,k+1)-dum(i,j,k))*rdz*0.5*(mh(i-1,j,k)/gz(i-1,j)+mh(i,j,k)/gz(i,j))
        enddo
        enddo
        enddo

      ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=i1,i2
          advz(i,j,k)=-(dum(i,j,k+1)-dum(i,j,k))*rdz*0.5*(mh(i-1,j,k)+mh(i,j,k))
        enddo
        enddo
        enddo

      ENDIF

!----------------------------------------------------------------
 
      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine adv6v(xh,rxh,uh,xf,vf,gz,mh,rho0,rr0,rf0,rrf0,rrv0,dum,advx,advy,advz,divx, &
                       rru,rrv,v3d,vten,rrw)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real, dimension(ib:ie) :: xh,rxh,uh
      real, dimension(ib:ie+1) :: xf
      real, dimension(jb:je+1) :: vf
      real, dimension(itb:ite,jtb:jte) :: gz
      real, dimension(ib:ie,jb:je,kb:ke) :: mh,rho0,rr0,rf0,rrf0,rrv0
      real, dimension(ib:ie,jb:je,kb:ke) :: dum,advx,advy,advz,divx
      real, dimension(ib:ie+1,jb:je,kb:ke) :: rru
      real, dimension(ib:ie,jb:je+1,kb:ke) :: rrv,v3d,vten
      real, dimension(ib:ie,jb:je,kb:ke+1) :: rrw
 
      integer i,j,k,i1,i2,j1,j2,jd1,jd2
      real, parameter :: tem = 1.0/120.0

!------------------------------------------------------------

      if(ibs.eq.1)then
        j1=2
      else
        j1=1
      endif
 
      if(ibn.eq.1)then
        j2=nj+1-1
      else
        j2=nj+1
      endif
 
!----------------------------------------------------------------
! Advection in x-direction

      i1 = 1
      i2 = ni+1

      if(wbc.eq.2 .and. ibw.eq.1)then
        i1=4
      endif

      if(ebc.eq.2 .and. ibe.eq.1)then
        i2=ni-2
      endif

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=j1,j2
      do i=i1,i2
        dum(i,j,k)=(rru(i,j,k)+rru(i,j-1,k))*             &
                   ( 37.0*(v3d(i  ,j,k)+v3d(i-1,j,k))     &
                     -8.0*(v3d(i+1,j,k)+v3d(i-2,j,k))     &
                         +(v3d(i+2,j,k)+v3d(i-3,j,k)) )*tem
      enddo
      enddo
      enddo

      IF(wbc.eq.2 .and. ibw.eq.1) call advbcvw(dum,rru,v3d,j1,j2)

      IF(ebc.eq.2 .and. ibe.eq.1) call advbcve(xf,dum,rru,v3d,j1,j2)

    IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=j1,j2
      do i=1,ni
        advx(i,j,k)=-(dum(i+1,j,k)-dum(i,j,k))*rdx*uh(i)
      enddo
      enddo
      enddo

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=j1,j2
      do i=1,ni
        advx(i,j,k)=-(xf(i+1)*dum(i+1,j,k)-xf(i)*dum(i,j,k))*rdx*uh(i)*rxh(i)
      enddo
      enddo
      enddo

    ENDIF

      IF(wbc.eq.2 .and. ibw.eq.1)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=j1,j2
          i=1
          if((rru(i,j,k)+rru(i,j-1,k)).ge.0.0)then
            advx(i,j,k)=advx(i,j,k)-v3d(i,j,k)*0.5*(            &
                    (rru(i+1,j-1,k)-rru(i,j-1,k))               &
                   +(rru(i+1,j  ,k)-rru(i,j  ,k)) )*rdx*uh(i)
          endif
        enddo
        enddo
      ENDIF

      IF(ebc.eq.2 .and. ibe.eq.1)THEN

      IF(axisymm.eq.0)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=j1,j2
          i=ni+1
          if((rru(i,j,k)+rru(i,j-1,k)).lt.0.0)then
            i=ni
            advx(i,j,k)=advx(i,j,k)-v3d(i,j,k)*0.5*(            &
                    (rru(i+1,j-1,k)-rru(i,j-1,k))               &
                   +(rru(i+1,j  ,k)-rru(i,j  ,k)) )*rdx*uh(i)
          endif
        enddo
        enddo
      ELSE
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=j1,j2
          i=ni+1
          if((rru(i,j,k)+rru(i,j-1,k)).lt.0.0)then
            i=ni
            advx(i,j,k)=advx(i,j,k)-v3d(i,j,k)*0.5*(            &
                    (xf(i+1)*rru(i+1,j-1,k)-xf(i)*rru(i,j-1,k))               &
                   +(xf(i+1)*rru(i+1,j  ,k)-xf(i)*rru(i,j  ,k)) )*rdx*uh(i)*rxh(i)
          endif
        enddo
        enddo
      ENDIF

      ENDIF

!----------------------------------------------------------------
! Advection in y-direction

    IF(axisymm.eq.0)THEN

      jd1 = j1-1
      jd2 = j2

      if(sbc.eq.2 .and. ibs.eq.1)then
        jd1 = 3
      endif

      if(nbc.eq.2 .and. ibn.eq.1)then
        jd2 = nj-2
      endif

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=jd1,jd2
      do i=1,ni
        dum(i,j,k)=(rrv(i,j,k)+rrv(i,j+1,k))*             &
                   ( 37.0*(v3d(i,j+1,k)+v3d(i,j  ,k))     &
                     -8.0*(v3d(i,j+2,k)+v3d(i,j-1,k))     &
                         +(v3d(i,j+3,k)+v3d(i,j-2,k)) )*tem
      enddo
      enddo
      enddo

      IF(sbc.eq.2 .and. ibs.eq.1) call advbcvs(dum,rrv,v3d)

      IF(nbc.eq.2 .and. ibn.eq.1) call advbcvn(dum,rrv,v3d)

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=j1,j2
      do i=1,ni
        advy(i,j,k)=-(dum(i,j,k)-dum(i,j-1,k))*rdy*vf(j)
      enddo
      enddo
      enddo

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=j1,j2
      do i=1,ni
        advy(i,j,k)=0.0
      enddo
      enddo
      enddo

    ENDIF

!----------------------------------------------------------------

      if(vadvorder.eq.5)then
        call vadv5v(gz,mh,dum,advz,v3d,rrw,j1,j2)
      elseif(vadvorder.eq.6)then
        call vadv6v(gz,mh,dum,advz,v3d,rrw,j1,j2)
      endif

!----------------------------------------------------------------

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=j1,j2
      do i=1,ni
        vten(i,j,k)=vten(i,j,k)+( advx(i,j,k)+advy(i,j,k)+advz(i,j,k)    &
                   +v3d(i,j,k)*0.5*(divx(i,j,k)+divx(i,j-1,k)) )*rrv0(i,j,k)
      enddo
      enddo
      enddo

!----------------------------------------------------------------
 
      if(timestats.ge.1) time_advv=time_advv+mytime()
 
      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine vadv6v(gz,mh,dum,advz,v3d,rrw,j1,j2)
      implicit none

      include 'input.incl'
      include 'constants.incl'

      real, dimension(itb:ite,jtb:jte) :: gz
      real, dimension(ib:ie,jb:je,kb:ke) :: mh
      real, dimension(ib:ie,jb:je,kb:ke) :: dum,advz
      real, dimension(ib:ie,jb:je+1,kb:ke) :: v3d
      real, dimension(ib:ie,jb:je,kb:ke+1) :: rrw
      integer :: j1,j2

      integer i,j,k
      real, parameter :: tem1 = 1.0/120.0
      real, parameter :: tem2 = 1.0/24.0

!----------------------------------------------------------------
! Advection in z-direction

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=4,nk-2
      do j=j1,j2
      do i=1,ni
        dum(i,j,k)=(rrw(i,j,k)+rrw(i,j-1,k))*           &
                   ( 37.0*(v3d(i,j,k  )+v3d(i,j,k-1))          &
                     -8.0*(v3d(i,j,k+1)+v3d(i,j,k-2))          &
                         +(v3d(i,j,k+2)+v3d(i,j,k-3)) )*tem1
      enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=3,(nk-1),(nk-4)
      do j=j1,j2
      do i=1,ni
        dum(i,j,k)=(rrw(i,j,k)+rrw(i,j-1,k))*          &
                   ( 7.0*(v3d(i,j,k  )+v3d(i,j,k-1))          &
                        -(v3d(i,j,k+1)+v3d(i,j,k-2)) )*tem2
      enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk,(nk-2)
      do j=j1,j2
      do i=1,ni
        dum(i,j,k)=0.25*(rrw(i,j,k)+rrw(i,j-1,k))    &
                       *(v3d(i,j,k-1)+v3d(i,j,k))
      enddo
      enddo
      enddo
 
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,(nk+1),nk
      do j=j1,j2
      do i=1,ni
        dum(i,j,k)=0.0
      enddo
      enddo
      enddo

      IF(terrain_flag)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=j1,j2
        do i=1,ni
          advz(i,j,k)=-(dum(i,j,k+1)-dum(i,j,k))*rdz*0.5*(mh(i,j-1,k)/gz(i,j-1)+mh(i,j,k)/gz(i,j))
        enddo
        enddo
        enddo

      ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=j1,j2
        do i=1,ni
          advz(i,j,k)=-(dum(i,j,k+1)-dum(i,j,k))*rdz*0.5*(mh(i,j-1,k)+mh(i,j,k))
        enddo
        enddo
        enddo

      ENDIF

!----------------------------------------------------------------
 
      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine adv6w(xh,rxh,uh,xf,vh,gz,mf,rho0,rr0,rf0,rrf0,dum,advx,advy,advz,divx, &
                       rru,rrv,rrw,w3d,wten)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real, dimension(ib:ie) :: xh,rxh,uh
      real, dimension(ib:ie+1) :: xf
      real, dimension(jb:je) :: vh
      real, dimension(itb:ite,jtb:jte) :: gz
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, dimension(ib:ie,jb:je,kb:ke) :: rho0,rr0,rf0,rrf0
      real, dimension(ib:ie,jb:je,kb:ke) :: dum,advx,advy,advz,divx
      real, dimension(ib:ie+1,jb:je,kb:ke) :: rru
      real, dimension(ib:ie,jb:je+1,kb:ke) :: rrv
      real, dimension(ib:ie,jb:je,kb:ke+1) :: rrw,w3d,wten
 
      integer i,j,k,i1,i2,j1,j2
      real, parameter :: tem = 1.0/120.0

!----------------------------------------------------------------
! Advection in x-direction

      i1 = 1
      i2 = ni+1

      if(wbc.eq.2 .and. ibw.eq.1)then
        i1=4
      endif

      if(ebc.eq.2 .and. ibe.eq.1)then
        i2=ni-2
      endif

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=i1,i2
        dum(i,j,k)=(rru(i,j,k)+rru(i,j,k-1))*             &
                   ( 37.0*(w3d(i  ,j,k)+w3d(i-1,j,k))     &
                     -8.0*(w3d(i+1,j,k)+w3d(i-2,j,k))     &
                         +(w3d(i+2,j,k)+w3d(i-3,j,k)) )*tem
      enddo
      enddo
      enddo

      IF(wbc.eq.2 .and. ibw.eq.1) call advbcww(dum,rru,w3d)

      IF(ebc.eq.2 .and. ibe.eq.1) call advbcwe(xf,dum,rru,w3d)

    IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni
        advx(i,j,k)=-(dum(i+1,j,k)-dum(i,j,k))*rdx*uh(i)
      enddo
      enddo
      enddo

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni
        advx(i,j,k)=-(xf(i+1)*dum(i+1,j,k)-xf(i)*dum(i,j,k))*rdx*uh(i)*rxh(i)
      enddo
      enddo
      enddo

    ENDIF

      IF(wbc.eq.2 .and. ibw.eq.1)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
          i=1
          if((rru(i,j,k)+rru(i,j,k-1)).ge.0.0)then
            advx(i,j,k)=advx(i,j,k)-w3d(i,j,k)*0.5*(      &
                    (rru(i+1,j,k-1)-rru(i,j,k-1))         &
                   +(rru(i+1,j,k  )-rru(i,j,k  )) )*rdx*uh(i)
          endif
        enddo
        enddo
      ENDIF

      IF(ebc.eq.2 .and. ibe.eq.1)THEN

      IF(axisymm.eq.0)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
          i=ni+1
          if((rru(i,j,k)+rru(i,j,k-1)).lt.0.0)then
            i=ni
            advx(i,j,k)=advx(i,j,k)-w3d(i,j,k)*0.5*(      &
                    (rru(i+1,j,k-1)-rru(i,j,k-1))         &
                   +(rru(i+1,j,k  )-rru(i,j,k  )) )*rdx*uh(i)
          endif
        enddo
        enddo
      ELSE
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
          i=ni+1
          if((rru(i,j,k)+rru(i,j,k-1)).lt.0.0)then
            i=ni
            advx(i,j,k)=advx(i,j,k)-w3d(i,j,k)*0.5*(      &
                    (xf(i+1)*rru(i+1,j,k-1)-xf(i)*rru(i,j,k-1))         &
                   +(xf(i+1)*rru(i+1,j,k  )-xf(i)*rru(i,j,k  )) )*rdx*uh(i)*rxh(i)
          endif
        enddo
        enddo
      ENDIF

      ENDIF

!----------------------------------------------------------------
! Advection in y-direction

    IF(axisymm.eq.0)THEN

      j1 = 1
      j2 = nj+1

      if(sbc.eq.2 .and. ibs.eq.1)then
        j1=4
      endif

      if(nbc.eq.2 .and. ibn.eq.1)then
        j2=nj-2
      endif

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=j1,j2
      do i=1,ni
        dum(i,j,k)=(rrv(i,j,k)+rrv(i,j,k-1))*             &
                   ( 37.0*(w3d(i,j  ,k)+w3d(i,j-1,k))     &
                     -8.0*(w3d(i,j+1,k)+w3d(i,j-2,k))     &
                         +(w3d(i,j+2,k)+w3d(i,j-3,k)) )*tem
      enddo
      enddo
      enddo

      IF(sbc.eq.2 .and. ibs.eq.1) call advbcws(dum,rrv,w3d)

      IF(nbc.eq.2 .and. ibn.eq.1) call advbcwn(dum,rrv,w3d)

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni
        advy(i,j,k)=-(dum(i,j+1,k)-dum(i,j,k))*rdy*vh(j)
      enddo
      enddo
      enddo

      IF(sbc.eq.2 .and. ibs.eq.1)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do i=1,ni
          j=1
          if((rrv(i,j,k)+rrv(i,j,k-1)).ge.0.0)then
            advy(i,j,k)=advy(i,j,k)-w3d(i,j,k)*0.5*(       &
                           (rrv(i,j+1,k-1)-rrv(i,j,k-1))   &
                          +(rrv(i,j+1,k  )-rrv(i,j,k  )) )*rdy*vh(j)
          endif
        enddo
        enddo
      ENDIF

      IF(nbc.eq.2 .and. ibn.eq.1)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do i=1,ni
          j=nj+1
          if((rrv(i,j,k)+rrv(i,j,k-1)).lt.0.0)then
            j=nj
            advy(i,j,k)=advy(i,j,k)-w3d(i,j,k)*0.5*(       &
                           (rrv(i,j+1,k-1)-rrv(i,j,k-1))   &
                          +(rrv(i,j+1,k  )-rrv(i,j,k  )) )*rdy*vh(j)
          endif
        enddo
        enddo
      ENDIF

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni
        advy(i,j,k)=0.0
      enddo
      enddo
      enddo

    ENDIF

!----------------------------------------------------------------

      if(vadvorder.eq.5)then
        call vadv5w(gz,mf,dum,advz,rrw,w3d)
      elseif(vadvorder.eq.6)then
        call vadv6w(gz,mf,dum,advz,rrw,w3d)
      endif
 
!----------------------------------------------------------------

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni
        wten(i,j,k)=wten(i,j,k)+( advx(i,j,k)+advy(i,j,k)+advz(i,j,k)    &
                   +w3d(i,j,k)*0.5*(divx(i,j,k)+divx(i,j,k-1)) )*rrf0(i,j,k)
      enddo
      enddo
      enddo

!----------------------------------------------------------------
 
      if(timestats.ge.1) time_advw=time_advw+mytime()
 
      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine vadv6w(gz,mf,dum,advz,rrw,w3d)
      implicit none

      include 'input.incl'
      include 'constants.incl'

      real, dimension(itb:ite,jtb:jte) :: gz
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, dimension(ib:ie,jb:je,kb:ke) :: dum,advz
      real, dimension(ib:ie,jb:je,kb:ke+1) :: rrw,w3d

      integer i,j,k
      real, parameter :: tem1 = 1.0/120.0
      real, parameter :: tem2 = 1.0/24.0

!----------------------------------------------------------------
! Advection in z-direction

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=3,nk-2
      do j=1,nj
      do i=1,ni
        dum(i,j,k)=(rrw(i,j,k)+rrw(i,j,k+1))*  &
                   ( 37.0*(w3d(i,j,k+1)+w3d(i,j,k  ))          &
                     -8.0*(w3d(i,j,k+2)+w3d(i,j,k-1))          &
                         +(w3d(i,j,k+3)+w3d(i,j,k-2)) )*tem1
      enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,(nk-1),(nk-3)
      do j=1,nj
      do i=1,ni
        dum(i,j,k)=(rrw(i,j,k)+rrw(i,j,k+1))*         &
                   ( 7.0*(w3d(i,j,k+1)+w3d(i,j,k  ))                  &
                        -(w3d(i,j,k+2)+w3d(i,j,k-1)) )*tem2
      enddo
      enddo
      enddo
 
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk,(nk-1)
      do j=1,nj
      do i=1,ni
        dum(i,j,k)=0.25*(rrw(i,j,k)+rrw(i,j,k+1))    &
                       *(w3d(i,j,k)+w3d(i,j,k+1))
      enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni
        advz(i,j,k)=-(dum(i,j,k)-dum(i,j,k-1))*rdz*mf(i,j,k)
      enddo
      enddo
      enddo

      IF(terrain_flag)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=1,ni
          advz(i,j,k)=advz(i,j,k)/gz(i,j)
        enddo
        enddo
        enddo

      ENDIF

!----------------------------------------------------------------
 
      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine advbcsw(dum,rru,s)
      implicit none

      include 'input.incl'
      include 'constants.incl'

      real, dimension(ib:ie,jb:je,kb:ke) :: dum
      real, dimension(ib:ie+1,jb:je,kb:ke) :: rru
      real, dimension(ib:ie,jb:je,kb:ke) :: s

      integer i,j,k
      real, parameter :: tem = 1.0/6.0

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
        i=3
        if(rru(i,j,k).ge.0.0)then
          dum(i,j,k)=rru(i,j,k)*(-s(i-2,j,k)+5.*s(i-1,j,k)+2.*s(i,j,k))*tem
        else
          dum(i,j,k)=rru(i,j,k)*(-s(i+1,j,k)+5.*s(i,j,k)+2.*s(i-1,j,k))*tem
        endif
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
        i=2
        if(rru(i,j,k).ge.0.0)then
          dum(i,j,k)=rru(i,j,k)*s(i-1,j,k)
        else
          dum(i,j,k)=rru(i,j,k)*s(i,j,k)
        endif
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
        i=1
        if(rru(i,j,k).lt.0.0)then
          dum(i,j,k)=rru(i,j,k)*s(i,j,k)
        else
          dum(i,j,k)=dum(i+1,j,k)
        endif
      enddo
      enddo

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine advbcse(xf,dum,rru,s)
      implicit none

      include 'input.incl'
      include 'constants.incl'

      real, dimension(ib:ie+1) :: xf
      real, dimension(ib:ie,jb:je,kb:ke) :: dum
      real, dimension(ib:ie+1,jb:je,kb:ke) :: rru
      real, dimension(ib:ie,jb:je,kb:ke) :: s

      integer i,j,k
      real, parameter :: tem = 1.0/6.0

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
        i=ni-1
        if(rru(i,j,k).ge.0.0)then
          dum(i,j,k)=rru(i,j,k)*(-s(i-2,j,k)+5.*s(i-1,j,k)+2.*s(i,j,k))*tem
        else
          dum(i,j,k)=rru(i,j,k)*(-s(i+1,j,k)+5.*s(i,j,k)+2.*s(i-1,j,k))*tem
        endif
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
        i=ni
        if(rru(i,j,k).ge.0.0)then
          dum(i,j,k)=rru(i,j,k)*s(i-1,j,k)
        else
          dum(i,j,k)=rru(i,j,k)*s(i,j,k)
        endif
      enddo
      enddo

    IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
        i=ni+1
        if(rru(i,j,k).ge.0.0)then
          dum(i,j,k)=rru(i,j,k)*s(i-1,j,k)
        else
          dum(i,j,k)=dum(i-1,j,k)
        endif
      enddo
      enddo

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
        i=ni+1
        if(rru(i,j,k).ge.0.0)then
          dum(i,j,k)=rru(i,j,k)*s(i-1,j,k)
        else
          dum(i,j,k)=dum(i-1,j,k)*xf(ni)/xf(ni+1)
        endif
      enddo
      enddo

    ENDIF

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine advbcss(dum,rrv,s)
      implicit none

      include 'input.incl'
      include 'constants.incl'

      real, dimension(ib:ie,jb:je,kb:ke) :: dum
      real, dimension(ib:ie,jb:je+1,kb:ke) :: rrv
      real, dimension(ib:ie,jb:je,kb:ke) :: s

      integer i,j,k
      real, parameter :: tem = 1.0/6.0

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do i=1,ni
        j=3
        if(rrv(i,j,k).ge.0.0)then
          dum(i,j,k)=rrv(i,j,k)*(-s(i,j-2,k)+5.*s(i,j-1,k)+2.*s(i,j,k))*tem
        else
          dum(i,j,k)=rrv(i,j,k)*(-s(i,j+1,k)+5.*s(i,j,k)+2.*s(i,j-1,k))*tem
        endif
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do i=1,ni
        j=2
        if(rrv(i,j,k).ge.0.0)then
          dum(i,j,k)=rrv(i,j,k)*s(i,j-1,k)
        else
          dum(i,j,k)=rrv(i,j,k)*s(i,j,k)
        endif
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do i=1,ni
        j=1
        if(rrv(i,j,k).lt.0.0)then
          dum(i,j,k)=rrv(i,j,k)*s(i,j,k)
        else
          dum(i,j,k)=dum(i,j+1,k)
        endif
      enddo
      enddo

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine advbcsn(dum,rrv,s)
      implicit none

      include 'input.incl'
      include 'constants.incl'

      real, dimension(ib:ie,jb:je,kb:ke) :: dum
      real, dimension(ib:ie,jb:je+1,kb:ke) :: rrv
      real, dimension(ib:ie,jb:je,kb:ke) :: s

      integer i,j,k
      real, parameter :: tem = 1.0/6.0

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do i=1,ni
        j=nj-1
        if(rrv(i,j,k).ge.0.0)then
          dum(i,j,k)=rrv(i,j,k)*(-s(i,j-2,k)+5.*s(i,j-1,k)+2.*s(i,j,k))*tem
        else
          dum(i,j,k)=rrv(i,j,k)*(-s(i,j+1,k)+5.*s(i,j,k)+2.*s(i,j-1,k))*tem
        endif
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do i=1,ni
        j=nj
        if(rrv(i,j,k).ge.0.0)then
          dum(i,j,k)=rrv(i,j,k)*s(i,j-1,k)
        else
          dum(i,j,k)=rrv(i,j,k)*s(i,j,k)
        endif
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do i=1,ni
        j=nj+1
        if(rrv(i,j,k).ge.0.0)then
          dum(i,j,k)=rrv(i,j,k)*s(i,j-1,k)
        else
          dum(i,j,k)=dum(i,j-1,k)
        endif
      enddo
      enddo

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine advbcuw(dum,rru,u3d)
      implicit none

      include 'input.incl'
      include 'constants.incl'

      real, dimension(ib:ie,jb:je,kb:ke) :: dum
      real, dimension(ib:ie+1,jb:je,kb:ke) :: rru,u3d

      integer i,j,k
      real, parameter :: tem = 1.0/12.0

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
        i=2
        if((rru(i,j,k)+rru(i+1,j,k)).ge.0.)then
          dum(i,j,k)=(rru(i,j,k)+rru(i+1,j,k))*                     &
                 (-u3d(i-1,j,k)+5.*u3d(i  ,j,k)+2.*u3d(i+1,j,k))*tem
        else
          dum(i,j,k)=(rru(i,j,k)+rru(i+1,j,k))*                       &
                 (-u3d(i+2,j,k)+5.*u3d(i+1,j,k)+2.*u3d(i  ,j,k))*tem
        endif
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
        i=1
        if((rru(i,j,k)+rru(i+1,j,k)).ge.0.)then
          dum(i,j,k)=0.5*(rru(i,j,k)+rru(i+1,j,k))*u3d(i  ,j,k)
        else
          dum(i,j,k)=0.5*(rru(i,j,k)+rru(i+1,j,k))*u3d(i+1,j,k)
        endif
      enddo
      enddo

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine advbcue(xf,dum,rru,u3d)
      implicit none

      include 'input.incl'
      include 'constants.incl'

      real, dimension(ib:ie+1) :: xf
      real, dimension(ib:ie,jb:je,kb:ke) :: dum
      real, dimension(ib:ie+1,jb:je,kb:ke) :: rru,u3d

      integer i,j,k
      real, parameter :: tem = 1.0/12.0

    IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
        i=ni-1
        if((rru(i,j,k)+rru(i+1,j,k)).ge.0.)then
          dum(i,j,k)=(rru(i,j,k)+rru(i+1,j,k))*                     &
                 (-u3d(i-1,j,k)+5.*u3d(i  ,j,k)+2.*u3d(i+1,j,k))*tem
        else
          dum(i,j,k)=(rru(i,j,k)+rru(i+1,j,k))*                       &
                 (-u3d(i+2,j,k)+5.*u3d(i+1,j,k)+2.*u3d(i  ,j,k))*tem
        endif
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
        i=ni
        if((rru(i,j,k)+rru(i+1,j,k)).ge.0.)then
          dum(i,j,k)=0.5*(rru(i,j,k)+rru(i+1,j,k))*u3d(i  ,j,k)
        else
          dum(i,j,k)=0.5*(rru(i,j,k)+rru(i+1,j,k))*u3d(i+1,j,k)
        endif
      enddo
      enddo

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
        i=ni-1
        if((rru(i,j,k)+rru(i+1,j,k)).ge.0.)then
          dum(i,j,k)=(xf(i)*rru(i,j,k)+xf(i+1)*rru(i+1,j,k))*                     &
                 (-u3d(i-1,j,k)+5.*u3d(i  ,j,k)+2.*u3d(i+1,j,k))*tem
        else
          dum(i,j,k)=(xf(i)*rru(i,j,k)+xf(i+1)*rru(i+1,j,k))*                       &
                 (-u3d(i+2,j,k)+5.*u3d(i+1,j,k)+2.*u3d(i  ,j,k))*tem
        endif
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
        i=ni
        if((rru(i,j,k)+rru(i+1,j,k)).ge.0.)then
          dum(i,j,k)=0.5*(xf(i)*rru(i,j,k)+xf(i+1)*rru(i+1,j,k))*u3d(i  ,j,k)
        else
          dum(i,j,k)=0.5*(xf(i)*rru(i,j,k)+xf(i+1)*rru(i+1,j,k))*u3d(i+1,j,k)
        endif
      enddo
      enddo

    ENDIF

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine advbcus(dum,u3d,rrv,i1,i2)
      implicit none

      include 'input.incl'
      include 'constants.incl'

      real, dimension(ib:ie,jb:je,kb:ke) :: dum
      real, dimension(ib:ie+1,jb:je,kb:ke) :: u3d
      real, dimension(ib:ie,jb:je+1,kb:ke) :: rrv
      integer i1,i2

      integer i,j,k
      real, parameter :: tem = 1.0/12.0

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do i=i1,i2
        j=3
        if((rrv(i,j,k)+rrv(i-1,j,k)).ge.0.0)then
          dum(i,j,k)=(rrv(i,j,k)+rrv(i-1,j,k))    &
                    *(-u3d(i,j-2,k)+5.*u3d(i,j-1,k)+2.*u3d(i,j,k))*tem
        else
          dum(i,j,k)=(rrv(i,j,k)+rrv(i-1,j,k))    &
                    *(-u3d(i,j+1,k)+5.*u3d(i,j,k)+2.*u3d(i,j-1,k))*tem
        endif
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do i=i1,i2
        j=2
        if((rrv(i,j,k)+rrv(i-1,j,k)).ge.0.0)then
          dum(i,j,k)=0.5*(rrv(i,j,k)+rrv(i-1,j,k))*u3d(i,j-1,k)
        else
          dum(i,j,k)=0.5*(rrv(i,j,k)+rrv(i-1,j,k))*u3d(i,j,k)
        endif
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do i=i1,i2
        j=1
        if((rrv(i,j,k)+rrv(i-1,j,k)).lt.0.0)then
          dum(i,j,k)=0.5*(rrv(i,j,k)+rrv(i-1,j,k))*u3d(i,j,k)
        else
          dum(i,j,k)=dum(i,j+1,k)
        endif
      enddo
      enddo

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine advbcun(dum,u3d,rrv,i1,i2)
      implicit none

      include 'input.incl'
      include 'constants.incl'

      real, dimension(ib:ie,jb:je,kb:ke) :: dum
      real, dimension(ib:ie+1,jb:je,kb:ke) :: u3d
      real, dimension(ib:ie,jb:je+1,kb:ke) :: rrv
      integer i1,i2

      integer i,j,k
      real, parameter :: tem = 1.0/12.0

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do i=i1,i2
        j=nj-1
        if((rrv(i,j,k)+rrv(i-1,j,k)).ge.0.0)then
          dum(i,j,k)=(rrv(i,j,k)+rrv(i-1,j,k))    &
                    *(-u3d(i,j-2,k)+5.*u3d(i,j-1,k)+2.*u3d(i,j,k))*tem
        else
          dum(i,j,k)=(rrv(i,j,k)+rrv(i-1,j,k))    &
                    *(-u3d(i,j+1,k)+5.*u3d(i,j,k)+2.*u3d(i,j-1,k))*tem
        endif
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do i=i1,i2
        j=nj
        if((rrv(i,j,k)+rrv(i-1,j,k)).ge.0.0)then
          dum(i,j,k)=0.5*(rrv(i,j,k)+rrv(i-1,j,k))*u3d(i,j-1,k)
        else
          dum(i,j,k)=0.5*(rrv(i,j,k)+rrv(i-1,j,k))*u3d(i,j,k)
        endif
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do i=i1,i2
        j=nj+1
        if((rrv(i,j,k)+rrv(i-1,j,k)).ge.0.0)then
          dum(i,j,k)=0.5*(rrv(i,j,k)+rrv(i-1,j,k))*u3d(i,j-1,k)
        else
          dum(i,j,k)=dum(i,j-1,k)
        endif
      enddo
      enddo

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine advbcvw(dum,rru,v3d,j1,j2)
      implicit none

      include 'input.incl'
      include 'constants.incl'

      real, dimension(ib:ie,jb:je,kb:ke) :: dum
      real, dimension(ib:ie+1,jb:je,kb:ke) :: rru
      real, dimension(ib:ie,jb:je+1,kb:ke) :: v3d
      integer j1,j2

      integer i,j,k
      real, parameter :: tem = 1.0/12.0

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=j1,j2
        i=3
        if((rru(i,j,k)+rru(i,j-1,k)).ge.0.)then
          dum(i,j,k)=(rru(i,j,k)+rru(i,j-1,k))*    &
                 (-v3d(i-2,j,k)+5.*v3d(i-1,j,k)+2.*v3d(i  ,j,k))*tem
        else
          dum(i,j,k)=(rru(i,j,k)+rru(i,j-1,k))*    &
                 (-v3d(i+1,j,k)+5.*v3d(i  ,j,k)+2.*v3d(i-1,j,k))*tem
        endif
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=j1,j2
        i=2
        if((rru(i,j,k)+rru(i,j-1,k)).ge.0.)then
          dum(i,j,k)=0.5*(rru(i,j,k)+rru(i,j-1,k))*v3d(i-1,j,k)
        else
          dum(i,j,k)=0.5*(rru(i,j,k)+rru(i,j-1,k))*v3d(i  ,j,k)
        endif
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=j1,j2
        i=1
        if((rru(i,j,k)+rru(i,j-1,k)).lt.0.0)then
          dum(i,j,k)=0.5*(rru(i,j,k)+rru(i,j-1,k))*v3d(i,j,k)
        else
          dum(i,j,k)=dum(i+1,j,k)
        endif
      enddo
      enddo

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine advbcve(xf,dum,rru,v3d,j1,j2)
      implicit none

      include 'input.incl'
      include 'constants.incl'

      real, dimension(ib:ie+1) :: xf
      real, dimension(ib:ie,jb:je,kb:ke) :: dum
      real, dimension(ib:ie+1,jb:je,kb:ke) :: rru
      real, dimension(ib:ie,jb:je+1,kb:ke) :: v3d
      integer j1,j2

      integer i,j,k
      real, parameter :: tem = 1.0/12.0

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=j1,j2
        i=ni-1
        if((rru(i,j,k)+rru(i,j-1,k)).ge.0.)then
          dum(i,j,k)=(rru(i,j,k)+rru(i,j-1,k))*    &
                 (-v3d(i-2,j,k)+5.*v3d(i-1,j,k)+2.*v3d(i  ,j,k))*tem
        else
          dum(i,j,k)=(rru(i,j,k)+rru(i,j-1,k))*    &
                 (-v3d(i+1,j,k)+5.*v3d(i  ,j,k)+2.*v3d(i-1,j,k))*tem
        endif
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=j1,j2
        i=ni
        if((rru(i,j,k)+rru(i,j-1,k)).ge.0.)then
          dum(i,j,k)=0.5*(rru(i,j,k)+rru(i,j-1,k))*v3d(i-1,j,k)
        else
          dum(i,j,k)=0.5*(rru(i,j,k)+rru(i,j-1,k))*v3d(i  ,j,k)
        endif
      enddo
      enddo

    IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=j1,j2
        i=ni+1
        if((rru(i,j,k)+rru(i,j-1,k)).ge.0.0)then
          dum(i,j,k)=0.5*(rru(i,j,k)+rru(i,j-1,k))*v3d(i-1,j,k)
        else
          dum(i,j,k)=dum(i-1,j,k)
        endif
      enddo
      enddo

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=j1,j2
        i=ni+1
        if((rru(i,j,k)+rru(i,j-1,k)).ge.0.0)then
          dum(i,j,k)=0.5*(rru(i,j,k)+rru(i,j-1,k))*v3d(i-1,j,k)
        else
          dum(i,j,k)=dum(i-1,j,k)*xf(ni)/xf(ni+1)
        endif
      enddo
      enddo

    ENDIF

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine advbcvs(dum,rrv,v3d)
      implicit none

      include 'input.incl'
      include 'constants.incl'

      real, dimension(ib:ie,jb:je,kb:ke) :: dum
      real, dimension(ib:ie,jb:je+1,kb:ke) :: rrv,v3d

      integer i,j,k
      real, parameter :: tem = 1.0/12.0

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do i=1,ni
        j=2
        if((rrv(i,j,k)+rrv(i,j+1,k)).ge.0.)then
          dum(i,j,k)=(rrv(i,j,k)+rrv(i,j+1,k))*                     &
                 (-v3d(i,j-1,k)+5.*v3d(i,j  ,k)+2.*v3d(i,j+1,k))*tem
        else
          dum(i,j,k)=(rrv(i,j,k)+rrv(i,j+1,k))*                       &
                 (-v3d(i,j+2,k)+5.*v3d(i,j+1,k)+2.*v3d(i,j  ,k))*tem
        endif
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do i=1,ni
        j=1
        if((rrv(i,j,k)+rrv(i,j+1,k)).ge.0.)then
          dum(i,j,k)=0.5*(rrv(i,j,k)+rrv(i,j+1,k))*v3d(i,j  ,k)
        else
          dum(i,j,k)=0.5*(rrv(i,j,k)+rrv(i,j+1,k))*v3d(i,j+1,k)
        endif
      enddo
      enddo

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine advbcvn(dum,rrv,v3d)
      implicit none

      include 'input.incl'
      include 'constants.incl'

      real, dimension(ib:ie,jb:je,kb:ke) :: dum
      real, dimension(ib:ie,jb:je+1,kb:ke) :: rrv,v3d

      integer i,j,k
      real, parameter :: tem = 1.0/12.0

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do i=1,ni
        j=nj-1
        if((rrv(i,j,k)+rrv(i,j+1,k)).ge.0.)then
          dum(i,j,k)=(rrv(i,j,k)+rrv(i,j+1,k))*                     &
                 (-v3d(i,j-1,k)+5.*v3d(i,j  ,k)+2.*v3d(i,j+1,k))*tem
        else
          dum(i,j,k)=(rrv(i,j,k)+rrv(i,j+1,k))*                       &
                 (-v3d(i,j+2,k)+5.*v3d(i,j+1,k)+2.*v3d(i,j  ,k))*tem
        endif
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do i=1,ni
        j=nj
        if((rrv(i,j,k)+rrv(i,j+1,k)).ge.0.)then
          dum(i,j,k)=0.5*(rrv(i,j,k)+rrv(i,j+1,k))*v3d(i,j  ,k)
        else
          dum(i,j,k)=0.5*(rrv(i,j,k)+rrv(i,j+1,k))*v3d(i,j+1,k)
        endif
      enddo
      enddo

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine advbcww(dum,rru,w3d)
      implicit none

      include 'input.incl'
      include 'constants.incl'

      real, dimension(ib:ie,jb:je,kb:ke) :: dum
      real, dimension(ib:ie+1,jb:je,kb:ke) :: rru
      real, dimension(ib:ie,jb:je,kb:ke+1) :: w3d

      integer i,j,k
      real, parameter :: tem = 1.0/12.0

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
        i=3
        if((rru(i,j,k)+rru(i,j,k-1)).ge.0.)then
          dum(i,j,k)=(rru(i,j,k)+rru(i,j,k-1))*     &
                 (-w3d(i-2,j,k)+5.*w3d(i-1,j,k)+2.*w3d(i  ,j,k))*tem
        else
          dum(i,j,k)=(rru(i,j,k)+rru(i,j,k-1))*     &
                 (-w3d(i+1,j,k)+5.*w3d(i  ,j,k)+2.*w3d(i-1,j,k))*tem
        endif
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
        i=2
        if((rru(i,j,k)+rru(i,j,k-1)).ge.0.)then
          dum(i,j,k)=0.5*(rru(i,j,k)+rru(i,j,k-1))*w3d(i-1,j,k)
        else
          dum(i,j,k)=0.5*(rru(i,j,k)+rru(i,j,k-1))*w3d(i  ,j,k)
        endif
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
        i=1
        if((rru(i,j,k)+rru(i,j,k-1)).lt.0.0)then
          dum(i,j,k)=0.5*(rru(i,j,k)+rru(i,j,k-1))*w3d(i,j,k)
        else
          dum(i,j,k)=dum(i+1,j,k)
        endif
      enddo
      enddo

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine advbcwe(xf,dum,rru,w3d)
      implicit none

      include 'input.incl'
      include 'constants.incl'

      real, dimension(ib:ie+1) :: xf
      real, dimension(ib:ie,jb:je,kb:ke) :: dum
      real, dimension(ib:ie+1,jb:je,kb:ke) :: rru
      real, dimension(ib:ie,jb:je,kb:ke+1) :: w3d

      integer i,j,k
      real, parameter :: tem = 1.0/12.0

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
        i=ni-1
        if((rru(i,j,k)+rru(i,j,k-1)).ge.0.)then
          dum(i,j,k)=(rru(i,j,k)+rru(i,j,k-1))*     &
                 (-w3d(i-2,j,k)+5.*w3d(i-1,j,k)+2.*w3d(i  ,j,k))*tem
        else
          dum(i,j,k)=(rru(i,j,k)+rru(i,j,k-1))*     &
                 (-w3d(i+1,j,k)+5.*w3d(i  ,j,k)+2.*w3d(i-1,j,k))*tem
        endif
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
        i=ni
        if((rru(i,j,k)+rru(i,j,k-1)).ge.0.)then
          dum(i,j,k)=0.5*(rru(i,j,k)+rru(i,j,k-1))*w3d(i-1,j,k)
        else
          dum(i,j,k)=0.5*(rru(i,j,k)+rru(i,j,k-1))*w3d(i  ,j,k)
        endif
      enddo
      enddo

    IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
        i=ni+1
        if((rru(i,j,k)+rru(i,j,k-1)).ge.0.0)then
          dum(i,j,k)=0.5*(rru(i,j,k)+rru(i,j,k-1))*w3d(i-1,j,k)
        else
          dum(i,j,k)=dum(i-1,j,k)
        endif
      enddo
      enddo

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
        i=ni+1
        if((rru(i,j,k)+rru(i,j,k-1)).ge.0.0)then
          dum(i,j,k)=0.5*(rru(i,j,k)+rru(i,j,k-1))*w3d(i-1,j,k)
        else
          dum(i,j,k)=dum(i-1,j,k)*xf(ni)/xf(ni+1)
        endif
      enddo
      enddo

    ENDIF

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine advbcws(dum,rrv,w3d)
      implicit none

      include 'input.incl'
      include 'constants.incl'

      real, dimension(ib:ie,jb:je,kb:ke) :: dum
      real, dimension(ib:ie,jb:je+1,kb:ke) :: rrv
      real, dimension(ib:ie,jb:je,kb:ke+1) :: w3d

      integer i,j,k
      real, parameter :: tem = 1.0/12.0

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do i=1,ni
        j=3
        if((rrv(i,j,k)+rrv(i,j,k-1)).ge.0.0)then
          dum(i,j,k)=(rrv(i,j,k)+rrv(i,j,k-1))    &
                    *(-w3d(i,j-2,k)+5.*w3d(i,j-1,k)+2.*w3d(i,j,k))*tem
        else
          dum(i,j,k)=(rrv(i,j,k)+rrv(i,j,k-1))    &
                    *(-w3d(i,j+1,k)+5.*w3d(i,j,k)+2.*w3d(i,j-1,k))*tem
        endif
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do i=1,ni
        j=2
        if((rrv(i,j,k)+rrv(i,j,k-1)).ge.0.0)then
          dum(i,j,k)=0.5*(rrv(i,j,k)+rrv(i,j,k-1))*w3d(i,j-1,k)
        else
          dum(i,j,k)=0.5*(rrv(i,j,k)+rrv(i,j,k-1))*w3d(i,j,k)
        endif
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do i=1,ni
        j=1
        if((rrv(i,j,k)+rrv(i,j,k-1)).lt.0.0)then
          dum(i,j,k)=0.5*(rrv(i,j,k)+rrv(i,j,k-1))*w3d(i,j,k)
        else
          dum(i,j,k)=dum(i,j+1,k)
        endif
      enddo
      enddo

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine advbcwn(dum,rrv,w3d)
      implicit none

      include 'input.incl'
      include 'constants.incl'

      real, dimension(ib:ie,jb:je,kb:ke) :: dum
      real, dimension(ib:ie,jb:je+1,kb:ke) :: rrv
      real, dimension(ib:ie,jb:je,kb:ke+1) :: w3d

      integer i,j,k
      real, parameter :: tem = 1.0/12.0

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do i=1,ni
        j=nj-1
        if((rrv(i,j,k)+rrv(i,j,k-1)).ge.0.0)then
          dum(i,j,k)=(rrv(i,j,k)+rrv(i,j,k-1))    &
                    *(-w3d(i,j-2,k)+5.*w3d(i,j-1,k)+2.*w3d(i,j,k))*tem
        else
          dum(i,j,k)=(rrv(i,j,k)+rrv(i,j,k-1))    &
                    *(-w3d(i,j+1,k)+5.*w3d(i,j,k)+2.*w3d(i,j-1,k))*tem
        endif
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do i=1,ni
        j=nj
        if((rrv(i,j,k)+rrv(i,j,k-1)).ge.0.0)then
          dum(i,j,k)=0.5*(rrv(i,j,k)+rrv(i,j,k-1))*w3d(i,j-1,k)
        else
          dum(i,j,k)=0.5*(rrv(i,j,k)+rrv(i,j,k-1))*w3d(i,j,k)
        endif
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do i=1,ni
        j=nj+1
        if((rrv(i,j,k)+rrv(i,j,k-1)).ge.0.0)then
          dum(i,j,k)=0.5*(rrv(i,j,k)+rrv(i,j,k-1))*w3d(i,j-1,k)
        else
          dum(i,j,k)=dum(i,j-1,k)
        endif
      enddo
      enddo

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine pdefx(xh,rho0,advx,dum,mass,s1,dt)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, dimension(ib:ie) :: xh
      real, dimension(ib:ie,jb:je,kb:ke) :: rho0
      real, dimension(ib:ie,jb:je,kb:ke) :: advx,dum,mass,s1
      real :: dt

      integer i,j,k
      real foo1,foo2,foo3,rdt
      logical, dimension(-1:ni+2) :: flag

#ifdef MPI
      include 'mpif.h'
      integer, dimension(4) :: reqs_s
      real west(2,nj,nk),newwest(2,nj,nk)
      real east(2,nj,nk),neweast(2,nj,nk)
#endif

!----------------------------------------------------------------

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          dum(i,j,k)=rho0(i,j,k)*s1(i,j,k)+dt*advx(i,j,k)
        enddo
        enddo
        enddo
        if(timestats.ge.1) time_pdef=time_pdef+mytime()

        call bcs(dum)
#ifdef MPI
        call comm_2we_start(dum,west,newwest,east,neweast,reqs_s)
#endif

        rdt=1.0/dt

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=-1,ni+2
          mass(i,j,k)=0.0
        enddo
        enddo
        enddo
        if(timestats.ge.1) time_pdef=time_pdef+mytime()

#ifdef MPI
        call comm_2we_end(dum,west,newwest,east,neweast,reqs_s)
#endif

        if(ibw.eq.1.and.wbc.eq.2)then
!$omp parallel do default(shared)  &
!$omp private(j,k)
          do k=1,nk
          do j=1,nj
            dum(-1,j,k)=0.0
            dum( 0,j,k)=0.0
            dum( 1,j,k)=0.0
          enddo
          enddo
        endif

        if(ibe.eq.1.and.ebc.eq.2)then
!$omp parallel do default(shared)  &
!$omp private(j,k)
          do k=1,nk
          do j=1,nj
            dum(ni  ,j,k)=0.0
            dum(ni+1,j,k)=0.0
            dum(ni+2,j,k)=0.0
          enddo
          enddo
        endif

      IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k,foo1,foo2,foo3,flag)
        do k=1,nk
        do j=1,nj
        do i=-1,ni+2
          flag(i)=.false.
        enddo
        do i=0,ni+1
          if(dum(i,j,k).lt.0.0)then
            foo1=max(0.0,dum(i-1,j,k))
            foo2=max(0.0,dum(i+1,j,k))
            if(foo1+foo2.gt.1.0e-30)then
              foo3=max(dum(i,j,k),-(foo1+foo2))/(foo1+foo2)
              mass(i-1,j,k)=mass(i-1,j,k)+foo1*foo3
              mass(i  ,j,k)=mass(i  ,j,k)-(foo1+foo2)*foo3
              mass(i+1,j,k)=mass(i+1,j,k)+foo2*foo3
              if(dum(i-1,j,k).gt.1.0e-30) flag(i-1)=.true.
                                          flag(i  )=.true.
              if(dum(i+1,j,k).gt.1.0e-30) flag(i+1)=.true.
            endif
          endif
        enddo
        do i=1,ni
        if(flag(i))then
          dum(i,j,k)=dum(i,j,k)+mass(i,j,k)
          advx(i,j,k)=(dum(i,j,k)-rho0(i,j,k)*s1(i,j,k))*rdt
        endif
        enddo
        enddo
        enddo

      ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k,foo1,foo2,foo3,flag)
        do k=1,nk
        do j=1,nj
        do i=-1,ni+2
          flag(i)=.false.
        enddo
        do i=0,ni+1
          if(dum(i,j,k).lt.0.0)then
            foo1=max(0.0,dum(i-1,j,k))
            foo2=max(0.0,dum(i+1,j,k))
            if(foo1+foo2.gt.1.0e-30)then
              foo3=max(xh(i)*dum(i,j,k),-(xh(i-1)*foo1+xh(i+1)*foo2))   &
                                        /(xh(i-1)*foo1+xh(i+1)*foo2)
              mass(i-1,j,k)=mass(i-1,j,k)+foo1*foo3
              mass(i  ,j,k)=mass(i  ,j,k)-(foo1+foo2)*foo3
              mass(i+1,j,k)=mass(i+1,j,k)+foo2*foo3
              if(dum(i-1,j,k).gt.1.0e-30) flag(i-1)=.true.
                                          flag(i  )=.true.
              if(dum(i+1,j,k).gt.1.0e-30) flag(i+1)=.true.
            endif
          endif
        enddo
        do i=1,ni
        if(flag(i))then
          dum(i,j,k)=dum(i,j,k)+mass(i,j,k)
          advx(i,j,k)=(dum(i,j,k)-rho0(i,j,k)*s1(i,j,k))*rdt
        endif
        enddo
        enddo
        enddo

      ENDIF

!----------------------------------------------------------------

      if(timestats.ge.1) time_pdef=time_pdef+mytime()

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine pdefy(rho0,advy,dum,mass,s1,dt)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, dimension(ib:ie,jb:je,kb:ke) :: rho0
      real, dimension(ib:ie,jb:je,kb:ke) :: advy,dum,mass,s1
      real :: dt

      integer i,j,k
      real foo1,foo2,foo3,rdt
      logical, dimension(-1:nj+2) :: flag

#ifdef MPI
      include 'mpif.h'
      integer, dimension(4) :: reqs_s
      real south(ni,2,nk),newsouth(ni,2,nk)
      real north(ni,2,nk),newnorth(ni,2,nk)
#endif

!----------------------------------------------------------------

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          dum(i,j,k)=rho0(i,j,k)*s1(i,j,k)+dt*advy(i,j,k)
        enddo
        enddo
        enddo
        if(timestats.ge.1) time_pdef=time_pdef+mytime()

        call bcs(dum)
#ifdef MPI
        call comm_2sn_start(dum,south,newsouth,north,newnorth,reqs_s)
#endif

        rdt=1.0/dt

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=-1,nj+2
        do i=1,ni
          mass(i,j,k)=0.0
        enddo
        enddo
        enddo
        if(timestats.ge.1) time_pdef=time_pdef+mytime()

#ifdef MPI
        call comm_2sn_end(dum,south,newsouth,north,newnorth,reqs_s)
#endif

        if(ibs.eq.1.and.sbc.eq.2)then
!$omp parallel do default(shared)  &
!$omp private(i,k)
          do k=1,nk
          do i=1,ni
            dum(i,-1,k)=0.0
            dum(i, 0,k)=0.0
            dum(i, 1,k)=0.0
          enddo
          enddo
        endif

        if(ibn.eq.1.and.nbc.eq.2)then
!$omp parallel do default(shared)  &
!$omp private(i,k)
          do k=1,nk
          do i=1,ni
            dum(i,nj  ,k)=0.0
            dum(i,nj+1,k)=0.0
            dum(i,nj+2,k)=0.0
          enddo
          enddo
        elseif(ibn.eq.1.and.nbc.eq.3)then
!$omp parallel do default(shared)  &
!$omp private(i,k)
          do k=1,nk
          do i=1,ni
            dum(i,nj+1,k)=dum(i,nj,k)
            dum(i,nj+2,k)=dum(i,nj,k)
          enddo
          enddo
        endif

!$omp parallel do default(shared)   &
!$omp private(i,j,k,foo1,foo2,foo3,flag)
        do k=1,nk
        do i=1,ni
        do j=-1,nj+2
          flag(j)=.false.
        enddo
        do j=0,nj+1
          if(dum(i,j,k).lt.0.0)then
            foo1=max(0.0,dum(i,j-1,k))
            foo2=max(0.0,dum(i,j+1,k))
            if(foo1+foo2.gt.1.0e-30)then
              foo3=max(dum(i,j,k),-(foo1+foo2))/(foo1+foo2)
              mass(i,j-1,k)=mass(i,j-1,k)+foo1*foo3
              mass(i,j  ,k)=mass(i,j  ,k)-(foo1+foo2)*foo3
              mass(i,j+1,k)=mass(i,j+1,k)+foo2*foo3
              if(dum(i,j-1,k).gt.1.0e-30) flag(j-1)=.true.
                                          flag(j  )=.true.
              if(dum(i,j+1,k).gt.1.0e-30) flag(j+1)=.true.
            endif
          endif
        enddo
        do j=1,nj
        if(flag(j))then
          dum(i,j,k)=dum(i,j,k)+mass(i,j,k)
          advy(i,j,k)=(dum(i,j,k)-rho0(i,j,k)*s1(i,j,k))*rdt
        endif
        enddo
        enddo
        enddo

!----------------------------------------------------------------

      if(timestats.ge.1) time_pdef=time_pdef+mytime()

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine pdefz(rho0,advz,dum,mass,s1,dt)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, dimension(ib:ie,jb:je,kb:ke) :: rho0
      real, dimension(ib:ie,jb:je,kb:ke) :: advz,dum,mass,s1
      real :: dt

      integer i,j,k
      real foo1,foo2,foo3,rdt
      logical, dimension(0:nk+1) :: flag

!----------------------------------------------------------------

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          dum(i,j,k)=rho0(i,j,k)*s1(i,j,k)+dt*advz(i,j,k)
        enddo
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          dum(i,j, 0)=0.0
          dum(i,j,nk+1)=0.0
        enddo
        enddo

        rdt=1.0/dt

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=0,nk+1
        do j=0,nj+1
        do i=0,ni+1
          mass(i,j,k)=0.0
        enddo
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k,foo1,foo2,foo3,flag)
      do j=1,nj
      do i=1,ni
        do k=0,nk+1
          flag(k)=.false.
        enddo
        do k=1,nk
          if(dum(i,j,k).lt.0.0)then
            foo1=max(0.0,dum(i,j,k-1))
            foo2=max(0.0,dum(i,j,k+1))
            if(foo1+foo2.gt.1.0e-30)then
              foo3=max(dum(i,j,k),-(foo1+foo2))/(foo1+foo2)
              mass(i,j,k-1)=mass(i,j,k-1)+foo1*foo3
              mass(i,j,k  )=mass(i,j,k  )-(foo1+foo2)*foo3
              mass(i,j,k+1)=mass(i,j,k+1)+foo2*foo3
              if(dum(i,j,k-1).gt.1.0e-30) flag(k-1)=.true.
                                          flag(k  )=.true.
              if(dum(i,j,k+1).gt.1.0e-30) flag(k+1)=.true.
            endif
          endif
        enddo
        do k=1,nk
        if(flag(k))then
          dum(i,j,k)=dum(i,j,k)+mass(i,j,k)
          advz(i,j,k)=(dum(i,j,k)-rho0(i,j,k)*s1(i,j,k))*rdt
        endif
        enddo
      enddo
      enddo

!----------------------------------------------------------------

      if(timestats.ge.1) time_pdef=time_pdef+mytime()

      return
      end



anelp.F/        1298670057  19071 8000  100644  7295      `


      subroutine anelp(xh,uh,xf,uf,yh,vh,yf,vf,                     &
                       zh,mh,rmh,mf,rmf,pi0,thv0,rho0,prs0,rf0,     &
                       radbcw,radbce,radbcs,radbcn,dum1,divx,       &
                       u0,ua,u3d,uten,v0,va,v3d,vten,wa,w3d,wten,   &
                       ppi,pp3d,thv,cfb,cfa,cfc,d1,d2,pdt,deft,rhs,trans,dttmp,nrk,rtime)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, dimension(ib:ie) :: xh,uh
      real, dimension(ib:ie+1) :: xf,uf
      real, dimension(jb:je) :: yh,vh
      real, dimension(jb:je+1) :: yf,vf
      real, dimension(ib:ie,jb:je,kb:ke) :: zh,mh,rmh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf,rmf
      real, dimension(ib:ie,jb:je,kb:ke) :: pi0,thv0,rho0,prs0,rf0
      real, dimension(jb:je,kb:ke) :: radbcw,radbce
      real, dimension(ib:ie,kb:ke) :: radbcs,radbcn
      real, dimension(ib:ie,jb:je,kb:ke) :: dum1,divx
      real, dimension(ib:ie+1,jb:je,kb:ke) :: u0,ua,u3d,uten
      real, dimension(ib:ie,jb:je+1,kb:ke) :: v0,va,v3d,vten
      real, dimension(ib:ie,jb:je,kb:ke+1) :: wa,w3d,wten
      real, dimension(ib:ie,jb:je,kb:ke) :: ppi,pp3d,thv
      real, dimension(ipb:ipe,jpb:jpe,kpb:kpe) :: cfb
      real, dimension(kpb:kpe) :: cfa,cfc,d1,d2
      complex, dimension(ipb:ipe,jpb:jpe,kpb:kpe) :: pdt,deft
      complex, dimension(ipb:ipe,jpb:jpe) :: rhs,trans
      real dttmp
      integer nrk
      real, intent(in) :: rtime

!-----

      integer :: i,j,k
      real :: tem
      real*8 :: fluxout,fluxin,u1,v1

!---------------------------------------------------------------------

        if(irbc.eq.2)then
 
          if(ibw.eq.1 .or. ibe.eq.1) call radbcew(radbcw,radbce,ua)
 
          if(ibs.eq.1 .or. ibn.eq.1) call radbcns(radbcs,radbcn,va)
 
        endif

!---------------------------------------------------------------------

        if(ibw.eq.1.and.wbc.eq.2)then
          do k=1,nk
          do j=1,nj
            uten(1,j,k)=uten(1,j,k)-radbcw(j,k)    &
                      *(ua(2,j,k)-ua(1,j,k))*rdx
          enddo
          enddo

          if(myid.eq.0)write(*,*) '  This model configuration has not been tested with open boundary conditions '
          call stopcm1
        endif

        if(ibe.eq.1.and.ebc.eq.2)then
          do k=1,nk
          do j=1,nj
            uten(ni+1,j,k)=uten(ni+1,j,k)-radbce(j,k)     &
                         *(ua(ni+1,j,k)-ua(ni  ,j,k))*rdx
          enddo
          enddo

          if(myid.eq.0)write(*,*) '  This model configuration has not been tested with open boundary conditions '
          call stopcm1
        endif

        if(ibs.eq.1.and.sbc.eq.2)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
          do k=1,nk
          do i=1,ni
            vten(i,1,k)=vten(i,1,k)-radbcs(i,k)    &
                      *(va(i,2,k)-va(i,1,k))*rdy
          enddo
          enddo

          if(myid.eq.0)write(*,*) '  This model configuration has not been tested with open boundary conditions '
          call stopcm1
        endif

        if(ibn.eq.1.and.nbc.eq.2)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
          do k=1,nk
          do i=1,ni
            vten(i,nj+1,k)=vten(i,nj+1,k)-radbcn(i,k)     &
                         *(va(i,nj+1,k)-va(i,nj  ,k))*rdy
          enddo
          enddo

          if(myid.eq.0)write(*,*) '  This model configuration has not been tested with open boundary conditions '
          call stopcm1
        endif

!---------------------------------------------------------------------
!  convergence forcing:

        IF( convinit.eq.1 )THEN
          IF( rtime.le.convtime .and. nx.gt.1 )THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
            do k=1,nk
            do j=1,nj
            do i=1,ni+1
              u3d(i,j,k)=ua(i,j,k)+dttmp*uten(i,j,k)
            enddo
            enddo
            enddo
            call convinitu(myid,ib,ie,jb,je,kb,ke,ni,nj,nk,ibw,ibe,   &
                           zdeep,lamx,lamy,xcent,ycent,aconv,    &
                           xf,yh,zh,u0,u3d)
            tem=1.0/dttmp
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
            do k=1,nk
            do j=1,nj
            do i=1,ni+1
              uten(i,j,k) = (u3d(i,j,k)-ua(i,j,k))*tem
            enddo
            enddo
            enddo
          ENDIF
          IF( rtime.le.convtime .and. ny.gt.1 )THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
            do k=1,nk
            do j=1,nj+1
            do i=1,ni
              v3d(i,j,k)=va(i,j,k)+dttmp*vten(i,j,k)
            enddo
            enddo
            enddo
            call convinitv(myid,ib,ie,jb,je,kb,ke,ni,nj,nk,ibs,ibn,   &
                           zdeep,lamx,lamy,xcent,ycent,aconv,    &
                           xh,yf,zh,v0,v3d)
            tem=1.0/dttmp
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
            do k=1,nk
            do j=1,nj+1
            do i=1,ni
              vten(i,j,k) = (v3d(i,j,k)-va(i,j,k))*tem
            enddo
            enddo
            enddo
          ENDIF
        ENDIF
        if(timestats.ge.1) time_sound=time_sound+mytime()

!---------------------------------------------------------------------
!  Get pressure

        call poiss(uh,vh,mh,rmh,mf,rmf,pi0,thv0,rho0,rf0,    &
                   dum1,divx,ppi,uten,vten,wten,             &
                   cfb,cfa,cfc,d1,d2,pdt,deft,rhs,trans,dttmp)

!---------------------------------------------------------------------

        tem=dttmp*rdx

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni+1
          u3d(i,j,k)=ua(i,j,k)+dttmp*uten(i,j,k)             &
                  -(tem*(ppi(i,j,k)-ppi(i-1,j,k))*uf(i))
        enddo
        enddo
        enddo

        if(timestats.ge.1) time_sound=time_sound+mytime()

        call bcu(u3d)

!-----

      IF(axisymm.eq.0)THEN

        tem=dttmp*rdy

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj+1
        do i=1,ni
          v3d(i,j,k)=va(i,j,k)+dttmp*vten(i,j,k)             &
                  -(tem*(ppi(i,j,k)-ppi(i,j-1,k))*vf(j))
        enddo
        enddo
        enddo

        if(timestats.ge.1) time_sound=time_sound+mytime()

        call bcv(v3d)

      ENDIF

!-----

        tem=dttmp*rdz

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=1,ni
          w3d(i,j,k)=wa(i,j,k)+dttmp*wten(i,j,k)             &
                  -(tem*(ppi(i,j,k)-ppi(i,j,k-1))*mf(i,j,k))
        enddo
        enddo
        enddo
        if(timestats.ge.1) time_sound=time_sound+mytime()

        call bcw(w3d,1)

!-------------------------------------------------------------------- 

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=kb,ke
        do j=jb,je
        do i=ib,ie
          ppi(i,j,k)=((prs0(1,1,k)+ppi(i,j,k)*rho0(1,1,k))*rp00)**rovcp   &
                    -pi0(1,1,k)
          pp3d(i,j,k)=ppi(i,j,k)
        enddo
        enddo
        enddo
        if(timestats.ge.1) time_sound=time_sound+mytime()

!-------------------------------------------------------------------- 

      return
      end



base.F/         1298670057  19071 8000  100644  66271     `


      subroutine base(zh,mh,zf,mf,rho0s,pi0s,prs0s,rth0s,pi0,prs0,rho0,thv0,th0,t0,qv0,u0,v0,rh0,    &
                      qc0,ql0,rr0,rf0,rrf0,rru0,rrv0)

      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'goddard.incl'

      real, dimension(ib:ie,jb:je,kb:ke) :: zh,mh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: zf,mf
      real, dimension(ib:ie,jb:je) :: rho0s,pi0s,prs0s,rth0s
      real, dimension(ib:ie,jb:je,kb:ke) :: pi0,prs0,rho0,thv0,th0,t0,qv0,rh0
      real, dimension(ib:ie,jb:je,kb:ke) :: qc0,ql0,rr0,rf0,rrf0,rru0,rrv0
      real, dimension(ib:ie+1,jb:je,kb:ke) :: u0
      real, dimension(ib:ie,jb:je+1,kb:ke) :: v0

!-----------------------------------------------------------------------

      integer i,j,k,n,nn,irec,niter,nsnd,kbot,ktop,tflag,nmax
      real zu,zv
      real z_trop,th_trop,th_sfc,t_trop,prs_sfc,qv_pbl,pi_sfc,t_sfc,rh_sfc,rh_pbl
      real qv_sfc,thv_sfc,psurf,tsurf,qsurf,thsurf,thvsurf
      real qv1,th1,tlast,th2,qv2,ql2,thbar,qvbar,tlcl
      real ns,ns1,ns2,zl1,zsfc
      real qcval,qtval,p_sfc,ql_sfc,thn,thlast,qtm,qtp,tavg,lhv,     &
           qvavg,qlavg,qtavg,desdt,gamma,tp,delz,pim,thvm,qvm,qlm,   &
           tm,pm,thm,drdt,pavg,qvl,qvi,fliq,fice,cpml,qim
      real thex,es,qvs,aaa
      real udep,uconst1,uconst2
      real udep1,udep2,umax1,umax2,vmax1,angle
      real tmp,ql,t1,t2,pitmp
      real hs,lapse
      real alpha,umax,nm,dudz,dvdz,rinum
      real, dimension(:), allocatable :: zsnd,thsnd,qvsnd,usnd,vsnd,   &
                                         thvsnd,pisnd,psnd
      real, dimension(:), allocatable :: thinterp,qvinterp,uinterp,vinterp
      integer :: kk,kup,kdn
      real :: interp_frac
      real*8 dblepi
      real rslf,rsif

      integer :: flag,ttype
      real :: pisfc,the_sfc,thv1,thv2,pi1,pi2,z1,z2,p2,theq,qt_sfc
      real :: getthe

      real :: ztrop,zmix,qv_mix,zmin,dtheta,getthp,thv_trop,qv_trop,pi_trop,p_trop,rhexp
      real, dimension(nk) :: thep,the0
      real :: depth_layer_01,depth_layer_02,shear_layer_01,shear_layer_02
      real :: du,dv

      real, dimension(:), allocatable :: pfoo,tfoo,qvfoo
      real :: cape,cin,zlcl,zlfc,zel,psource,tsource,thsource,qvsource
      logical :: control_file_exists

#ifdef MPI
      integer, dimension(8) :: reqs_u,reqs_v,reqs_s
      real, dimension(3,nj,nk) :: uw31,uw32,ue31,ue32
      real, dimension(ni+1,3,nk) :: us31,us32,un31,un32
      real, dimension(3,nj+1,nk) :: vw31,vw32,ve31,ve32
      real, dimension(ni,3,nk) :: vs31,vs32,vn31,vn32
      real, dimension(3,nj,nk) :: sw31,sw32,se31,se32
      real, dimension(ni,3,nk) :: ss31,ss32,sn31,sn32
#endif

      character(len=200) :: cpcmd

!------------------------------------------------------------------

      if(myid.eq.0) write(outfile,*) 'Inside BASE'

!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cc  Start definition of base state sounding (isnd opton)  cccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      psurf = 0.0
      tsurf = 0.0
      qsurf = 0.0
      rho0s = 0.0
      pi0s = 0.0
      prs0s = 0.0
      rth0s = 0.0

      do k=kb,ke
      do j=jb,je
      do i=ib,ie
        pi0(i,j,k)=0.0
        prs0(i,j,k)=0.0
        rho0(i,j,k)=0.0
        thv0(i,j,k)=0.0
        th0(i,j,k)=0.0
        t0(i,j,k)=0.0
        qv0(i,j,k)=0.0
        rh0(i,j,k)=0.0
        qc0(i,j,k)=0.0
        ql0(i,j,k)=0.0
        rr0(i,j,k)=0.0
        rf0(i,j,k)=0.0
        rrf0(i,j,k)=0.0
      enddo
      enddo
      enddo

!-----------------------------------------------------------------------
!  isnd = 1
!  Dry adiabatic base state

      IF(isnd.eq.1)THEN

        ! Set these two variables for dry adiabatic sounding

        th_sfc   =   300.0   ! Potential temperature of atmosphere (K)
        pi_sfc   =   1.0     ! Exner function at surface

        do k=kb,ke
        do j=jb,je
        do i=ib,ie
          th0(i,j,k)=th_sfc
          pi0(i,j,k)=pi_sfc-g*zh(i,j,k)/(cp*th_sfc)
          prs0(i,j,k)=p00*(pi0(i,j,k)**cpdrd)
        enddo
        enddo
        enddo

        do k=kb,ke
        do j=jb,je
        do i=ib,ie
          qv0(i,j,k)=0.0
          rh0(i,j,k)=0.0
        enddo
        enddo
        enddo

!-----------------------------------------------------------------------
!  isnd = 2
!  Dry isothermal base state
            
      ELSEIF(isnd.eq.2)THEN
          
        ! Set these two variables for dry isothermal sounding

        t_sfc    =   250.0    ! Temperature of atmosphere (K)
        prs_sfc  =   p00      ! Pressure at surface (Pa)


        hs=rd*t_sfc/g        ! scale height of atmosphere

        do k=kb,ke
        do j=jb,je
        do i=ib,ie

          ! calculate pressure field
          prs0(i,j,k)=prs_sfc*EXP(-zh(i,j,k)/hs)

          ! using the pressure field, calculate the exner pressure
          pi0(i,j,k)=(prs0(i,j,k)/p00)**(rd/cp)

          ! using exner pressure, determine the potential temperature
          th0(i,j,k)=t_sfc/pi0(i,j,k)

        enddo
        enddo
        enddo

        do k=kb,ke
        do j=jb,je
        do i=ib,ie
          qv0(i,j,k)=0.0
          rh0(i,j,k)=0.0
        enddo
        enddo
        enddo


!-----------------------------------------------------------------------
!  isnd = 3
!  Dry, constant dT/dz sounding.
!  Lapse rate of 0.0065  =  standard dry atmosphere.

      ELSEIF(isnd.eq.3)THEN

        ! Set these three variables for dry constant lapse rate sounding

        th_sfc   =  300.0     ! theta at surface (K)
        prs_sfc  =  p00       ! pressure at surface (Pa)
        lapse    =  0.0065    ! dT/dz (K m^-1)

        do k=kb,ke
        do j=jb,je
        do i=ib,ie

          ! Calculate the temperature using the specified lapse rate.
          t0(i,j,k)=th_sfc-lapse*zh(i,j,k)

          ! Calculate the pressure from the temperature field.
          prs0(i,j,k)=p00*(t0(i,j,k)/th_sfc)**(g/(lapse*rd))

          ! Calculate the exner pressure from the pressure field.
          pi0(i,j,k)=(prs0(i,j,k)/p00)**(rd/cp)

          ! Calculate the theta field from temperature and the 
          ! specified lapse rate.
          th0(i,j,k)=th_sfc*(t0(i,j,k)/th_sfc)**(1-g/(lapse*cp))

        enddo
        enddo
        enddo

        do k=kb,ke
        do j=jb,je
        do i=ib,ie
          qv0(i,j,k)=0.0
          rh0(i,j,k)=0.0
        enddo
        enddo
        enddo


!------------------------------------------------------------------
!  isnd = 4
!  Saturated, neutrally-stable sounding for moist benchmark simulation.
!  reference:  Bryan and Fritsch, 2002, MWR, 130, 2917-2928.

      ELSEIF(isnd.eq.4)THEN

        ! these two parameters define the sounding

        thec_mb   =   320.0     ! wet equivalent potential temp (K)
        qt_mb     =   0.020     ! total water mixing ratio (unitless)


        if(myid.eq.0)then
        write(outfile,*)
        write(outfile,*) '  Saturated, neutrally-stable sounding'
        write(outfile,*) '    thec,qt=',thec_mb,qt_mb
        write(outfile,*)
        endif

      do j=jb,je
      do i=ib,ie

        !! First guesses at lowest model level
        prs0(i,j,1)=100000.
        qv1=qt_mb
        tmp=thec_mb
        tlast=tmp

        do n=1,20
          thbar=(tmp*(p00/prs0(i,j,1))**(rd/cp))*(1.0+qv1*reps)/(1.0+qt_mb)
          pi0(i,j,1)=1.0-g*zh(i,j,1)/(cp*thbar)
          prs0(i,j,1)=p00*(pi0(i,j,1)**(cpdrd))
          qv1=rslf(prs0(i,j,1),tmp)
          tmp=thec_mb*((prs0(i,j,1)/(1.0+qv1/eps)/p00)**(rd/(cp+cpl*qt_mb)))  &
             /exp((lv1-lv2*tmp)*qv1/(tmp*(cp+cpl*qt_mb)))
          tmp=tlast+0.3*(tmp-tlast)
          tlast=tmp
        enddo
 
        th0(i,j,1)=tmp/pi0(i,j,1)
        rh0(i,j,1)=1.0
        qv0(i,j,1)=rslf(prs0(i,j,1),tmp)
        t1=tmp
        qv1=qv0(i,j,1)
        th1=th0(i,j,1)

        do k=2,nk
          tlast=th1
          t2=t1
          qv2=qv1
          th2=th1
          n=0
          pi0(i,j,k)=pi0(i,j,k-1)-g*(zh(i,j,k)-zh(i,j,k-1))/(cp*th2)
100       continue
            n=n+1
            th2=tlast
            t2=th2*pi0(i,j,k)
            thbar=0.5*( th1*(1.0+qv1*reps)/(1.0+qt_mb)    &
                       +th2*(1.0+qv2*reps)/(1.0+qt_mb) )
            pi0(i,j,k)=pi0(i,j,k-1)-g*(zh(i,j,k)-zh(i,j,k-1))/(cp*thbar)
            prs0(i,j,k)=p00*(pi0(i,j,k)**(cpdrd))
            qv2=rslf(prs0(i,j,k),t2)
            t2=thec_mb*((prs0(i,j,k)/(1.0+qv2/eps)/p00)**(rd/(cp+cpl*qt_mb))) &
             /exp((lv1-lv2*t2)*qv2/(t2*(cp+cpl*qt_mb)))
            th2=t2/pi0(i,j,k)

            if(n.gt.50) write(*,*) myid,n,th2
            if(abs(th2-tlast).gt.0.0001 .and. n.lt.100)then
              tlast=tlast+0.3*(th2-tlast)
              go to 100
            elseif(n.ge.100)then
              write(*,*) myid, '  stuck in loop!'
              call stopcm1
            endif
 
          th0(i,j,k)=th2
          qv0(i,j,k)=rslf(prs0(i,j,k),th0(i,j,k)*pi0(i,j,k))
          rh0(i,j,k)=1.0
 
          th1=th2
          qv1=qv2
          t1=t2
 
        enddo

        do k=1,nk
          qc0(i,j,k)=qt_mb-qv0(i,j,k)
        enddo

      enddo
      enddo


!-----------------------------------------------------------------------
!  isnd = 5
!  Weisman-Klemp analytic sounding.
!  reference:  Weisman and Klemp, 1982, MWR, 110, 504-520.

      ELSEIF(isnd.eq.5)THEN

      if(myid.eq.0)then
        write(outfile,*)
        write(outfile,*) '  WK sounding'
       endif

!  variables related to Weisman-Klemp analytic sounding
        z_trop   = 12000.0      ! height of tropopause (m)
        th_trop  = 343.0        ! theta at tropopause (K)
        t_trop   = 213.0        ! temp at tropopause (K)
        th_sfc   = 300.0        ! theta at surface (K)
        prs_sfc  = 100000.0     ! pressure at surface (Pa)
        qv_pbl   = 0.014        ! constant value of mixing ratio in PBL

!--------------

        pi_sfc  = (prs_sfc/p00)**(rd/cp)
        qv_sfc  = rslf(prs_sfc,th_sfc*pi_sfc)
        thv_sfc = th_sfc*(1.0+qv_sfc*reps)/(1.0+qv_sfc)

      do j=jb,je
      do i=ib,ie

        do k=kb,ke
          rh0(i,j,k)=0.0
        enddo

        do k=1,nk
          if(zh(i,j,k).le.z_trop)then
            th0(i,j,k)=th_sfc+(th_trop-th_sfc)*((zh(i,j,k)/z_trop)**1.25)
            if(imoist.eq.1) rh0(i,j,k)=1.0-0.75*((zh(i,j,k)/z_trop)**1.25)
          else
            th0(i,j,k)=th_trop*exp((g/(t_trop*cp))*(zh(i,j,k)-z_trop))
            if(imoist.eq.1) rh0(i,j,k)=0.25
          endif
        enddo

        th0(i,j,0)=th0(i,j,1)
        th0(i,j,nk+1)=th0(i,j,nk)


!  Get pressure, temperature, and mixing ratio using hydrostatic eqt.

        do k=kb,ke
          qv0(i,j,k)=0.0
        enddo

        do n=1,20
! virtual potential temperature
          do k=kb,ke
            thv0(i,j,k)=th0(i,j,k)*(1.0+reps*qv0(i,j,k))/(1.0+qv0(i,j,k))
          enddo

          pi0(i,j,1)=pi_sfc-g*zh(i,j,1)/(cp*0.5*(thv_sfc+thv0(i,j,1)))
          do k=2,nk
            pi0(i,j,k)=pi0(i,j,k-1)-g*(zh(i,j,k)-zh(i,j,k-1))/(cp*0.5*(thv0(i,j,k)+thv0(i,j,k-1)))
          enddo

! pressure
          do k=1,nk
            prs0(i,j,k)=p00*(pi0(i,j,k)**(cp/rd))
          enddo

! mixing ratio
          do k=1,nk
            qv0(i,j,k)=rh0(i,j,k)*rslf(prs0(i,j,k),th0(i,j,k)*pi0(i,j,k))
            if(qv0(i,j,k).gt.qv_pbl) qv0(i,j,k)=qv_pbl
          enddo

        enddo

        do k=1,nk
          rh0(i,j,k)=qv0(i,j,k)/(rslf(prs0(i,j,k),th0(i,j,k)*pi0(i,j,k)))
        enddo

      enddo
      enddo

!------------------------------------------------------------------
!  isnd = 6

      ELSEIF(isnd.eq.6)THEN

      if(myid.eq.0)then
        write(outfile,*)
        write(outfile,*) ' isnd = 6 code has been removed (for now)'
        write(outfile,*)
      endif
        call stopcm1

!------------------------------------------------------------------
!  isnd = 7
!  Read base-state sounding from an external text file.
!  Assumes file name = input_sounding
!  NOTE:  for isnd=7, iwnd is ignored.
!
!  The format is the same as that for the WRF Model, as well as 
!  for the Klemp-Wilhelmson Model.  Format is:
!
!  1 line header containing: sfc pres (mb)    sfc theta (K)    sfc qv (g/kg)
!  nsnd lines of:  zheight (m)    theta (K)   qv (g/kg)    u (m/s)    v (m/s)
!
!  (Thanks to Leigh Orf, Central Michigan University, for contributing this
!   code.)
!  Note:  This now works with terrain.  (GHB, 061011)
!

      ELSEIF(isnd.eq.7)then

      if(myid.eq.0)then
        write(outfile,*)
        write(outfile,*) ' Reading sounding from external file, input_sounding'
        write(outfile,*)
      endif

        nmax = 100000 !should be enough!

        allocate(   zsnd(nmax) )
        allocate(  thsnd(nmax) )
        allocate(  qvsnd(nmax) )
        allocate(   usnd(nmax) )
        allocate(   vsnd(nmax) )
        allocate( thvsnd(nmax) )
        allocate(  pisnd(nmax) )
        allocate(   psnd(nmax) )

        allocate( thinterp(nk) )
        allocate( qvinterp(nk) )
        allocate(  uinterp(nk) )
        allocate(  vinterp(nk) )

        open(unit=40,file='input_sounding',status='old')

        ! read surface parameters:
        read(40,*) p_sfc, th_sfc, qv_sfc
        if(myid.eq.0)write(outfile,*) ' p_sfc, th_sfc, qv_sfc = ',p_sfc, th_sfc, qv_sfc

        if(imoist.eq.0) qv_sfc = 0.0

        p_sfc = p_sfc * 100.0
        ! put qv in g/g
        qv_sfc = qv_sfc / 1000.0
        pi_sfc  = (p_sfc/p00)**(rd/cp)
        thv_sfc = th_sfc*(1.0+qv_sfc*reps)/(1.0+qv_sfc)

        psurf  = p_sfc
        thsurf = th_sfc
        tsurf  = th_sfc * pi_sfc
        qsurf  = qv_sfc

        zsnd(1) = 0.0
        thsnd(1) = th_sfc
        qvsnd(1) = qv_sfc
        usnd(1) = 0.0
        vsnd(1) = 0.0

        ! now, read entire sounding until end of file is discovered
        nsnd=1
        do k=1,nmax
          read(40,*,end=445) zsnd(k+1),thsnd(k+1),qvsnd(k+1),usnd(k+1),vsnd(k+1)
          ! put qv in g/g
          qvsnd(k+1) = qvsnd(k+1)/1000.0
          nsnd=nsnd+1
        enddo
445     continue
      if(myid.eq.0)write(outfile,*) '  Found ',nsnd,'  levels (including surface)'
      if(myid.eq.0)write(outfile,*)
        close(unit=40)

        if(imoist.eq.0) qvsnd = 0.0

!--------------------------------------------------------------------
!  Added by GHB, 061021:
!  Get thv and prs ... check if qv is too small.  If so, set rh to 5%
!  (This code has no effect on the sounding if qv > 1e-12 everywere)
!  (It was added to deal with the 0 g/kg qv values in the Trier sounding.)
        do k=1,nsnd
          thvsnd(k)=thsnd(k)*(1.0+reps*qvsnd(k))/(1.0+qvsnd(k))
        enddo
        pisnd(1)=pi_sfc
        do k=2,nsnd
          pisnd(k)=pisnd(k-1)-g*(zsnd(k)-zsnd(k-1))   &
                               /(cp*0.5*(thvsnd(k)+thvsnd(k-1)))
        enddo
        do k=1,nsnd
          psnd(k)=p00*(pisnd(k)**(cp/rd))
        enddo
      if(imoist.eq.1)then
        do k=1,nsnd
          if(qvsnd(k).lt.1.0e-12)then
                if(myid.eq.0)write(outfile,*) '  Qv is too small.  Setting rh to 5%.  k,zsnd=',k,zsnd(k)
            qvsnd(k)=0.05*rslf(psnd(k),thsnd(k)*pisnd(k))
          endif
        enddo
      endif
!--------------------------------------------------------------------

      if(myid.eq.0)then
        write(outfile,*)
        write(outfile,*) '    k,z,th,qv:'
        do k=1,nsnd
          write(outfile,*) k,zsnd(k),thsnd(k),1000.0*qvsnd(k)
        enddo
        write(outfile,*)
        write(outfile,*) '    k,u,v:'
        do k=1,nsnd
          write(outfile,*) k,usnd(k),vsnd(k)
        enddo
        write(outfile,*)

! check to make sure sounding levels span computational grid (WICKER)
!!!        061011, GHB:  Commented this out ... we'll use the surface info.
!!!        if (zsnd(1) .gt. zh(1,1,1)) then
!!!          write(*,*) 'zmin of sounding > zmin of grid!'
!!!          write(*,*) 'zmin of sounding = ',zsnd(1)
!!!          write(*,*) 'zmin of grid = ',zh(1,1,1)
!!!          call stopcm1
!!!        endif

        write(outfile,*)
        write(outfile,*) 'interpolating sounding to grid: '
        write(outfile,*)
     endif

      DO j=jb,je
      DO i=ib,ie

        if (zsnd(nsnd) .lt. zh(i,j,nk)) then

        if(myid.eq.0)then
          write(outfile,*) 'zmax of sounding < zmax of grid!'
          write(outfile,*) 'zmax of sounding = ',zsnd(nsnd)
          write(outfile,*) 'zmax of grid  = ',zh(i,j,nk)
        endif
          call stopcm1
        endif

        DO k=1,nk

            kk = 1
            do while( zsnd(kk) .lt. zh(i,j,k) )
              kk = kk+1
            enddo
            kdn = kk-1
            kup = kk

            zu=0.5*(zh(max(ib,i-1),j,k)+zh(i,j,k))
            interp_frac = (   zu        - zsnd(kdn) )   &
                        / ( zsnd( kup ) - zsnd(kdn) )
            uinterp(k) =  usnd(kdn) + ( usnd(kup)- usnd(kdn))*interp_frac

            zv=0.5*(zh(i,max(jb,j-1),k)+zh(i,j,k))
            interp_frac = (   zv        - zsnd(kdn) )   &
                        / ( zsnd( kup ) - zsnd(kdn) )
            vinterp(k) =  vsnd(kdn) + ( vsnd(kup)- vsnd(kdn))*interp_frac

!!!            ! if this is first grid point, utilize surface values of th,qv:
!!!            if( k.eq.1 ) kdn = 1

            interp_frac = (   zh(i,j,k) - zsnd(kdn) )   &
                        / ( zsnd( kup ) - zsnd(kdn) )
            thinterp(k) = thsnd(kdn) + (thsnd(kup)-thsnd(kdn))*interp_frac
            qvinterp(k) = qvsnd(kdn) + (qvsnd(kup)-qvsnd(kdn))*interp_frac

            if(i.eq.1.and.j.eq.1.and.myid.eq.0)   &
              write(outfile,*) '       ',zsnd(kdn),zh(i,j,k),zsnd(kup),interp_frac

        ENDDO
        if(i.eq.1.and.j.eq.1.and.myid.eq.0) write(outfile,*)

        do k=1,nk
           u0(i,j,k) =  uinterp(k)
           v0(i,j,k) =  vinterp(k)
          qv0(i,j,k) = qvinterp(k)
          th0(i,j,k) = thinterp(k)
        enddo

        ! get pi0 and prs0 from thv0, using hydrostatic equation

        do k=1,nk
          thv0(i,j,k)=th0(i,j,k)*(1.0+reps*qv0(i,j,k))/(1.0+qv0(i,j,k))
        enddo

        pi0(i,j,1)=pi_sfc-g*zh(i,j,1)/(cp*0.5*(thv_sfc+thv0(i,j,1)))
        do k=2,nk
          pi0(i,j,k)=pi0(i,j,k-1)-g*(zh(i,j,k)-zh(i,j,k-1))   &
                                   /(cp*0.5*(thv0(i,j,k)+thv0(i,j,k-1)))
        enddo

        do k=1,nk
          prs0(i,j,k)=p00*(pi0(i,j,k)**(cp/rd))
        enddo

        ! rh, just in case we want/need it later

      if(imoist.eq.1)then
        do k=1,nk
          rh0(i,j,k)=qv0(i,j,k)/(rslf(prs0(i,j,k),th0(i,j,k)*pi0(i,j,k)))
        enddo
      endif

      ENDDO    ! enddo for i loop
      ENDDO    ! enddo for j loop


        ! deallocate temporary 1D arrays
        deallocate(   zsnd )
        deallocate(  thsnd )
        deallocate(  qvsnd )
        deallocate(   usnd )
        deallocate(   vsnd )
        deallocate( thvsnd )
        deallocate(  pisnd )
        deallocate(   psnd )
        deallocate( thinterp )
        deallocate( qvinterp )
        deallocate(  uinterp )
        deallocate(  vinterp )


!-----------------------------------------------------------------------
!  isnd = 8
!  Dry, constant d(theta)/dz sounding

      ELSEIF(isnd.eq.8)THEN

        ! Set these three variables for dry, constant d(theta)/dz sounding

        th_sfc   =  300.0     ! theta at surface (K)
        pi_sfc   =    1.0     ! Exner function at surface
        lapse    =  0.0035    ! potential temperature lapse rate (K/m)

        do k=kb,ke
        do j=jb,je
        do i=ib,ie

          ! Calculate theta using the specified lapse rate.
          th0(i,j,k)=th_sfc+lapse*zh(i,j,k)

          ! Calculate pi from theta
          pi0(i,j,k)=pi_sfc-(g/(cp*lapse))*alog(th0(i,j,k)/th_sfc)

          ! Calculate pressure from pi
          prs0(i,j,k)=p00*(pi0(i,j,k)**(cp/rd))

          ! Calculate temperature from theta and pi
          t0(i,j,k)=th0(i,j,k)*pi0(i,j,k)

        enddo
        enddo
        enddo

        do k=kb,ke
        do j=jb,je
        do i=ib,ie
          qv0(i,j,k)=0.0
          rh0(i,j,k)=0.0
        enddo
        enddo
        enddo

!------------------------------------------------------------------
!  isnd = 9
!  Constant Brunt-Vaisala frequency

      ELSEIF(isnd.eq.9)then

        ns1 =  0.0001
        ns2 =  0.0000

        zl1 = 40000.0

      do j=jb,je
      do i=ib,ie
        th_sfc   =  288.00
        pi_sfc   =    1.0
        if(zh(i,j,1).lt.zl1)then
          zsfc = 0.0
          ns   = ns1
        else
          if(abs(ns1).lt.1.0e-6)then
            pi_sfc=pi_sfc-g*zl1/(cp*th_sfc)
          else
            pi_sfc=pi_sfc+g*g/(cp*ns1*th_sfc)*(exp(-ns1*zl1/g)-1.0)
            th_sfc=th_sfc*exp(ns1*zl1/g)
          endif
          zsfc = zl1
          ns   = ns2
        endif
        do k=1,nk
          qv0(i,j,k)=0.0
          qc0(i,j,k)=0.0
          rh0(i,j,k)=0.0
          if(abs(ns).lt.1.0e-6)then
            thv0(i,j,k)=th_sfc
            pi0(i,j,k)=pi_sfc-g*(zh(i,j,k)-zsfc)/(cp*th_sfc)
          else
            thv0(i,j,k)=th_sfc*exp(ns*(zh(i,j,k)-zsfc)/g)
            pi0(i,j,k)=pi_sfc+g*g/(cp*ns*th_sfc)   &
                           *(exp(-ns*(zh(i,j,k)-zsfc)/g)-1.0)
          endif
          prs0(i,j,k)=p00*(pi0(i,j,k)**cpdrd)
          th0(i,j,k)=thv0(i,j,k)
          do n=1,20
            t0(i,j,k)=th0(i,j,k)*pi0(i,j,k)
            qv0(i,j,k)=rh0(i,j,k)*rslf(prs0(i,j,k),t0(i,j,k))
            th0(i,j,k)=thv0(i,j,k)*(1.0+qv0(i,j,k)+qc0(i,j,k))/(1.0+reps*qv0(i,j,k))
!!!            if(i.eq.1.and.j.eq.1) write(outfile,*) k,n,th0(i,j,k),qv0(i,j,k)
          enddo
          if(zh(i,j,k+1).gt.zl1.and.zsfc.lt.1.0)then
            if(abs(ns1).lt.1.0e-6)then
              pi_sfc=pi_sfc-g*zl1/(cp*th_sfc)
            else
              pi_sfc=pi_sfc+g*g/(cp*ns1*th_sfc)*(exp(-ns1*zl1/g)-1.0)
              th_sfc=th_sfc*exp(ns1*zl1/g)
            endif
            zsfc=zl1
            ns=ns2
          endif
        enddo

      enddo
      enddo

!------------------------------------------------------------------
!  isnd = 10
!  Moist, constant Brunt-Vaisala frequency

      ELSEIF(isnd.eq.10)then

      if(myid.eq.0)write(outfile,*) '  isnd = 10'

        qcval    =   0.005
        qtval    =   0.00000

        ns1 =  0.0
        ns2 =  4.0e-4

        zl1 = 111700.0

      do k=kb,ke
      do j=jb,je
      do i=ib,ie
        rh0(i,j,k)=1.0
        qc0(i,j,k)=qcval
      enddo
      enddo
      enddo

      if(myid.eq.0)write(outfile,*)
      do j=jb,je
      do i=ib,ie
        th_sfc   =  288.0
        pi_sfc   =    1.0
        ns=ns1
        p_sfc=p00*(pi_sfc**(cp/rd))
        t_sfc=th_sfc*pi_sfc
        qv_sfc=rslf(p_sfc,t_sfc)
        ql_sfc=qcval
!!!        ql_sfc=qtval-qv_sfc
        thv_sfc=th_sfc*(1.0+reps*qv_sfc)/(1.0+qv_sfc+ql_sfc)
        thn=th_sfc
        thlast=thn
        k=1
        n=1
        qv0(i,j,k)=qv_sfc
        qc0(i,j,k)=ql_sfc
 571      continue
          th0(i,j,k)=thn
          thv0(i,j,k)=th0(i,j,k)*(1.0+reps*qv0(i,j,k))   &
                                /(1.0+qv0(i,j,k)+qc0(i,j,k))
          pi0(i,j,k)=pi_sfc-g*zh(i,j,k)/(cp*0.5*(thv0(i,j,k)+thv_sfc))
          prs0(i,j,k)=p00*(pi0(i,j,k)**(cp/rd))
          t0(i,j,k)=th0(i,j,k)*pi0(i,j,k)
          qvs=rslf(prs0(i,j,k),t0(i,j,k))
          qv0(i,j,k)=qvs
          qc0(i,j,k)=qcval
!!!          qc0(i,j,k)=qtval-qv0(i,j,k)
          qtm=qv_sfc+ql_sfc
          qtp=qv0(i,j,k)+qc0(i,j,k)
          tavg=0.5*( t0(i,j,k)+t_sfc )
          lhv=lv1-lv2*tavg
          qvavg=0.5*( qv_sfc + qv0(i,j,k) )
          qlavg=0.5*( ql_sfc + qc0(i,j,k) )
          qtavg=qvavg+qlavg
          desdt=17.67*(273.15-29.65)/((tavg-29.65)**2)
          drdt=17.67*(273.15-29.65)*qvavg/((tavg-29.65)**2)
        if(neweqts.ge.1)then
          gamma=g*(1.0+qtavg)*(1.0+lhv*qvavg/rd/tavg)   &
               /( cp+cpv*qvavg+cpl*qlavg          &
                 +lhv*drdt )
        else
          gamma=g*(1.0+qtavg)*(rd/(rd+rv*qvavg)+lhv*qvavg/rd/tavg)   &
               /( cp+lhv*(1.0+qvavg*reps)*qvavg*desdt )
        endif
          tp=t_sfc*exp( zh(i,j,k)*(                     &
                ((ns/g)+alog((1.0+qtp)/(1.0+qtm))/zh(i,j,k))  &
                   /(1.0+tavg*drdt/(eps+qvavg))-gamma/tavg                  &
                                                      ) )
          thn=tp/pi0(i,j,k)

          n=n+1

          if(n.gt.180) write(*,*) myid,n,thn
          if(abs(thn-thlast).gt.0.0001 .and. n.lt.200)then
            thn=thlast+0.3*(thn-thlast)
            thlast=thn
            go to 571
          elseif(n.ge.200)then
            write(*,*) myid, '  stuck in loop!'
            call stopcm1
          endif

        th0(i,j,k)=thn
        prs0(i,j,k)=p00*(pi0(i,j,k)**(cp/rd))
        t0(i,j,k)=th0(i,j,k)*pi0(i,j,k)
        qvs=rslf(prs0(i,j,k),t0(i,j,k))
        qv0(i,j,k)=qvs
        qc0(i,j,k)=qcval
!!!        qc0(i,j,k)=qtval-qv0(i,j,k)
        if(qc0(i,j,1).lt.0.0) call stopcm1
        if(i.eq.1.and.j.eq.1.and.myid.eq.0) write(outfile,*) k,n,th0(i,j,k),prs0(i,j,k)
        qvs=qv0(i,j,1)
        ns=ns1
        do k=2,nk
        tflag=0
        do niter=1,2
        if(tflag.lt.2)then
          if(zh(i,j,k).gt.zl1.and.ns.eq.ns1.and.tflag.eq.0.and.zh(i,j,k-1).lt.zl1)then
            tflag=1
            delz=zl1-zh(i,j,k-1)
            pim=pi0(i,j,k-1)
            thm=th0(i,j,k-1)
            thvm=thv0(i,j,k-1)
            qtm=qv0(i,j,k-1)+qc0(i,j,k-1)+ql0(i,j,k-1)
            qvm=qv0(i,j,k-1)
            qlm=qc0(i,j,k-1)
            qim=ql0(i,j,k-1)
            tm=t0(i,j,k-1)
            pm=prs0(i,j,k-1)
          elseif(tflag.eq.1)then
            tflag=0
            ns=ns2
            delz=zh(i,j,k)-zl1
            pim=pi0(i,j,k)
            thm=th0(i,j,k)
            thvm=thv0(i,j,k)
            qtm=qv0(i,j,k)+qc0(i,j,k)+ql0(i,j,k)
            qvm=qv0(i,j,k)
            qlm=qc0(i,j,k)
            qim=ql0(i,j,k)
            tm=t0(i,j,k)
            pm=prs0(i,j,k)
          else
            tflag=2
            delz=zh(i,j,k)-zh(i,j,k-1)
            pim=pi0(i,j,k-1)
            thm=th0(i,j,k-1)
            thvm=thv0(i,j,k-1)
            qtm=qv0(i,j,k-1)+qc0(i,j,k-1)+ql0(i,j,k-1)
            qvm=qv0(i,j,k-1)
            qlm=qc0(i,j,k-1)
            qim=ql0(i,j,k-1)
            tm=t0(i,j,k-1)
            pm=prs0(i,j,k-1)
          endif
!!!          t0(i,j,k)=tm
          th0(i,j,k)=thm
          qv0(i,j,k)=qvm
          qc0(i,j,k)=qlm
          ql0(i,j,k)=qim
          thv0(i,j,k)=thvm
!!!          thlast=tm*pim
          thlast=thm
          n=0
          thn=thlast
          thlast=thn
 572      continue
            th0(i,j,k)=thn
            thv0(i,j,k)=th0(i,j,k)*(1.0+reps*qv0(i,j,k))   &
                                  /(1.0+qv0(i,j,k)+qc0(i,j,k)+ql0(i,j,k))
            pi0(i,j,k)=pim-g*delz/(cp*0.5*(thv0(i,j,k)+thvm))
            prs0(i,j,k)=p00*(pi0(i,j,k)**(cp/rd))
            t0(i,j,k)=th0(i,j,k)*pi0(i,j,k)
          if(iice.eq.0)then
            qvs=rslf(prs0(i,j,k),t0(i,j,k))
            qv0(i,j,k)=qvs
            qc0(i,j,k)=qcval
!!!            qc0(i,j,k)=qtval-qv0(i,j,k)
            qtp=qv0(i,j,k)+qc0(i,j,k)
            pavg=0.5*(prs0(i,j,k-1)+prs0(i,j,k))
            tavg=0.5*( t0(i,j,k)+tm )
            qvavg=rslf(pavg,tavg)
            qlavg=0.5*( qlm + qc0(i,j,k) )
            qtavg=0.5*( qtm + qtp )
            drdt=17.67*(273.15-29.65)*qvavg/((tavg-29.65)**2)
            lhv=lv1-lv2*tavg
            cpml=cp+cpv*qvavg+cpl*qlavg
          else
            qvl=rslf(prs0(i,j,k),t0(i,j,k))
            qvi=rsif(prs0(i,j,k),t0(i,j,k))
            fliq=max(min((t0(i,j,k)-t00k)*rt0,1.0),0.0)
            fice=1.0-fliq
            qvs=fliq*qvl+fice*qvi
            qv0(i,j,k)=qvs
            qc0(i,j,k)=fliq*qcval
            ql0(i,j,k)=fice*qcval
            qtp=qv0(i,j,k)+qc0(i,j,k)+ql0(i,j,k)
            pavg=0.5*(prs0(i,j,k-1)+prs0(i,j,k))
            tavg=0.5*( t0(i,j,k)+tm )
            qvl=rslf(pavg,tavg)
            qvi=rsif(pavg,tavg)
            fliq=max(min((tavg-t00k)*rt0,1.0),0.0)
            fice=1.0-fliq
            qvavg=fliq*qvl+fice*qvi
            qlavg=0.5*( qlm + qc0(i,j,k) )
            qtavg=0.5*( qtm + qtp )
            drdt=fliq*17.67*(273.15-29.65)*qvl/((tavg-29.65)**2)    &
                +fice*21.8745584*(273.15-7.66)*qvi/((tavg-7.66)**2)
            if(tavg.gt.t00k.and.tavg.lt.t0k)then
              drdt=drdt+(qvl-qvi)*rt0
            endif
            lhv=fliq*(lv1-lv2*tavg)+fice*(ls1-ls2*tavg)
            cpml=cp+cpv*qvavg+cpl*qlavg+cpi*(qtavg-qlavg-qvavg)
          endif
          if(neweqts.ge.1)then
            gamma=g*(1.0+qtavg)*(1.0+lhv*qvavg/rd/tavg)   &
                 /( cpml+lhv*drdt )
          else
            gamma=g*(1.0+qtavg)*(rd/(rd+rv*qvavg)+lhv*qvavg/rd/tavg)   &
                 /( cp+lhv*(1.0+qvavg*reps)*qvavg*desdt )
          endif
            tp=tm*exp( delz*(                                 &
                  ((ns/g)+alog((1.0+qtp)/(1.0+qtm))/delz)     &
                     /(1.0+tavg*drdt/(eps+qvavg))-gamma/tavg  &
                                                        ) )
            thn=tp/pi0(i,j,k)

            n=n+1

            if(n.gt.180) write(*,*) myid, n,tp,tm,delz
            if(abs(thn-thlast).gt.0.0001 .and. n.lt.200)then
              thn=thlast+0.3*(thn-thlast)
              thlast=thn
              go to 572
            elseif(n.ge.200)then
              write(*,*) myid, '  stuck in loop!'
              call stopcm1
            endif

          t0(i,j,k)=tp
          th0(i,j,k)=thn
          prs0(i,j,k)=p00*(pi0(i,j,k)**(cp/rd))
          t0(i,j,k)=th0(i,j,k)*pi0(i,j,k)
          if(iice.eq.0)then
            qvs=rslf(prs0(i,j,k),t0(i,j,k))
            qv0(i,j,k)=qvs
          else
            qvl=rslf(prs0(i,j,k),t0(i,j,k))
            qvi=rsif(prs0(i,j,k),t0(i,j,k))
            fliq=max(min((t0(i,j,k)-t00k)*rt0,1.0),0.0)
            fice=1.0-fliq
            qvs=fliq*qvl+fice*qvi
            qv0(i,j,k)=qvs
            qc0(i,j,k)=fliq*qcval
            ql0(i,j,k)=fice*qcval
          endif
          if(qc0(i,j,1).lt.0.0) call stopcm1
!!!          if(i.eq.1.and.j.eq.1) write(outfile,*) k,n,zh(i,j,k),th0(i,j,k),prs0(i,j,k)
          if(i.eq.1.and.j.eq.1.and.myid.eq.0) write(outfile,*) k,n,t0(i,j,k),fliq,fice
        endif
        enddo
        enddo
      enddo
      enddo
      write(outfile,*)

!------------------------------------------------------------------
!  constant theta-e, saturated
!  Reference:  Bryan and Rotunno, 2009, JAS, v10, pp. 3042-3060

      ELSEIF(isnd.eq.11)THEN

        IF(imoist.eq.0)THEN
         if(myid.eq.0)then
          write(outfile,*)
          write(outfile,*) '  isnd=11 requires imoist=1'
          write(outfile,*)
          write(outfile,*) '  stopping model ...'
          write(outfile,*)
         endif
          call stopcm1
        ENDIF

        zl1 = 15000.0    ! tropopause height

        ttype =  2    ! 1 = reversible
                      ! 2 = pseudoadiabatic

        psurf = 101510.0    ! surface pressure (Pa)

      DO j=jb,je
      DO i=ib,ie

        ! use psurf:
        pi_sfc   =  (psurf*rp00)**rovcp
        ! use tsk from namelist.input, make 3 K cooler:
        th_sfc   =  ( tsk0 - 3.0 )/pi_sfc

        t_sfc=th_sfc*pi_sfc
        p_sfc=p00*(pi_sfc**(cp/rd))
        qv_sfc=rslf(p_sfc,t_sfc)
        qt_sfc=qv_sfc
        thv_sfc=th_sfc*(1.0+reps*qv_sfc)/(1.0+qv_sfc)

        the_sfc=getthe(ttype,p_sfc,t_sfc,qv_sfc,qt_sfc)
        if(i.eq.1.and.j.eq.1.and.myid.eq.0)   &
        write(outfile,*) '  p_sfc,t_sfc,qv_sfc = ',p_sfc,t_sfc,qv_sfc
        if(i.eq.1.and.j.eq.1.and.myid.eq.0)   &
        write(outfile,*) '  the_sfc,qt_sfc = ',the_sfc,qt_sfc

        th_sfc=0.0
        qv_sfc=0.0
        call revthe(ttype,the_sfc,p_sfc,qt_sfc,t_sfc,qv_sfc)
        if(i.eq.1.and.j.eq.1.and.myid.eq.0)   &
        write(outfile,*) '  p_sfc,t_sfc,qv_sfc = ',p_sfc,t_sfc,qv_sfc

        pi1=pi_sfc
        z1=0.0
        t1=t_sfc
        thv1=thv_sfc
        thv2=thv1
        flag=0

        do k=1,nk

          z2=zh(i,j,k)
          t2=t1
          tlast=0.0
          n=0

        if(z2.le.zl1)then
          ! troposphere
          theq=the_sfc
          ! iterate:
          do while( abs(t2-tlast).gt.0.0001 )
            tlast=t2
            n=n+1
            pi2=pi1-g*(z2-z1)/(cp*0.5*(thv1+thv2))
            p2=p00*(pi2**(cp/rd))
            call revthe(ttype,theq,p2,qt_sfc,t2,qv2)
            th2=t2/pi2
            if(ttype.eq.1)then
              ql2=qt_sfc-qv2
            elseif(ttype.eq.2)then
              ql2=0.0
            endif
            thv2=th2*(1.0+reps*qv2)/(1.0+qv2+ql2)
          enddo
        else
          ! stratosphere
          ns=4.0e-4
          if(flag.eq.0)then
            ! first time in this section ... get sfc params
            !-------------------
            z2=zl1
            t2=t1
            tlast=0.0
            n=0
            theq=the_sfc
            do while( abs(t2-tlast).gt.0.0001 )
              tlast=t2
              n=n+1
              pi2=pi1-g*(z2-z1)/(cp*0.5*(thv1+thv2))
              p2=p00*(pi2**(cp/rd))
              call revthe(ttype,theq,p2,qt_sfc,t2,qv2)
              th2=t2/pi2
              if(ttype.eq.1)then
                ql2=qt_sfc-qv2
              elseif(ttype.eq.2)then
                ql2=0.0
              endif
              thv2=th2*(1.0+reps*qv2)/(1.0+qv2+ql2)
            enddo
            flag=1
            th_sfc=thv2
            pi_sfc=pi2
            zsfc=z2
            !-------------------
            z2=zh(i,j,k)
            t2=t1
            tlast=0.0
            n=0
          endif
          if(abs(ns).lt.1.0e-6)then
            thv2=th_sfc
            pi2=pi_sfc-g*(z2-zsfc)/(cp*th_sfc)
          else
            thv2=th_sfc*exp(ns*(z2-zsfc)/g)
            pi2=pi_sfc+g*g/(cp*ns*th_sfc)   &
                           *(exp(-ns*(z2-zsfc)/g)-1.0)
          endif
          p2=p00*(pi2**cpdrd)
          th2=thv2
          do n=1,20
            t2=th2*pi2
            qv2=rslf(p2,t2)
            if(ttype.eq.1)then
              ql2=qt_sfc-qv2
            elseif(ttype.eq.2)then
              ql2=0.0
            endif
            th2=thv2*(1.0+qv2+ql2)/(1.0+reps*qv2)
          enddo
        endif
!!!          if(i.eq.1.and.j.eq.1) write(outfile,*) n,p2,th2

          t1=t2
          thv1=thv2
          z1=z2
          pi1=pi2

          pi0(i,j,k)=pi2
          prs0(i,j,k)=p2
          t0(i,j,k)=t2
          th0(i,j,k)=th2
          thv0(i,j,k)=thv2
          rh0(i,j,k)=1.0
          qv0(i,j,k)=qv2
          qc0(i,j,k)=ql2

        enddo

      ENDDO
      ENDDO

!------------------------------------------------------------------
!  PBL simulation:  assumed dry

      ELSEIF(isnd.eq.12)THEN

        pi_sfc = 1.0
        th_sfc = 300.0
        zl1    = 900.0
        lapse  = 0.003

        pisfc = pi_sfc-g*zl1/(cp*th_sfc)

        do k=1,nk
        do j=jb,je
        do i=ib,ie
          IF(zh(i,j,k).le.zl1)THEN
            th0(i,j,k) = th_sfc
            pi0(i,j,k)=pi_sfc-g*zh(i,j,k)/(cp*th_sfc)
          ELSE
            th0(i,j,k) = th_sfc+lapse*(zh(i,j,k)-zl1)
            pi0(i,j,k)=pisfc-(g/(cp*lapse))*alog(th0(i,j,k)/th_sfc)
          ENDIF
          prs0(i,j,k)=p00*(pi0(i,j,k)**(cp/rd))
          t0(i,j,k)=th0(i,j,k)*pi0(i,j,k)
          rh0(i,j,k)=0.0
          qv0(i,j,k)=0.0
          if(i.eq.1.and.j.eq.1.and.myid.eq.0) write(outfile,*) k,zh(i,j,k),th0(i,j,k),prs0(i,j,k)
        enddo
        enddo
        enddo

     ELSEIF(isnd.eq.14)THEN

        p_sfc  = 96000.0     ! surface pressure (Pa)
        th_sfc = 303.00      ! surface potential temperature (K)
        zmix   =  1000.0     ! depth (m) of nearly mixed layer
        ztrop  = 11000.0     ! height (m) above mixed layer of tropopause
        zmin   = 3000.0      ! height (m) above mixed layer where theta-e is
                             ! a minimum
        dtheta = -25.0       ! change in theta-e (K) from zmix to zmin
        rhexp  =  0.75       ! exponent in specification of RH profile

        rh_sfc = 0.70        ! rh at sfc
        rh_pbl = 0.90        ! rh at top of pbl

        ! assuming no terrain (for now)
        i=1
        j=1

        if(myid.eq.0)write(outfile,*)
        do k=1,nk
          if(zh(i,j,k).lt.zmix)then
            thep(k) = 0.0
          elseif(zh(i,j,k).lt.(zmix+zmin))then
            thep(k) = dtheta*sin( 0.5*pi*(zh(i,j,k)-zmix)/(zmin) )
          elseif(zh(i,j,k).lt.(zmix+ztrop))then
            thep(k) = dtheta*sin( 0.5*pi*(zh(i,j,k)-((ztrop+zmix)-2.0*(ztrop-zmin)))/(ztrop-zmin) )
          else
            thep(k) = 0.0
          endif
          if(myid.eq.0)write(outfile,*) '  zh,thep = ',k,zh(i,j,k),thep(k)
        enddo
        if(myid.eq.0)write(outfile,*)

        pi_sfc = (p_sfc*rp00)**rovcp
        t_sfc = th_sfc * pi_sfc
        qv_sfc = rh_sfc*rslf(p_sfc,t_sfc)
        thv_sfc = th_sfc*(1.0+reps*qv_sfc)/(1.0+qv_sfc)
        the_sfc = getthp(p_sfc,th_sfc*pi_sfc,qv_sfc)

        if(myid.eq.0)write(outfile,*)

        do k=1,nk
          the0(k)=the_sfc+thep(k)
          th0(i,j,k)=the0(k)
          ! reasonable first-guess values:
          t0(i,j,k)=200.0
          qv0(i,j,k)=0.001
          if(myid.eq.0)write(outfile,*) '  zh,the0 = ',k,zh(i,j,k),the0(k)
        enddo

        thv_trop = thv_sfc
        t_trop = thv_trop
        qv_trop = 0.0

        ! RH profile is set here:
        if(myid.eq.0)write(outfile,*)
        do k=1,nk
          if(zh(i,j,k).le.zmix)then
            rh0(i,j,k)=rh_sfc-(rh_sfc-rh_pbl)*zh(i,j,k)/zmix
          elseif(zh(i,j,k).le.zmix+ztrop)then
            rh0(i,j,k)=rh_pbl-(rh_pbl-0.20)*(( (zh(i,j,k)-zmix)/ztrop)**rhexp)
          else
            rh0(i,j,k)=0.20
          endif
          if(myid.eq.0)write(outfile,*) '  zh,rh0 = ',zh(i,j,k),rh0(i,j,k)
        enddo

        if(myid.eq.0)write(outfile,*)
        do n=1,20
          do k=1,nk
            if(zh(i,j,k).lt.zmix)then
!!!              thv0(i,j,k)=thv_sfc*exp(nm*zh(i,j,k)/g)
              thv0(i,j,k)=th0(i,j,k)*(1.0+reps*qv0(i,j,k))/(1.0+qv0(i,j,k))
            elseif(zh(i,j,k).lt.ztrop+zmix)then
              thv0(i,j,k)=th0(i,j,k)*(1.0+reps*qv0(i,j,k))/(1.0+qv0(i,j,k))
            else
              ! this sets stability in stratosphere:
              thv0(i,j,k)=thv_trop*exp(4.0e-4*(zh(i,j,k)-(ztrop+zmix))/g)
            endif
          enddo
          pi0(i,j,1)=pi_sfc-g*zh(i,j,1)/(cp*0.5*(thv_sfc+thv0(i,j,1)))
          do k=2,nk
            pi0(i,j,k)=pi0(i,j,k-1)-g*(zh(i,j,k)-zh(i,j,k-1))/(cp*0.5*(thv0(i,j,k-1)+thv0(i,j,k)))
          enddo
          do k=1,nk
            prs0(i,j,k)=p00*(pi0(i,j,k)**(cp/rd))
          enddo
          do k=1,nk
            if(zh(i,j,k).lt.zmix)then
!              th0(i,j,k)=thv0(i,j,k)*(1.0+qv0(i,j,k))/(1.0+reps*qv0(i,j,k))
 !             t0(i,j,k)=th0(i,j,k)*pi0(i,j,k)
 !             qv0(i,j,k)=qv_sfc+(qv_mix-qv_sfc)*zh(i,j,k)/zmix
 !             ! use the following line for constant rh in PBL:
 !             qv0(i,j,k)=0.80*rslf(prs0(i,j,k),t0(i,j,k))
 !             the0(k) = getthp(prs0(i,j,k),t0(i,j,k),qv0(i,j,k))
              the0(k) = the_sfc
              call revthe2(the0(k),prs0(i,j,k),rh0(i,j,k),t0(i,j,k),qv0(i,j,k))
              th0(i,j,k)=t0(i,j,k)/pi0(i,j,k)
            elseif(zh(i,j,k).lt.ztrop+zmix)then
              call revthe2(the0(k),prs0(i,j,k),rh0(i,j,k),t0(i,j,k),qv0(i,j,k))
              th0(i,j,k)=t0(i,j,k)/pi0(i,j,k)
              if(zh(i,j,k+1).gt.ztrop+zmix)then
                pi_trop=pi0(i,j,k)-g*(ztrop-zh(i,j,k))/(cp*0.5*(thv0(i,j,k)+thv_trop))
                p_trop=p00*(pi_trop**(cp/rd))
                call revthe2(the_sfc,p_trop,0.25,t_trop,qv_trop)
                th_trop=t_trop/pi_trop
                thv_trop=th_trop*(1.0+reps*qv_trop)/(1.0+qv_trop)
              endif
            else
              th0(i,j,k)=thv0(i,j,k)*(1.0+qv0(i,j,k))/(1.0+reps*qv0(i,j,k))
              t0(i,j,k)=th0(i,j,k)*pi0(i,j,k)
              qv0(i,j,k)=rh0(i,j,k)*rslf(prs0(i,j,k),t0(i,j,k))
              the0(k) = getthp(prs0(i,j,k),t0(i,j,k),qv0(i,j,k))
            endif
          enddo 
          if(myid.eq.0)write(outfile,*) n,prs0(i,j,1),thv_trop
        enddo
        if(myid.eq.0)write(outfile,*)

        do k=1,nk
          rh0(i,j,k)=qv0(i,j,k)/(rslf(prs0(i,j,k),th0(i,j,k)*pi0(i,j,k)))
        enddo

        ! assuming no terrain (for now):
        do k=1,nk
        do j=jb,je
        do i=ib,ie
           pi0(i,j,k) =  pi0(1,1,k)
          prs0(i,j,k) = prs0(1,1,k)
           th0(i,j,k) =  th0(1,1,k)
           qv0(i,j,k) =  qv0(1,1,k)
           rh0(i,j,k) =  rh0(1,1,k)
        enddo
        enddo
        enddo

!------------------------------------------------------------------

      ENDIF

!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cc  End definition of base state sounding (isnd opton)  cccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


!------------------------------------------------------------------
!  fill in ghost cells

      call bcs(pi0)
      call bcs(prs0)
      call bcs(th0)
      call bcs(qv0)
      call bcs(qc0)
      call bcs(rh0)

#ifdef MPI
      nf=0
      nu=0
      nv=0
      nw=0
      call comm_3s_start(pi0,sw31,sw32,se31,se32,   &
                             ss31,ss32,sn31,sn32,reqs_s)
      call comm_3s_end(pi0,sw31,sw32,se31,se32,   &
                           ss31,ss32,sn31,sn32,reqs_s)
      call comm_3s_start(prs0,sw31,sw32,se31,se32,   &
                             ss31,ss32,sn31,sn32,reqs_s)
      call comm_3s_end(prs0,sw31,sw32,se31,se32,   &
                           ss31,ss32,sn31,sn32,reqs_s)
      call comm_3s_start(th0,sw31,sw32,se31,se32,   &
                             ss31,ss32,sn31,sn32,reqs_s)
      call comm_3s_end(th0,sw31,sw32,se31,se32,   &
                           ss31,ss32,sn31,sn32,reqs_s)
      call comm_3s_start(qv0,sw31,sw32,se31,se32,   &
                             ss31,ss32,sn31,sn32,reqs_s)
      call comm_3s_end(qv0,sw31,sw32,se31,se32,   &
                           ss31,ss32,sn31,sn32,reqs_s)
      call comm_3s_start(qc0,sw31,sw32,se31,se32,   &
                             ss31,ss32,sn31,sn32,reqs_s)
      call comm_3s_end(qc0,sw31,sw32,se31,se32,   &
                           ss31,ss32,sn31,sn32,reqs_s)
      call comm_3s_start(rh0,sw31,sw32,se31,se32,   &
                             ss31,ss32,sn31,sn32,reqs_s)
      call comm_3s_end(rh0,sw31,sw32,se31,se32,   &
                           ss31,ss32,sn31,sn32,reqs_s)
#endif

    do j=jb,je
    do i=ib,ie

      pi0(i,j,0)=pi0(i,j,1)
      pi0(i,j,nk+1)=pi0(i,j,nk)

      prs0(i,j,0)=prs0(i,j,1)
      prs0(i,j,nk+1)=prs0(i,j,nk)

      th0(i,j,0)=th0(i,j,1)
      th0(i,j,nk+1)=th0(i,j,nk)

      qv0(i,j,0)=qv0(i,j,1)
      qv0(i,j,nk+1)=qv0(i,j,nk)

      qc0(i,j,0)=qc0(i,j,1)
      qc0(i,j,nk+1)=qc0(i,j,nk)

      rh0(i,j,0)=rh0(i,j,1)
      rh0(i,j,nk+1)=rh0(i,j,nk)

!------------------------------------------------------------------
!  check thv0
!  Assumes th0, qv0 are accurate

      if(imoist.eq.1)then
        do k=kb,ke
          thv0(i,j,k)=th0(i,j,k)*(1.0+reps*qv0(i,j,k))/(1.0+qv0(i,j,k)+qc0(i,j,k))
        enddo
      else
        do k=kb,ke
          qv0(i,j,k)=0.0
          rh0(i,j,k)=0.0
          thv0(i,j,k)=th0(i,j,k)
        enddo
      endif

!----------------------------
!  calculate pressure, density, and temperature

      do k=kb,ke
        prs0(i,j,k)=p00*(pi0(i,j,k)**cpdrd)
      enddo

      do k=kb,ke
        rho0(i,j,k)=prs0(i,j,k)/(rd*th0(i,j,k)*pi0(i,j,k)*(1.0+qv0(i,j,k)*reps))
        rr0(i,j,k)=1.0/rho0(i,j,k)
      enddo

      rf0(i,j,kb)=0.0
      rrf0(i,j,kb)=0.0
      do k=kb+1,ke
        rf0(i,j,k)=0.5*(rho0(i,j,k-1)+rho0(i,j,k))
        rrf0(i,j,k)=1.0/rf0(i,j,k)
      enddo

      do k=kb,ke
        t0(i,j,k)=th0(i,j,k)*pi0(i,j,k)
      enddo

!----------------------------
!  This reduces errors associated with buoyancy term
!  (seems kind of redundant ... but it works)

      !  This qv0 must match specification of qva array in 
      !  the INIT3D subroutine
      !  (i.e., identical bit-for-bit calculation)

!    IF(imoist.eq.1)THEN
!      do k=kb,ke
!        qv0(i,j,k)=rh0(i,j,k)*rslf(prs0(i,j,k),th0(i,j,k)*pi0(i,j,k))
!      enddo
!    ENDIF


      !  This thv0 must exactly match the manner in which thv
      !  is calculated in the SOLVE subroutine
      !  (i.e., identical bit-for-bit calculation)

      do k=kb,ke
        if(imoist.eq.1)then
          thv0(i,j,k)=(th0(i,j,k)+0.0)*(1.0+reps*max(0.0,qv0(i,j,k)))/(1.0+max(0.0,qv0(i,j,k))+max(0.0,qc0(i,j,k)))
        else
          thv0(i,j,k)=th0(i,j,k)
        endif
      enddo

    enddo
    enddo

      call bcs(rho0)
#ifdef MPI
      call comm_3s_start(rho0,sw31,sw32,se31,se32,   &
                              ss31,ss32,sn31,sn32,reqs_s)
      call comm_3s_end(rho0,sw31,sw32,se31,se32,   &
                            ss31,ss32,sn31,sn32,reqs_s)
      call bcs2(rho0)
      call getcorner(rho0)
#endif
    do j=jb,je
    do i=ib,ie
      rho0(i,j,0)=rho0(i,j,1)
      rho0(i,j,nk+1)=rho0(i,j,nk)
    enddo
    enddo

      IF(psolver.eq.5)THEN   ! incompressible option:  set rho0 to a constant

        do k=kb,ke
        do j=jb,je
        do i=ib,ie
          rho0(i,j,k) = 1.0
        enddo
        enddo
        enddo

      ENDIF

      do k=kb,ke
      do j=jb,je
      do i=ib,ie
        rr0(i,j,k)=1.0/rho0(i,j,k)
      enddo
      enddo
      enddo

      do k=2,nk
      do j=jb,je
      do i=ib,ie
        rf0(i,j,k)=0.5*(rho0(i,j,k-1)+rho0(i,j,k))
      enddo
      enddo
      enddo

      do j=jb,je
      do i=ib,ie
        rf0(i,j,1)=rho0(i,j,1)-zh(i,j,1)*(rho0(i,j,2)-rho0(i,j,1))   &
                                        /(  zh(i,j,2)-  zh(i,j,1))
        rf0(i,j,0)=rf0(i,j,1)
        rho0s(i,j) = rf0(i,j,1)
        rf0(i,j,nk+1)=rho0(i,j,nk)+(zf(i,j,nk+1)-zh(i,j,nk))       &
                                  *(rho0(i,j,nk)-rho0(i,j,nk-1))   &
                                  /(  zh(i,j,nk)-  zh(i,j,nk-1))
      enddo
      enddo

      do k=kb,ke
      do j=jb,je
      do i=ib,ie
        rrf0(i,j,k)=1.0/rf0(i,j,k)
      enddo
      enddo
      enddo

      do k=0,nk+1
      do j=(jb+1),je
      do i=(ib+1),ie
        rru0(i,j,k)=1.0/(0.5*(rho0(i-1,j,k)+rho0(i,j,k)))
        rrv0(i,j,k)=1.0/(0.5*(rho0(i,j-1,k)+rho0(i,j,k)))
      enddo
      enddo
      enddo

!-----------------------------------------------------------------------
!  values at surface:

      ! Get surface p/T/q (for surface models and for CAPE calculation):

      IF( (isnd.eq.7) .and. (.not.terrain_flag) )THEN
        ! this section of code only if no terrain
        do j=jb,je
        do i=ib,ie
          prs0s(i,j) = psurf
          pi0s(i,j) = (psurf/p00)**(rd/cp)
          rth0s(i,j) = thsurf**(-1)
        enddo
        enddo
      ELSE
        do j=jb,je
        do i=ib,ie
          thsurf = th0(i,j,1)-zh(i,j,1)*(th0(i,j,2)-th0(i,j,1))   &
                                       /( zh(i,j,2)- zh(i,j,1))
          qsurf = qv0(i,j,1)-zh(i,j,1)*(qv0(i,j,2)-qv0(i,j,1))   &
                                       /(zh(i,j,2)-zh(i,j,1))
          thvsurf = thsurf*(1.0+qsurf*reps)/(1.0+qsurf)
          ! use hydrostatic equation:
          pi0s(i,j) = pi0(i,j,1)+zh(i,j,1)*g/(cp*0.5*(thvsurf+thv0(i,j,1)))
          prs0s(i,j) = p00*( pi0s(i,j)**(cp/rd) )
          rth0s(i,j) = thsurf**(-1)
        enddo
        enddo
      ENDIF

      if( psurf.lt.tsmall ) psurf = prs0s(1,1)

      i = 1
      j = 1
      tsurf=t0(i,j,1)-zh(i,j,1)*(t0(i,j,2)-t0(i,j,1))   &
                               /(zh(i,j,2)-zh(i,j,1))
      i = 1
      j = 1
      qsurf=qv0(i,j,1)-zh(i,j,1)*(qv0(i,j,2)-qv0(i,j,1))   &
                                 /(zh(i,j,2)-zh(i,j,1))


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cc  Start definition of base state wind (iwnd option)  ccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


!-----------------------------------------------------------------------
!  Get wind profiles  ...  assume zero wind to start

!--------------------------
! 061012:
! Ignore this section if isnd = 7;  in that case, wind profile has
! already been retrieved from the input_sounding file
!--------------------------

    IF(isnd.ne.7)THEN

      do k=1,nk
      do j=1,nj
      do i=1,ni+1
        u0(i,j,k)= 0.0
      enddo
      enddo
      enddo

      do k=1,nk
      do j=1,nj+1
      do i=1,ni
        v0(i,j,k)= 0.0
      enddo
      enddo
      enddo

!-----------------------------------------------------------------------
!  iwnd = 1
!  RKW-type wind profile
!  reference: Rotunno, Klemp, and Weisman, 1988, JAS, 463-485.

      if(iwnd.eq.1)then

        udep1   =     0.0    ! height of bottom of shear layer (m)
        udep2   =  2500.0    ! height of top of shear layer (m)
        uconst1 =     0.0    ! u at bottom of shear layer
        uconst2 =    10.0    ! u at top of shear layer
        uconst2 =     0.0    ! ORF collidig microburst, no winds

        do k=1,nk
        do j=1,nj
        do i=1,ni+1
          zu=0.5*(zh(i-1,j,k)+zh(i,j,k))
          if(zu.lt.udep1)then
            u0(i,j,k)=uconst1
          elseif(zu.gt.udep1 .and. zu.lt.udep2)then
            u0(i,j,k)=(uconst2-uconst1)*(zu-udep1)/(udep2-udep1)+uconst1
          else
            u0(i,j,k)=uconst2
          endif
        enddo
        enddo
        enddo

        do k=1,nk
        do j=1,nj+1
        do i=1,ni
          v0(i,j,k)=0.0
        enddo
        enddo
        enddo

!-----------------------------------------------------------------------
!  iwnd = 2
!  Weisman-Klemp type supercell profile

      elseif(iwnd.eq.2)then

        udep1=2000.0
        udep2=6000.0
        umax1=7.0
        umax2=31.0

        do k=1,nk
        do j=1,nj
        do i=1,ni+1
          zu=0.5*(zh(i-1,j,k)+zh(i,j,k))
          if(zu.le.udep1)THEN
            ANGLE=90.0*(zu/udep1)*(pi/180.0)
            u0(i,j,k)=umax1-umax1*cos(ANGLE)
          elseif(zu.gt.udep1 .and. zu.le.udep2)THEN
            u0(i,j,k)=umax1+(zu-udep1)*(umax2-umax1)/(udep2-udep1)
          ELSE
            u0(i,j,k)=umax2
          ENDIF
        enddo
        enddo
        enddo

        vmax1=umax1

        do k=1,nk
        do j=1,nj+1
        do i=1,ni
          zv=0.5*(zh(i,j-1,k)+zh(i,j,k))
          if(zv.le.udep1)THEN
            ANGLE=90.0*(zv/udep1)*(pi/180.0)
            v0(i,j,k)=vmax1*SIN(ANGLE)
          elseif(zv.gt.udep1 .and. zv.le.udep2)THEN
            v0(i,j,k)=vmax1
          ELSE
            v0(i,j,k)=vmax1
          ENDIF
        enddo
        enddo
        enddo

!-----------------------------------------------------------------------
!  iwnd = 3
!  Mulit-cell type profile (?)

      elseif(iwnd.eq.3)then

        udep1=0.0
        udep2=7500.0
        umax1=-40.0/pi
        umax2=40.0/pi+40.0

        do k=1,nk
        do j=1,nj
        do i=1,ni+1
          zu=0.5*(zh(i-1,j,k)+zh(i,j,k))
          if(zu.le.udep2)then
            u0(i,j,k)=umax1+(zu-udep1)*(umax2-umax1)/(udep2-udep1)
          else
            u0(i,j,k)=umax2
          endif
        enddo
        enddo
        enddo

        do k=1,nk
        do j=1,nj+1
        do i=1,ni
          v0(i,j,k)=40.0/pi
        enddo
        enddo
        enddo

!-----------------------------------------------------------------------
!  iwnd = 4
!  Multi-cell
!  reference:  Weisman and Klemp, 1982, MWR, 110, 504-520.

      elseif(iwnd.eq.4)then

        umax1=35.0

        do k=1,nk
        do j=1,nj
        do i=1,ni+1
          u0(i,j,k)=umax1*tanh(0.5*(zh(i-1,j,k)+zh(i,j,k))/3000.0)
        enddo
        enddo
        enddo

        do k=1,nk
        do j=1,nj+1
        do i=1,ni
          v0(i,j,k)=0.
        enddo
        enddo
        enddo

!-----------------------------------------------------------------------
!  iwnd = 5
!  reference:  Dornbrack et al., 2005, Atmos. Sci. Let., 6, 118-122

      elseif(iwnd.eq.5)then

        umax  =   15.0
        udep1 = 4000.0
        udep2 = 6000.0

        do k=1,nk
        do j=1,nj
        do i=1,ni+1
          zu=0.5*(zh(i-1,j,k)+zh(i,j,k))
          if(zu.lt.udep1)then
            u0(i,j,k) = umax
          elseif(zu.lt.udep2)then
            alpha=0.25*pi*(1.0+cos(pi*(zu-udep1)/(udep2-udep1)))
            u0(i,j,k) = umax*sin(alpha)
          else
            u0(i,j,k) = 0.0
          endif
        enddo
        enddo
        enddo

        do k=1,nk
        do j=1,nj+1
        do i=1,ni
          zv=0.5*(zh(i,j-1,k)+zh(i,j,k))
          if(zv.lt.udep1)then
            v0(i,j,k) = 0.0
          elseif(zv.lt.udep2)then
            alpha=0.25*pi*(1.0+cos(pi*(zv-udep1)/(udep2-udep1)))
            v0(i,j,k) = umax*cos(alpha)
          else
            v0(i,j,k) = umax
          endif
        enddo
        enddo
        enddo

!-----------------------------------------------------------------------
!  iwnd = 6
!  constant wind

      ELSEIF(iwnd.eq.6)THEN

        do k=1,nk
        do j=1,nj
        do i=1,ni+1
          u0(i,j,k) = 10.0
        enddo
        enddo
        enddo

        do k=1,nk
        do j=1,nj+1
        do i=1,ni
          v0(i,j,k) = 0.0
        enddo
        enddo
        enddo

!-----------------------------------------------------------------------
      ELSEIF(iwnd.eq.7)THEN
! sickle hodograph
        ! user inputs:

!       shear_layer_01 = 0.010      ! shear (s^{-1}) in layer 1
!       shear_layer_02 = 0.004      ! shear (s^{-1}) in layer 2

!       depth_layer_01 = 1000.0     ! depth of layer 1 (m)
!       depth_layer_02 = 7000.0     ! depth of layer 2 (m)

!       angle =  0.0                ! angle of lower layer (degrees)
                                    !  -45 is SW-to-NE orientation
                                    !    0 is  N-to-S  orientation
                                    !  +45 is SE-to-NW orientation
!ORF
        shear_layer_01 = var1      ! shear (s^{-1}) in layer 1
        shear_layer_02 = var2      ! shear (s^{-1}) in layer 2

        depth_layer_01 = var3     ! depth of layer 1 (m)
        depth_layer_02 = var4     ! depth of layer 2 (m)

        angle =  90.0-var5          ! angle of lower layer (degrees)
                                    !  -45 is SW-to-NE orientation
                                    !    0 is  N-to-S  orientation
                                    !  +45 is SE-to-NW orientation

                                    ! ORF changing this to 90 degrees is N-to-S
                                    ! for more standard referencing, hence 90-
                                    ! This is for naming convention in files

!---------

        ! no need to change anything below here:

        angle = angle*pi/180.0

        du = shear_layer_01 * depth_layer_01 * sin(angle)
        dv = shear_layer_01 * depth_layer_01 * cos(angle)

        do k=1,nk
        do j=1,nj
        do i=1,ni+1
          zu=0.5*(zh(i-1,j,k)+zh(i,j,k))
          if( zu.le.depth_layer_01 )then
!!!            u0(i,j,k) = 0.0
            u0(i,j,k) = du - (shear_layer_01 * zu)*sin(angle)
          elseif( (zu-depth_layer_01).le.depth_layer_02 )then
            u0(i,j,k) = 0.0 + shear_layer_02 * ( zu - depth_layer_01 )
          else
            u0(i,j,k) = 0.0 + shear_layer_02 * depth_layer_02
          endif
        enddo
        enddo
        enddo

        do k=1,nk
        do j=1,nj+1
        do i=1,ni
          zv=0.5*(zh(i,j-1,k)+zh(i,j,k))
          if( zv.le.depth_layer_01 )then
!!!            v0(i,j,k) = 0.0 + shear_layer_01 * zv
            v0(i,j,k) = (shear_layer_01 * zv)*cos(angle)    &
                      + ( shear_layer_01 * depth_layer_01 - dv )
          else
            v0(i,j,k) = 0.0 + shear_layer_01 * depth_layer_01
          endif
        enddo
        enddo
        enddo

!-----------------------------------------------------------------------

      ENDIF    ! endif for iwnd options

    ENDIF   ! endif for isnd=7 check


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


!-----------------------------------------------------------------------
!  subtract off umove and vmove (if applicable)

      if(imove.eq.1)then
        do k=1,nk
        do j=1,nj+1
        do i=1,ni+1
          u0(i,j,k)=u0(i,j,k)-umove
          v0(i,j,k)=v0(i,j,k)-vmove
        enddo
        enddo
        enddo
      else
        umove=0.0
        vmove=0.0
      endif

!-----------------------------------------------------------------------
!  Fill in ghost cells

      call bcu(u0)
      call bcv(v0)

#ifdef MPI
      call comm_3u_start(u0,uw31,uw32,ue31,ue32,   &
                            us31,us32,un31,un32,reqs_u)
      call comm_3u_end(u0,uw31,uw32,ue31,ue32,   &
                          us31,us32,un31,un32,reqs_u)
      call comm_3v_start(v0,vw31,vw32,ve31,ve32,   &
                            vs31,vs32,vn31,vn32,reqs_v)
      call comm_3v_end(v0,vw31,vw32,ve31,ve32,   &
                          vs31,vs32,vn31,vn32,reqs_v)
#endif

      do j=jb,je
      do i=ib,ie+1
        u0(i,j,   0) = u0(i,j, 1)
        u0(i,j,nk+1) = u0(i,j,nk)
      enddo
      enddo

      do j=jb,je+1
      do i=ib,ie
        v0(i,j,   0) = v0(i,j, 1)
        v0(i,j,nk+1) = v0(i,j,nk)
      enddo
      enddo

!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cc  End definition of base state wind (iwnd option)  ccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


!---------------------------------------------------------------------

!  Print out base state
if(myid.eq.0)then
      write(outfile,*)
      write(outfile,101)
      write(outfile,102)
      do k=1,nk
        write(outfile,103) k,prs0(1,1,k),pi0(1,1,k),rho0(1,1,k)
      enddo
      write(outfile,*)

101   format(7x,'k    prs0 (Pa)       pi0       rho0 (kg/m^3)')
102   format(4x,'-------------------------------------------------------------------')
103   format(4x,i4,4x,f9.2,4x,f9.7,4x,f9.7)

!-----

      write(outfile,*)
      write(outfile,104)
      write(outfile,102)
      do k=1,nk
        write(outfile,105) k,th0(1,1,k),thv0(1,1,k),t0(1,1,k),   &
                   -1000*(t0(1,1,k)-t0(1,1,k-1))*rdz*mh(1,1,k),  &
                    1.0e4*g*alog(thv0(1,1,k)/thv0(1,1,k-1))*rdz*mh(1,1,k)
      enddo
      write(outfile,*)

104   format(7x,'k    th0 (K)     thv0 (K)     t0 (K)    l.r. (K/km)   N^2')
105   format(4x,i4,4x,f8.4,4x,f8.4,4x,f8.4,4x,f8.4,4x,f8.4)

!-----
! Ri check ... warn user if Ri < 0.25, but do not stop model
! 061021: added N^2 check ... stop model if N^2 < 0

      write(outfile,*)
      write(outfile,*) '  Richardson number:  NOTE!!!  Ri should be > 0.25 for most applications!'
      write(outfile,*)
      do k=2,nk
        nm = g*alog(thv0(1,1,k)/thv0(1,1,k-1))*rdz*mf(1,1,k)
        if(nm .lt. -1.0e-12)then
          write(outfile,*)
          write(outfile,*) '  k,z,N^2:',k,0.5*(zh(1,1,k-1)+zh(1,1,k)),nm
          write(outfile,*)
          write(outfile,*) ' Warning.  N^2 (Brunt-Vaisala frequency squared) is less than zero!'
          write(outfile,*) ' This is really, really not recommended for the base state.'
          write(outfile,*) ' Stopping model ....'
          write(outfile,*)
!         call stopcm1
        endif
        dudz = (u0(1,1,k)-u0(1,1,k-1))*rdz*mf(1,1,k)
        dvdz = (v0(1,1,k)-v0(1,1,k-1))*rdz*mf(1,1,k)
        rinum = nm/(1.0e-12+dudz*dudz+dvdz*dvdz)
        if(rinum.gt.0.25)then
          write(outfile,*) '  k,z,Ri:',k,0.5*(zh(1,1,k-1)+zh(1,1,k)),rinum
        else
          write(outfile,*) '  k,z,Ri:',k,0.5*(zh(1,1,k-1)+zh(1,1,k)),rinum,'<---- NOTE!  Ri < 0.25'
        endif
      enddo
      write(outfile,*)

!-----

      write(outfile,*)
      write(outfile,106)
      write(outfile,102)
      do k=1,nk
        if(rh0(1,1,k).gt.0.999 .or. imoist.eq.0)then
          tlcl=t0(1,1,k)
        else
          tlcl=55.0+(2840./(3.5*alog(t0(1,1,k))-    &
                   alog(0.01*prs0(1,1,k)*qv0(1,1,k)/(0.622+qv0(1,1,k)))-4.805))
        endif
        write(outfile,107) k,                                              &
            th0(1,1,k)*exp((3376./tlcl-2.54)*qv0(1,1,k)*(1.0+0.81*qv0(1,1,k))),  &
            rh0(1,1,k),qv0(1,1,k),qc0(1,1,k),ql0(1,1,k)
      enddo
      write(outfile,*)
endif !myid.eq.0
106   format(7x,'k  theta-e (K)      rh0         qv0         qc0         ql0')
107   format(4x,i4,4x,f8.4,4x,f8.6,4x,f8.6,4x,f8.6,4x,f8.6)

!------------------------------------------------------------------
!  Get CAPE,CIN,etc:

  IF(imoist.eq.1)THEN

    allocate(  pfoo(nk+1) )
    allocate(  tfoo(nk+1) )
    allocate( qvfoo(nk+1) )

    pfoo(1) = psurf * 0.01
    tfoo(1) = tsurf - 273.15
   qvfoo(1) = qsurf

    do k=1,nk
      pfoo(k+1) = 0.01*prs0(1,1,k)
      tfoo(k+1) = t0(1,1,k) - 273.15
      qvfoo(k+1) = qv0(1,1,k)
    enddo
if(myid.eq.0)then
    write(outfile,*)
    write(outfile,*) '  Thermodynamic properties of base-state sounding:'
  IF(terrain_flag)THEN
    write(outfile,*) '    (for lower-left corner of domain:  i=1,j=1)  '
  ENDIF
    write(outfile,*)
    do n=1,3
      call getcape( n , nk+1 , pfoo , tfoo , qvfoo , cape , cin ,   &
                    zlcl, zlfc, zel , psource , tsource , qvsource )
      if(n.eq.1)then
        write(outfile,*) '    for surface parcel:'
      elseif(n.eq.2)then
        write(outfile,*) '    for most-unstable parcel:'
      elseif(n.eq.3)then
        write(outfile,*) '    for mixed-layer parcel:'
      endif
      write(outfile,116) 0.01*psource,tsource,1000.0*qvsource
      write(outfile,118) zlcl,zlfc,zel
      write(outfile,117) cape,cin
116   format('        source p(mb),T(K),qv(g/kg) = ',3(4x,f6.1))
118   format('        LCL,LFC,EL (m AGL)         = ',3(3x,f7.1))
117   format('        CAPE,CIN (J/kg)            = ',2(4x,f6.1))
      write(outfile,*)
    enddo
    write(outfile,*)
endif
    deallocate(  pfoo )
    deallocate(  tfoo )
    deallocate( qvfoo )

  ENDIF

!------------------------------------------------------------------
if(myid.eq.0)then
      write(outfile,*)
      write(outfile,108)
      write(outfile,102)
      do k=1,nk
        write(outfile,109) k,u0(1,1,k),v0(1,1,k)
      enddo
      write(outfile,*)

108   format(7x,'k     u0 (m/s)     v0 (m/s)')
109   format(4x,i4,4x,f9.4,4x,f9.4)

!------------------------------------------------------------------

      cpcmd = trim('cp proc00000.print.out '// TRIM(output_basename) // '.print.out')
      call system (cpcmd)
      cpcmd = trim('cp namelist.input ' // TRIM(output_basename) // '.namelist.input')
      call system (cpcmd)

      write(outfile,*) 'Leaving BASE'
endif
      return
      end

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

    real function getthe(ttype,p,t,qv,qt)
    implicit none
    include 'constants.incl'
    integer ttype
    real p,t,qv,qt

    ! Assumes air is saturated

    real :: pd,cpm,lhv

  IF(ttype.eq.1)THEN
    pd=p/(1.0+reps*qv)
    cpm=cp+cpl*qt
    lhv=lv1-lv2*t
    getthe=t*((p00/pd)**(rd/cpm))*exp(lhv*qv/(cpm*t))
  ELSEIF(ttype.eq.2)THEN
    getthe=t*( (p00/p)**(0.2854*(1.0-0.28*qv)) )   &
            *exp( ((3376.0/t)-2.54)*qv*(1.0+0.81*qv) )
  ENDIF
    end function getthe

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

    subroutine revthe(ttype,the,p,qt,t,qv)
    implicit none
    include 'constants.incl'
    integer ttype
    real the,p,qt,rh,t,qv

    ! Assumes air is saturated
    ! Input:   the,p,qt  (t is first guess value upon input)
    ! Output:  t,qv

    integer n
    real tlast,tinc,pd,cpm,lhv,thx,diff
    real rslf

    n=1
    tlast=t
    tinc=0.0
250 continue
      t=tlast+tinc
      qv=rslf(p,t)
    IF(ttype.eq.1)THEN
      pd=p/(1.0+reps*qv)
      cpm=cp+cpl*qt
      lhv=lv1-lv2*t
      thx=t*((p00/pd)**(rd/cpm))*exp(lhv*qv/(cpm*t))
    ELSEIF(ttype.eq.2)THEN
      thx=t*( (p00/p)**(0.2854*(1.0-0.28*qv)) )   &
           *exp( ((3376.0/t)-2.54)*qv*(1.0+0.81*qv) )
    ENDIF

      diff=the-thx
      if(n.ge.40) print *,n,p,the,thx
      if(abs(diff).gt.0.0001 .and. n.lt.50)then
        n=n+1
        tinc=0.30*diff
        tlast=t
        if(abs(tinc).ge.0.0001) go to 250
      elseif(n.ge.50)then
        print *,'n exceeded 50!'
        print *,'n=',n
        stop 1222
      endif

    return
    end subroutine revthe


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

    real function getthp(p,t,qv)
    implicit none
    include 'constants.incl'
    real p,t,qv

    real :: tlcl

    tlcl=55.0+(2840./(3.5*alog(t)-    &
             alog(0.01*p*qv/(eps+qv))-4.805))
    getthp=t*( (p00/p)**(0.2854*(1.0-0.28*qv)) )   &
             *exp( ((3376.0/tlcl)-2.54)*qv*(1.0+0.81*qv) )

    return
    end function getthp

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

    subroutine revthe2(the,p,rh,t,qv)
    implicit none
    include 'constants.incl'
    integer ttype
    real the,p,qt,rh,t,qv

    ! Input:   the,p,rh
    ! Output:  t,qv

    integer n
    real tlast,tinc,pd,cpm,lhv,thx,diff,tlcl
    real rslf

    n=1
    tlast=t
    tinc=0.0
250 continue
      t=tlast+tinc
      qv=rh*rslf(p,t)
      tlcl=55.0+(2840./(3.5*alog(t)-    &
               alog(0.01*p*qv/(eps+qv))-4.805))
      thx=t*( (p00/p)**(0.2854*(1.0-0.28*qv)) )   &
           *exp( ((3376.0/tlcl)-2.54)*qv*(1.0+0.81*qv) )

      diff=the-thx
!!!      if(n.ge.40) print *,n,p,the,thx
      if(abs(diff).gt.0.0001 .and. n.lt.50)then
        n=n+1
        tinc=0.30*diff
        tlast=t
        if(abs(tinc).ge.0.0001) go to 250
      elseif(n.ge.50)then
        print *,'n exceeded 50!'
        print *,'n=',n
        stop 1222
      endif

    return
    end subroutine revthe2


bc.F/           1298670057  19071 8000  100644  70073     `
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine bc2d(s)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, dimension(ib:ie,jb:je) :: s

      integer i,j

!-----------------------------------------------------------------------
!  west boundary condition

#ifndef MPI
      if(wbc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(j)
        do j=jb,je
          s(   0,j)=s(ni  ,j)
          s(  -1,j)=s(ni-1,j)
          s(  -2,j)=s(ni-2,j)
        enddo
      elseif(wbc.eq.2)then
#else
      if(ibw.eq.1.and.wbc.eq.2)then
#endif
!$omp parallel do default(shared)  &
!$omp private(j)
        do j=jb,je
          s(   0,j)=s( 1,j)
          s(  -1,j)=s( 1,j)
          s(  -2,j)=s( 1,j)
        enddo
#ifdef MPI
      elseif(ibw.eq.1.and.wbc.eq.3)then
#else
      elseif(wbc.eq.3)then
#endif
!$omp parallel do default(shared)  &
!$omp private(j)
        do j=jb,je
          s(   0,j)=s(   1,j)
          s(  -1,j)=s(   2,j)
          s(  -2,j)=s(   3,j)
        enddo
      endif

!-----------------------------------------------------------------------
!  east boundary condition

#ifndef MPI
      if(ebc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(j)
        do j=jb,je
          s(ni+1,j)=s(   1,j)
          s(ni+2,j)=s(   2,j)
          s(ni+3,j)=s(   3,j)
        enddo
      elseif(ebc.eq.2)then
#else
      if(ibe.eq.1.and.ebc.eq.2)then
#endif
!$omp parallel do default(shared)  &
!$omp private(j)
        do j=jb,je
          s(ni+1,j)=s(ni,j)
          s(ni+2,j)=s(ni,j)
          s(ni+3,j)=s(ni,j)
        enddo
#ifdef MPI
      elseif(ibe.eq.1.and.ebc.eq.3)then
#else
      elseif(ebc.eq.3)then
#endif
!$omp parallel do default(shared)  &
!$omp private(j)
        do j=jb,je
          s(ni+1,j)=s(  ni,j)
          s(ni+2,j)=s(ni-1,j)
          s(ni+3,j)=s(ni-2,j)
        enddo
      endif

!-----------------------------------------------------------------------
!  south boundary condition

#ifndef MPI
      if(sbc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i)
        do i=ib,ie
          s(i,   0)=s(i,nj  )
          s(i,  -1)=s(i,nj-1)
          s(i,  -2)=s(i,nj-2)
        enddo
      elseif(sbc.eq.2)then
#else
      if(ibs.eq.1.and.sbc.eq.2)then
#endif
!$omp parallel do default(shared)  &
!$omp private(i)
        do i=ib,ie
          s(i,   0)=s(i, 1)
          s(i,  -1)=s(i, 1)
          s(i,  -2)=s(i, 1)
        enddo
#ifdef MPI
      elseif(ibs.eq.1.and.sbc.eq.3)then
#else
      elseif(sbc.eq.3)then
#endif
!$omp parallel do default(shared)  &
!$omp private(i)
        do i=ib,ie
          s(i,   0)=s(i, 1)
          s(i,  -1)=s(i, 2)
          s(i,  -2)=s(i, 3)
        enddo
      endif

!-----------------------------------------------------------------------
!  north boundary condition

#ifndef MPI
      if(nbc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i)
        do i=ib,ie
          s(i,nj+1)=s(i,   1)
          s(i,nj+2)=s(i,   2)
          s(i,nj+3)=s(i,   3)
        enddo
      elseif(nbc.eq.2)then
#else
      if(ibn.eq.1.and.nbc.eq.2)then
#endif
!$omp parallel do default(shared)  &
!$omp private(i)
        do i=ib,ie
          s(i,nj+1)=s(i,nj)
          s(i,nj+2)=s(i,nj)
          s(i,nj+3)=s(i,nj)
        enddo
#ifdef MPI
      elseif(ibn.eq.1.and.nbc.eq.3)then
#else
      elseif(nbc.eq.3)then
#endif
!$omp parallel do default(shared)  &
!$omp private(i)
        do i=ib,ie
          s(i,nj+1)=s(i,nj  )
          s(i,nj+2)=s(i,nj-1)
          s(i,nj+3)=s(i,nj-2)
        enddo
      endif

!-----------------------------------------------------------------------

      if(timestats.ge.1) time_bc=time_bc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine bcs(s)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, dimension(ib:ie,jb:je,kb:ke) :: s

      integer i,j,k

!-----------------------------------------------------------------------
!  west boundary condition

#ifndef MPI
      if(wbc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=1,nk
        do j=jb,je
          s(   0,j,k)=s(ni  ,j,k)
          s(  -1,j,k)=s(ni-1,j,k)
          s(  -2,j,k)=s(ni-2,j,k)
        enddo
        enddo
      elseif(wbc.eq.2)then
#else
      if(ibw.eq.1.and.wbc.eq.2)then
#endif
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=1,nk
        do j=0,nj+1
          s(   0,j,k)=s( 1,j,k)
          s(  -1,j,k)=s( 1,j,k)
          s(  -2,j,k)=s( 1,j,k)
        enddo
        enddo
#ifdef MPI
      elseif(ibw.eq.1.and.wbc.eq.3)then
#else
      elseif(wbc.eq.3)then
#endif
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=1,nk
        do j=0,nj+1
          s(   0,j,k)=s(   1,j,k)
          s(  -1,j,k)=s(   2,j,k)
          s(  -2,j,k)=s(   3,j,k)
        enddo
        enddo
      endif

!-----------------------------------------------------------------------
!  east boundary condition

#ifndef MPI
      if(ebc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=1,nk
        do j=jb,je
          s(ni+1,j,k)=s(   1,j,k)
          s(ni+2,j,k)=s(   2,j,k)
          s(ni+3,j,k)=s(   3,j,k)
        enddo
        enddo
      elseif(ebc.eq.2)then
#else
      if(ibe.eq.1.and.ebc.eq.2)then
#endif
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=1,nk
        do j=0,nj+1
          s(ni+1,j,k)=s(ni,j,k)
          s(ni+2,j,k)=s(ni,j,k)
          s(ni+3,j,k)=s(ni,j,k)
        enddo
        enddo
#ifdef MPI
      elseif(ibe.eq.1.and.ebc.eq.3)then
#else
      elseif(ebc.eq.3)then
#endif
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=1,nk
        do j=0,nj+1
          s(ni+1,j,k)=s(  ni,j,k)
          s(ni+2,j,k)=s(ni-1,j,k)
          s(ni+3,j,k)=s(ni-2,j,k)
        enddo
        enddo
      endif

!-----------------------------------------------------------------------
!  south boundary condition

#ifndef MPI
      if(sbc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=1,nk
        do i=ib,ie
          s(i,   0,k)=s(i,nj  ,k)
          s(i,  -1,k)=s(i,nj-1,k)
          s(i,  -2,k)=s(i,nj-2,k)
        enddo
        enddo
      elseif(sbc.eq.2)then
#else
      if(ibs.eq.1.and.sbc.eq.2)then
#endif
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=1,nk
        do i=0,ni+1
          s(i,   0,k)=s(i, 1,k)
          s(i,  -1,k)=s(i, 1,k)
          s(i,  -2,k)=s(i, 1,k)
        enddo
        enddo
#ifdef MPI
      elseif(ibs.eq.1.and.sbc.eq.3)then
#else
      elseif(sbc.eq.3)then
#endif
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=1,nk
        do i=0,ni+1
          s(i,   0,k)=s(i, 1,k)
          s(i,  -1,k)=s(i, 2,k)
          s(i,  -2,k)=s(i, 3,k)
        enddo
        enddo
      endif

!-----------------------------------------------------------------------
!  north boundary condition

#ifndef MPI
      if(nbc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=1,nk
        do i=ib,ie
          s(i,nj+1,k)=s(i,   1,k)
          s(i,nj+2,k)=s(i,   2,k)
          s(i,nj+3,k)=s(i,   3,k)
        enddo
        enddo
      elseif(nbc.eq.2)then
#else
      if(ibn.eq.1.and.nbc.eq.2)then
#endif
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=1,nk
        do i=0,ni+1
          s(i,nj+1,k)=s(i,nj,k)
          s(i,nj+2,k)=s(i,nj,k)
          s(i,nj+3,k)=s(i,nj,k)
        enddo
        enddo
#ifdef MPI
      elseif(ibn.eq.1.and.nbc.eq.3)then
#else
      elseif(nbc.eq.3)then
#endif
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=1,nk
        do i=0,ni+1
          s(i,nj+1,k)=s(i,nj  ,k)
          s(i,nj+2,k)=s(i,nj-1,k)
          s(i,nj+3,k)=s(i,nj-2,k)
        enddo
        enddo
      endif

!-----------------------------------------------------------------------
!  top/bottom boundary condition

!$omp parallel do default(shared)  &
!$omp private(i,j)
      do j=0,nj+1
      do i=0,ni+1
        s(i,j, 0)=s(i,j,1)
        s(i,j,nk+1)=s(i,j,nk  )
      enddo
      enddo

!-----------------------------------------------------------------------

      if(timestats.ge.1) time_bc=time_bc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine bcp(p)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, dimension(ib:ie,jb:je,kb:ke) :: p

      integer i,j,k

!-----------------------------------------------------------------------
!  west boundary condition

      if(wbc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=1,nk
        do j=0,nj+1
          p(   0,j,k)=p(ni  ,j,k)
          p(  -1,j,k)=p(ni-1,j,k)
          p(  -2,j,k)=p(ni-2,j,k)
        enddo
        enddo
      elseif(wbc.eq.2)then
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=1,nk
        do j=0,nj+1
          p(  -1,j,k)=p( 0,j,k)
          p(  -2,j,k)=p( 0,j,k)
        enddo
        enddo
      elseif(wbc.eq.3)then
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=1,nk
        do j=0,nj+1
          p(   0,j,k)=p(   1,j,k)
          p(  -1,j,k)=p(   2,j,k)
          p(  -2,j,k)=p(   3,j,k)
        enddo
        enddo
      endif

!-----------------------------------------------------------------------
!  east boundary condition

      if(ebc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=1,nk
        do j=0,nj+1
          p(ni+1,j,k)=p(   1,j,k)
          p(ni+2,j,k)=p(   2,j,k)
          p(ni+3,j,k)=p(   3,j,k)
        enddo
        enddo
      elseif(ebc.eq.2)then
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=1,nk
        do j=0,nj+1
          p(ni+2,j,k)=p(ni+1,j,k)
          p(ni+3,j,k)=p(ni+1,j,k)
        enddo
        enddo
      elseif(ebc.eq.3)then
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=1,nk
        do j=0,nj+1
          p(ni+1,j,k)=p(  ni,j,k)
          p(ni+2,j,k)=p(ni-1,j,k)
          p(ni+3,j,k)=p(ni-2,j,k)
        enddo
        enddo
      endif

!-----------------------------------------------------------------------
!  south boundary condition

      if(sbc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=1,nk
        do i=ib,ie
          p(i,   0,k)=p(i,nj  ,k)
          p(i,  -1,k)=p(i,nj-1,k)
          p(i,  -2,k)=p(i,nj-2,k)
        enddo
        enddo
      elseif(sbc.eq.2)then
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=1,nk
        do i=0,ni+1
          p(i,  -1,k)=p(i, 0,k)
          p(i,  -2,k)=p(i, 0,k)
        enddo
        enddo
      elseif(sbc.eq.3)then
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=1,nk
        do i=0,ni+1
          p(i,   0,k)=p(i, 1,k)
          p(i,  -1,k)=p(i, 2,k)
          p(i,  -2,k)=p(i, 3,k)
        enddo
        enddo
      endif

!-----------------------------------------------------------------------
!  north boundary condition

      if(nbc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=1,nk
        do i=ib,ie
          p(i,nj+1,k)=p(i,   1,k)
          p(i,nj+2,k)=p(i,   2,k)
          p(i,nj+3,k)=p(i,   3,k)
        enddo
        enddo
      elseif(nbc.eq.2)then
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=1,nk
        do i=0,ni+1
          p(i,nj+2,k)=p(i,nj+1,k)
          p(i,nj+3,k)=p(i,nj+1,k)
        enddo
        enddo
      elseif(nbc.eq.3)then
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=1,nk
        do i=0,ni+1
          p(i,nj+1,k)=p(i,nj  ,k)
          p(i,nj+2,k)=p(i,nj-1,k)
          p(i,nj+3,k)=p(i,nj-2,k)
        enddo
        enddo
      endif

!-----------------------------------------------------------------------
!  top/bottom boundary condition

!$omp parallel do default(shared)  &
!$omp private(i,j)
      do j=jb,je
      do i=ib,ie
        p(i,j,   0)=p(i,j, 1)
        p(i,j,nk+1)=p(i,j,nk)
      enddo
      enddo

!-----------------------------------------------------------------------

      if(timestats.ge.1) time_bc=time_bc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine bcu(u)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'  

      real, dimension(ib:ie+1,jb:je,kb:ke) :: u

      integer i,j,k  

!-----------------------------------------------------------------------
!  west boundary condition

#ifndef MPI
      if(wbc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=1,nk
        do j=jb,je
          u(   0,j,k)=u(ni  ,j,k)
          u(  -1,j,k)=u(ni-1,j,k)
          u(  -2,j,k)=u(ni-2,j,k)
        enddo
        enddo
      elseif(wbc.eq.2)then
#else
      if(ibw.eq.1.and.wbc.eq.2)then
#endif
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=1,nk
        do j=0,nj+1
          u(   0,j,k)=u(1,j,k)
          u(  -1,j,k)=u(1,j,k)
          u(  -2,j,k)=u(1,j,k)
        enddo
        enddo
#ifdef MPI
      elseif(ibw.eq.1.and.wbc.eq.3)then
#else
      elseif(wbc.eq.3)then
#endif
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=1,nk
        do j=0,nj+1
          u(   1,j,k)=0.
          u(   0,j,k)=-u(   2,j,k)
          u(  -1,j,k)=-u(   3,j,k)
          u(  -2,j,k)=-u(   4,j,k)
        enddo
        enddo
      endif

!-----------------------------------------------------------------------
!  east boundary condition

#ifndef MPI
      if(ebc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=1,nk
        do j=jb,je
          u(ni+2,j,k)=u(2,j,k)
          u(ni+3,j,k)=u(3,j,k)
          u(ni+4,j,k)=u(4,j,k)
        enddo
        enddo
      elseif(ebc.eq.2)then
#else
      if(ibe.eq.1.and.ebc.eq.2)then
#endif
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=1,nk
        do j=0,nj+1
          u(ni+2,j,k)=u(ni+1,j,k)
          u(ni+3,j,k)=u(ni+1,j,k)
          u(ni+4,j,k)=u(ni+1,j,k)
        enddo
        enddo
#ifdef MPI
      elseif(ibe.eq.1.and.ebc.eq.3)then
#else
      elseif(ebc.eq.3)then
#endif
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=1,nk
        do j=0,nj+1
          u(ni+1,j,k)=0.
          u(ni+2,j,k)=-u(ni  ,j,k)
          u(ni+3,j,k)=-u(ni-1,j,k)
          u(ni+4,j,k)=-u(ni-2,j,k)
        enddo
        enddo
      endif

!-----------------------------------------------------------------------
!  south boundary condition

#ifndef MPI
      if(sbc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=1,nk
        do i=ib,ie+1
          u(i,   0,k)=u(i,nj  ,k)
          u(i,  -1,k)=u(i,nj-1,k)
          u(i,  -2,k)=u(i,nj-2,k)
        enddo
        enddo
      elseif(sbc.eq.2)then
#else
      if(ibs.eq.1.and.sbc.eq.2)then
#endif
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=1,nk
        do i=0,ni+2
          u(i,   0,k)=u(i, 1,k)
          u(i,  -1,k)=u(i, 1,k)
          u(i,  -2,k)=u(i, 1,k)
        enddo
        enddo
#ifdef MPI
      elseif(ibs.eq.1.and.sbc.eq.3)then
#else
      elseif(sbc.eq.3)then
#endif
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=1,nk
        do i=0,ni+2
          u(i,   0,k)=u(i, 1,k)
          u(i,  -1,k)=u(i, 2,k)
          u(i,  -2,k)=u(i, 3,k)
        enddo
        enddo
      endif

!-----------------------------------------------------------------------
!  north boundary condition

#ifndef MPI
      if(nbc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=1,nk
        do i=ib,ie+1
          u(i,nj+1,k)=u(i,   1,k)
          u(i,nj+2,k)=u(i,   2,k)
          u(i,nj+3,k)=u(i,   3,k)
        enddo
        enddo
      elseif(nbc.eq.2)then
#else
      if(ibn.eq.1.and.nbc.eq.2)then
#endif
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=1,nk
        do i=0,ni+2
          u(i,nj+1,k)=u(i,nj,k)
          u(i,nj+2,k)=u(i,nj,k)
          u(i,nj+3,k)=u(i,nj,k)
        enddo
        enddo
#ifdef MPI
      elseif(ibn.eq.1.and.nbc.eq.3)then
#else
      elseif(nbc.eq.3)then
#endif
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=1,nk
        do i=0,ni+2
          u(i,nj+1,k)=u(i,nj  ,k)
          u(i,nj+2,k)=u(i,nj-1,k)
          u(i,nj+3,k)=u(i,nj-2,k)
        enddo
        enddo
      endif

!-----------------------------------------------------------------------
!  top/bottom boundary condition

!$omp parallel do default(shared)  &
!$omp private(i,j)
      do j=0,nj+1
      do i=0,ni+2
        u(i,j, 0)=u(i,j,1)
        u(i,j,nk+1)=u(i,j,nk  )
      enddo
      enddo

!-----------------------------------------------------------------------

      if(timestats.ge.1) time_bc=time_bc+mytime()
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine bcv(v)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real, dimension(ib:ie,jb:je+1,kb:ke) :: v
 
      integer i,j,k

!-----------------------------------------------------------------------
!  south boundary condition
 
#ifndef MPI
      if(sbc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=1,nk
        do i=ib,ie
          v(i,   0,k)=v(i,nj  ,k)
          v(i,  -1,k)=v(i,nj-1,k)
          v(i,  -2,k)=v(i,nj-2,k)
        enddo
        enddo
      elseif(sbc.eq.2)then
#else
      if(ibs.eq.1.and.sbc.eq.2)then
#endif
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=1,nk
        do i=0,ni+1
          v(i,   0,k)=v(i,1,k)
          v(i,  -1,k)=v(i,1,k)
          v(i,  -2,k)=v(i,1,k)
        enddo
        enddo
#ifdef MPI
      elseif(ibs.eq.1.and.sbc.eq.3)then
#else
      elseif(sbc.eq.3)then
#endif
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=1,nk
        do i=0,ni+1
          v(i,   1,k)=0.
          v(i,   0,k)=-v(i,2,k)
          v(i,  -1,k)=-v(i,3,k)
          v(i,  -2,k)=-v(i,4,k)
        enddo
        enddo
      endif

!-----------------------------------------------------------------------
!  north boundary condition

      IF(axisymm.eq.1)THEN
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=1,nk
        do i=ib,ie
          v(i,2,k)=v(i,1,k)
        enddo
        enddo
      ENDIF

#ifndef MPI
      if(nbc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=1,nk
        do i=ib,ie
          v(i,nj+2,k)=v(i,   2,k)
          v(i,nj+3,k)=v(i,   3,k)
          v(i,nj+4,k)=v(i,   4,k)
        enddo
        enddo
      elseif(nbc.eq.2)then
#else
      if(ibn.eq.1.and.nbc.eq.2)then
#endif
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=1,nk
        do i=0,ni+1
          v(i,nj+2,k)=v(i,nj+1,k)
          v(i,nj+3,k)=v(i,nj+1,k)
          v(i,nj+4,k)=v(i,nj+1,k)
        enddo
        enddo
#ifdef MPI
      elseif(ibn.eq.1.and.nbc.eq.3)then
#else
      elseif(nbc.eq.3)then
#endif
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=1,nk
        do i=0,ni+1
          v(i,nj+1,k)=0.
          v(i,nj+2,k)=-v(i,nj  ,k)
          v(i,nj+3,k)=-v(i,nj-1,k)
          v(i,nj+4,k)=-v(i,nj-2,k)
        enddo
        enddo
      endif

!-----------------------------------------------------------------------
!  west boundary condition

#ifndef MPI
      if(wbc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=1,nk
        do j=jb,je+1
          v(   0,j,k)=v(ni  ,j,k)
          v(  -1,j,k)=v(ni-1,j,k)
          v(  -2,j,k)=v(ni-2,j,k)
        enddo
        enddo
      elseif(wbc.eq.2)then
#else
      if(ibw.eq.1.and.wbc.eq.2)then
#endif
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=1,nk
        do j=0,nj+2
          v(   0,j,k)=v( 1,j,k)
          v(  -1,j,k)=v( 1,j,k)
          v(  -2,j,k)=v( 1,j,k)
        enddo
        enddo
#ifdef MPI
      elseif(ibw.eq.1.and.wbc.eq.3)then
#else
      elseif(wbc.eq.3)then
#endif
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=1,nk
        do j=0,nj+2
          v(   0,j,k)=v( 1,j,k)
          v(  -1,j,k)=v( 2,j,k)
          v(  -2,j,k)=v( 3,j,k)
        enddo
        enddo
      endif

      IF(axisymm.eq.1)THEN
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=1,nk
        do j=0,nj+2
          v( 0,j,k) = -v(1,j,k)
          v(-1,j,k) = -v(2,j,k)
          v(-2,j,k) = -v(3,j,k)
        enddo
        enddo
      ENDIF

!-----------------------------------------------------------------------
!  east boundary condition

#ifndef MPI
      if(ebc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=1,nk
        do j=jb,je+1
          v(ni+1,j,k)=v(   1,j,k)
          v(ni+2,j,k)=v(   2,j,k)
          v(ni+3,j,k)=v(   3,j,k)
        enddo
        enddo
      elseif(ebc.eq.2)then
#else
      if(ibe.eq.1.and.ebc.eq.2)then
#endif
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=1,nk
        do j=0,nj+2
          v(ni+1,j,k)=v(ni,j,k)
          v(ni+2,j,k)=v(ni,j,k)
          v(ni+3,j,k)=v(ni,j,k)
        enddo
        enddo
#ifdef MPI
      elseif(ibe.eq.1.and.ebc.eq.3)then
#else
      elseif(ebc.eq.3)then
#endif
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=1,nk
        do j=0,nj+2
          v(ni+1,j,k)=v(ni  ,j,k)
          v(ni+2,j,k)=v(ni-1,j,k)
          v(ni+3,j,k)=v(ni-2,j,k)
        enddo
        enddo
      endif

!-----------------------------------------------------------------------
!  top/bottom boundary condition

!$omp parallel do default(shared)  &
!$omp private(i,j)
      do j=0,nj+2
      do i=0,ni+1
        v(i,j, 0)=v(i,j,1)
        v(i,j,nk+1)=v(i,j,nk  )
      enddo
      enddo

!-----------------------------------------------------------------------

      if(timestats.ge.1) time_bc=time_bc+mytime()
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine bcw(w,flag)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real, dimension(ib:ie,jb:je,kb:ke+1) :: w
      integer flag
 
      integer i,j,k

!-----------------------------------------------------------------------
!  west boundary condition
 
#ifndef MPI
      if(wbc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=2,nk
        do j=jb,je
          w(   0,j,k)=w(ni  ,j,k)
          w(  -1,j,k)=w(ni-1,j,k)
          w(  -2,j,k)=w(ni-2,j,k)
        enddo
        enddo
      elseif(wbc.eq.2)then
#else
      if(ibw.eq.1.and.wbc.eq.2)then
#endif
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=2,nk
        do j=0,nj+1
          w(   0,j,k)=w( 1,j,k)
          w(  -1,j,k)=w( 1,j,k)
          w(  -2,j,k)=w( 1,j,k)
        enddo
        enddo
#ifdef MPI
      elseif(ibw.eq.1.and.wbc.eq.3)then
#else
      elseif(wbc.eq.3)then
#endif
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=2,nk
        do j=0,nj+1
          w(   0,j,k)=w( 1,j,k)
          w(  -1,j,k)=w( 2,j,k)
          w(  -2,j,k)=w( 3,j,k)
        enddo
        enddo
      endif

!-----------------------------------------------------------------------
!  east boundary condition

#ifndef MPI
      if(ebc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=2,nk
        do j=jb,je
          w(ni+1,j,k)=w(   1,j,k)
          w(ni+2,j,k)=w(   2,j,k)
          w(ni+3,j,k)=w(   3,j,k)
        enddo
        enddo
      elseif(ebc.eq.2)then
#else
      if(ibe.eq.1.and.ebc.eq.2)then
#endif
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=2,nk
        do j=0,nj+1
          w(ni+1,j,k)=w(ni,j,k)
          w(ni+2,j,k)=w(ni,j,k)
          w(ni+3,j,k)=w(ni,j,k)
        enddo
        enddo
#ifdef MPI
      elseif(ibe.eq.1.and.ebc.eq.3)then
#else
      elseif(ebc.eq.3)then
#endif
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=2,nk
        do j=0,nj+1
          w(ni+1,j,k)=w(ni  ,j,k)
          w(ni+2,j,k)=w(ni-1,j,k)
          w(ni+3,j,k)=w(ni-2,j,k)
        enddo 
        enddo 
      endif

!-----------------------------------------------------------------------
!  south boundary condition

#ifndef MPI
      if(sbc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=2,nk
        do i=ib,ie
          w(i,   0,k)=w(i,nj  ,k)
          w(i,  -1,k)=w(i,nj-1,k)
          w(i,  -2,k)=w(i,nj-2,k)
        enddo
        enddo
      elseif(sbc.eq.2)then
#else
      if(ibs.eq.1.and.sbc.eq.2)then
#endif
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=2,nk
        do i=0,ni+1
          w(i,   0,k)=w(i, 1,k)
          w(i,  -1,k)=w(i, 1,k)
          w(i,  -2,k)=w(i, 1,k)
        enddo
        enddo
#ifdef MPI
      elseif(ibs.eq.1.and.sbc.eq.3)then
#else
      elseif(sbc.eq.3)then
#endif
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=2,nk
        do i=0,ni+1
          w(i,   0,k)=w(i, 1,k)
          w(i,  -1,k)=w(i, 2,k)
          w(i,  -2,k)=w(i, 3,k)
        enddo
        enddo
      endif

!-----------------------------------------------------------------------
!  north boundary condition

#ifndef MPI
      if(nbc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=2,nk
        do i=ib,ie
          w(i,nj+1,k)=w(i,   1,k)
          w(i,nj+2,k)=w(i,   2,k)
          w(i,nj+3,k)=w(i,   3,k)
        enddo
        enddo
      elseif(nbc.eq.2)then
#else
      if(ibn.eq.1.and.nbc.eq.2)then
#endif
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=2,nk
        do i=0,ni+1
          w(i,nj+1,k)=w(i,nj,k)
          w(i,nj+2,k)=w(i,nj,k)
          w(i,nj+3,k)=w(i,nj,k)
        enddo
        enddo
#ifdef MPI
      elseif(ibn.eq.1.and.nbc.eq.3)then
#else
      elseif(nbc.eq.3)then
#endif
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=2,nk
        do i=0,ni+1
          w(i,nj+1,k)=w(i,nj  ,k)
          w(i,nj+2,k)=w(i,nj-1,k)
          w(i,nj+3,k)=w(i,nj-2,k)
        enddo
        enddo
      endif

!-----------------------------------------------------------------------
!  top/bottom boundary condition

    IF(flag.eq.1)THEN

!$omp parallel do default(shared)  &
!$omp private(i,j)
      do j=0,nj+1
      do i=0,ni+1
        w(i,j, 0)=-w(i,j,2)
        w(i,j, 1)=0.0
        w(i,j,nk+1)=0.0
        w(i,j,nk+2)=-w(i,j,nk  )
      enddo
      enddo

    ENDIF

!-----------------------------------------------------------------------

      if(timestats.ge.1) time_bc=time_bc+mytime()
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine bcwsfc(dzdx,dzdy,u,v,w)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, dimension(itb:ite,jtb:jte) :: dzdx,dzdy
      real, dimension(ib:ie+1,jb:je,kb:ke) :: u
      real, dimension(ib:ie,jb:je+1,kb:ke) :: v
      real, dimension(ib:ie,jb:je,kb:ke+1) :: w

      integer i,j

!-----------------------------------------------------------------------

!$omp parallel do default(shared)  &
!$omp private(i,j)
      do j=0,nj+1
      do i=0,ni+1
        w(i,j,1)=0.5*( (u(i,j,1)+u(i+1,j,1))*dzdx(i,j)    &
                      +(v(i,j,1)+v(i,j+1,1))*dzdy(i,j) )
      enddo
      enddo

!-----------------------------------------------------------------------

      if(timestats.ge.1) time_bc=time_bc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine bct(t)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, dimension(ib:ie,jb:je,kb:ke+1) :: t

      integer i,j,k

!-----------------------------------------------------------------------
!  west boundary condition

#ifndef MPI
      if(wbc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=1,nk+1
        do j=jb,je
          t(   0,j,k)=t(ni  ,j,k)
          t(  -1,j,k)=t(ni-1,j,k)
          t(  -2,j,k)=t(ni-2,j,k)
        enddo
        enddo
      elseif(wbc.eq.2)then
#else
      if(ibw.eq.1.and.wbc.eq.2)then
#endif
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=1,nk+1
        do j=0,nj+1
          t(   0,j,k)=t( 1,j,k)
          t(  -1,j,k)=t( 1,j,k)
          t(  -2,j,k)=t( 1,j,k)
        enddo
        enddo
#ifdef MPI
      elseif(ibw.eq.1.and.wbc.eq.3)then
#else
      elseif(wbc.eq.3)then
#endif
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=1,nk+1
        do j=0,nj+1
          t(   0,j,k)=t(   1,j,k)
          t(  -1,j,k)=t(   2,j,k)
          t(  -2,j,k)=t(   3,j,k)
        enddo
        enddo
      endif

!-----------------------------------------------------------------------
!  east boundary condition

#ifndef MPI
      if(ebc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=1,nk+1
        do j=jb,je
          t(ni+1,j,k)=t(   1,j,k)
          t(ni+2,j,k)=t(   2,j,k)
          t(ni+3,j,k)=t(   3,j,k)
        enddo
        enddo
      elseif(ebc.eq.2)then
#else
      if(ibe.eq.1.and.ebc.eq.2)then
#endif
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=1,nk+1
        do j=0,nj+1
          t(ni+1,j,k)=t(ni,j,k)
          t(ni+2,j,k)=t(ni,j,k)
          t(ni+3,j,k)=t(ni,j,k)
        enddo
        enddo
#ifdef MPI
      elseif(ibe.eq.1.and.ebc.eq.3)then
#else
      elseif(ebc.eq.3)then
#endif
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=1,nk+1
        do j=0,nj+1
          t(ni+1,j,k)=t(  ni,j,k)
          t(ni+2,j,k)=t(ni-1,j,k)
          t(ni+3,j,k)=t(ni-2,j,k)
        enddo
        enddo
      endif

!-----------------------------------------------------------------------
!  south boundary condition

#ifndef MPI
      if(sbc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=1,nk+1
        do i=ib,ie
          t(i,   0,k)=t(i,nj  ,k)
          t(i,  -1,k)=t(i,nj-1,k)
          t(i,  -2,k)=t(i,nj-2,k)
        enddo
        enddo
      elseif(sbc.eq.2)then
#else
      if(ibs.eq.1.and.sbc.eq.2)then
#endif
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=1,nk+1
        do i=0,ni+1
          t(i,   0,k)=t(i, 1,k)
          t(i,  -1,k)=t(i, 1,k)
          t(i,  -2,k)=t(i, 1,k)
        enddo
        enddo
#ifdef MPI
      elseif(ibs.eq.1.and.sbc.eq.3)then
#else
      elseif(sbc.eq.3)then
#endif
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=1,nk+1
        do i=0,ni+1
          t(i,   0,k)=t(i, 1,k)
          t(i,  -1,k)=t(i, 2,k)
          t(i,  -2,k)=t(i, 3,k)
        enddo
        enddo
      endif

!-----------------------------------------------------------------------
!  north boundary condition

#ifndef MPI
      if(nbc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=1,nk+1
        do i=ib,ie
          t(i,nj+1,k)=t(i,   1,k)
          t(i,nj+2,k)=t(i,   2,k)
          t(i,nj+3,k)=t(i,   3,k)
        enddo
        enddo
      elseif(nbc.eq.2)then
#else
      if(ibn.eq.1.and.nbc.eq.2)then
#endif
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=1,nk+1
        do i=0,ni+1
          t(i,nj+1,k)=t(i,nj,k)
          t(i,nj+2,k)=t(i,nj,k)
          t(i,nj+3,k)=t(i,nj,k)
        enddo
        enddo
#ifdef MPI
      elseif(ibn.eq.1.and.nbc.eq.3)then
#else
      elseif(nbc.eq.3)then
#endif
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=1,nk+1
        do i=0,ni+1
          t(i,nj+1,k)=t(i,nj  ,k)
          t(i,nj+2,k)=t(i,nj-1,k)
          t(i,nj+3,k)=t(i,nj-2,k)
        enddo
        enddo
      endif

!-----------------------------------------------------------------------
!  top/bottom boundary condition

!$omp parallel do default(shared)  &
!$omp private(i,j)
      do j=0,nj+1
      do i=0,ni+1
        t(i,j, 0)=t(i,j,1)
        t(i,j,nk+2)=t(i,j,nk+1)
      enddo
      enddo

!-----------------------------------------------------------------------

      if(timestats.ge.1) time_bc=time_bc+mytime()

      return
      end


#ifdef MPI
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine bcs2(s)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real s(ib:ie,jb:je,kb:ke)

      integer i,j,k

!---------------------------------------------------------
!  This subroutine sets the corner points
!---------------------------------------------------------

      if(ibw.eq.1)then

        if(patchsww)then
          j=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            s(  -2,j,k)=s( 1,j,k)
            s(  -1,j,k)=s( 1,j,k)
            s(   0,j,k)=s( 1,j,k)
          enddo
        endif

        if(patchnww)then
          j=nj+1
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            s(  -2,j,k)=s( 1,j,k)
            s(  -1,j,k)=s( 1,j,k)
            s(   0,j,k)=s( 1,j,k)
          enddo
        endif

      endif

      if(ibe.eq.1)then

        if(patchsee)then
          j=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            s(ni+1,j,k)=s(ni,j,k)
            s(ni+2,j,k)=s(ni,j,k)
            s(ni+3,j,k)=s(ni,j,k)
          enddo
        endif

        if(patchnee)then
          j=nj+1
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            s(ni+1,j,k)=s(ni,j,k)
            s(ni+2,j,k)=s(ni,j,k)
            s(ni+3,j,k)=s(ni,j,k)
          enddo
        endif

      endif

      if(ibs.eq.1)then

        if(patchsws)then
          i=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            s(i,  -2,k)=s(i, 1,k)
            s(i,  -1,k)=s(i, 1,k)
            s(i,   0,k)=s(i, 1,k)
          enddo
        endif

        if(patchses)then
          i=ni+1
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            s(i,  -2,k)=s(i, 1,k)
            s(i,  -1,k)=s(i, 1,k)
            s(i,   0,k)=s(i, 1,k)
          enddo
        endif

      endif

      if(ibn.eq.1)then

        if(patchnwn)then
          i=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            s(i,nj+1,k)=s(i,nj,k)
            s(i,nj+2,k)=s(i,nj,k)
            s(i,nj+3,k)=s(i,nj,k)
          enddo
        endif

        if(patchnen)then
          i=ni+1
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            s(i,nj+1,k)=s(i,nj,k)
            s(i,nj+2,k)=s(i,nj,k)
            s(i,nj+3,k)=s(i,nj,k)
          enddo
        endif

      endif

      if(timestats.ge.1) time_bc=time_bc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine bct2(t)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real t(ib:ie,jb:je,kb:ke+1)

      integer i,j,k

!---------------------------------------------------------
!  This subroutine sets the corner points
!---------------------------------------------------------

      if(ibw.eq.1)then

        if(patchsww)then
          j=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk+1
            t(  -2,j,k)=t( 1,j,k)
            t(  -1,j,k)=t( 1,j,k)
            t(   0,j,k)=t( 1,j,k)
          enddo
        endif

        if(patchnww)then
          j=nj+1
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk+1
            t(  -2,j,k)=t( 1,j,k)
            t(  -1,j,k)=t( 1,j,k)
            t(   0,j,k)=t( 1,j,k)
          enddo
        endif

      endif

      if(ibe.eq.1)then

        if(patchsee)then
          j=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk+1
            t(ni+1,j,k)=t(ni,j,k)
            t(ni+2,j,k)=t(ni,j,k)
            t(ni+3,j,k)=t(ni,j,k)
          enddo
        endif

        if(patchnee)then
          j=nj+1
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk+1
            t(ni+1,j,k)=t(ni,j,k)
            t(ni+2,j,k)=t(ni,j,k)
            t(ni+3,j,k)=t(ni,j,k)
          enddo
        endif

      endif

      if(ibs.eq.1)then

        if(patchsws)then
          i=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk+1
            t(i,  -2,k)=t(i, 1,k)
            t(i,  -1,k)=t(i, 1,k)
            t(i,   0,k)=t(i, 1,k)
          enddo
        endif

        if(patchses)then
          i=ni+1
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk+1
            t(i,  -2,k)=t(i, 1,k)
            t(i,  -1,k)=t(i, 1,k)
            t(i,   0,k)=t(i, 1,k)
          enddo
        endif

      endif

      if(ibn.eq.1)then

        if(patchnwn)then
          i=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk+1
            t(i,nj+1,k)=t(i,nj,k)
            t(i,nj+2,k)=t(i,nj,k)
            t(i,nj+3,k)=t(i,nj,k)
          enddo
        endif

        if(patchnen)then
          i=ni+1
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk+1
            t(i,nj+1,k)=t(i,nj,k)
            t(i,nj+2,k)=t(i,nj,k)
            t(i,nj+3,k)=t(i,nj,k)
          enddo
        endif

      endif

      if(timestats.ge.1) time_bc=time_bc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine bcu2(u)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real u(ib:ie+1,jb:je,kb:ke)

      integer i,j,k

!---------------------------------------------------------
!  This subroutine sets the corner points
!---------------------------------------------------------

      if(ibw.eq.1)then

        if(patchsww)then
          j=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            u(  -2,j,k)=u( 1,j,k)
            u(  -1,j,k)=u( 1,j,k)
            u(   0,j,k)=u( 1,j,k)
          enddo
        endif

        if(patchnww)then
          j=nj+1
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            u(  -2,j,k)=u( 1,j,k)
            u(  -1,j,k)=u( 1,j,k)
            u(   0,j,k)=u( 1,j,k)
          enddo
        endif

      endif

      if(ibe.eq.1)then

        if(patchsee)then
          j=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            u(ni+2,j,k)=u(ni+1,j,k)
            u(ni+3,j,k)=u(ni+1,j,k)
            u(ni+4,j,k)=u(ni+1,j,k)
          enddo
        endif

        if(patchnee)then
          j=nj+1
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            u(ni+2,j,k)=u(ni+1,j,k)
            u(ni+3,j,k)=u(ni+1,j,k)
            u(ni+4,j,k)=u(ni+1,j,k)
          enddo
        endif

      endif

      if(ibs.eq.1)then

        if(patchsws)then
          i=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            u(i,  -2,k)=u(i, 1,k)
            u(i,  -1,k)=u(i, 1,k)
            u(i,   0,k)=u(i, 1,k)
          enddo
        endif

        if(patchses)then
          i=ni+2
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            u(i,  -2,k)=u(i, 1,k)
            u(i,  -1,k)=u(i, 1,k)
            u(i,   0,k)=u(i, 1,k)
          enddo
        endif

      endif

      if(ibn.eq.1)then

        if(patchnwn)then
          i=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            u(i,nj+1,k)=u(i,nj,k)
            u(i,nj+2,k)=u(i,nj,k)
            u(i,nj+3,k)=u(i,nj,k)
          enddo
        endif

        if(patchnen)then
          i=ni+2
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            u(i,nj+1,k)=u(i,nj,k)
            u(i,nj+2,k)=u(i,nj,k)
            u(i,nj+3,k)=u(i,nj,k)
          enddo
        endif

      endif

      if(timestats.ge.1) time_bc=time_bc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine bcv2(v)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real v(ib:ie,jb:je+1,kb:ke)

      integer i,j,k

!---------------------------------------------------------
!  This subroutine sets the corner points
!---------------------------------------------------------

      if(ibw.eq.1)then

        if(patchsww)then
          j=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            v(  -2,j,k)=v( 1,j,k)
            v(  -1,j,k)=v( 1,j,k)
            v(   0,j,k)=v( 1,j,k)
          enddo
        endif

        if(patchnww)then
          j=nj+2
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            v(  -2,j,k)=v( 1,j,k)
            v(  -1,j,k)=v( 1,j,k)
            v(   0,j,k)=v( 1,j,k)
          enddo
        endif

      endif

      if(ibe.eq.1)then

        if(patchsee)then
          j=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            v(ni+1,j,k)=v(ni,j,k)
            v(ni+2,j,k)=v(ni,j,k)
            v(ni+3,j,k)=v(ni,j,k)
          enddo
        endif

        if(patchnee)then
          j=nj+2
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            v(ni+1,j,k)=v(ni,j,k)
            v(ni+2,j,k)=v(ni,j,k)
            v(ni+3,j,k)=v(ni,j,k)
          enddo
        endif

      endif

      if(ibs.eq.1)then

        if(patchsws)then
          i=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            v(i,  -2,k)=v(i, 1,k)
            v(i,  -1,k)=v(i, 1,k)
            v(i,   0,k)=v(i, 1,k)
          enddo
        endif

        if(patchses)then
          i=ni+1
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            v(i,  -2,k)=v(i, 1,k)
            v(i,  -1,k)=v(i, 1,k)
            v(i,   0,k)=v(i, 1,k)
          enddo
        endif

      endif

      if(ibn.eq.1)then

        if(patchnwn)then
          i=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            v(i,nj+2,k)=v(i,nj+1,k)
            v(i,nj+3,k)=v(i,nj+1,k)
            v(i,nj+4,k)=v(i,nj+1,k)
          enddo
        endif

        if(patchnen)then
          i=ni+1
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk
            v(i,nj+2,k)=v(i,nj+1,k)
            v(i,nj+3,k)=v(i,nj+1,k)
            v(i,nj+4,k)=v(i,nj+1,k)
          enddo
        endif

      endif

      if(timestats.ge.1) time_bc=time_bc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine bcw2(w)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real w(ib:ie,jb:je,kb:ke+1)

      integer i,j,k

!---------------------------------------------------------
!  This subroutine sets the corner points
!---------------------------------------------------------

      if(ibw.eq.1)then

        if(patchsww)then
          j=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk+1
            w(  -2,j,k)=w( 1,j,k)
            w(  -1,j,k)=w( 1,j,k)
            w(   0,j,k)=w( 1,j,k)
          enddo
        endif

        if(patchnww)then
          j=nj+1
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk+1
            w(  -2,j,k)=w( 1,j,k)
            w(  -1,j,k)=w( 1,j,k)
            w(   0,j,k)=w( 1,j,k)
          enddo
        endif

      endif

      if(ibe.eq.1)then

        if(patchsee)then
          j=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk+1
            w(ni+1,j,k)=w(ni,j,k)
            w(ni+2,j,k)=w(ni,j,k)
            w(ni+3,j,k)=w(ni,j,k)
          enddo
        endif

        if(patchnee)then
          j=nj+1
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk+1
            w(ni+1,j,k)=w(ni,j,k)
            w(ni+2,j,k)=w(ni,j,k)
            w(ni+3,j,k)=w(ni,j,k)
          enddo
        endif

      endif

      if(ibs.eq.1)then

        if(patchsws)then
          i=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk+1
            w(i,  -2,k)=w(i, 1,k)
            w(i,  -1,k)=w(i, 1,k)
            w(i,   0,k)=w(i, 1,k)
          enddo
        endif

        if(patchses)then
          i=ni+1
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk+1
            w(i,  -2,k)=w(i, 1,k)
            w(i,  -1,k)=w(i, 1,k)
            w(i,   0,k)=w(i, 1,k)
          enddo
        endif

      endif

      if(ibn.eq.1)then

        if(patchnwn)then
          i=0
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk+1
            w(i,nj+1,k)=w(i,nj,k)
            w(i,nj+2,k)=w(i,nj,k)
            w(i,nj+3,k)=w(i,nj,k)
          enddo
        endif

        if(patchnen)then
          i=ni+1
!$omp parallel do default(shared)   &
!$omp private(k)
          do k=1,nk+1
            w(i,nj+1,k)=w(i,nj,k)
            w(i,nj+2,k)=w(i,nj,k)
            w(i,nj+3,k)=w(i,nj,k)
          enddo
        endif

      endif

      if(timestats.ge.1) time_bc=time_bc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine bcs2_2d(s)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real s(ib:ie,jb:je)

      integer i,j

!---------------------------------------------------------
!  This subroutine sets the corner points
!---------------------------------------------------------

      if(ibw.eq.1)then

        if(patchsww)then
          j=0
          s(  -2,j)=s( 1,j)
          s(  -1,j)=s( 1,j)
          s(   0,j)=s( 1,j)
        endif

        if(patchnww)then
          j=nj+1
          s(  -2,j)=s( 1,j)
          s(  -1,j)=s( 1,j)
          s(   0,j)=s( 1,j)
        endif

      endif

      if(ibe.eq.1)then

        if(patchsee)then
          j=0
          s(ni+1,j)=s(ni,j)
          s(ni+2,j)=s(ni,j)
          s(ni+3,j)=s(ni,j)
        endif

        if(patchnee)then
          j=nj+1
          s(ni+1,j)=s(ni,j)
          s(ni+2,j)=s(ni,j)
          s(ni+3,j)=s(ni,j)
        endif

      endif

      if(ibs.eq.1)then

        if(patchsws)then
          i=0
          s(i,  -2)=s(i, 1)
          s(i,  -1)=s(i, 1)
          s(i,   0)=s(i, 1)
        endif

        if(patchses)then
          i=ni+1
          s(i,  -2)=s(i, 1)
          s(i,  -1)=s(i, 1)
          s(i,   0)=s(i, 1)
        endif

      endif

      if(ibn.eq.1)then

        if(patchnwn)then
          i=0
          s(i,nj+1)=s(i,nj)
          s(i,nj+2)=s(i,nj)
          s(i,nj+3)=s(i,nj)
        endif

        if(patchnen)then
          i=ni+1
          s(i,nj+1)=s(i,nj)
          s(i,nj+2)=s(i,nj)
          s(i,nj+3)=s(i,nj)
        endif

      endif

      if(timestats.ge.1) time_bc=time_bc+mytime()

      return
      end


#endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine radbcew(radbcw,radbce,ua)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real, dimension(jb:je,kb:ke) :: radbcw,radbce
      real, dimension(ib:ie+1,jb:je,kb:ke) :: ua
 
      integer j,k
      real cbcw,cbce
 
      if(ibw.eq.1.and.wbc.eq.2)then
!$omp parallel do default(shared)  &
!$omp private(j,k,cbcw)
        do k=1,nk
        do j=1,nj
          cbcw=ua(1,j,k)-30.0
          if(cbcw.lt.0.0)then
            radbcw(j,k)=cbcw
          else
            radbcw(j,k)=0.
          endif
        enddo
        enddo
      endif
 
      if(ibe.eq.1.and.ebc.eq.2)then
!$omp parallel do default(shared)  &
!$omp private(j,k,cbce)
        do k=1,nk
        do j=1,nj
          cbce=ua(ni+1,j,k)+30.0
          if(cbce.gt.0.0)then
            radbce(j,k)=cbce
          else
            radbce(j,k)=0.
          endif
        enddo
        enddo
      endif

!-----------------------------------------------------------------------
 
      if(timestats.ge.1) time_bc=time_bc+mytime()
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine radbcns(radbcs,radbcn,va)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real, dimension(ib:ie,kb:ke) :: radbcs,radbcn
      real, dimension(ib:ie,jb:je+1,kb:ke) :: va
 
      integer i,k
      real cbcs,cbcn

      if(ibs.eq.1.and.sbc.eq.2)then
!$omp parallel do default(shared)  &
!$omp private(i,k,cbcs)
        do k=1,nk
        do i=1,ni
          cbcs=va(i,1,k)-30.0
          if(cbcs.lt.0.0)then
            radbcs(i,k)=cbcs
          else
            radbcs(i,k)=0.
          endif
        enddo
        enddo
      endif
 
      if(ibn.eq.1.and.nbc.eq.2)then
!$omp parallel do default(shared)  &
!$omp private(i,k,cbcn)
        do k=1,nk
        do i=1,ni
          cbcn=va(i,nj+1,k)+30.0
          if(cbcn.gt.0.0)then
            radbcn(i,k)=cbcn
          else
            radbcn(i,k)=0.
          endif
        enddo
        enddo
      endif

!-----------------------------------------------------------------------
 
      if(timestats.ge.1) time_bc=time_bc+mytime()
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine radbcew4(ruf,radbcw,radbce,u1,u2,dt)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, dimension(ib:ie+1) :: ruf
      real, dimension(jb:je,kb:ke) :: radbcw,radbce
      real, dimension(ib:ie+1,jb:je,kb:ke) :: u1,u2
      real dt

      integer j,k
      real umax,avgw,avge,foo,cbcw,cbce

      umax=350.0

      if(ibw.eq.1.and.wbc.eq.2)then
!$omp parallel do default(shared)   &
!$omp private(j,k,foo,avgw,cbcw)
        do j=1,nj
          avgw=0.
          do k=1,nk
            foo=(u1(3,j,k)-u1(2,j,k))
            cbcw=dx*ruf(2)*(u1(2,j,k)-u2(2,j,k))   &
                   /(dt*(sign(1.e-10,foo)+foo))
            cbcw=max(min(cbcw,0.0),-umax)
            avgw=avgw+cbcw
          enddo
          avgw=avgw/float(nk)
          do k=1,nk
            radbcw(j,k)=avgw
          enddo
        enddo
      endif

      if(ibe.eq.1.and.ebc.eq.2)then
!$omp parallel do default(shared)   &
!$omp private(j,k,foo,avge,cbce)
        do j=1,nj
          avge=0.
          do k=1,nk
            foo=(u1(ni+1-1,j,k)-u1(ni+1-2,j,k))
            cbce=dx*ruf(ni+1-1)*(u1(ni+1-1,j,k)-u2(ni+1-1,j,k))   &
                   /(dt*(sign(1.e-10,foo)+foo))
            cbce=min(max(cbce,0.0),umax)
            avge=avge+cbce
          enddo
          avge=avge/float(nk)
          do k=1,nk
            radbce(j,k)=avge
          enddo
        enddo
      endif

      if(timestats.ge.1) time_bc=time_bc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine radbcns4(rvf,radbcs,radbcn,v1,v2,dt)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, dimension(jb:je+1) :: rvf
      real, dimension(ib:ie,kb:ke) :: radbcs,radbcn
      real, dimension(ib:ie,jb:je+1,kb:ke) :: v1,v2
      real dt

      integer i,k
      real umax,avgs,avgn,foo,cbcs,cbcn

      umax=350.0

      if(ibs.eq.1.and.sbc.eq.2)then
!$omp parallel do default(shared)   &
!$omp private(i,k,avgs,foo,cbcs)
        do i=1,ni
          avgs=0.
          do k=1,nk
            foo=(v1(i,3,k)-v1(i,2,k))
            cbcs=dy*rvf(2)*(v1(i,2,k)-v2(i,2,k))   &
                   /(dt*(sign(1.e-10,foo)+foo))
            cbcs=max(min(cbcs,0.0),-umax)
            avgs=avgs+cbcs
          enddo
          avgs=avgs/float(nk)
          do k=1,nk
            radbcs(i,k)=avgs
          enddo
        enddo
      endif

      if(ibn.eq.1.and.nbc.eq.2)then
!$omp parallel do default(shared)   &
!$omp private(i,k,avgn,foo,cbcn)
        do i=1,ni
          avgn=0.
          do k=1,nk
            foo=(v1(i,nj+1-1,k)-v1(i,nj+1-2,k))
            cbcn=dy*rvf(nj+1-1)*(v1(i,nj+1-1,k)-v2(i,nj+1-1,k))   &
                   /(dt*(sign(1.e-10,foo)+foo))
            cbcn=min(max(cbcn,0.0),umax)
            avgn=avgn+cbcn
          enddo
          avgn=avgn/float(nk)
          do k=1,nk
            radbcn(i,k)=avgn
          enddo
        enddo
      endif

      if(timestats.ge.1) time_bc=time_bc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine restrict_openbc_we(rvh,rmh,rho0,u3d)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
#ifdef MPI
      include 'mpif.h'
#endif

      real, dimension(jb:je) :: rvh
      real, dimension(ib:ie,jb:je,kb:ke) :: rmh
      real, dimension(ib:ie,jb:je,kb:ke) :: rho0
      real, dimension(ib:ie+1,jb:je,kb:ke) :: u3d

      integer i,j,k
      real*8 :: fluxout,fluxin,tem,u1,t3
      real*8, dimension(nk) :: temout,temin

!$omp parallel do default(shared)   &
!$omp private(k)
      do k=1,nk
        temout(k) = 0.0d0
        temin(k)  = 0.0d0
      enddo

      if(wbc.eq.2.and.ibw.eq.1)then
        i=1
!$omp parallel do default(shared)   &
!$omp private(j,k)
        do k=1,nk
        do j=1,nj
          temout(k)=temout(k)-min(0.0,rho0(1,j,k)*u3d(i,j,k)*rvh(j)*rmh(1,j,k))
          temin(k) =temin(k) +max(0.0,rho0(1,j,k)*u3d(i,j,k)*rvh(j)*rmh(1,j,k))
        enddo
        enddo
      endif

      if(ebc.eq.2.and.ibe.eq.1)then
        i=ni+1
!$omp parallel do default(shared)   &
!$omp private(j,k)
        do k=1,nk
        do j=1,nj
          temout(k)=temout(k)+max(0.0,rho0(ni,j,k)*u3d(i,j,k)*rvh(j)*rmh(ni,j,k))
          temin(k) =temin(k) -min(0.0,rho0(ni,j,k)*u3d(i,j,k)*rvh(j)*rmh(ni,j,k))
        enddo
        enddo
      endif

      fluxout = 0.0d0
      fluxin  = 0.0d0

      do k=1,nk
        fluxout = fluxout + temout(k)
        fluxin  = fluxin  + temin(k)
      enddo

#ifdef MPI
      tem=0.0d0
      call MPI_ALLREDUCE(fluxout,tem,1,MPI_DOUBLE_PRECISION,MPI_SUM,   &
                         MPI_COMM_WORLD,ierr)
      fluxout=tem
      tem=0.0d0
      call MPI_ALLREDUCE(fluxin,tem,1,MPI_DOUBLE_PRECISION,MPI_SUM,   &
                         MPI_COMM_WORLD,ierr)
      fluxin=tem
#endif

      t3=(fluxin+1.0d-20)/(fluxout+1.0d-20)

      if(wbc.eq.2.and.ibw.eq.1)then
        i=1
!$omp parallel do default(shared)   &
!$omp private(j,k,u1)
        do k=1,nk
        do j=1,nj
          u1=rho0(1,j,k)*u3d(i,j,k)
          if(u1.lt.0.0)then
            u3d(i,j,k)=u1*t3/rho0(1,j,k)
          endif
        enddo
        enddo
      endif

      if(ebc.eq.2.and.ibe.eq.1)then
        i=ni+1
!$omp parallel do default(shared)   &
!$omp private(j,k,u1)
        do k=1,nk
        do j=1,nj
          u1=rho0(ni,j,k)*u3d(i,j,k)
          if(u1.gt.0.0)then
            u3d(i,j,k)=u1*t3/rho0(ni,j,k)
          endif
        enddo
        enddo
      endif

      if(timestats.ge.1) time_bc=time_bc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine restrict_openbc_sn(ruh,rmh,rho0,v3d)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
#ifdef MPI
      include 'mpif.h'
#endif

      real, dimension(ib:ie) :: ruh
      real, dimension(ib:ie,jb:je,kb:ke) :: rmh
      real, dimension(ib:ie,jb:je,kb:ke) :: rho0
      real, dimension(ib:ie,jb:je+1,kb:ke) :: v3d

      integer i,j,k
      real*8 :: fluxout,fluxin,tem,u1,t3
      real*8, dimension(nk) :: temout,temin

!$omp parallel do default(shared)   &
!$omp private(k)
      do k=1,nk
        temout(k) = 0.0d0
        temin(k)  = 0.0d0
      enddo

      if(sbc.eq.2.and.ibs.eq.1)then
        j=1
!$omp parallel do default(shared)   &
!$omp private(i,k)
        do k=1,nk
        do i=1,ni
          temout(k)=temout(k)-min(0.0,rho0(i,1,k)*v3d(i,j,k)*ruh(i)*rmh(i,1,k))
          temin(k) =temin(k) +max(0.0,rho0(i,1,k)*v3d(i,j,k)*ruh(i)*rmh(i,1,k))
        enddo
        enddo
      endif

      if(nbc.eq.2.and.ibn.eq.1)then
        j=nj+1
!$omp parallel do default(shared)   &
!$omp private(i,k)
        do k=1,nk
        do i=1,ni
          temout(k)=temout(k)+max(0.0,rho0(i,nj,k)*v3d(i,j,k)*ruh(i)*rmh(i,nj,k))
          temin(k) =temin(k) -min(0.0,rho0(i,nj,k)*v3d(i,j,k)*ruh(i)*rmh(i,nj,k))
        enddo
        enddo
      endif

      fluxout = 0.0d0
      fluxin  = 0.0d0

      do k=1,nk
        fluxout = fluxout + temout(k)
        fluxin  = fluxin  + temin(k)
      enddo

#ifdef MPI
      tem=0.0d0
      call MPI_ALLREDUCE(fluxout,tem,1,MPI_DOUBLE_PRECISION,MPI_SUM,   &
                         MPI_COMM_WORLD,ierr)
      fluxout=tem
      tem=0.0d0
      call MPI_ALLREDUCE(fluxin,tem,1,MPI_DOUBLE_PRECISION,MPI_SUM,   &
                         MPI_COMM_WORLD,ierr)
      fluxin=tem
#endif

      t3=(fluxin+1.0d-20)/(fluxout+1.0d-20)

      if(sbc.eq.2.and.ibs.eq.1)then
        j=1
!$omp parallel do default(shared)   &
!$omp private(i,k,u1)
        do k=1,nk
        do i=1,ni
          u1=rho0(i,1,k)*v3d(i,j,k)
          if(u1.lt.0.0)then
            v3d(i,j,k)=u1*t3/rho0(i,1,k)
          endif
        enddo
        enddo
      endif

      if(nbc.eq.2.and.ibn.eq.1)then
        j=nj+1
!$omp parallel do default(shared)   &
!$omp private(i,k,u1)
        do k=1,nk
        do i=1,ni
          u1=rho0(i,nj,k)*v3d(i,j,k)
          if(u1.gt.0.0)then
            v3d(i,j,k)=u1*t3/rho0(i,nj,k)
          endif
        enddo
        enddo
      endif

      if(timestats.ge.1) time_bc=time_bc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine movesfc(rmax,dt,uh,vh,sfc,s,dum1,dum2)
      implicit none

      include 'input.incl'
      include 'constants.incl'

      real :: rmax,dt
      real, dimension(ib:ie) :: uh
      real, dimension(jb:je) :: vh
      real, dimension(ib:ie,jb:je) :: sfc,s,dum1,dum2

      integer i,j,nrk
      real s1,s2,s3,s4,s5,f1,f2,f3,b1,b2,b3,w1,w2,w3,tem

      real epsilon,onedsix,thdtw
      parameter(epsilon=1.0e-8)
      parameter(onedsix=1.0/6.0)
      parameter(thdtw=13.0/12.0)

#ifdef MPI
      real, dimension(3,nj) :: west,newwest,east,neweast
      real, dimension(ni,3) :: south,newsouth,north,newnorth
      integer reqs(8)
#endif

!------------------------------------------------------------

!$omp parallel do default(shared)  &
!$omp private(i,j)
    do j=1,nj
    do i=1,ni
      s(i,j)=sfc(i,j)
    enddo
    enddo

!$omp parallel do default(shared)  &
!$omp private(i,j)
    do j=0,nj+1
    do i=0,ni+1
      dum1(i,j)=0.0
      dum2(i,j)=0.0
    enddo
    enddo

    DO nrk=1,3

!-------------------------
!  set boundary conditions

#ifdef MPI
      call comm_2d_start(s,west,newwest,east,neweast,   &
                           south,newsouth,north,newnorth,reqs)
#else
      if(wbc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(j)
        do j=1,nj
          s( 0,j)=s(ni  ,j)
          s(-1,j)=s(ni-1,j)
          s(-2,j)=s(ni-2,j)
        enddo
      endif
      if(ebc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(j)
        do j=1,nj
          s(ni+1,j)=s(1,j)
          s(ni+2,j)=s(2,j)
          s(ni+3,j)=s(3,j)
        enddo
      endif
      if(sbc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i)
        do i=1,ni
          s(i, 0)=s(i,nj  )
          s(i,-1)=s(i,nj-1)
          s(i,-2)=s(i,nj-2)
        enddo
      endif
      if(nbc.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i)
        do i=1,ni
          s(i,nj+1)=s(i,1)
          s(i,nj+2)=s(i,2)
          s(i,nj+3)=s(i,3)
        enddo
      endif
#endif

      if(ibw.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(j)
        do j=1,nj
          s( 0,j)=s(1,j)
          s(-1,j)=s(1,j)
          s(-2,j)=s(1,j)
        enddo
      endif

      if(ibe.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(j)
        do j=1,nj
          s(ni+1,j)=s(ni,j)
          s(ni+2,j)=s(ni,j)
          s(ni+3,j)=s(ni,j)
        enddo
      endif

      if(ibs.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i)
        do i=1,ni
          s(i, 0)=s(i,1)
          s(i,-1)=s(i,1)
          s(i,-2)=s(i,1)
        enddo
      endif

      if(ibn.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i)
        do i=1,ni
          s(i,nj+1)=s(i,nj)
          s(i,nj+2)=s(i,nj)
          s(i,nj+3)=s(i,nj)
        enddo
      endif

!-------------------------

#ifdef MPI
      call comm_2dew_end(s,west,newwest,east,neweast,reqs)
#endif

!-------------------------

    if(abs(umove).gt.0.01)then
!$omp parallel do default(shared)  &
!$omp private(i,j,s1,s2,s3,s4,s5,f1,f2,f3,b1,b2,b3,w1,w2,w3)
      do j=1,nj
      do i=1,ni+1
        if(umove.ge.0.0)then
          s1=s(i+2,j)
          s2=s(i+1,j)
          s3=s(i  ,j)
          s4=s(i-1,j)
          s5=s(i-2,j)
        else
          s1=s(i-3,j)
          s2=s(i-2,j)
          s3=s(i-1,j)
          s4=s(i  ,j)
          s5=s(i+1,j)
        endif

        f1=( 2.0*s1 -7.0*s2 +11.0*s3 )*onedsix
        f2=(    -s2 +5.0*s3  +2.0*s4 )*onedsix
        f3=( 2.0*s3 +5.0*s4      -s5 )*onedsix

        b1=thdtw*( s1 -2.0*s2 +s3 )**2 + 0.25*(     s1 -4.0*s2 +3.0*s3 )**2
        b2=thdtw*( s2 -2.0*s3 +s4 )**2 + 0.25*(     s2             -s4 )**2
        b3=thdtw*( s3 -2.0*s4 +s5 )**2 + 0.25*( 3.0*s3 -4.0*s4     +s5 )**2

        w1=0.10/((epsilon+b1)**2)
        w2=0.60/((epsilon+b2)**2)
        w3=0.30/((epsilon+b3)**2)

        dum1(i,j)=((w1*f1)+(w2*f2)+(w3*f3))/(w1+w2+w3)
      enddo
      enddo
    endif

!-------------------------

#ifdef MPI
      call comm_2dns_end(s,south,newsouth,north,newnorth,reqs)
#endif

!-------------------------

    if(abs(vmove).gt.0.01)then
!$omp parallel do default(shared)  &
!$omp private(i,j,s1,s2,s3,s4,s5,f1,f2,f3,b1,b2,b3,w1,w2,w3)
      do j=1,nj+1
      do i=1,ni
        if(vmove.ge.0.0)then
          s1=s(i,j+2)
          s2=s(i,j+1)
          s3=s(i,j  )
          s4=s(i,j-1)
          s5=s(i,j-2)
        else
          s1=s(i,j-3)
          s2=s(i,j-2)
          s3=s(i,j-1)
          s4=s(i,j  )
          s5=s(i,j+1)
        endif

        f1=( 2.0*s1 -7.0*s2 +11.0*s3 )*onedsix
        f2=(    -s2 +5.0*s3  +2.0*s4 )*onedsix
        f3=( 2.0*s3 +5.0*s4      -s5 )*onedsix

        b1=thdtw*( s1 -2.0*s2 +s3 )**2 + 0.25*(     s1 -4.0*s2 +3.0*s3 )**2
        b2=thdtw*( s2 -2.0*s3 +s4 )**2 + 0.25*(     s2             -s4 )**2
        b3=thdtw*( s3 -2.0*s4 +s5 )**2 + 0.25*( 3.0*s3 -4.0*s4     +s5 )**2

        w1=0.10/((epsilon+b1)**2)
        w2=0.60/((epsilon+b2)**2)
        w3=0.30/((epsilon+b3)**2)

        dum2(i,j)=((w1*f1)+(w2*f2)+(w3*f3))/(w1+w2+w3)
      enddo
      enddo
    endif

      tem=dt/(4-nrk)

!$omp parallel do default(shared)  &
!$omp private(i,j)
      do j=1,nj
      do i=1,ni
        s(i,j)=max( rmax , sfc(i,j)+tem*(                          &
                          umove*(dum1(i+1,j)-dum1(i,j))*rdx*uh(i)  &
                         +vmove*(dum2(i,j+1)-dum2(i,j))*rdy*vh(j) ) )
      enddo
      enddo

!-------------------------

    ENDDO

!$omp parallel do default(shared)  &
!$omp private(i,j)
    do j=1,nj
    do i=1,ni
      sfc(i,j)=s(i,j)
    enddo
    enddo

!----------------------------------------------------------------

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine bsx(dt,bsq,rvh,rmh,dum)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real :: dt
      real*8 bsq
      real, dimension(jb:je) :: rvh
      real, dimension(ib:ie,jb:je,kb:ke) :: rmh
      real, dimension(ib:ie,jb:je,kb:ke) :: dum

      integer j,k
      real*8 tem
      real*8 bud(nk)

!-----------------------------------------------------------------------

!$omp parallel do default(shared)  &
!$omp private(k)
      do k=1,nk
        bud(k)=0.0d0
      enddo

      if(ibw.eq.1 .and. wbc.eq.2)then
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=1,nk
        do j=1,nj
          bud(k)=bud(k)+dum(1,j,k)*rvh(j)*rmh(1,j,k)
        enddo
        enddo
      endif

      if(ibe.eq.1 .and. ebc.eq.2)then
!$omp parallel do default(shared)  &
!$omp private(j,k)
        do k=1,nk
        do j=1,nj
          bud(k)=bud(k)-dum(ni+1,j,k)*rvh(j)*rmh(ni+1,j,k)
        enddo
        enddo
      endif

      tem=dt*dy*dz
      do k=1,nk
        bsq=bsq+bud(k)*tem
      enddo

!-----------------------------------------------------------------------

      if(timestats.ge.1) time_stat=time_stat+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine bsy(dt,bsq,ruh,rmh,dum)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real :: dt
      real*8 bsq
      real, dimension(ib:ie) :: ruh
      real, dimension(ib:ie,jb:je,kb:ke) :: rmh
      real, dimension(ib:ie,jb:je,kb:ke) :: dum

      integer i,k
      real*8 tem
      real*8 bud(nk)

!-----------------------------------------------------------------------

!$omp parallel do default(shared)  &
!$omp private(k)
      do k=1,nk
        bud(k)=0.0d0
      enddo

      if(ibs.eq.1 .and. sbc.eq.2)then
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=1,nk
        do i=1,ni
          bud(k)=bud(k)+dum(i,1,k)*ruh(i)*rmh(i,1,k)
        enddo
        enddo
      endif

      if(ibn.eq.1 .and. nbc.eq.2)then
!$omp parallel do default(shared)  &
!$omp private(i,k)
        do k=1,nk
        do i=1,ni
          bud(k)=bud(k)-dum(i,nj+1,k)*ruh(i)*rmh(i,nj+1,k)
        enddo
        enddo
      endif

      tem=dt*dx*dz
      do k=1,nk
        bsq=bsq+bud(k)*tem
      enddo

!-----------------------------------------------------------------------

      if(timestats.ge.1) time_stat=time_stat+mytime()

      return
      end



cm1.F/          1299680022  19071 8000  100644  63107     `
      program cm1

#ifdef ORFSWATHS
      use orfswathsmod
#endif
      use orfiomod

      use HDF5

      implicit none

!-----------------------------------------------------------------------
!  CM1 Numerical Model, Release 15  (cm1r15)
!  13 January 2011
!  http://www.mmm.ucar.edu/people/bryan/cm1/
!-----------------------------------------------------------------------
!
!  Please see documentation at the top of the "solve.F" file.
!
!  See also documentation at the cm1 website, such as:
!
!    "The governing equations for CM1"
!        http://www.mmm.ucar.edu/people/bryan/cm1/cm1_equations.pdf
!
!-----------------------------------------------------------------------

      include 'input.incl'
      include 'radcst.incl'
      include 'constants.incl'
      include 'timestat.incl'
#ifdef MPI
      include 'mpif.h'
#endif

      integer :: nstep
      integer :: nrec,prec,nwrite,nrst
      integer :: rbufsz,num_soil_layers,ndt
      real :: dt,dtlast
      real*8 :: mtime,stattim,taptim,rsttim,radtim,adt,acfl
      logical :: dodrag,dosfcflx
      logical, dimension(maxq) :: cloudvar,rhovar
      character*15 :: tdef
      character*3, dimension(maxq) :: qname
      character*6, dimension(maxq) :: budname
      real*8, dimension(:), allocatable :: bud,bud2
      real*8, dimension(:), allocatable :: qbudget
      real*8, dimension(:), allocatable :: asq,bsq
      real, dimension(:), allocatable :: xh,rxh,uh,ruh
      real, dimension(:), allocatable :: xf,rxf,uf,ruf
      real, dimension(:), allocatable :: yh,vh,rvh
      real, dimension(:), allocatable :: yf,vf,rvf
      real, dimension(:), allocatable :: xfref,yfref
      real, dimension(:), allocatable :: sigma,sigmaf
      real, dimension(:,:,:), allocatable :: tauh,taus,zh,mh,rmh
      real, dimension(:,:,:), allocatable :: tauf,zf,mf,rmf
      real, dimension(:), allocatable :: rstat
      real, dimension(:,:), allocatable :: rho0s,pi0s,prs0s,rth0s
      real, dimension(:,:,:), allocatable :: pi0,rho0,prs0,thv0,th0,qv0
      real, dimension(:,:,:), allocatable :: ql0,rr0,rf0,rrf0,rru0,rrv0,u0,v0
      real, dimension(:,:,:), allocatable :: t0,rh0,qc0
      real, dimension(:,:), allocatable :: zs,gz,dzdx,dzdy
      real, dimension(:,:,:), allocatable :: gx,gy
      real, dimension(:,:,:), allocatable :: rain,sws,svs,sps,srs,sgs,sus,shs
      logical, dimension(:,:), allocatable :: doimpl
      real, dimension(:,:), allocatable :: tsk,thflux,qvflux,cdu,cdv,ce,u1,v1,w1
      real, dimension(:,:), allocatable :: radbcw,radbce
      real, dimension(:,:), allocatable :: radbcs,radbcn
      real, dimension(:,:,:), allocatable :: dum1,dum2,dum3,dum4
      real, dimension(:,:,:), allocatable :: divx,rho,prs
      real, dimension(:,:,:), allocatable :: t11,t12,t13,t22,t23,t33
      real, dimension(:,:,:), allocatable :: rru,ua,u3d,uten,uten1
      real, dimension(:,:,:), allocatable :: rrv,va,v3d,vten,vten1
      real, dimension(:,:,:), allocatable :: rrw,wa,w3d,wten,wten1
      real, dimension(:,:,:), allocatable :: ppi,pp3d,ppten,sten
      real, dimension(:,:,:), allocatable :: tha,th3d,thten,thten1
      real, dimension(:,:,:), allocatable :: thterm,tk
      real, dimension(:,:,:,:), allocatable :: qa,q3d,qten
      real, dimension(:,:,:,:), allocatable :: zvdarray
      real, dimension(:,:,:), allocatable :: kmh,kmv,khh,khv
      real, dimension(:,:,:), allocatable :: tkea,tke3d,tketen
      real, dimension(:,:,:), allocatable :: dissten
      real, dimension(:,:,:), allocatable :: thpten,qvpten,qcpten,qipten,upten,vpten
      real, dimension(:,:,:), allocatable :: swten,lwten,o30
      real, dimension(:,:), allocatable :: radsw,rnflx,radswnet,radlwin
      real, dimension(:,:,:), allocatable :: rad2d
      real, dimension(:), allocatable :: x,y,z,za
      real, dimension(:,:,:), allocatable :: zp
      integer, dimension(:,:), allocatable :: lu_index,kpbl2d
      real, dimension(:,:), allocatable :: psfc,u10,v10,hfx,qfx,xland,znt,ust, &
                                      hpbl,wspd,psim,psih,gz1oz0,br,          &
                                      CHS,CHS2,CQS2,CPMM,ZOL,MAVAIL,          &
                                      MOL,RMOL,REGIME,LH,FLHC,FLQC,QGH,       &
                                      CK,CKA,CD,CDA,USTM,QSFC,T2,Q2,TH2,EMISS,THC,ALBD,   &
                                      f2d,gsw,glw,chklowq,capg,snowc,dsxy
      real, dimension(:), allocatable :: slab_zs,slab_dzs
      real, dimension(:,:,:), allocatable :: tslb
      real, dimension(:,:), allocatable :: tmn,tml,t0ml,hml,h0ml,huml,hvml,tmoml
      real, dimension(:,:,:,:),  allocatable :: pta,pt3d,ptten
      real, dimension(:,:),      allocatable :: pdata
      real, dimension(:,:,:),    allocatable :: cfb
      real, dimension(:),        allocatable :: cfa,cfc,d1,d2
      complex, dimension(:,:,:), allocatable :: pdt,deft
      complex, dimension(:,:),   allocatable :: rhs,trans
#ifdef MICROBURST
      real, dimension(:,:,:), allocatable :: q1mb,q2mb
#endif


!--- arrays for MPI ---
      integer, dimension(:), allocatable :: reqs_u,reqs_v,reqs_w,reqs_s,reqs_p,reqs_tk
      integer, dimension(:,:),  allocatable :: reqs_q,reqs_t
      real, dimension(:,:), allocatable :: ww1,ww2,we1,we2
      real, dimension(:,:), allocatable :: ws1,ws2,wn1,wn2
      real, dimension(:,:), allocatable :: pw1,pw2,pe1,pe2
      real, dimension(:,:), allocatable :: ps1,ps2,pn1,pn2
      real, dimension(:,:), allocatable :: vw1,vw2,ve1,ve2
      real, dimension(:,:), allocatable :: vs1,vs2,vn1,vn2
      real, dimension(:,:,:), allocatable :: uw31,uw32,ue31,ue32
      real, dimension(:,:,:), allocatable :: us31,us32,un31,un32
      real, dimension(:,:,:), allocatable :: vw31,vw32,ve31,ve32
      real, dimension(:,:,:), allocatable :: vs31,vs32,vn31,vn32
      real, dimension(:,:,:), allocatable :: ww31,ww32,we31,we32
      real, dimension(:,:,:), allocatable :: ws31,ws32,wn31,wn32
      real, dimension(:,:,:), allocatable :: sw31,sw32,se31,se32
      real, dimension(:,:,:), allocatable :: ss31,ss32,sn31,sn32
      real, dimension(:,:,:), allocatable :: pw31,pw32,pe31,pe32
      real, dimension(:,:,:), allocatable :: ps31,ps32,pn31,pn32
      real, dimension(:,:,:), allocatable :: tkw1,tkw2,tke1,tke2
      real, dimension(:,:,:), allocatable :: tks1,tks2,tkn1,tkn2
      real, dimension(:,:,:,:), allocatable :: qw1,qw2,qe1,qe2
      real, dimension(:,:,:,:), allocatable :: qs1,qs2,qn1,qn2
      real, dimension(:,:,:,:), allocatable :: tw1,tw2,te1,te2
      real, dimension(:,:,:,:), allocatable :: ts1,ts2,tn1,tn2
      real, dimension(:,:), allocatable :: ploc,packet

!-----

      integer count,rate,maxr
      real rtime,xtime,time_solve
      real steptime1,steptime2
      integer :: i,j,k,n,nn,fnum
#ifdef MPI
      integer rc
      real mp_total
      real*8 tstart,tend
#endif
!ORF only one proc file now, shit to enable that
      integer(HID_T) timings_file_id,plist_id
      integer(HSIZE_T), DIMENSION(1) :: dims,hcount
      integer(HSSIZE_T), DIMENSION(1) :: offset
      character(len=200)  filename
      character(len=120)  description
      character(len=20)   units
      character(len=20)   varname
      integer info
      real, dimension(:), allocatable :: time_solve_full,timbuf
      real time_solve_avg,favg,totpercent
      character(len=109) dircmd
      character(len=4) cid
      character(len=5) ctime

!end ORF

      namelist /param0/ nx,ny,nz,nodex,nodey,timeformat,timestats,terrain_flag

!----------------------------------------------------------------------

      nstep = 0
      mtime = 0.0d0
      nrec=1
      prec=1
      nwrite=1
      nrst=0
      outfile=6
      stopit = .false.
      smeps = 1.0e-30
      tsmall = 0.0001
#ifdef DP
      smeps = 1.0e-60
      tsmall = 0.000000000001
#endif

!----------------------------------------------------------------------
!  Initialize MPI

      myid=0
      numprocs=1

#ifdef MPI
      outfile=10
      call MPI_INIT( ierr )
      call MPI_COMM_RANK( MPI_COMM_WORLD, myid, ierr )
      call MPI_COMM_SIZE( MPI_COMM_WORLD, numprocs, ierr )
#endif

!----------------------------------------------------------------------
!  Get domain dimensions, allocate some arrays, then call PARAM

      open(unit=20,file='namelist.input',form='formatted',status='old',    &
           access='sequential')
      read(20,nml=param0)
      close(unit=20)

      ni = nx / nodex
      nj = ny / nodey
      nk = nz
      nkp1 = nk+1

      ! (The following are needed by ZVD, but are also included for future 
      !  development, e.g., possible distributed-memory decomposition in 
      !  z direction)
      !
      ! number of 'ghost' points in the horizontal directions:
      ngxy  = 3
      ! number of 'ghost' points in the vertical direction:
      ngz   = 1

!---------------------------------------------------------------------
!      For ZVD:
!      ngz   = 3
!      IF( ngz.eq.3 )THEN
!        kb =  1 - ngz
!        ke = nk + ngz
!      ENDIF
!---------------------------------------------------------------------

      ib =  1 - ngxy
      ie = ni + ngxy
      jb =  1 - ngxy
      je = nj + ngxy
      kb =  1 - ngz
      ke = nk + ngz

      allocate(    xh(ib:ie) )
      allocate(   rxh(ib:ie) )
      allocate(    uh(ib:ie) )
      allocate(   ruh(ib:ie) )
      allocate(    xf(ib:ie+1) )
      allocate(   rxf(ib:ie+1) )
      allocate(    uf(ib:ie+1) )
      allocate(   ruf(ib:ie+1) )
      allocate(    yh(jb:je) )
      allocate(    vh(jb:je) )
      allocate(   rvh(jb:je) )
      allocate(    yf(jb:je+1) )
      allocate(    vf(jb:je+1) )
      allocate(   rvf(jb:je+1) )
      allocate( xfref(-2:nx+4) )
      allocate( yfref(-2:ny+4) )
      allocate( sigma(kb:ke) )
      allocate( sigmaf(kb:ke+1) )
      allocate(  tauh(ib:ie,jb:je,kb:ke) )
      allocate(  taus(ib:ie,jb:je,kb:ke) )
      allocate(    zh(ib:ie,jb:je,kb:ke) )
      allocate(    mh(ib:ie,jb:je,kb:ke) )
      allocate(   rmh(ib:ie,jb:je,kb:ke) )
      allocate(  tauf(ib:ie,jb:je,kb:ke+1) )
      allocate(    mf(ib:ie,jb:je,kb:ke+1) )
      allocate(   rmf(ib:ie,jb:je,kb:ke+1) )

      if(terrain_flag)then
        itb=ib
        ite=ie
        jtb=jb
        jte=je
        ktb=kb
        kte=ke
      else
        itb=1
        ite=1
        jtb=1
        jte=1
        ktb=1
        kte=1
      endif

      allocate(   zs(itb:ite,jtb:jte) )
      allocate(   gz(itb:ite,jtb:jte) )
      allocate( dzdx(itb:ite,jtb:jte) )
      allocate( dzdy(itb:ite,jtb:jte) )
      allocate(   gx(itb:ite+1,jtb:jte,ktb:kte) )
      allocate(   gy(itb:ite,jtb:jte+1,ktb:kte) )
      allocate(   zf(ib:ie,jb:je,kb:ke+1) )

      call param(dt,dtlast,stattim,taptim,rsttim,radtim,          &
                 cloudvar,rhovar,qname,budname,                   &
                 xh,rxh,uh,ruh,xf,rxf,uf,ruf,yh,vh,rvh,yf,vf,rvf, &
                 xfref,yfref,                                     &
                 sigma,sigmaf,tauh,taus,zh,mh,rmh,tauf,zf,mf,rmf, &
                 zs,gz,dzdx,dzdy,gx,gy)

!----------------------------------------------------------------------
!  allocate the base state arrays, then call BASE

#ifdef MICROBURST
      allocate(    q1mb(ib:ie,jb:je,kb:ke) )
      allocate(    q2mb(ib:ie,jb:je,kb:ke) )
#endif

      allocate( rstat(stat_out) )
      allocate( rho0s(ib:ie,jb:je) )
      allocate(  pi0s(ib:ie,jb:je) )
      allocate( prs0s(ib:ie,jb:je) )
      allocate( rth0s(ib:ie,jb:je) )
      allocate(  pi0(ib:ie,jb:je,kb:ke) )
      allocate( rho0(ib:ie,jb:je,kb:ke) )
      allocate( prs0(ib:ie,jb:je,kb:ke) )
      allocate( thv0(ib:ie,jb:je,kb:ke) )
      allocate(  th0(ib:ie,jb:je,kb:ke) )
      allocate(  qv0(ib:ie,jb:je,kb:ke) )
      allocate(  ql0(ib:ie,jb:je,kb:ke) )
      allocate(  rr0(ib:ie,jb:je,kb:ke) )
      allocate(  rf0(ib:ie,jb:je,kb:ke) )
      allocate( rrf0(ib:ie,jb:je,kb:ke) )
      allocate( rru0(ib:ie,jb:je,kb:ke) )
      allocate( rrv0(ib:ie,jb:je,kb:ke) )
      allocate(   u0(ib:ie+1,jb:je,kb:ke) )
      allocate(   v0(ib:ie,jb:je+1,kb:ke) )

      allocate(   t0(ib:ie,jb:je,kb:ke) )
      allocate(  rh0(ib:ie,jb:je,kb:ke) )
      allocate(  qc0(ib:ie,jb:je,kb:ke) )

      call base(zh,mh,zf,mf,rho0s,pi0s,prs0s,rth0s,pi0,prs0,rho0,thv0,th0,t0,qv0,u0,v0,rh0,    &
                qc0,ql0,rr0,rf0,rrf0,rru0,rrv0)

!----------------------------------------------------------------------
!  Now, allocate the mother lode, then call INIT3D

      allocate(   rain(ib:ie,jb:je,nrain) )
      allocate(    sws(ib:ie,jb:je,nrain) )
      allocate(    svs(ib:ie,jb:je,nrain) )
      allocate(    sps(ib:ie,jb:je,nrain) )
      allocate(    srs(ib:ie,jb:je,nrain) )
      allocate(    sgs(ib:ie,jb:je,nrain) )
      allocate(    sus(ib:ie,jb:je,nrain) )
      allocate(    shs(ib:ie,jb:je,nrain) )
#ifdef ORFSWATHS
      allocate(    orfswaths(ib:ie,jb:je,nrain,norfswaths) )
#endif
      allocate( doimpl(ib:ie,jb:je) )

      allocate(    tsk(ib:ie,jb:je) )
      allocate( thflux(ib:ie,jb:je) )
      allocate( qvflux(ib:ie,jb:je) )
      allocate(    cdu(ib:ie,jb:je) )
      allocate(    cdv(ib:ie,jb:je) )
      allocate(     ce(ib:ie,jb:je) )
      allocate(     u1(ib:ie,jb:je) )
      allocate(     v1(ib:ie,jb:je) )
      allocate(     w1(ib:ie,jb:je) )

      allocate( radbcw(jb:je,kb:ke) )
      allocate( radbce(jb:je,kb:ke) )
      allocate( radbcs(ib:ie,kb:ke) )
      allocate( radbcn(ib:ie,kb:ke) )

      allocate( dum1(ib:ie,jb:je,kb:ke) )
      allocate( dum2(ib:ie,jb:je,kb:ke) )
      allocate( dum3(ib:ie,jb:je,kb:ke) )
      allocate( dum4(ib:ie,jb:je,kb:ke) )
      allocate( divx(ib:ie,jb:je,kb:ke) )
      allocate(  rho(ib:ie,jb:je,kb:ke) )
      allocate(  prs(ib:ie,jb:je,kb:ke) )
      allocate(  t11(ib:ie,jb:je,kb:ke) )
      allocate(  t12(ib:ie,jb:je,kb:ke) )
      allocate(  t13(ib:ie,jb:je,kb:ke) )
      allocate(  t22(ib:ie,jb:je,kb:ke) )
      allocate(  t23(ib:ie,jb:je,kb:ke) )
      allocate(  t33(ib:ie,jb:je,kb:ke) )

      allocate(   rru(ib:ie+1,jb:je,kb:ke) )
      allocate(    ua(ib:ie+1,jb:je,kb:ke) )
      allocate(   u3d(ib:ie+1,jb:je,kb:ke) )
      allocate(  uten(ib:ie+1,jb:je,kb:ke) )
      allocate( uten1(ib:ie+1,jb:je,kb:ke) )
      allocate(   rrv(ib:ie,jb:je+1,kb:ke) )
      allocate(    va(ib:ie,jb:je+1,kb:ke) )
      allocate(   v3d(ib:ie,jb:je+1,kb:ke) )
      allocate(  vten(ib:ie,jb:je+1,kb:ke) )
      allocate( vten1(ib:ie,jb:je+1,kb:ke) )
      allocate(   rrw(ib:ie,jb:je,kb:ke+1) )
      allocate(    wa(ib:ie,jb:je,kb:ke+1) )
      allocate(   w3d(ib:ie,jb:je,kb:ke+1) )
      allocate(  wten(ib:ie,jb:je,kb:ke+1) )
      allocate( wten1(ib:ie,jb:je,kb:ke+1) )

      allocate(   ppi(ib:ie,jb:je,kb:ke) )
      allocate(  pp3d(ib:ie,jb:je,kb:ke) )
      allocate( ppten(ib:ie,jb:je,kb:ke) )
      allocate(  sten(ib:ie,jb:je,kb:ke) )
      allocate(   tha(ib:ie,jb:je,kb:ke) )
      allocate(  th3d(ib:ie,jb:je,kb:ke) )
      allocate( thten(ib:ie,jb:je,kb:ke) )
      allocate(thten1(ib:ie,jb:je,kb:ke) )
      allocate(thterm(ib:ie,jb:je,kb:ke) )
      allocate(    tk(ib:ie,jb:je,kb:ke) )

      allocate(   bud(nk) )
      allocate(  bud2(nj) )
      allocate( qbudget(nbudget) )
      allocate(    asq(numq) )
      allocate(    bsq(numq) )
      allocate(     qa(ibm:iem,jbm:jem,kbm:kem,numq) )
      allocate(    q3d(ibm:iem,jbm:jem,kbm:kem,numq) )
      allocate(   qten(ibm:iem,jbm:jem,kbm:kem,numq) )
      allocate( zvdarray(ibzvd:iezvd,jbzvd:jezvd,kbzvd:kezvd,nqzvd) )
      allocate(    kmh(ibc:iec,jbc:jec,kbc:kec) )
      allocate(    kmv(ibc:iec,jbc:jec,kbc:kec) )
      allocate(    khh(ibc:iec,jbc:jec,kbc:kec) )
      allocate(    khv(ibc:iec,jbc:jec,kbc:kec) )
      allocate(   tkea(ibt:iet,jbt:jet,kbt:ket) )
      allocate(  tke3d(ibt:iet,jbt:jet,kbt:ket) )
      allocate( tketen(ibt:iet,jbt:jet,kbt:ket) )

      allocate( dissten(ib:ie,jb:je,kb:ke) )

      allocate( thpten(ibb:ieb,jbb:jeb,kbb:keb) )
      allocate( qvpten(ibb:ieb,jbb:jeb,kbb:keb) )
      allocate( qcpten(ibb:ieb,jbb:jeb,kbb:keb) )
      allocate( qipten(ibb:ieb,jbb:jeb,kbb:keb) )
      allocate(  upten(ibb:ieb,jbb:jeb,kbb:keb) )
      allocate(  vpten(ibb:ieb,jbb:jeb,kbb:keb) )

      allocate( swten(ibr:ier,jbr:jer,kbr:ker) )
      allocate( lwten(ibr:ier,jbr:jer,kbr:ker) )
      allocate(   o30(ibr:ier,jbr:jer,kbr:ker) )

      nir = 1
      njr = 1
      nkr = nk+3

      IF( radopt .eq. 1 )THEN
        rbufsz = n2d_radiat*nir*njr + n3d_radiat*nir*njr*nkr
      ELSE
        rbufsz = 1
      ENDIF

      allocate(    rad2d(ni,nj,nrad2d) )
      allocate(    radsw(ni,nj) )
      allocate(    rnflx(ni,nj) )
      allocate( radswnet(ni,nj) )
      allocate(  radlwin(ni,nj) )

      rad2d = 0.0
      radsw = 0.0
      rnflx = 0.0
      radswnet = 0.0
      radlwin = 0.0

      if(myid.eq.0)write(outfile,*) '  rbufsz,nrad2d = ',rbufsz,nrad2d

      allocate( x(ni+1) )
      allocate( y(nj+1) )
      allocate( z(nk+3) )
      allocate( za(nk+3) )
      allocate( zp(ni,nj,nk+3) )

      allocate( lu_index(ibl:iel,jbl:jel) )
      allocate(   kpbl2d(ibl:iel,jbl:jel) )
      allocate(     psfc(ibl:iel,jbl:jel) )
      allocate(      u10(ibl:iel,jbl:jel) )
      allocate(      v10(ibl:iel,jbl:jel) )
      allocate(      hfx(ibl:iel,jbl:jel) )
      allocate(      qfx(ibl:iel,jbl:jel) )
      allocate(    xland(ibl:iel,jbl:jel) )
      allocate(      znt(ibl:iel,jbl:jel) )
      allocate(      ust(ibl:iel,jbl:jel) )
      allocate(     hpbl(ibl:iel,jbl:jel) )
      allocate(     wspd(ibl:iel,jbl:jel) )
      allocate(     psim(ibl:iel,jbl:jel) )
      allocate(     psih(ibl:iel,jbl:jel) )
      allocate(   gz1oz0(ibl:iel,jbl:jel) )
      allocate(       br(ibl:iel,jbl:jel) )
      allocate(      chs(ibl:iel,jbl:jel) )
      allocate(     chs2(ibl:iel,jbl:jel) )
      allocate(     cqs2(ibl:iel,jbl:jel) )
      allocate(     cpmm(ibl:iel,jbl:jel) )
      allocate(      zol(ibl:iel,jbl:jel) )
      allocate(   mavail(ibl:iel,jbl:jel) )
      allocate(      mol(ibl:iel,jbl:jel) )
      allocate(     rmol(ibl:iel,jbl:jel) )
      allocate(   regime(ibl:iel,jbl:jel) )
      allocate(       lh(ibl:iel,jbl:jel) )
      allocate(     flhc(ibl:iel,jbl:jel) )
      allocate(     flqc(ibl:iel,jbl:jel) )
      allocate(      qgh(ibl:iel,jbl:jel) )
      allocate(       ck(ibl:iel,jbl:jel) )
      allocate(      cka(ibl:iel,jbl:jel) )
      allocate(       cd(ibl:iel,jbl:jel) )
      allocate(      cda(ibl:iel,jbl:jel) )
      allocate(     ustm(ibl:iel,jbl:jel) )
      allocate(     qsfc(ibl:iel,jbl:jel) )
      allocate(       t2(ibl:iel,jbl:jel) )
      allocate(       q2(ibl:iel,jbl:jel) )
      allocate(      th2(ibl:iel,jbl:jel) )
      allocate(    emiss(ibl:iel,jbl:jel) )
      allocate(      thc(ibl:iel,jbl:jel) )
      allocate(     albd(ibl:iel,jbl:jel) )
      allocate(      f2d(ibl:iel,jbl:jel) )
      allocate(      gsw(ibl:iel,jbl:jel) )
      allocate(      glw(ibl:iel,jbl:jel) )
      allocate(  chklowq(ibl:iel,jbl:jel) )
      allocate(     capg(ibl:iel,jbl:jel) )
      allocate(    snowc(ibl:iel,jbl:jel) )
      allocate(     dsxy(ibl:iel,jbl:jel) )

      ! start with very small, but non-zero, numbers:
      znt = 1.0e-6
      ust = 1.0e-6

      ! start assuming neutral sfclayer:
      mol = 0.0
      zol = 0.0

      num_soil_layers = 5
      allocate(  slab_zs(num_soil_layers) )
      allocate( slab_dzs(num_soil_layers) )
      allocate(  tslb(ibl:iel,jbl:jel,num_soil_layers) )
      allocate(   tmn(ibl:iel,jbl:jel) )

      ! arrays for oml model:
      allocate(   tml(ibl:iel,jbl:jel) )
      allocate(  t0ml(ibl:iel,jbl:jel) )
      allocate(   hml(ibl:iel,jbl:jel) )
      allocate(  h0ml(ibl:iel,jbl:jel) )
      allocate(  huml(ibl:iel,jbl:jel) )
      allocate(  hvml(ibl:iel,jbl:jel) )
      allocate( tmoml(ibl:iel,jbl:jel) )

      allocate(    pta(ibp:iep,jbp:jep,kbp:kep,npt) )
      allocate(   pt3d(ibp:iep,jbp:jep,kbp:kep,npt) )
      allocate(  ptten(ibp:iep,jbp:jep,kbp:kep,npt) )

      allocate(  pdata(npvals,nparcels) )

      allocate(    cfb(ipb:ipe,jpb:jpe,kpb:kpe) )
      allocate(    cfa(kpb:kpe) )
      allocate(    cfc(kpb:kpe) )
      allocate(     d1(kpb:kpe) )
      allocate(     d2(kpb:kpe) )
      allocate(    pdt(ipb:ipe,jpb:jpe,kpb:kpe) )
      allocate(   deft(ipb:ipe,jpb:jpe,kpb:kpe) )
      allocate(    rhs(ipb:ipe,jpb:jpe) )
      allocate(  trans(ipb:ipe,jpb:jpe) )

      call init3d(num_soil_layers,qbudget,asq,bsq,                  &
                  xh,rxh,uh,ruh,xf,rxf,uf,ruf,yh,vh,rvh,yf,vf,rvf,  &
                  xfref,yfref,                                      &
                  zh,mh,rmh,zf,mf,rmf,rho0s,pi0s,prs0s,pi0,prs0,rho0,thv0,th0,t0,qv0,   &
                  u0,v0,rh0,qc0,ql0,rr0,rf0,rrf0,                   &
                  zs,gz,rain,sws,svs,sps,srs,sgs,sus,shs, &
                  thflux,qvflux,cdu,cdv,ce,    &
                  radbcw,radbce,radbcs,radbcn,                      &
                  dum1,dum2,dum3,dum4,divx,rho,prs,                 &
                  t11,t12,t13,t22,t23,t33,                          &
                  rru,ua,u3d,uten,uten1,rrv,va,v3d,vten,vten1,      &
                  rrw,wa,w3d,wten,wten1,ppi,pp3d,ppten,sten,        &
                  tha,th3d,thten,thten1,thterm,tk,qa,q3d,qten,      &
                  kmh,kmv,khh,khv,tkea,tke3d,tketen,                &
                  pta,pt3d,ptten,                                   &
#ifdef MICROBURST
                  q1mb,q2mb, &
#endif
                  pdata,cfb,cfa,cfc,d1,d2,pdt,deft,rhs,trans)



! ORF initialize control file
      if (myid.eq.0)then
            call reset_control_file
      endif

!     if (myid.eq.0)then
!           inquire(FILE="cm1control.txt", EXIST=control_file_exists)
!           if (control_file_exists) then
!                 call read_control_file
!           else
!                 call reset_control_file
!           endif
!     endif

!----------------------------------------------------------------------
!  Now, allocate the MPI arrays (if necessary)

      deallocate( t0 )
      deallocate( rh0 )
!!!      deallocate( qc0 )
      if(ibalance.eq.2 .and.  psolver.ne.4.and.psolver.ne.5 )then
        deallocate( cfb )
        deallocate( cfa )
        deallocate( cfc )
        deallocate( d1 )
        deallocate( d2 )
        deallocate( pdt )
        deallocate( deft )
        deallocate( rhs )
        deallocate( trans )
      endif

#ifdef MPI
      imp = max(1,ni)
      jmp = max(1,nj)
      kmp = max(2,nk)
      kmt = max(2,nk+1)
      rmp = 8
      cmp = 3
#else
      imp = 1
      jmp = 1
      kmp = 2
      rmp = 1
      cmp = 1
#endif
      allocate( reqs_u(rmp) )
      allocate( reqs_v(rmp) )
      allocate( reqs_w(rmp) )
      allocate( reqs_s(rmp) )
      allocate( reqs_p(rmp) )
      allocate( reqs_tk(rmp) )
      allocate( reqs_q(rmp,numq) )
      allocate( reqs_t(rmp,npt) )

      allocate( ww1(jmp,kmp-1) )
      allocate( ww2(jmp,kmp-1) )
      allocate( we1(jmp,kmp-1) )
      allocate( we2(jmp,kmp-1) )
      allocate( ws1(imp,kmp-1) )
      allocate( ws2(imp,kmp-1) )
      allocate( wn1(imp,kmp-1) )
      allocate( wn2(imp,kmp-1) )

      allocate( pw1(jmp,kmp) )
      allocate( pw2(jmp,kmp) )
      allocate( pe1(jmp,kmp) )
      allocate( pe2(jmp,kmp) )
      allocate( ps1(imp,kmp) )
      allocate( ps2(imp,kmp) )
      allocate( pn1(imp,kmp) )
      allocate( pn2(imp,kmp) )

      allocate( vw1(jmp,kmp) )
      allocate( vw2(jmp,kmp) )
      allocate( ve1(jmp,kmp) )
      allocate( ve2(jmp,kmp) )
      allocate( vs1(imp,kmp) )
      allocate( vs2(imp,kmp) )
      allocate( vn1(imp,kmp) )
      allocate( vn2(imp,kmp) )

      allocate( uw31(cmp,jmp,kmp) )
      allocate( uw32(cmp,jmp,kmp) )
      allocate( ue31(cmp,jmp,kmp) )
      allocate( ue32(cmp,jmp,kmp) )
      allocate( us31(imp+1,cmp,kmp) )
      allocate( us32(imp+1,cmp,kmp) )
      allocate( un31(imp+1,cmp,kmp) )
      allocate( un32(imp+1,cmp,kmp) )

      allocate( vw31(cmp,jmp+1,kmp) )
      allocate( vw32(cmp,jmp+1,kmp) )
      allocate( ve31(cmp,jmp+1,kmp) )
      allocate( ve32(cmp,jmp+1,kmp) )
      allocate( vs31(imp,cmp,kmp) )
      allocate( vs32(imp,cmp,kmp) )
      allocate( vn31(imp,cmp,kmp) )
      allocate( vn32(imp,cmp,kmp) )

      allocate( ww31(cmp,jmp,kmp-1) )
      allocate( ww32(cmp,jmp,kmp-1) )
      allocate( we31(cmp,jmp,kmp-1) )
      allocate( we32(cmp,jmp,kmp-1) )
      allocate( ws31(imp,cmp,kmp-1) )
      allocate( ws32(imp,cmp,kmp-1) )
      allocate( wn31(imp,cmp,kmp-1) )
      allocate( wn32(imp,cmp,kmp-1) )

      allocate( sw31(cmp,jmp,kmp) )
      allocate( sw32(cmp,jmp,kmp) )
      allocate( se31(cmp,jmp,kmp) )
      allocate( se32(cmp,jmp,kmp) )
      allocate( ss31(imp,cmp,kmp) )
      allocate( ss32(imp,cmp,kmp) )
      allocate( sn31(imp,cmp,kmp) )
      allocate( sn32(imp,cmp,kmp) )

      allocate( pw31(cmp,jmp,kmp) )
      allocate( pw32(cmp,jmp,kmp) )
      allocate( pe31(cmp,jmp,kmp) )
      allocate( pe32(cmp,jmp,kmp) )
      allocate( ps31(imp,cmp,kmp) )
      allocate( ps32(imp,cmp,kmp) )
      allocate( pn31(imp,cmp,kmp) )
      allocate( pn32(imp,cmp,kmp) )

      allocate( tkw1(cmp,jmp,kmt) )
      allocate( tkw2(cmp,jmp,kmt) )
      allocate( tke1(cmp,jmp,kmt) )
      allocate( tke2(cmp,jmp,kmt) )
      allocate( tks1(imp,cmp,kmt) )
      allocate( tks2(imp,cmp,kmt) )
      allocate( tkn1(imp,cmp,kmt) )
      allocate( tkn2(imp,cmp,kmt) )

      allocate( qw1(cmp,jmp,kmp,numq) )
      allocate( qw2(cmp,jmp,kmp,numq) )
      allocate( qe1(cmp,jmp,kmp,numq) )
      allocate( qe2(cmp,jmp,kmp,numq) )
      allocate( qs1(imp,cmp,kmp,numq) )
      allocate( qs2(imp,cmp,kmp,numq) )
      allocate( qn1(imp,cmp,kmp,numq) )
      allocate( qn2(imp,cmp,kmp,numq) )

      allocate( tw1(cmp,jmp,kmp,npt) )
      allocate( tw2(cmp,jmp,kmp,npt) )
      allocate( te1(cmp,jmp,kmp,npt) )
      allocate( te2(cmp,jmp,kmp,npt) )
      allocate( ts1(imp,cmp,kmp,npt) )
      allocate( ts2(imp,cmp,kmp,npt) )
      allocate( tn1(imp,cmp,kmp,npt) )
      allocate( tn2(imp,cmp,kmp,npt) )

      allocate(          ploc(3,nparcels) )
      allocate( packet(npvals+1,nparcels) )

!----------------------------------------------------------------------

      call setup_output(tdef,qname,budname,xh,xf,yh,yf,xfref,yfref,zh,zf)

      call init_physics(prs0,rf0,cdu,cdv,ce,dum1,dum2,dum3,u0,ua,v0,va,o30,   &
                             lu_index,xland,emiss,thc,albd,znt,mavail,f2d,tsk,u1,v1,w1)

      call init_surface(num_soil_layers,   &
                        dodrag,dosfcflx,xh,ruh,xf,yh,rvh,yf,   &
                        lu_index,xland,tsk,slab_zs,slab_dzs,tslb, &
                        emiss,thc,albd,znt,mavail,dsxy,prs0s,prs0,   &
                        tmn,tml,t0ml,hml,h0ml,huml,hvml,tmoml)
! ORF TODO: add orfswaths to restart files
      if(irst.eq.1)then
        call read_restart(nstep,nrec,prec,nwrite,nrst,nrad2d,num_soil_layers, &
                              stattim,taptim,rsttim,  &
                              dt,mtime,radtim,qbudget,asq,bsq,              &
                              rain,sws,svs,sps,srs,sgs,sus,shs,tsk,radbcw,radbce,radbcs,radbcn,  &
                              ua,va,wa,ppi,tha,qa,tkea,swten,lwten,   &
                              radsw,rnflx,radswnet,radlwin,rad2d,   &
                               lu_index,kpbl2d,psfc,u10,v10,hfx,qfx,xland,znt,ust, &
                               hpbl,wspd,psim,psih,gz1oz0,br,                      &
                               CHS,CHS2,CQS2,CPMM,ZOL,MAVAIL,                      &
                               MOL,RMOL,REGIME,LH,FLHC,FLQC,QGH,                   &
                               CK,CKA,CD,CDA,USTM,QSFC,T2,Q2,TH2,EMISS,THC,ALBD,   &
                               f2d,gsw,glw,chklowq,capg,snowc,tslb,                &
                               tmn,tml,t0ml,hml,h0ml,huml,hvml,tmoml,              &
                              pta,pdata,rtime)
        dtlast = 0.0
      endif

      call getset(dzdx,dzdy,pi0,th0,rho0,prs0,rho,prs,                &
                  ua,u3d,va,v3d,wa,w3d,ppi,pp3d,                      &
                  tha,th3d,qa,q3d,tkea,tke3d,pta,pt3d,                &
                  reqs_u,reqs_v,reqs_w,reqs_s,reqs_tk,                &
                  uw31,uw32,ue31,ue32,us31,us32,un31,un32,            &
                  vw31,vw32,ve31,ve32,vs31,vs32,vn31,vn32,            &
                  ww31,ww32,we31,we32,ws31,ws32,wn31,wn32,            &
                  sw31,sw32,se31,se32,ss31,ss32,sn31,sn32,            &
                  tkw1,tkw2,tke1,tke2,tks1,tks2,tkn1,tkn2)

!----------------------------------------------------------------------
!  All done with initialization.  A few more odds and ends ....

      if( adapt_dt.eq.1 )then
        call calccfl(1,rstat,dt,acfl,uf,vf,mf,ua,va,wa,0)
        ndt = 1
        adt = dt
        acfl = cflmax
      endif

      if(irst.ne.1)then
            if(myid.eq.0)then
              write(outfile,*)
              write(outfile,*) '  initial conditions:'
              write(outfile,*)
            endif
      endif

      IF(axisymm.eq.0)THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ppten(i,j,k)=rho(i,j,k)
        enddo
        enddo
        enddo
      ELSE
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ppten(i,j,k) = rho(i,j,k)*pi*(xf(i+1)**2-xf(i)**2)/(dx*dy)
        enddo
        enddo
        enddo
      ENDIF
      rtime=sngl(mtime)
     call statpack(nrec,ndt,dt,rtime,adt,acfl,cloudvar,qname,budname,qbudget,asq,bsq, &
                   xh,rxh,uh,ruh,xf,uf,yh,vh,rvh,vf,zh,mh,rmh,mf,     &
                   rstat,pi0,rho0,thv0,th0,qv0,u0,v0,                 &
                   dum1,dum2,dum3,dum4,divx,ppten,prs,                &
                   ua,va,wa,ppi,tha,qa,qten,kmh,kmv,khh,khv,tkea,pta,u10,v10)

    if(irst.ne.1)then
      IF(output_format.eq.1)THEN
        sten = 0.0
        nn = 1
        if(terrain_flag .and. output_interp.eq.1) nn = 2
        DO n=1,nn
          if(n.eq.1)then
            fnum = 51
          else
            fnum = 71
          endif
! ORF temporarily disable all output for bd testing
#ifdef EATPOO
          call writeout(fnum,1,qname,xh,xf,uf,vf,sigma,zh,zf,mf,pi0,prs0,rho0,th0,qv0,u0,v0,   &
                      zs,rain,sws,svs,sps,srs,sgs,sus,shs,thflux,qvflux,cdu,cdv,ce,dum1,dum2,dum3,dum4, &
                      rho,prs,sten,ua,uten,va,vten,wa,wten,ppi,tha,      &
                   dissten,thpten,qvpten,qcpten,qipten,upten,vpten,           &
                      lu_index,xland,mavail,tsk,tmn,tml,hml,huml,hvml,hfx,qfx,gsw,glw,tslb,     &
                      qa,kmh,kmv,khh,khv,tkea,swten,lwten,radsw,rnflx,radswnet,radlwin,pta,   &
                      num_soil_layers,u10,v10,t2,q2,znt,ust,hpbl,zol,mol,br)
#endif
        ENDDO
#ifdef NETCDF
      ELSEIF(output_format.eq.2)THEN
        sten = 0.0
        call writeout_cdf(nwrite,qname,sigma,sigmaf,xh,xf,uf,yh,yf,vf,mh,zh,mf,zf, &
                      pi0,prs0,rho0,th0,qv0,u0,v0,                     &
                      zs,rain,sws,svs,sps,srs,sgs,sus,shs,thflux,qvflux,cdu,cdv,ce,dum1,dum2,dum3,dum4,  &
                      rho,prs,sten,ua,uten,va,vten,wa,wten,ppi,tha,    &
                      qa,kmh,kmv,khh,khv,tkea,pta,num_soil_layers,   &
                      lu_index,xland,mavail,tsk,tmn,tml,hml,huml,hvml,hfx,qfx,gsw,glw,tslb,   &
                      radsw,rnflx,radswnet,radlwin,u10,v10,t2,q2,znt,ust,hpbl,zol,mol,br,   &
                      dissten,thpten,qvpten,qcpten,qipten,upten,vpten,swten,lwten)
#endif
#ifdef HDFOUT
      ELSEIF(output_format.ge.3)THEN
       sten = 0.0
       wr3d = .true.  ! do write 3d initial fields
       wr2d = .false. ! don't write 2d initial fields

!Make directory that holds files
      if (wr2d .or. wr3d) then
        if (len_trim(output_path) .eq. 0) then
              if(myid.eq.0)then
                 write(outfile,*) 'empty output_path'
                 write(outfile,*) 'defaulting to current working directory'
              endif
              output_path='.'
        endif
        write(ctime,102)int(rtime)
        write(cid,103)ioid
102     format(i5.5)
103     format(i4.4)
        filedir = trim(output_path)//'/'//trim(output_basename)//'.'//ctime//'.cdir/'
        dircmd = 'mkdir -p '// trim(filedir)
        if (myid.eq.0) call system(dircmd)
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
     endif

        call writeout_mult_hdf5(0.0,qname,sigma,sigmaf,xh,xf,uf,yh,yf,vf,mh,zh,mf,zf, &
                      pi0,prs0,rho0,th0,thv0,qv0,u0,v0,                     &
                      zs,rain,sws,svs,sps,srs,sgs,sus,shs, &
                      thflux,qvflux,cdu,cdv,ce,dum1,dum2,dum3,dum4,  &
                      rho,prs,sten,ua,uten,va,vten,wa,wten,ppi,tha,    &
                      qa,kmh,kmv,khh,khv,tkea,pta,num_soil_layers,   &
                      lu_index,xland,mavail,tsk,tmn,tml,hml,huml,hvml,hfx,qfx,gsw,glw,tslb,   &
                      radsw,rnflx,radswnet,radlwin,u10,v10,t2,q2,znt,ust,hpbl,zol,mol,br,   &
                      dissten,thpten,qvpten,qcpten,qipten,upten,vpten,swten,lwten)
#endif
      ENDIF
    endif


      rtime=sngl(mtime)
      if(myid.eq.0)then
        if(timeformat.eq.1)then
          write(6,110) nstep,rtime,' sec '
        elseif(timeformat.eq.2)then
          write(6,110) nstep,rtime/60.0,' min '
        elseif(timeformat.eq.3)then
          write(6,110) nstep,rtime/3600.0,' hour'
        elseif(timeformat.eq.4)then
          write(6,110) nstep,rtime/86400.0,' day '
        else
          write(6,110) nstep,rtime,' sec'
        endif
110     format(2x,i12,4x,f18.6,a5)
      endif

      if(myid.eq.0)then
            write(outfile,*)
            write(outfile,*) '-------------Done with Preprocessors-----------'
            write(outfile,*)
      endif

      if(iconly.eq.1)then
          if(myid.eq.0)then
              write(outfile,*)
              write(outfile,*) '  User has requested initial conditions only'
              write(outfile,*) '     (iconly = 1)'
              write(outfile,*) '  ... stopping ... '
              write(outfile,*)
          endif
#ifdef MPI
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif
        stop 55555
      endif

!----------------------------------------------------------------------

      time_sound=0.
      time_poiss=0.
      time_advs=0.
      time_advu=0.
      time_advv=0.
      time_advw=0.
      time_buoyan=0.
      time_turb=0.
      time_diffu=0.
      time_microphy=0.
      time_stat=0.
      time_bc=0.
      time_misc=0.
      time_integ=0.
      time_rdamp=0.
      time_divx=0.
      time_write=0.
      time_tmix=0.
      time_cor=0.
      time_fall=0.
      time_satadj=0.
      time_sfcphys=0.
      time_parcels=0.0
      time_rad=0.
      time_pbl=0.
      time_swath=0.
      time_pdef=0.
#ifdef MPI
      time_mpu1=0.
      time_mpv1=0.
      time_mpw1=0.
      time_mpp1=0.
      time_mpu2=0.
      time_mpv2=0.
      time_mpw2=0.
      time_mpp2=0.
      time_mps1=0.
      time_mpq1=0.
      time_mptk1=0.
      time_mptk2=0.
      time_mps2=0.
      time_mpq2=0.
      time_mpb=0.

    call MPI_BARRIER (MPI_COMM_WORLD,ierr)

      if(myid.eq.0)then
        tstart=mpi_wtime()
      endif
#endif

      ! This initializes timer
      if(timestats.ge.1)then
        call system_clock(count,rate,maxr)
        clock_rate=1.0/rate
        xtime=mytime()
      endif

!----------------------------------------------------------------------
!  Time loop

      if(timestats.ge.1)then
        steptime1 = 0.0
        steptime2 = 0.0
      endif

!   print *, "ORF: Just before solve call in cm1, myid = ",myid
      do while( mtime.lt.timax )
        nstep = nstep + 1


! ORF read in control file
      if(myid.eq.0) then
            call read_control_file
            call reset_control_file
      endif

      call MPI_BCAST(ctrldropslice,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(ctrldrophist,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(ctrldroprestart,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(ctrlexit,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)


        call solve(nstep,nrec,prec,nwrite,nrst,rbufsz,num_soil_layers,ndt,     &
                   dt,dtlast,mtime,stattim,taptim,rsttim,radtim,adt,acfl,  &
                   dodrag,dosfcflx,cloudvar,rhovar,qname,budname,bud,bud2,qbudget,asq,bsq, &
                   xh,rxh,uh,ruh,xf,rxf,uf,ruf,yh,vh,rvh,yf,vf,rvf,   &
                   sigma,sigmaf,tauh,taus,zh,mh,rmh,tauf,zf,mf,rmf,   &
                   rstat,rho0s,pi0s,prs0s,rth0s,pi0,rho0,prs0,thv0,th0,qv0,qc0,  &
                   ql0,rr0,rf0,rrf0,rru0,rrv0,                        &
                   zs,gz,dzdx,dzdy,rain,sws,svs,sps,srs,sgs,sus,shs,  &
                   doimpl,tsk,thflux,qvflux,cdu,cdv,ce,u1,v1,w1,      &
                   radbcw,radbce,radbcs,radbcn,                       &
                   dum1,dum2,dum3,dum4,divx,rho,prs,                  &
                   t11,t12,t13,t22,t23,t33,                           &
                   gx,u0,rru,ua,u3d,uten,uten1,                       &
                   gy,v0,rrv,va,v3d,vten,vten1,                       &
                   rrw,wa,w3d,wten,wten1,ppi,pp3d,ppten,sten,         &
                   tha,th3d,thten,thten1,thterm,tk,qa,q3d,qten,zvdarray, &
                   kmh,kmv,khh,khv,tkea,tke3d,tketen,                 &
                   dissten,thpten,qvpten,qcpten,qipten,upten,vpten,   &
                   swten,lwten,o30,radsw,rnflx,radswnet,radlwin,rad2d, &
                   x,y,z,za,zp,                                       &
                   lu_index,kpbl2d,psfc,u10,v10,hfx,qfx,xland,znt,ust,   &
                   hpbl,wspd,psim,psih,gz1oz0,br,                     &
                   CHS,CHS2,CQS2,CPMM,ZOL,MAVAIL,                     &
                   MOL,RMOL,REGIME,LH,FLHC,FLQC,QGH,                  &
                   CK,CKA,CD,CDA,USTM,QSFC,T2,Q2,TH2,EMISS,THC,ALBD,  &
                   f2d,gsw,glw,chklowq,capg,snowc,dsxy,               &
                   slab_zs,slab_dzs,tslb,tmn,tml,t0ml,hml,h0ml,huml,hvml,tmoml,        &
                   pta,pt3d,ptten,                                    &
#ifdef MICROBURST
                   q1mb,q2mb, &
#endif
                   pdata,cfb,cfa,cfc,d1,d2,pdt,deft,rhs,trans,        &
                   reqs_u,reqs_v,reqs_w,reqs_s,reqs_p,reqs_tk,reqs_q,reqs_t, &
                   ww1,ww2,we1,we2,ws1,ws2,wn1,wn2,                  &
                   pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,                  &
                   vw1,vw2,ve1,ve2,vs1,vs2,vn1,vn2,                  &
                   uw31,uw32,ue31,ue32,us31,us32,un31,un32,          &
                   vw31,vw32,ve31,ve32,vs31,vs32,vn31,vn32,          &
                   ww31,ww32,we31,we32,ws31,ws32,wn31,wn32,          &
                   sw31,sw32,se31,se32,ss31,ss32,sn31,sn32,          &
                   pw31,pw32,pe31,pe32,ps31,ps32,pn31,pn32,          &
                   tkw1,tkw2,tke1,tke2,tks1,tks2,tkn1,tkn2,          &
                   qw1,qw2,qe1,qe2,qs1,qs2,qn1,qn2,                  &
                   tw1,tw2,te1,te2,ts1,ts2,tn1,tn2,ploc,packet)
        if(timestats.eq.2)then
          steptime2=time_sound+time_poiss+time_buoyan+time_turb+            &
                    time_diffu+time_microphy+time_stat+                     &
                    time_bc+time_misc+time_integ+time_rdamp+time_divx+      &
                    time_write+time_tmix+time_cor+time_fall+                &
                    time_satadj+time_sfcphys+time_parcels+                  &
                    time_rad+time_pbl+time_swath+time_pdef+                 &
#ifdef MPI
                    time_mpu1+time_mpv1+time_mpw1+time_mpp1+                &
                    time_mpu2+time_mpv2+time_mpw2+time_mpp2+                &
                    time_mps1+time_mpq1+time_mptk1+                         &
                    time_mps2+time_mpq2+time_mptk2+time_mpb+                &
#endif
                    time_advs+time_advu+time_advv+time_advw
          write(6,157) nstep,steptime2-steptime1
157       format('    timing for time step ',i12,':',f12.4,' s')
          steptime1 = steptime2
        endif
! ORF cheap and dirty way to get model to finish
      if (ctrlexit.eq.1) then
            mtime = 999999.0
            if (myid.eq.0)print *, "Control file tells us to exit, we are breaking out of time loop."
      endif
      enddo

!----------------------------------------------------------------------
!  write new stats descriptor file, if necessary:

      IF( output_format.eq.1 .and. myid.eq.0 )THEN
        IF( adapt_dt.eq.1 .and. statfrq.lt.0.0 )THEN
          print *,'  re-writing GrADS stats descriptor file .... '
          call write_statsctl(tdef,qname,budname,nstep+1)
        ENDIF
      ENDIF

!----------------------------------------------------------------------

#ifdef MPI
      call MPI_BARRIER (MPI_COMM_WORLD,ierr)
      if(timestats.ge.1) time_mpb=time_mpb+mytime()

      if(myid.eq.0)then
        tend=mpi_wtime()
        print *
        print *,'Total time (s): ',tend-tstart
        print *
      endif

#endif
!----------------------------------------------------------------------

    IF(timestats.ge.1)THEN

      time_solve=time_sound+time_poiss+time_buoyan+time_turb+             &
                  time_diffu+time_microphy+time_stat+                     &
                  time_bc+time_misc+time_integ+time_rdamp+time_divx+      &
                  time_write+time_tmix+time_cor+time_fall+                &
                  time_satadj+time_sfcphys+time_parcels+                  &
                  time_rad+time_pbl+time_swath+time_pdef+                 &
#ifdef MPI
                  time_mpu1+time_mpv1+time_mpw1+time_mpp1+                &
                  time_mpu2+time_mpv2+time_mpw2+time_mpp2+                &
                  time_mps1+time_mpq1+time_mptk1+                         &
                  time_mps2+time_mpq2+time_mptk2+time_mpb+                &
#endif
                  time_advs+time_advu+time_advv+time_advw

#ifdef MPI
      mp_total=time_mpu1+time_mpv1+time_mpw1+time_mpp1+                   &
               time_mpu2+time_mpv2+time_mpw2+time_mpp2+                   &
               time_mps1+time_mpq1+time_mptk1+                            &
               time_mps2+time_mpq2+time_mptk2+time_mpb
#endif

      call MPI_REDUCE(time_solve,time_solve_avg,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
      time_solve_avg = time_solve_avg/numprocs

      if(myid.eq.0)then
            write(outfile,*)
            write(outfile,*) 'Total time (averaged): ',time_solve_avg
            write(outfile,*)
      endif

      time_solve=0.01*time_solve
      if(time_solve.lt.0.0001) time_solve=1.

! ORF
! ARGH... we don't need the timings file to be accessed in parallel;
! however, in order to use the existing h5_write_1d_float routine, we
! make it parallel, and pass rootonlyrank to it.

      filename = trim(output_basename)//'_timings.hdf5'
      call h5open_f (ierr)

      CALL h5pcreate_f(H5P_FILE_ACCESS_F, plist_id, ierr)
      info = MPI_INFO_NULL !WTF?
      CALL h5pset_fapl_mpio_f(plist_id, MPI_COMM_WORLD, info, ierr)
      call h5fcreate_f(trim(filename),H5F_ACC_TRUNC_F,timings_file_id,ierr,access_prp=plist_id)
      CALL h5pclose_f(plist_id, ierr)

      dims(1)=numprocs; hcount(1)=numprocs; offset(1)=0

      allocate ( timbuf(numprocs) )
      allocate ( time_solve_full(numprocs) )

      call MPI_GATHER(time_solve,1,MPI_REAL,time_solve_full,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_solve'; description='Time to solve'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,time_solve_full,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_sound,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_sound'; description='Time for sound'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_poiss,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_poiss'; description='Time for poiss'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_advs,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_advs'; description='Time for advs'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_advu,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_advu'; description='Time for advu'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_advv,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_advv'; description='Time for advv'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_advw,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_advw'; description='Time for advw'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_divx,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_divx'; description='Time for divx'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_buoyan,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_buoyan'; description='Time for buoyan'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_turb,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_turb'; description='Time for turb'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_sfcphys,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_sfcphys'; description='Time for sfcphys'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_tmix,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_tmix'; description='Time for tmix'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_cor,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_cor'; description='Time for cor'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_diffu,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_diffu'; description='Time for diffu'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_rdamp,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_rdamp'; description='Time for rdamp'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_microphy,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_microphy'; description='Time for microphy'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_satadj,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_satadj'; description='Time for satadj'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_fall,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_fall'; description='Time for fallout'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_rad,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_rad'; description='Time for radiation'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_pbl,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_pbl'; description='Time for pbl'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_stat,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_stat'; description='Time for stat'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_bc,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_bc'; description='Time for bc'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_integ,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_integ'; description='Time for integ'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_write,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_write'; description='Time for write'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_misc,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_misc'; description='Time for misc'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_swath,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_swath'; description='Time for swaths'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_pdef,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_pdef'; description='Time for pdef'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_parcels,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_parcels'; description='Time for parcels'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(mp_total,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='mp_total'; description='Time for mp_total'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_mpu1,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_mpu1'; description='Time for mpu1'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_mpv1,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_mpv1'; description='Time for mpv1'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_mpw1,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_mpw1'; description='Time for mpw1'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_mpp1,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_mpp1'; description='Time for mpp1'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_mpu2,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_mpu2'; description='Time for mpu2'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_mpv2,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_mpv2'; description='Time for mpv2'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_mpw2,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_mpw2'; description='Time for mpw2'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_mpp2,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_mpp2'; description='Time for mpp2'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_mps1,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_mps1'; description='Time for mps1'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_mpq1,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_mpq1'; description='Time for mpq1'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_mps2,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_mps2'; description='Time for mps2'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_mpq2,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_mpq2'; description='Time for mpq2'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_mptk1,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_mptk1'; description='Time for mptk1'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_mptk2,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_mptk2'; description='Time for mptk2'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      call MPI_GATHER(time_mpb,1,MPI_REAL,timbuf,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      varname='time_mpb'; description='Time for mpb'; units='seconds'
      call h5_write_1d_float(timings_file_id,varname,description,units,timbuf,numprocs,dims,hcount,offset,rootonlyrank)

      if(myid.eq.0) call h5fclose_f(timings_file_id,ierr)
      call h5close_f(ierr)

! ORF We output averaged values of all timings to the procfile

      time_solve_avg = 0.01 * time_solve_avg ! for percent, not fraction
      totpercent=0.0
      call MPI_REDUCE(time_sound,favg,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
      favg = favg/numprocs
      if(myid.eq.0)write(outfile,100) 'sound   ',favg,favg/time_solve_avg
      totpercent = totpercent +favg/time_solve_avg

      call MPI_REDUCE(time_poiss,favg,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
      favg = favg/numprocs
      if(myid.eq.0)write(outfile,100) 'poiss   ',favg,favg/time_solve_avg
      totpercent = totpercent +favg/time_solve_avg

      call MPI_REDUCE(time_advs,favg,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
      favg = favg/numprocs
      if(myid.eq.0)write(outfile,100) 'advs    ',favg,favg/time_solve_avg
      totpercent = totpercent +favg/time_solve_avg

      call MPI_REDUCE(time_advu,favg,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
      favg = favg/numprocs
      if(myid.eq.0)write(outfile,100) 'advu    ',favg,favg/time_solve_avg
      totpercent = totpercent +favg/time_solve_avg

      call MPI_REDUCE(time_advv,favg,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
      favg = favg/numprocs
      if(myid.eq.0)write(outfile,100) 'advv    ',favg,favg/time_solve_avg
      totpercent = totpercent +favg/time_solve_avg

      call MPI_REDUCE(time_advw,favg,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
      favg = favg/numprocs
      if(myid.eq.0)write(outfile,100) 'advw    ',favg,favg/time_solve_avg
      totpercent = totpercent +favg/time_solve_avg

      call MPI_REDUCE(time_divx,favg,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
      favg = favg/numprocs
      if(myid.eq.0)write(outfile,100) 'divx    ',favg,favg/time_solve_avg
      totpercent = totpercent +favg/time_solve_avg

      call MPI_REDUCE(time_buoyan,favg,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
      favg = favg/numprocs
      if(myid.eq.0)write(outfile,100) 'buoyan  ',favg,favg/time_solve_avg
      totpercent = totpercent +favg/time_solve_avg

      call MPI_REDUCE(time_turb,favg,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
      favg = favg/numprocs
      if(myid.eq.0)write(outfile,100) 'turb    ',favg,favg/time_solve_avg
      totpercent = totpercent +favg/time_solve_avg
 
      call MPI_REDUCE(time_sfcphys,favg,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
      favg = favg/numprocs
      if(myid.eq.0)write(outfile,100) 'sfcphys ',favg,favg/time_solve_avg
      totpercent = totpercent +favg/time_solve_avg
 
      call MPI_REDUCE(time_tmix,favg,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
      favg = favg/numprocs
      if(myid.eq.0)write(outfile,100) 'tmix    ',favg,favg/time_solve_avg
      totpercent = totpercent +favg/time_solve_avg
 
      call MPI_REDUCE(time_cor,favg,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
      favg = favg/numprocs
      if(myid.eq.0)write(outfile,100) 'cor     ',favg,favg/time_solve_avg
      totpercent = totpercent +favg/time_solve_avg
 
      call MPI_REDUCE(time_diffu,favg,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
      favg = favg/numprocs
      if(myid.eq.0)write(outfile,100) 'diffu   ',favg,favg/time_solve_avg
      totpercent = totpercent +favg/time_solve_avg
 
      call MPI_REDUCE(time_rdamp,favg,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
      favg = favg/numprocs
      if(myid.eq.0)write(outfile,100) 'rdamp   ',favg,favg/time_solve_avg
      totpercent = totpercent +favg/time_solve_avg
 
      call MPI_REDUCE(time_microphy,favg,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
      favg = favg/numprocs
      if(myid.eq.0)write(outfile,100) 'microphy',favg,favg/time_solve_avg
      totpercent = totpercent +favg/time_solve_avg
 
      call MPI_REDUCE(time_satadj,favg,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
      favg = favg/numprocs
      if(myid.eq.0)write(outfile,100) 'satadj  ',favg,favg/time_solve_avg
      totpercent = totpercent +favg/time_solve_avg
 
      call MPI_REDUCE(time_fall,favg,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
      favg = favg/numprocs
      if(myid.eq.0)write(outfile,100) 'fallout ',favg,favg/time_solve_avg
      totpercent = totpercent +favg/time_solve_avg
 
      call MPI_REDUCE(time_rad,favg,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
      favg = favg/numprocs
      if(myid.eq.0)write(outfile,100) 'radiatio',favg,favg/time_solve_avg
      totpercent = totpercent +favg/time_solve_avg

      call MPI_REDUCE(time_pbl,favg,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
      favg = favg/numprocs
      if(myid.eq.0)write(outfile,100) 'pbl     ',favg,favg/time_solve_avg
      totpercent = totpercent +favg/time_solve_avg

      call MPI_REDUCE(time_stat,favg,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
      favg = favg/numprocs
      if(myid.eq.0)write(outfile,100) 'stat    ',favg,favg/time_solve_avg
      totpercent = totpercent +favg/time_solve_avg

      call MPI_REDUCE(time_bc,favg,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
      favg = favg/numprocs
      if(myid.eq.0)write(outfile,100) 'bc      ',favg,favg/time_solve_avg
      totpercent = totpercent +favg/time_solve_avg

      call MPI_REDUCE(time_integ,favg,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
      favg = favg/numprocs
      if(myid.eq.0)write(outfile,100) 'integ   ',favg,favg/time_solve_avg
      totpercent = totpercent +favg/time_solve_avg

      call MPI_REDUCE(time_write,favg,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
      favg = favg/numprocs
      if(myid.eq.0)write(outfile,100) 'write   ',favg,favg/time_solve_avg
      totpercent = totpercent +favg/time_solve_avg

      call MPI_REDUCE(time_misc,favg,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
      favg = favg/numprocs
      if(myid.eq.0)write(outfile,100) 'misc    ',favg,favg/time_solve_avg
      totpercent = totpercent +favg/time_solve_avg

      call MPI_REDUCE(time_swath,favg,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
      favg = favg/numprocs
      if(myid.eq.0)write(outfile,100) 'swaths  ',favg,favg/time_solve_avg
      totpercent = totpercent +favg/time_solve_avg

      call MPI_REDUCE(time_pdef,favg,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
      favg = favg/numprocs
      if(myid.eq.0)write(outfile,100) 'pdef    ',favg,favg/time_solve_avg
      totpercent = totpercent +favg/time_solve_avg

      call MPI_REDUCE(time_parcels,favg,1,MPI_REAL,MPI_SUM,0,MPI_COMM_WORLD,ierr)
      favg = favg/numprocs
      if(myid.eq.0)write(outfile,100) 'parcels ',favg,favg/time_solve_avg
      totpercent = totpercent +favg/time_solve_avg

      if(myid.eq.0)write(outfile,*) '100 percent is actually ',totpercent,' percent due to averaging'

      deallocate ( timbuf )
      deallocate ( time_solve_full )


100   format(3x,a8,' :  ',f10.2,2x,f6.2,'%')

    ENDIF

!  End time loop
!----------------------------------------------------------------------

      close(unit=51)
      close(unit=52)
      close(unit=53)
      close(unit=54)
      close(unit=60)

!----------------------------------------------------------------------

#ifdef MPI
      call MPI_FINALIZE(rc)
      print *,'Program terminated normally:  myid=',myid
#else
      print *,'Program terminated normally'
#endif

      stop
      end



comm.F/         1298670057  19071 8000  100644  122915    `
!-----------------------------------------------------------------------
!  message passing routines
!-----------------------------------------------------------------------


      function nabor(i,j,nx,ny)
      implicit none
      integer i,j,nx,ny,nabor
      integer newi,newj

      newi=i
      newj=j

      if ( newi .lt.  1 ) newi = nx
      if ( newi .gt.  nx) newi = 1

      if ( newj .lt.  1 ) newj = ny
      if ( newj .gt.  ny) newj = 1

      nabor = (newi-1) + (newj-1)*nx

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

#ifdef MPI
      subroutine getcorner(s)
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'mpif.h'
 
      real s(ib:ie,jb:je,kb:ke)
 
      integer k
      integer reqs(8),status(MPI_STATUS_SIZE)
      real, dimension(nk) :: nw1,nw2,ne1,ne2,sw1,sw2,se1,se2
      integer tag,count

!-----

      tag=5001
      count=nk

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call mpi_irecv(nw2,count,MPI_REAL,mynw,tag,MPI_COMM_WORLD,   &
                       reqs(2),ierr)
      endif

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          se1(k)=s(ni,1,k)
        enddo
        call mpi_isend(se1,count,MPI_REAL,myse,tag,MPI_COMM_WORLD,   &
                       reqs(1),ierr)
      endif
 
!-----

      tag=5002
      count=nk

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call mpi_irecv(sw2,count,MPI_REAL,mysw,tag,MPI_COMM_WORLD,   &
                       reqs(4),ierr)
      endif

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          ne1(k)=s(ni,nj,k)
        enddo
        call mpi_isend(ne1,count,MPI_REAL,myne,tag,MPI_COMM_WORLD,   &
                       reqs(3),ierr)
      endif
 
!-----

      tag=5003
      count=nk

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call mpi_irecv(ne2,count,MPI_REAL,myne,tag,MPI_COMM_WORLD,   &
                       reqs(6),ierr)
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          sw1(k)=s(1,1,k)
        enddo
        call mpi_isend(sw1,count,MPI_REAL,mysw,tag,MPI_COMM_WORLD,   &
                       reqs(5),ierr)
      endif
 
!-----

      tag=5004
      count=nk

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call mpi_irecv(se2,count,MPI_REAL,myse,tag,MPI_COMM_WORLD,   &
                       reqs(8),ierr)
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          nw1(k)=s(1,nj,k)
        enddo
        call mpi_isend(nw1,count,MPI_REAL,mynw,tag,MPI_COMM_WORLD,   &
                       reqs(7),ierr)
      endif
 
!-----

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call MPI_WAIT (reqs(2),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          s(0,nj+1,k)=nw2(k)
        enddo
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call MPI_WAIT (reqs(4),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          s(0,0,k)=sw2(k)
        enddo
      endif

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call MPI_WAIT (reqs(6),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          s(ni+1,nj+1,k)=ne2(k)
        enddo
      endif

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call MPI_WAIT (reqs(8),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          s(ni+1,0,k)=se2(k)
        enddo
      endif

!-----

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call MPI_WAIT (reqs(1),status,ierr)
      endif

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call MPI_WAIT (reqs(3),status,ierr)
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call MPI_WAIT (reqs(5),status,ierr)
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call MPI_WAIT (reqs(7),status,ierr)
      endif

!-----

      if(timestats.ge.1) time_mptk1=time_mptk1+mytime()

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine getcornert(t)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'mpif.h'

      real t(ib:ie,jb:je,kb:ke+1)

      integer k
      integer reqs(8),status(MPI_STATUS_SIZE)
      real, dimension(nk+1) :: nw1,nw2,ne1,ne2,sw1,sw2,se1,se2
      integer tag,count

!-----

      tag=5001
      count=nkp1

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call mpi_irecv(nw2,count,MPI_REAL,mynw,tag,MPI_COMM_WORLD,   &
                       reqs(2),ierr)
      endif

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nkp1
          se1(k)=t(ni,1,k)
        enddo
        call mpi_isend(se1,count,MPI_REAL,myse,tag,MPI_COMM_WORLD,   &
                       reqs(1),ierr)
      endif

!-----

      tag=5002
      count=nkp1

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call mpi_irecv(sw2,count,MPI_REAL,mysw,tag,MPI_COMM_WORLD,   &
                       reqs(4),ierr)
      endif

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nkp1
          ne1(k)=t(ni,nj,k)
        enddo
        call mpi_isend(ne1,count,MPI_REAL,myne,tag,MPI_COMM_WORLD,   &
                       reqs(3),ierr)
      endif

!-----

      tag=5003
      count=nkp1

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call mpi_irecv(ne2,count,MPI_REAL,myne,tag,MPI_COMM_WORLD,   &
                       reqs(6),ierr)
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nkp1
          sw1(k)=t(1,1,k)
        enddo
        call mpi_isend(sw1,count,MPI_REAL,mysw,tag,MPI_COMM_WORLD,   &
                       reqs(5),ierr)
      endif

!-----

      tag=5004
      count=nkp1

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call mpi_irecv(se2,count,MPI_REAL,myse,tag,MPI_COMM_WORLD,   &
                       reqs(8),ierr)
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nkp1
          nw1(k)=t(1,nj,k)
        enddo
        call mpi_isend(nw1,count,MPI_REAL,mynw,tag,MPI_COMM_WORLD,   &
                       reqs(7),ierr)
      endif

!-----

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call MPI_WAIT (reqs(2),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nkp1
          t(0,nj+1,k)=nw2(k)
        enddo
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call MPI_WAIT (reqs(4),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nkp1
          t(0,0,k)=sw2(k)
        enddo
      endif

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call MPI_WAIT (reqs(6),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nkp1
          t(ni+1,nj+1,k)=ne2(k)
        enddo
      endif

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call MPI_WAIT (reqs(8),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nkp1
          t(ni+1,0,k)=se2(k)
        enddo
      endif

!-----

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call MPI_WAIT (reqs(1),status,ierr)
      endif

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call MPI_WAIT (reqs(3),status,ierr)
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call MPI_WAIT (reqs(5),status,ierr)
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call MPI_WAIT (reqs(7),status,ierr)
      endif

!-----

      if(timestats.ge.1) time_mptk1=time_mptk1+mytime()

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine getcorneru(u)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'mpif.h'

      real u(ib:ie+1,jb:je,kb:ke)

      integer k
      integer reqs(8),status(MPI_STATUS_SIZE)
      real, dimension(nk) :: nw1,nw2,ne1,ne2,sw1,sw2,se1,se2
      integer tag,count

!-----

      tag=5001
      count=nk

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call mpi_irecv(nw2,count,MPI_REAL,mynw,tag,MPI_COMM_WORLD,   &
                       reqs(2),ierr)
      endif

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          se1(k)=u(ni,1,k)
        enddo
        call mpi_isend(se1,count,MPI_REAL,myse,tag,MPI_COMM_WORLD,   &
                       reqs(1),ierr)
      endif

!-----

      tag=5002
      count=nk

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call mpi_irecv(sw2,count,MPI_REAL,mysw,tag,MPI_COMM_WORLD,   &
                       reqs(4),ierr)
      endif

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          ne1(k)=u(ni,nj,k)
        enddo
        call mpi_isend(ne1,count,MPI_REAL,myne,tag,MPI_COMM_WORLD,   &
                       reqs(3),ierr)
      endif

!-----

      tag=5003
      count=nk

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call mpi_irecv(ne2,count,MPI_REAL,myne,tag,MPI_COMM_WORLD,   &
                       reqs(6),ierr)
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          sw1(k)=u(2,1,k)
        enddo
        call mpi_isend(sw1,count,MPI_REAL,mysw,tag,MPI_COMM_WORLD,   &
                       reqs(5),ierr)
      endif

!-----

      tag=5004
      count=nk

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call mpi_irecv(se2,count,MPI_REAL,myse,tag,MPI_COMM_WORLD,   &
                       reqs(8),ierr)
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          nw1(k)=u(2,nj,k)
        enddo
        call mpi_isend(nw1,count,MPI_REAL,mynw,tag,MPI_COMM_WORLD,   &
                       reqs(7),ierr)
      endif

!-----

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call MPI_WAIT (reqs(2),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          u(0,nj+1,k)=nw2(k)
        enddo
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call MPI_WAIT (reqs(4),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          u(0,0,k)=sw2(k)
        enddo
      endif

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call MPI_WAIT (reqs(6),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          u(ni+2,nj+1,k)=ne2(k)
        enddo
      endif

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call MPI_WAIT (reqs(8),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          u(ni+2,0,k)=se2(k)
        enddo
      endif

!-----

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call MPI_WAIT (reqs(1),status,ierr)
      endif

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call MPI_WAIT (reqs(3),status,ierr)
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call MPI_WAIT (reqs(5),status,ierr)
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call MPI_WAIT (reqs(7),status,ierr)
      endif

!-----

      if(timestats.ge.1) time_mptk1=time_mptk1+mytime()

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine getcornerv(v)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'mpif.h'

      real v(ib:ie,jb:je+1,kb:ke)

      integer k
      integer reqs(8),status(MPI_STATUS_SIZE)
      real, dimension(nk) :: nw1,nw2,ne1,ne2,sw1,sw2,se1,se2
      integer tag,count

!-----

      tag=5001
      count=nk

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call mpi_irecv(nw2,count,MPI_REAL,mynw,tag,MPI_COMM_WORLD,   &
                       reqs(2),ierr)
      endif

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          se1(k)=v(ni,2,k)
        enddo
        call mpi_isend(se1,count,MPI_REAL,myse,tag,MPI_COMM_WORLD,   &
                       reqs(1),ierr)
      endif

!-----

      tag=5002
      count=nk

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call mpi_irecv(sw2,count,MPI_REAL,mysw,tag,MPI_COMM_WORLD,   &
                       reqs(4),ierr)
      endif

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          ne1(k)=v(ni,nj,k)
        enddo
        call mpi_isend(ne1,count,MPI_REAL,myne,tag,MPI_COMM_WORLD,   &
                       reqs(3),ierr)
      endif

!-----

      tag=5003
      count=nk

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call mpi_irecv(ne2,count,MPI_REAL,myne,tag,MPI_COMM_WORLD,   &
                       reqs(6),ierr)
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          sw1(k)=v(1,2,k)
        enddo
        call mpi_isend(sw1,count,MPI_REAL,mysw,tag,MPI_COMM_WORLD,   &
                       reqs(5),ierr)
      endif

!-----

      tag=5004
      count=nk

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call mpi_irecv(se2,count,MPI_REAL,myse,tag,MPI_COMM_WORLD,   &
                       reqs(8),ierr)
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          nw1(k)=v(1,nj,k)
        enddo
        call mpi_isend(nw1,count,MPI_REAL,mynw,tag,MPI_COMM_WORLD,   &
                       reqs(7),ierr)
      endif

!-----

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call MPI_WAIT (reqs(2),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          v(0,nj+2,k)=nw2(k)
        enddo
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call MPI_WAIT (reqs(4),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          v(0,0,k)=sw2(k)
        enddo
      endif

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call MPI_WAIT (reqs(6),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          v(ni+1,nj+2,k)=ne2(k)
        enddo
      endif

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call MPI_WAIT (reqs(8),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nk
          v(ni+1,0,k)=se2(k)
        enddo
      endif

!-----

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call MPI_WAIT (reqs(1),status,ierr)
      endif

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call MPI_WAIT (reqs(3),status,ierr)
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call MPI_WAIT (reqs(5),status,ierr)
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call MPI_WAIT (reqs(7),status,ierr)
      endif

!-----

      if(timestats.ge.1) time_mptk1=time_mptk1+mytime()

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine getcornerw(w)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'mpif.h'

      real w(ib:ie,jb:je,kb:ke+1)

      integer k
      integer reqs(8),status(MPI_STATUS_SIZE)
      real, dimension(nk+1) :: nw1,nw2,ne1,ne2,sw1,sw2,se1,se2
      integer tag,count

!-----

      tag=5001
      count=nkp1

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call mpi_irecv(nw2,count,MPI_REAL,mynw,tag,MPI_COMM_WORLD,   &
                       reqs(2),ierr)
      endif

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nkp1
          se1(k)=w(ni,1,k)
        enddo
        call mpi_isend(se1,count,MPI_REAL,myse,tag,MPI_COMM_WORLD,   &
                       reqs(1),ierr)
      endif

!-----

      tag=5002
      count=nkp1

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call mpi_irecv(sw2,count,MPI_REAL,mysw,tag,MPI_COMM_WORLD,   &
                       reqs(4),ierr)
      endif

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nkp1
          ne1(k)=w(ni,nj,k)
        enddo
        call mpi_isend(ne1,count,MPI_REAL,myne,tag,MPI_COMM_WORLD,   &
                       reqs(3),ierr)
      endif

!-----

      tag=5003
      count=nkp1

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call mpi_irecv(ne2,count,MPI_REAL,myne,tag,MPI_COMM_WORLD,   &
                       reqs(6),ierr)
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nkp1
          sw1(k)=w(1,1,k)
        enddo
        call mpi_isend(sw1,count,MPI_REAL,mysw,tag,MPI_COMM_WORLD,   &
                       reqs(5),ierr)
      endif

!-----

      tag=5004
      count=nkp1

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call mpi_irecv(se2,count,MPI_REAL,myse,tag,MPI_COMM_WORLD,   &
                       reqs(8),ierr)
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nkp1
          nw1(k)=w(1,nj,k)
        enddo
        call mpi_isend(nw1,count,MPI_REAL,mynw,tag,MPI_COMM_WORLD,   &
                       reqs(7),ierr)
      endif

!-----

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call MPI_WAIT (reqs(2),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nkp1
          w(0,nj+1,k)=nw2(k)
        enddo
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call MPI_WAIT (reqs(4),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nkp1
          w(0,0,k)=sw2(k)
        enddo
      endif

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call MPI_WAIT (reqs(6),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nkp1
          w(ni+1,nj+1,k)=ne2(k)
        enddo
      endif

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call MPI_WAIT (reqs(8),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(k)
        do k=1,nkp1
          w(ni+1,0,k)=se2(k)
        enddo
      endif

!-----

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call MPI_WAIT (reqs(1),status,ierr)
      endif

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call MPI_WAIT (reqs(3),status,ierr)
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call MPI_WAIT (reqs(5),status,ierr)
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call MPI_WAIT (reqs(7),status,ierr)
      endif

!-----

      if(timestats.ge.1) time_mptk1=time_mptk1+mytime()

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine comm_2we_start(s,west,newwest,east,neweast,reqs)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'mpif.h'

      real s(ib:ie,jb:je,kb:ke)
      real west(2,nj,nk),newwest(2,nj,nk)
      real east(2,nj,nk),neweast(2,nj,nk)
      integer reqs(4)

      integer i,j,k
      integer tag,count

!------------------------------------------------

      count=cs2we
      nf=nf+1
      tag=nf

      ! receive east
      if(ibe.eq.0)then
        call mpi_irecv(neweast,count,MPI_REAL,myeast,tag,   &
                      MPI_COMM_WORLD,reqs(2),ierr)
      endif

      ! send west
      if(ibw.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,2
          west(i,j,k)=s(i,j,k)
        enddo
        enddo
        enddo
        call mpi_isend(west,count,MPI_REAL,mywest,tag,   &
                       MPI_COMM_WORLD,reqs(1),ierr)
      endif

!----------

      count=cs2we
      nf=nf+1
      tag=nf

      ! receive west
      if(ibw.eq.0)then
        call mpi_irecv(newwest,count,MPI_REAL,mywest,tag,   &
                      MPI_COMM_WORLD,reqs(4),ierr)
      endif

      ! send east
      if(ibe.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,2
          east(i,j,k)=s(ni-2+i,j,k)
        enddo
        enddo
        enddo
        call mpi_isend(east,count,MPI_REAL,myeast,tag,   &
                       MPI_COMM_WORLD,reqs(3),ierr)
      endif

!----------

      if(timestats.ge.1) time_mps1=time_mps1+mytime()

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine comm_2we_end(s,west,newwest,east,neweast,reqs)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'mpif.h'

      real s(ib:ie,jb:je,kb:ke)
      real west(2,nj,nk),newwest(2,nj,nk)
      real east(2,nj,nk),neweast(2,nj,nk)
      integer reqs(4)

      integer i,j,k
      integer status(MPI_STATUS_SIZE)

!-------------------------------------------------------------------

      if(ibe.eq.0)then
        call MPI_WAIT (reqs(2),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,2
          s(ni+i,j,k)=neweast(i,j,k)
        enddo
        enddo
        enddo
      endif

      if(ibw.eq.0)then
        call MPI_WAIT (reqs(4),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,2
          s(i-2,j,k)=newwest(i,j,k)
        enddo
        enddo
        enddo
      endif

!----------

      if(ibw.eq.0)then
        call MPI_WAIT (reqs(1),status,ierr)
      endif

      if(ibe.eq.0)then
        call MPI_WAIT (reqs(3),status,ierr)
      endif

      if(timestats.ge.1) time_mps2=time_mps2+mytime()

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine comm_2sn_start(s,south,newsouth,north,newnorth,reqs)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'mpif.h'

      real s(ib:ie,jb:je,kb:ke)
      real south(ni,2,nk),newsouth(ni,2,nk)
      real north(ni,2,nk),newnorth(ni,2,nk)
      integer reqs(4)

      integer i,j,k
      integer tag,count

!----------

      count=cs2sn
      nf=nf+1
      tag=nf

      ! receive south
      if(ibs.eq.0)then
        call mpi_irecv(newsouth,count,MPI_REAL,mysouth,tag,   &
                      MPI_COMM_WORLD,reqs(2),ierr)
      endif

      ! send north
      if(ibn.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,2
        do i=1,ni
          north(i,j,k)=s(i,nj-2+j,k)
        enddo
        enddo
        enddo
        call mpi_isend(north,count,MPI_REAL,mynorth,tag,   &
                       MPI_COMM_WORLD,reqs(1),ierr)
      endif

!----------

      count=cs2sn
      nf=nf+1
      tag=nf

      ! receive north
      if(ibn.eq.0)then
        call mpi_irecv(newnorth,count,MPI_REAL,mynorth,tag,   &
                      MPI_COMM_WORLD,reqs(4),ierr)
      endif

      ! send south
      if(ibs.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,2
        do i=1,ni
          south(i,j,k)=s(i,j,k)
        enddo
        enddo
        enddo
        call mpi_isend(south,count,MPI_REAL,mysouth,tag,   &
                       MPI_COMM_WORLD,reqs(3),ierr)
      endif

!----------

      if(timestats.ge.1) time_mps1=time_mps1+mytime()

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine comm_2sn_end(s,south,newsouth,north,newnorth,reqs)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'mpif.h'

      real s(ib:ie,jb:je,kb:ke)
      real south(ni,2,nk),newsouth(ni,2,nk)
      real north(ni,2,nk),newnorth(ni,2,nk)
      integer reqs(4)

      integer i,j,k
      integer status(MPI_STATUS_SIZE)

!----------

      if(ibs.eq.0)then
        call MPI_WAIT (reqs(2),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,2
        do i=1,ni
          s(i,j-2,k)=newsouth(i,j,k)
        enddo
        enddo
        enddo
      endif

      if(ibn.eq.0)then
        call MPI_WAIT (reqs(4),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,2
        do i=1,ni
          s(i,nj+j,k)=newnorth(i,j,k)
        enddo
        enddo
        enddo
      endif

      if(ibn.eq.0)then
        call MPI_WAIT (reqs(1),status,ierr)
      endif

      if(ibs.eq.0)then
        call MPI_WAIT (reqs(3),status,ierr)
      endif

      if(timestats.ge.1) time_mps2=time_mps2+mytime()

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine comm_3s_start(s,west,newwest,east,neweast,   &
                                 south,newsouth,north,newnorth,reqs)
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'mpif.h'
 
      real s(ib:ie,jb:je,kb:ke)
      real west(3,nj,nk),newwest(3,nj,nk)
      real east(3,nj,nk),neweast(3,nj,nk)
      real south(ni,3,nk),newsouth(ni,3,nk)
      real north(ni,3,nk),newnorth(ni,3,nk)
      integer reqs(8)
 
      integer i,j,k
      integer tag,count
 
!------------------------------------------------

      count=cs3we
      nf=nf+1
      tag=nf

      ! receive east
      if(ibe.eq.0)then
        call mpi_irecv(neweast,count,MPI_REAL,myeast,tag,   &
                      MPI_COMM_WORLD,reqs(2),ierr)
      endif

      ! send west
      if(ibw.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,3
          west(i,j,k)=s(i,j,k)
        enddo
        enddo
        enddo
        call mpi_isend(west,count,MPI_REAL,mywest,tag,   &
                       MPI_COMM_WORLD,reqs(1),ierr)
      endif
 
!----------
 
      count=cs3we
      nf=nf+1
      tag=nf

      ! receive west
      if(ibw.eq.0)then
        call mpi_irecv(newwest,count,MPI_REAL,mywest,tag,   &
                      MPI_COMM_WORLD,reqs(4),ierr)
      endif
 
      ! send east
      if(ibe.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,3
          east(i,j,k)=s(ni-3+i,j,k)
        enddo
        enddo
        enddo
        call mpi_isend(east,count,MPI_REAL,myeast,tag,   &
                       MPI_COMM_WORLD,reqs(3),ierr)
      endif
 
!----------
 
      count=cs3sn
      nf=nf+1
      tag=nf

      ! receive south
      if(ibs.eq.0)then
        call mpi_irecv(newsouth,count,MPI_REAL,mysouth,tag,   &
                      MPI_COMM_WORLD,reqs(6),ierr)
      endif
 
      ! send north
      if(ibn.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,3
        do i=1,ni
          north(i,j,k)=s(i,nj-3+j,k)
        enddo
        enddo
        enddo
        call mpi_isend(north,count,MPI_REAL,mynorth,tag,   &
                       MPI_COMM_WORLD,reqs(5),ierr)
      endif
 
!----------
 
      count=cs3sn
      nf=nf+1
      tag=nf

      ! receive north
      if(ibn.eq.0)then
        call mpi_irecv(newnorth,count,MPI_REAL,mynorth,tag,   &
                      MPI_COMM_WORLD,reqs(8),ierr)
      endif
 
      ! send south
      if(ibs.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,3
        do i=1,ni
          south(i,j,k)=s(i,j,k)
        enddo
        enddo
        enddo
        call mpi_isend(south,count,MPI_REAL,mysouth,tag,   &
                       MPI_COMM_WORLD,reqs(7),ierr)
      endif
 
!----------
 
      if(timestats.ge.1) time_mps1=time_mps1+mytime()

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 
      subroutine comm_3s_end(s,west,newwest,east,neweast,   &
                               south,newsouth,north,newnorth,reqs)
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'mpif.h'
 
      real s(ib:ie,jb:je,kb:ke)
      real west(3,nj,nk),newwest(3,nj,nk)
      real east(3,nj,nk),neweast(3,nj,nk)
      real south(ni,3,nk),newsouth(ni,3,nk)
      real north(ni,3,nk),newnorth(ni,3,nk)
      integer reqs(8)
 
      integer i,j,k
      integer status(MPI_STATUS_SIZE)

!-------------------------------------------------------------------
 
      if(ibe.eq.0)then
        call MPI_WAIT (reqs(2),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,3
          s(ni+i,j,k)=neweast(i,j,k)
        enddo
        enddo
        enddo
      endif
 
      if(ibw.eq.0)then
        call MPI_WAIT (reqs(4),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,3
          s(i-3,j,k)=newwest(i,j,k)
        enddo
        enddo
        enddo
      endif
 
!----------

      if(ibs.eq.0)then
        call MPI_WAIT (reqs(6),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,3
        do i=1,ni
          s(i,j-3,k)=newsouth(i,j,k)
        enddo
        enddo
        enddo
      endif
 
      if(ibn.eq.0)then
        call MPI_WAIT (reqs(8),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,3
        do i=1,ni
          s(i,nj+j,k)=newnorth(i,j,k)
        enddo
        enddo
        enddo
      endif

!----------

      if(ibw.eq.0)then
        call MPI_WAIT (reqs(1),status,ierr)
      endif

      if(ibe.eq.0)then
        call MPI_WAIT (reqs(3),status,ierr)
      endif

      if(ibn.eq.0)then
        call MPI_WAIT (reqs(5),status,ierr)
      endif

      if(ibs.eq.0)then
        call MPI_WAIT (reqs(7),status,ierr)
      endif

      if(timestats.ge.1) time_mps2=time_mps2+mytime()
 
!----------
!  patch for corner
 
      if( (ebc.eq.2.or.wbc.eq.2).and.(sbc.eq.1.or.nbc.eq.1) )then
 
        if(ibw.eq.1)then

          if(p2tchsww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(0,0,k)=s(1,0,k)
            enddo
          endif

          if(p2tchnww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(0,nj+1,k)=s(1,nj+1,k)
            enddo
          endif

        endif

        if(ibe.eq.1)then
 
          if(p2tchsee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(ni+1,0,k)=s(ni,0,k)
            enddo
          endif
 
          if(p2tchnee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(ni+1,nj+1,k)=s(ni,nj+1,k)
            enddo
          endif
 
        endif
 
      endif

      if( (ebc.eq.1.or.wbc.eq.1).and.(sbc.eq.2.or.nbc.eq.2) )then
 
        if(ibs.eq.1)then
 
          if(p2tchsws)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(0,0,k)=s(0,1,k)
            enddo
          endif
 
          if(p2tchses)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(ni+1,0,k)=s(ni+1,1,k)
            enddo
          endif
 
        endif
 
        if(ibn.eq.1)then
 
          if(p2tchnwn)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(0,nj+1,k)=s(0,nj,k)
            enddo
          endif
 
          if(p2tchnen)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(ni+1,nj+1,k)=s(ni+1,nj,k)
            enddo
          endif
 
        endif
 
      endif

!-----------------------------------------------------------
!  Mirror b.c. patch
!
!      if(ibn.eq.1)then
!!$omp parallel do default(shared)   &
!!$omp private(i,k)
!        do k=1,nk
!        do i=0,ni+1
!          s(i,nj+1,k)=s(i,nj  ,k)
!          s(i,nj+2,k)=s(i,nj-1,k)
!          s(i,nj+3,k)=s(i,nj-2,k)
!        enddo
!        enddo
!      endif
!
!      if(ibw.eq.1)then
!!$omp parallel do default(shared)   &
!!$omp private(i,k)
!        do k=1,nk
!        do j=0,nj+1
!          s(-2,j,k)=s(3,j,k)
!          s(-1,j,k)=s(2,j,k)
!          s( 0,j,k)=s(1,j,k)
!        enddo
!        enddo
!      endif
!
!-----------------------------------------------------------
 
      if(timestats.ge.1) time_bc=time_bc+mytime()
 
      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine comm_3t_start(t,west,newwest,east,neweast,   &
                                 south,newsouth,north,newnorth,reqs)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'mpif.h'

      real t(ib:ie,jb:je,kb:ke+1)
      real west(3,nj,nk+1),newwest(3,nj,nk+1)
      real east(3,nj,nk+1),neweast(3,nj,nk+1)
      real south(ni,3,nk+1),newsouth(ni,3,nk+1)
      real north(ni,3,nk+1),newnorth(ni,3,nk+1)
      integer reqs(8)

      integer i,j,k
      integer tag,count

!------------------------------------------------

      count=ct3we
      nf=nf+1
      tag=nf

      ! receive east
      if(ibe.eq.0)then
        call mpi_irecv(neweast,count,MPI_REAL,myeast,tag,   &
                      MPI_COMM_WORLD,reqs(2),ierr)
      endif

      ! send west
      if(ibw.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nkp1
        do j=1,nj
        do i=1,3
          west(i,j,k)=t(i,j,k)
        enddo
        enddo
        enddo
        call mpi_isend(west,count,MPI_REAL,mywest,tag,   &
                       MPI_COMM_WORLD,reqs(1),ierr)
      endif

!----------

      count=ct3we
      nf=nf+1
      tag=nf

      ! receive west
      if(ibw.eq.0)then
        call mpi_irecv(newwest,count,MPI_REAL,mywest,tag,   &
                      MPI_COMM_WORLD,reqs(4),ierr)
      endif

      ! send east
      if(ibe.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nkp1
        do j=1,nj
        do i=1,3
          east(i,j,k)=t(ni-3+i,j,k)
        enddo
        enddo
        enddo
        call mpi_isend(east,count,MPI_REAL,myeast,tag,   &
                       MPI_COMM_WORLD,reqs(3),ierr)
      endif

!----------

      count=ct3sn
      nf=nf+1
      tag=nf

      ! receive south
      if(ibs.eq.0)then
        call mpi_irecv(newsouth,count,MPI_REAL,mysouth,tag,   &
                      MPI_COMM_WORLD,reqs(6),ierr)
      endif

      ! send north
      if(ibn.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nkp1
        do j=1,3
        do i=1,ni
          north(i,j,k)=t(i,nj-3+j,k)
        enddo
        enddo
        enddo
        call mpi_isend(north,count,MPI_REAL,mynorth,tag,   &
                       MPI_COMM_WORLD,reqs(5),ierr)
      endif

!----------

      count=ct3sn
      nf=nf+1
      tag=nf

      ! receive north
      if(ibn.eq.0)then
        call mpi_irecv(newnorth,count,MPI_REAL,mynorth,tag,   &
                      MPI_COMM_WORLD,reqs(8),ierr)
      endif

      ! send south
      if(ibs.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nkp1
        do j=1,3
        do i=1,ni
          south(i,j,k)=t(i,j,k)
        enddo
        enddo
        enddo
        call mpi_isend(south,count,MPI_REAL,mysouth,tag,   &
                       MPI_COMM_WORLD,reqs(7),ierr)
      endif

!----------

      if(timestats.ge.1) time_mps1=time_mps1+mytime()

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine comm_3t_end(t,west,newwest,east,neweast,   &
                               south,newsouth,north,newnorth,reqs)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'mpif.h'

      real t(ib:ie,jb:je,kb:ke+1)
      real west(3,nj,nk+1),newwest(3,nj,nk+1)
      real east(3,nj,nk+1),neweast(3,nj,nk+1)
      real south(ni,3,nk+1),newsouth(ni,3,nk+1)
      real north(ni,3,nk+1),newnorth(ni,3,nk+1)
      integer reqs(8)

      integer i,j,k
      integer status(MPI_STATUS_SIZE)

!-------------------------------------------------------------------

      if(ibe.eq.0)then
        call MPI_WAIT (reqs(2),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nkp1
        do j=1,nj
        do i=1,3
          t(ni+i,j,k)=neweast(i,j,k)
        enddo
        enddo
        enddo
      endif

      if(ibw.eq.0)then
        call MPI_WAIT (reqs(4),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nkp1
        do j=1,nj
        do i=1,3
          t(i-3,j,k)=newwest(i,j,k)
        enddo
        enddo
        enddo
      endif

!----------

      if(ibs.eq.0)then
        call MPI_WAIT (reqs(6),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nkp1
        do j=1,3
        do i=1,ni
          t(i,j-3,k)=newsouth(i,j,k)
        enddo
        enddo
        enddo
      endif

      if(ibn.eq.0)then
        call MPI_WAIT (reqs(8),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nkp1
        do j=1,3
        do i=1,ni
          t(i,nj+j,k)=newnorth(i,j,k)
        enddo
        enddo
        enddo
      endif

!----------

      if(ibw.eq.0)then
        call MPI_WAIT (reqs(1),status,ierr)
      endif

      if(ibe.eq.0)then
        call MPI_WAIT (reqs(3),status,ierr)
      endif

      if(ibn.eq.0)then
        call MPI_WAIT (reqs(5),status,ierr)
      endif

      if(ibs.eq.0)then
        call MPI_WAIT (reqs(7),status,ierr)
      endif

      if(timestats.ge.1) time_mps2=time_mps2+mytime()

!----------
!  patch for corner

     if( (ebc.eq.2.or.wbc.eq.2).and.(sbc.eq.1.or.nbc.eq.1) )then

        if(ibw.eq.1)then

          if(p2tchsww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nkp1
              t(0,0,k)=t(1,0,k)
            enddo
          endif

          if(p2tchnww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nkp1
              t(0,nj+1,k)=t(1,nj+1,k)
            enddo
          endif

        endif

        if(ibe.eq.1)then

          if(p2tchsee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nkp1
              t(ni+1,0,k)=t(ni,0,k)
            enddo
          endif

          if(p2tchnee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nkp1
              t(ni+1,nj+1,k)=t(ni,nj+1,k)
            enddo
          endif

        endif

      endif

      if( (ebc.eq.1.or.wbc.eq.1).and.(sbc.eq.2.or.nbc.eq.2) )then

        if(ibs.eq.1)then

          if(p2tchsws)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nkp1
              t(0,0,k)=t(0,1,k)
            enddo
          endif

          if(p2tchses)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nkp1
              t(ni+1,0,k)=t(ni+1,1,k)
            enddo
          endif

        endif

        if(ibn.eq.1)then

          if(p2tchnwn)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nkp1
              t(0,nj+1,k)=t(0,nj,k)
            enddo
          endif

          if(p2tchnen)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nkp1
              t(ni+1,nj+1,k)=t(ni+1,nj,k)
            enddo
          endif

        endif

      endif

      if(timestats.ge.1) time_bc=time_bc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 
      subroutine comm_3u_start(u,west,newwest,east,neweast,   &
                                 south,newsouth,north,newnorth,reqs)
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'mpif.h'
 
      real u(ib:ie+1,jb:je,kb:ke)
      real west(3,nj,nk),newwest(3,nj,nk)
      real east(3,nj,nk),neweast(3,nj,nk)
      real south(ni+1,3,nk),newsouth(ni+1,3,nk)
      real north(ni+1,3,nk),newnorth(ni+1,3,nk)
      integer reqs(8)
 
      integer i,j,k
      integer tag,count
 
!------------------------------------------------

      nu=nu+1
      tag=1000+nu
      count=cs3we

      ! receive east
      if(ibe.eq.0)then
        call mpi_irecv(neweast,count,MPI_REAL,myeast,tag,   &
                      MPI_COMM_WORLD,reqs(2),ierr)
      endif
 
      ! send west
      if(ibw.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,3
          west(i,j,k)=u(i+1,j,k)
        enddo
        enddo
        enddo
        call mpi_isend(west,count,MPI_REAL,mywest,tag,   &
                       MPI_COMM_WORLD,reqs(1),ierr)
      endif
 
!----------
 
      nu=nu+1
      tag=1000+nu
      count=cs3we
 
      ! receive west
      if(ibw.eq.0)then
        call mpi_irecv(newwest,count,MPI_REAL,mywest,tag,   &
                      MPI_COMM_WORLD,reqs(4),ierr)
      endif

      ! send east
      if(ibe.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,3
          east(i,j,k)=u(ni-3+i,j,k)
        enddo
        enddo
        enddo
        call mpi_isend(east,count,MPI_REAL,myeast,tag,   &
                       MPI_COMM_WORLD,reqs(3),ierr)
      endif

!----------
 
      nu=nu+1
      tag=1000+nu
      count=cu3sn

      ! receive north
      if(ibn.eq.0)then
        call mpi_irecv(newnorth,count,MPI_REAL,mynorth,tag,   &
                      MPI_COMM_WORLD,reqs(6),ierr)
      endif
 
      ! send south
      if(ibs.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,3
        do i=1,ni+1
          south(i,j,k)=u(i,j,k)
        enddo
        enddo
        enddo
        call mpi_isend(south,count,MPI_REAL,mysouth,tag,   &
                       MPI_COMM_WORLD,reqs(5),ierr)
      endif
 
!----------
 
      nu=nu+1
      tag=1000+nu
      count=cu3sn

      ! receive south
      if(ibs.eq.0)then
        call mpi_irecv(newsouth,count,MPI_REAL,mysouth,tag,   &
                      MPI_COMM_WORLD,reqs(8),ierr)
      endif
 
      ! send north
      if(ibn.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,3
        do i=1,ni+1
          north(i,j,k)=u(i,nj-3+j,k)
        enddo
        enddo
        enddo
        call mpi_isend(north,count,MPI_REAL,mynorth,tag,   &
                       MPI_COMM_WORLD,reqs(7),ierr)
      endif
 
!----------

      if(timestats.ge.1) time_mpu1=time_mpu1+mytime()
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 
      subroutine comm_3u_end(u,west,newwest,east,neweast,   &
                               south,newsouth,north,newnorth,reqs)
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'mpif.h'
 
      real u(ib:ie+1,jb:je,kb:ke)
      real west(3,nj,nk),newwest(3,nj,nk)
      real east(3,nj,nk),neweast(3,nj,nk)
      real south(ni+1,3,nk),newsouth(ni+1,3,nk)
      real north(ni+1,3,nk),newnorth(ni+1,3,nk)
      integer reqs(8)
 
      integer i,j,k
      integer status(MPI_STATUS_SIZE)

!----------
 
      if(ibe.eq.0)then
        call MPI_WAIT (reqs(2),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,3
          u(ni+1+i,j,k)=neweast(i,j,k)
        enddo
        enddo
        enddo
      endif
 
      if(ibw.eq.0)then
        call MPI_WAIT (reqs(4),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,3
          u(i-3,j,k)=newwest(i,j,k)
        enddo
        enddo
        enddo
      endif
 
      if(ibn.eq.0)then
        call MPI_WAIT (reqs(6),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,3
        do i=1,ni+1
          u(i,nj+j,k)=newnorth(i,j,k)
        enddo
        enddo
        enddo
      endif
 
      if(ibs.eq.0)then
        call MPI_WAIT (reqs(8),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,3
        do i=1,ni+1
          u(i,j-3,k)=newsouth(i,j,k)
        enddo
        enddo
        enddo
      endif

!----------

      if(ibw.eq.0)then
        call MPI_WAIT (reqs(1),status,ierr)
      endif

      if(ibe.eq.0)then
        call MPI_WAIT (reqs(3),status,ierr)
      endif

      if(ibs.eq.0)then
        call MPI_WAIT (reqs(5),status,ierr)
      endif

      if(ibn.eq.0)then
        call MPI_WAIT (reqs(7),status,ierr)
      endif
 
      if(timestats.ge.1) time_mpu2=time_mpu2+mytime()

!----------
!  patch for corner
 
      if( (ebc.eq.2.or.wbc.eq.2).and.(sbc.eq.1.or.nbc.eq.1) )then
 
        if(ibw.eq.1)then
 
          if(p2tchsww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              u(0,0,k)=u(1,0,k)
            enddo
          endif
 
          if(p2tchnww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              u(0,nj+1,k)=u(1,nj+1,k)
            enddo
          endif
 
        endif
 
        if(ibe.eq.1)then
 
          if(p2tchsee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              u(ni+2,0,k)=u(ni+1,0,k)
            enddo
          endif
 
          if(p2tchnee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              u(ni+2,nj+1,k)=u(ni+1,nj+1,k)
            enddo
          endif
 
        endif
 
      endif

      if( (ebc.eq.1.or.wbc.eq.1).and.(sbc.eq.2.or.nbc.eq.2) )then
 
        if(ibs.eq.1)then
 
          if(p2tchsws)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              u(0,0,k)=u(0,1,k)
            enddo
          endif
 
          if(p2tchses)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              u(ni+2,0,k)=u(ni+2,1,k)
            enddo
          endif
 
        endif
 
        if(ibn.eq.1)then
 
          if(p2tchnwn)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              u(0,nj+1,k)=u(0,nj,k)
            enddo
          endif
 
          if(p2tchnen)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              u(ni+2,nj+1,k)=u(ni+2,nj,k)
            enddo
          endif
 
        endif
 
      endif

!-----------------------------------------------------------
!  Mirror b.c. patch
!
!      if(ibn.eq.1)then
!!$omp parallel do default(shared)   &
!!$omp private(i,k)
!        do k=1,nk
!        do i=0,ni+2
!          u(i,nj+1,k)=u(i,nj  ,k)
!          u(i,nj+2,k)=u(i,nj-1,k)
!          u(i,nj+3,k)=u(i,nj-2,k)
!        enddo
!        enddo
!      endif
!
!      if(ibw.eq.1)then
!!$omp parallel do default(shared)   &
!!$omp private(i,k)
!        do k=1,nk
!        do j=0,nj+1
!          u(-2,j,k)=-u(4,j,k)
!          u(-1,j,k)=-u(3,j,k)
!          u( 0,j,k)=-u(2,j,k)
!          u( 1,j,k)=0.0
!        enddo
!        enddo
!      endif
!
!-----------------------------------------------------------
 
      if(timestats.ge.1) time_bc=time_bc+mytime()
 
!----------
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 
      subroutine comm_3v_start(v,west,newwest,east,neweast,   &
                                 south,newsouth,north,newnorth,reqs)
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'mpif.h'
 
      real v(ib:ie,jb:je+1,kb:ke)
      real west(3,nj+1,nk),newwest(3,nj+1,nk)
      real east(3,nj+1,nk),neweast(3,nj+1,nk)
      real south(ni,3,nk),newsouth(ni,3,nk)
      real north(ni,3,nk),newnorth(ni,3,nk)
      integer reqs(8)
 
      integer i,j,k
      integer tag,count
 
!------------------------------------------------

      nv=nv+1
      tag=2000+nv
      count=cv3we

      ! receive east
      if(ibe.eq.0)then
        call mpi_irecv(neweast,count,MPI_REAL,myeast,tag,   &
                      MPI_COMM_WORLD,reqs(2),ierr)
      endif
 
      ! send west
      if(ibw.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj+1
        do i=1,3
          west(i,j,k)=v(i,j,k)
        enddo
        enddo
        enddo
        call mpi_isend(west,count,MPI_REAL,mywest,tag,   &
                       MPI_COMM_WORLD,reqs(1),ierr)
      endif
 
!----------
 
      nv=nv+1
      tag=2000+nv
      count=cv3we
 
      ! receive west
      if(ibw.eq.0)then
        call mpi_irecv(newwest,count,MPI_REAL,mywest,tag,   &
                      MPI_COMM_WORLD,reqs(4),ierr)
      endif

      if(ibe.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj+1
        do i=1,3
          east(i,j,k)=v(ni-3+i,j,k)
        enddo
        enddo
        enddo
        call mpi_isend(east,count,MPI_REAL,myeast,tag,   &
                       MPI_COMM_WORLD,reqs(3),ierr)
      endif

!----------
 
      nv=nv+1
      tag=2000+nv
      count=cs3sn
 
      ! receive north
      if(ibn.eq.0)then
        call mpi_irecv(newnorth,count,MPI_REAL,mynorth,tag,   &
                      MPI_COMM_WORLD,reqs(6),ierr)
      endif

      ! send south
      if(ibs.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,3
        do i=1,ni
          south(i,j,k)=v(i,j+1,k)
        enddo
        enddo
        enddo
        call mpi_isend(south,count,MPI_REAL,mysouth,tag,   &
                       MPI_COMM_WORLD,reqs(5),ierr)
      endif
 
!----------
 
      nv=nv+1
      tag=2000+nv
      count=cs3sn
 
      ! receive south
      if(ibs.eq.0)then
        call mpi_irecv(newsouth,count,MPI_REAL,mysouth,tag,   &
                      MPI_COMM_WORLD,reqs(8),ierr)
      endif

      ! send north
      if(ibn.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,3
        do i=1,ni
          north(i,j,k)=v(i,nj-3+j,k)
        enddo
        enddo
        enddo
        call mpi_isend(north,count,MPI_REAL,mynorth,tag,   &
                       MPI_COMM_WORLD,reqs(7),ierr)
      endif
 
!----------

      if(timestats.ge.1) time_mpv1=time_mpv1+mytime()
 
      return
      end

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 
      subroutine comm_3v_end(v,west,newwest,east,neweast,   &
                               south,newsouth,north,newnorth,reqs)
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'mpif.h'
 
      real v(ib:ie,jb:je+1,kb:ke)
      real west(3,nj+1,nk),newwest(3,nj+1,nk)
      real east(3,nj+1,nk),neweast(3,nj+1,nk)
      real south(ni,3,nk),newsouth(ni,3,nk)
      real north(ni,3,nk),newnorth(ni,3,nk)
      integer reqs(8)
 
      integer i,j,k
      integer status(MPI_STATUS_SIZE)
 
!--------
 
      if(ibe.eq.0)then
        call MPI_WAIT (reqs(2),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj+1
        do i=1,3
          v(ni+i,j,k)=neweast(i,j,k)
        enddo
        enddo
        enddo
      endif

      if(ibw.eq.0)then
        call MPI_WAIT (reqs(4),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj+1
        do i=1,3
          v(i-3,j,k)=newwest(i,j,k)
        enddo
        enddo
        enddo
      endif
 
      if(ibn.eq.0)then
        call MPI_WAIT (reqs(6),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,3
        do i=1,ni
          v(i,nj+1+j,k)=newnorth(i,j,k)
        enddo
        enddo
        enddo
      endif
 
      if(ibs.eq.0)then
        call MPI_WAIT (reqs(8),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,3
        do i=1,ni
          v(i,j-3,k)=newsouth(i,j,k)
        enddo
        enddo
        enddo
      endif

!--------

      if(ibw.eq.0)then
        call MPI_WAIT (reqs(1),status,ierr)
      endif

      if(ibe.eq.0)then
        call MPI_WAIT (reqs(3),status,ierr)
      endif

      if(ibs.eq.0)then
        call MPI_WAIT (reqs(5),status,ierr)
      endif

      if(ibn.eq.0)then
        call MPI_WAIT (reqs(7),status,ierr)
      endif
 
      if(timestats.ge.1) time_mpv2=time_mpv2+mytime()

!----------
!  patch for corner
 
      if( (ebc.eq.2.or.wbc.eq.2).and.(sbc.eq.1.or.nbc.eq.1) )then
 
        if(ibw.eq.1)then
 
          if(p2tchsww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              v(0,0,k)=v(1,0,k)
            enddo
          endif
 
          if(p2tchnww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              v(0,nj+2,k)=v(1,nj+2,k)
            enddo
          endif
 
        endif
 
        if(ibe.eq.1)then
 
          if(p2tchsee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              v(ni+1,0,k)=v(ni,0,k)
            enddo
          endif
 
          if(p2tchnee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              v(ni+1,nj+2,k)=v(ni,nj+2,k)
            enddo
          endif
 
        endif
 
      endif

      if( (ebc.eq.1.or.wbc.eq.1).and.(sbc.eq.2.or.nbc.eq.2) )then
 
        if(ibs.eq.1)then
 
          if(p2tchsws)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              v(0,0,k)=v(0,1,k)
            enddo
          endif
 
          if(p2tchses)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              v(ni+1,0,k)=v(ni+1,1,k)
            enddo
          endif
 
        endif
 
        if(ibn.eq.1)then
 
          if(p2tchnwn)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              v(0,nj+2,k)=v(0,nj+1,k)
            enddo
          endif
 
          if(p2tchnen)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              v(ni+1,nj+2,k)=v(ni+1,nj+1,k)
            enddo
          endif
 
        endif
 
      endif

!-----------------------------------------------------------
!  Mirror b.c. patch
!
!      if(ibn.eq.1)then
!!$omp parallel do default(shared)   &
!!$omp private(i,k)
!        do k=1,nk
!        do i=0,ni+1
!          v(i,nj+1,k)=0.0
!          v(i,nj+2,k)=-v(i,nj  ,k)
!          v(i,nj+3,k)=-v(i,nj-1,k)
!          v(i,nj+4,k)=-v(i,nj-2,k)
!        enddo
!        enddo
!      endif
!
!      if(ibw.eq.1)then
!!$omp parallel do default(shared)   &
!!$omp private(i,k)
!        do k=1,nk
!        do j=0,nj+2
!          v(-2,j,k)=v(3,j,k)
!          v(-1,j,k)=v(2,j,k)
!          v( 0,j,k)=v(1,j,k)
!        enddo
!        enddo
!      endif
!
!-----------------------------------------------------------
 
      if(timestats.ge.1) time_bc=time_bc+mytime()
 
!----------
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 
      subroutine comm_3w_start(w,west,newwest,east,neweast,   &
                                 south,newsouth,north,newnorth,reqs)
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'mpif.h'
 
      real w(ib:ie,jb:je,kb:ke+1)
      real west(3,nj,nk-1),newwest(3,nj,nk-1)
      real east(3,nj,nk-1),neweast(3,nj,nk-1)
      real south(ni,3,nk-1),newsouth(ni,3,nk-1)
      real north(ni,3,nk-1),newnorth(ni,3,nk-1)
      integer reqs(8)
 
      integer i,j,k
      integer tag,count
 
!------------------------------------------------

      nw=nw+1
      tag=3000+nw
      count=cw3we

      ! receive east
      if(ibe.eq.0)then
        call mpi_irecv(neweast,count,MPI_REAL,myeast,tag,   &
                      MPI_COMM_WORLD,reqs(2),ierr)
      endif
 
      ! send west
      if(ibw.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=1,3
          west(i,j,k-1)=w(i,j,k)
        enddo
        enddo
        enddo
        call mpi_isend(west,count,MPI_REAL,mywest,tag,    &
                       MPI_COMM_WORLD,reqs(1),ierr)
      endif
 
!----------
 
      nw=nw+1
      tag=3000+nw
      count=cw3we
 
      ! receive west
      if(ibw.eq.0)then
        call mpi_irecv(newwest,count,MPI_REAL,mywest,tag,   &
                      MPI_COMM_WORLD,reqs(4),ierr)
      endif

      ! send east
      if(ibe.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=1,3
          east(i,j,k-1)=w(ni-3+i,j,k)
        enddo
        enddo
        enddo
        call mpi_isend(east,count,MPI_REAL,myeast,tag,   &
                       MPI_COMM_WORLD,reqs(3),ierr)
      endif

!----------

      nw=nw+1
      tag=3000+nw
      count=cw3sn
 
      ! receive north
      if(ibn.eq.0)then
        call mpi_irecv(newnorth,count,MPI_REAL,mynorth,tag,   &
                      MPI_COMM_WORLD,reqs(6),ierr)
      endif

      ! send south
      if(ibs.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,3
        do i=1,ni
          south(i,j,k-1)=w(i,j,k)
        enddo
        enddo
        enddo
        call mpi_isend(south,count,MPI_REAL,mysouth,tag,   &
                       MPI_COMM_WORLD,reqs(5),ierr)
      endif
 
!----------
 
      nw=nw+1
      tag=3000+nw
      count=cw3sn
 
      ! receive south
      if(ibs.eq.0)then
        call mpi_irecv(newsouth,count,MPI_REAL,mysouth,tag,   &
                      MPI_COMM_WORLD,reqs(8),ierr)
      endif

      ! send north
      if(ibn.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,3
        do i=1,ni
          north(i,j,k-1)=w(i,nj-3+j,k)
        enddo
        enddo
        enddo
        call mpi_isend(north,count,MPI_REAL,mynorth,tag,   &
                       MPI_COMM_WORLD,reqs(7),ierr)
      endif
 
!----------

      if(timestats.ge.1) time_mpw1=time_mpw1+mytime()
 
      return
      end

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 
      subroutine comm_3w_end(w,west,newwest,east,neweast,   &
                               south,newsouth,north,newnorth,reqs)
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'mpif.h'
 
      real w(ib:ie,jb:je,kb:ke+1)
      real west(3,nj,nk-1),newwest(3,nj,nk-1)
      real east(3,nj,nk-1),neweast(3,nj,nk-1)
      real south(ni,3,nk-1),newsouth(ni,3,nk-1)
      real north(ni,3,nk-1),newnorth(ni,3,nk-1)
      integer reqs(8)
 
      integer i,j,k
      integer status(MPI_STATUS_SIZE)

!--------
 
      if(ibe.eq.0)then
        call MPI_WAIT (reqs(2),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=1,3
          w(ni+i,j,k)=neweast(i,j,k-1)
        enddo
        enddo
        enddo
      endif
 
      if(ibw.eq.0)then
        call MPI_WAIT (reqs(4),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=1,3
          w(i-3,j,k)=newwest(i,j,k-1)
        enddo
        enddo
        enddo
      endif
 
      if(ibn.eq.0)then
        call MPI_WAIT (reqs(6),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,3
        do i=1,ni
          w(i,nj+j,k)=newnorth(i,j,k-1)
        enddo
        enddo
        enddo
      endif
 
      if(ibs.eq.0)then
        call MPI_WAIT (reqs(8),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,3
        do i=1,ni
          w(i,j-3,k)=newsouth(i,j,k-1)
        enddo
        enddo
        enddo
      endif
 
!--------

      if(ibw.eq.0)then
        call MPI_WAIT (reqs(1),status,ierr)
      endif

      if(ibe.eq.0)then
        call MPI_WAIT (reqs(3),status,ierr)
      endif

      if(ibs.eq.0)then
        call MPI_WAIT (reqs(5),status,ierr)
      endif

      if(ibn.eq.0)then
        call MPI_WAIT (reqs(7),status,ierr)
      endif

      if(timestats.ge.1) time_mpw2=time_mpw2+mytime()

!----------
!  patch for corner
 
      if( (ebc.eq.2.or.wbc.eq.2).and.(sbc.eq.1.or.nbc.eq.1) )then
 
        if(ibw.eq.1)then
 
          if(p2tchsww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=2,nk
              w(0,0,k)=w(1,0,k)
            enddo
          endif
 
          if(p2tchnww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=2,nk
              w(0,nj+1,k)=w(1,nj+1,k)
            enddo
          endif
 
        endif
 
        if(ibe.eq.1)then
 
          if(p2tchsee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=2,nk
              w(ni+1,0,k)=w(ni,0,k)
            enddo
          endif
 
          if(p2tchnee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=2,nk
              w(ni+1,nj+1,k)=w(ni,nj+1,k)
            enddo
          endif
 
        endif
 
      endif

      if( (ebc.eq.1.or.wbc.eq.1).and.(sbc.eq.2.or.nbc.eq.2) )then
 
        if(ibs.eq.1)then
 
          if(p2tchsws)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=2,nk
              w(0,0,k)=w(0,1,k)
            enddo
          endif
 
          if(p2tchses)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=2,nk
              w(ni+1,0,k)=w(ni+1,1,k)
            enddo
          endif
 
        endif
 
        if(ibn.eq.1)then
 
          if(p2tchnwn)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=2,nk
              w(0,nj+1,k)=w(0,nj,k)
            enddo
          endif
 
          if(p2tchnen)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=2,nk
              w(ni+1,nj+1,k)=w(ni+1,nj,k)
            enddo
          endif
 
        endif
 
      endif

!-----------------------------------------------------------
!  Mirror b.c. patch
!
!      if(ibn.eq.1)then
!!$omp parallel do default(shared)   &
!!$omp private(i,k)
!        do k=2,nk
!        do i=0,ni+1
!          w(i,nj+1,k)=w(i,nj  ,k)
!          w(i,nj+2,k)=w(i,nj-1,k)
!          w(i,nj+3,k)=w(i,nj-2,k)
!        enddo
!        enddo
!      endif
!
!      if(ibw.eq.1)then
!!$omp parallel do default(shared)   &
!!$omp private(i,k)
!        do k=2,nk
!        do j=0,nj+1
!          w(-2,j,k)=w(3,j,k)
!          w(-1,j,k)=w(2,j,k)
!          w( 0,j,k)=w(1,j,k)
!        enddo
!        enddo
!      endif
!
!-----------------------------------------------------------
 
      if(timestats.ge.1) time_bc=time_bc+mytime()
 
!----------
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine comm_1s_start(s,west,newwest,east,neweast,   &
                                 south,newsouth,north,newnorth,reqs)
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'mpif.h'
 
      real s(ib:ie,jb:je,kb:ke)
      real west(nj,nk),newwest(nj,nk)
      real east(nj,nk),neweast(nj,nk)
      real south(ni,nk),newsouth(ni,nk)
      real north(ni,nk),newnorth(ni,nk)
      integer reqs(8)
 
      integer i,j,k
      integer tag,count
 
!------------------------------------------------

      nf=nf+1
      tag=nf
      count=cs1we

      ! receive east
      if(ibe.eq.0)then
        call mpi_irecv(neweast,count,MPI_REAL,myeast,tag,   &
                      MPI_COMM_WORLD,reqs(2),ierr)
      endif
 
      ! send west
      if(ibw.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(j,k)
        do k=1,nk
        do j=1,nj
          west(j,k)=s(1,j,k)
        enddo
        enddo
        call mpi_isend(west,count,MPI_REAL,mywest,tag,   &
                       MPI_COMM_WORLD,reqs(1),ierr)
      endif
 
!----------

      nf=nf+1
      tag=nf
      count=cs1we

      ! receive west
      if(ibw.eq.0)then
        call mpi_irecv(newwest,count,MPI_REAL,mywest,tag,   &
                      MPI_COMM_WORLD,reqs(4),ierr)
      endif
 
      ! send east
      if(ibe.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(j,k)
        do k=1,nk
        do j=1,nj
          east(j,k)=s(ni,j,k)
        enddo
        enddo
        call mpi_isend(east,count,MPI_REAL,myeast,tag,   &
                       MPI_COMM_WORLD,reqs(3),ierr)
      endif
 
!----------

      nf=nf+1
      tag=nf
      count=cs1sn

      ! receive south
      if(ibs.eq.0)then
        call mpi_irecv(newsouth,count,MPI_REAL,mysouth,tag,   &
                      MPI_COMM_WORLD,reqs(6),ierr)
      endif
 
      ! send north
      if(ibn.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
        do k=1,nk
        do i=1,ni
          north(i,k)=s(i,nj,k)
        enddo
        enddo
        call mpi_isend(north,count,MPI_REAL,mynorth,tag,   &
                       MPI_COMM_WORLD,reqs(5),ierr)
      endif
 
!----------

      nf=nf+1
      tag=nf
      count=cs1sn

      ! receive north
      if(ibn.eq.0)then
        call mpi_irecv(newnorth,count,MPI_REAL,mynorth,tag,   &
                      MPI_COMM_WORLD,reqs(8),ierr)
      endif
 
      ! send south
      if(ibs.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
        do k=1,nk
        do i=1,ni
          south(i,k)=s(i,1,k)
        enddo
        enddo
        call mpi_isend(south,count,MPI_REAL,mysouth,tag,   &
                       MPI_COMM_WORLD,reqs(7),ierr)
      endif

!----------
 
      if(timestats.ge.1) time_mps1=time_mps1+mytime()
 
      return
      end

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 
      subroutine comm_1s_end(s,west,newwest,east,neweast,   &
                               south,newsouth,north,newnorth,reqs)
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'mpif.h'
 
      real s(ib:ie,jb:je,kb:ke)
      real west(nj,nk),newwest(nj,nk)
      real east(nj,nk),neweast(nj,nk)
      real south(ni,nk),newsouth(ni,nk)
      real north(ni,nk),newnorth(ni,nk)
      integer reqs(8)
 
      integer i,j,k
      integer status(MPI_STATUS_SIZE)

!---------------------------------------------------------------------
 
      if(ibe.eq.0)then
        call MPI_WAIT (reqs(2),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(j,k)
        do k=1,nk
        do j=1,nj
          s(ni+1,j,k)=neweast(j,k)
        enddo
        enddo
      endif
 
      if(ibw.eq.0)then
        call MPI_WAIT (reqs(4),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(j,k)
        do k=1,nk
        do j=1,nj
          s(0,j,k)=newwest(j,k)
        enddo
        enddo
      endif
 
      if(ibs.eq.0)then
        call MPI_WAIT (reqs(6),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,k)
        do k=1,nk
        do i=1,ni
          s(i,0,k)=newsouth(i,k)
        enddo
        enddo
      endif
 
      if(ibn.eq.0)then
        call MPI_WAIT (reqs(8),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,k)
        do k=1,nk
        do i=1,ni
          s(i,nj+1,k)=newnorth(i,k)
        enddo
        enddo
      endif

!----------

      if(ibw.eq.0)then
        call MPI_WAIT (reqs(1),status,ierr)
      endif

      if(ibe.eq.0)then
        call MPI_WAIT (reqs(3),status,ierr)
      endif

      if(ibn.eq.0)then
        call MPI_WAIT (reqs(5),status,ierr)
      endif

      if(ibs.eq.0)then
        call MPI_WAIT (reqs(7),status,ierr)
      endif

      if(timestats.ge.1) time_mps2=time_mps2+mytime()

!----------
!  patch for corner
 
      if( (ebc.eq.2.or.wbc.eq.2).and.(sbc.eq.1.or.nbc.eq.1) )then
 
        if(ibw.eq.1)then
 
          if(p2tchsww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(0,0,k)=s(1,0,k)
            enddo
          endif
 
          if(p2tchnww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(0,nj+1,k)=s(1,nj+1,k)
            enddo
          endif
 
        endif
 
        if(ibe.eq.1)then
 
          if(p2tchsee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(ni+1,0,k)=s(ni,0,k)
            enddo
          endif
 
          if(p2tchnee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(ni+1,nj+1,k)=s(ni,nj+1,k)
            enddo
          endif
 
        endif
 
      endif

      if( (ebc.eq.1.or.wbc.eq.1).and.(sbc.eq.2.or.nbc.eq.2) )then
 
        if(ibs.eq.1)then
 
          if(p2tchsws)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(0,0,k)=s(0,1,k)
            enddo
          endif
 
          if(p2tchses)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(ni+1,0,k)=s(ni+1,1,k)
            enddo
          endif
 
        endif
 
        if(ibn.eq.1)then
 
          if(p2tchnwn)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(0,nj+1,k)=s(0,nj,k)
            enddo
          endif
 
          if(p2tchnen)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(ni+1,nj+1,k)=s(ni+1,nj,k)
            enddo
          endif
 
        endif
 
      endif

!-----------------------------------------------------------
!  Mirror b.c. patch
!
!      if(ibn.eq.1)then
!!$omp parallel do default(shared)   &
!!$omp private(i,k)
!        do k=1,nk
!        do i=0,ni+1
!          s(i,nj+1,k)=s(i,nj  ,k)
!          s(i,nj+2,k)=s(i,nj-1,k)
!          s(i,nj+3,k)=s(i,nj-2,k)
!        enddo
!        enddo
!      endif
!
!      if(ibw.eq.1)then
!!$omp parallel do default(shared)   &
!!$omp private(i,k)
!        do k=1,nk
!        do j=0,nj+1
!          s(-2,j,k)=s(3,j,k)
!          s(-1,j,k)=s(2,j,k)
!          s( 0,j,k)=s(1,j,k)
!        enddo
!        enddo
!      endif
!
!-----------------------------------------------------------
 
      if(timestats.ge.1) time_bc=time_bc+mytime()
 
!----------
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine comm_1s_end_we(s,west,newwest,east,neweast,   &
                               south,newsouth,north,newnorth,reqs)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'mpif.h'

      real s(ib:ie,jb:je,kb:ke)
      real west(nj,nk),newwest(nj,nk)
      real east(nj,nk),neweast(nj,nk)
      real south(ni,nk),newsouth(ni,nk)
      real north(ni,nk),newnorth(ni,nk)
      integer reqs(8)

      integer i,j,k
      integer status(MPI_STATUS_SIZE)

!---------------------------------------------------------------------

      if(ibe.eq.0)then
        call MPI_WAIT (reqs(2),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(j,k)
        do k=1,nk
        do j=1,nj
          s(ni+1,j,k)=neweast(j,k)
        enddo
        enddo
      endif

      if(ibw.eq.0)then
        call MPI_WAIT (reqs(4),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(j,k)
        do k=1,nk
        do j=1,nj
          s(0,j,k)=newwest(j,k)
        enddo
        enddo
      endif

!-----------------------------------------------------------

      if(timestats.ge.1) time_mps2=time_mps2+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine comm_1s_end_sn(s,west,newwest,east,neweast,   &
                               south,newsouth,north,newnorth,reqs)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'mpif.h'
 
      real s(ib:ie,jb:je,kb:ke)
      real west(nj,nk),newwest(nj,nk)
      real east(nj,nk),neweast(nj,nk)
      real south(ni,nk),newsouth(ni,nk)
      real north(ni,nk),newnorth(ni,nk)
      integer reqs(8)

      integer i,j,k
      integer status(MPI_STATUS_SIZE)

!-----------------------------------------------------------

      if(ibs.eq.0)then
        call MPI_WAIT (reqs(6),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,k)
        do k=1,nk
        do i=1,ni
          s(i,0,k)=newsouth(i,k)
        enddo
        enddo
      endif

      if(ibn.eq.0)then
        call MPI_WAIT (reqs(8),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,k)
        do k=1,nk
        do i=1,ni
          s(i,nj+1,k)=newnorth(i,k)
        enddo
        enddo
      endif

!-----------------------------------------------------------

      if(timestats.ge.1) time_mps2=time_mps2+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 

      subroutine comm_1s_end_misc(s,west,newwest,east,neweast,   &
                               south,newsouth,north,newnorth,reqs)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'mpif.h'

      real s(ib:ie,jb:je,kb:ke)
      real west(nj,nk),newwest(nj,nk)
      real east(nj,nk),neweast(nj,nk)
      real south(ni,nk),newsouth(ni,nk)
      real north(ni,nk),newnorth(ni,nk)
      integer reqs(8)

      integer i,j,k
      integer status(MPI_STATUS_SIZE)

!----------

      if(ibw.eq.0)then
        call MPI_WAIT (reqs(1),status,ierr)
      endif

      if(ibe.eq.0)then
        call MPI_WAIT (reqs(3),status,ierr)
      endif

      if(ibn.eq.0)then
        call MPI_WAIT (reqs(5),status,ierr)
      endif

      if(ibs.eq.0)then
        call MPI_WAIT (reqs(7),status,ierr)
      endif

      if(timestats.ge.1) time_mps2=time_mps2+mytime()

!----------
!  patch for corner

      if( (ebc.eq.2.or.wbc.eq.2).and.(sbc.eq.1.or.nbc.eq.1) )then

        if(ibw.eq.1)then

          if(p2tchsww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(0,0,k)=s(1,0,k)
            enddo
          endif

          if(p2tchnww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(0,nj+1,k)=s(1,nj+1,k)
            enddo
          endif

        endif

        if(ibe.eq.1)then

          if(p2tchsee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(ni+1,0,k)=s(ni,0,k)
            enddo
          endif

          if(p2tchnee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(ni+1,nj+1,k)=s(ni,nj+1,k)
            enddo
          endif

        endif

      endif

      if( (ebc.eq.1.or.wbc.eq.1).and.(sbc.eq.2.or.nbc.eq.2) )then

        if(ibs.eq.1)then

          if(p2tchsws)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(0,0,k)=s(0,1,k)
            enddo
          endif

          if(p2tchses)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(ni+1,0,k)=s(ni+1,1,k)
            enddo
          endif

        endif

        if(ibn.eq.1)then

          if(p2tchnwn)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(0,nj+1,k)=s(0,nj,k)
            enddo
          endif

          if(p2tchnen)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              s(ni+1,nj+1,k)=s(ni+1,nj,k)
            enddo
          endif

        endif

      endif

      if(timestats.ge.1) time_bc=time_bc+mytime()

!----------

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine comm_1t_start(t,west,newwest,east,neweast,   &
                                 south,newsouth,north,newnorth,reqs)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'mpif.h'

      real t(ib:ie,jb:je,kb:ke+1)
      real west(nj,nk+1),newwest(nj,nk+1)
      real east(nj,nk+1),neweast(nj,nk+1)
      real south(ni,nk+1),newsouth(ni,nk+1)
      real north(ni,nk+1),newnorth(ni,nk+1)
      integer reqs(8)

      integer i,j,k
      integer tag,count

!------------------------------------------------

      nf=nf+1
      tag=nf
      count=ct1we

      ! receive east
      if(ibe.eq.0)then
        call mpi_irecv(neweast,count,MPI_REAL,myeast,tag,   &
                      MPI_COMM_WORLD,reqs(2),ierr)
      endif

      ! send west
      if(ibw.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(j,k)
        do k=1,nkp1
        do j=1,nj
          west(j,k)=t(1,j,k)
        enddo
        enddo
        call mpi_isend(west,count,MPI_REAL,mywest,tag,   &
                       MPI_COMM_WORLD,reqs(1),ierr)
      endif

!----------

      nf=nf+1
      tag=nf
      count=ct1we

      ! receive west
      if(ibw.eq.0)then
        call mpi_irecv(newwest,count,MPI_REAL,mywest,tag,   &
                      MPI_COMM_WORLD,reqs(4),ierr)
      endif

      ! send east
      if(ibe.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(j,k)
        do k=1,nkp1
        do j=1,nj
          east(j,k)=t(ni,j,k)
        enddo
        enddo
        call mpi_isend(east,count,MPI_REAL,myeast,tag,   &
                       MPI_COMM_WORLD,reqs(3),ierr)
      endif

!----------

      nf=nf+1
      tag=nf
      count=ct1sn

      ! receive south
      if(ibs.eq.0)then
        call mpi_irecv(newsouth,count,MPI_REAL,mysouth,tag,   &
                      MPI_COMM_WORLD,reqs(6),ierr)
      endif

      ! send north
      if(ibn.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
        do k=1,nkp1
        do i=1,ni
          north(i,k)=t(i,nj,k)
        enddo
        enddo
        call mpi_isend(north,count,MPI_REAL,mynorth,tag,   &
                       MPI_COMM_WORLD,reqs(5),ierr)
      endif

!----------

      nf=nf+1
      tag=nf
      count=ct1sn

      ! receive north
      if(ibn.eq.0)then
        call mpi_irecv(newnorth,count,MPI_REAL,mynorth,tag,   &
                      MPI_COMM_WORLD,reqs(8),ierr)
      endif

      ! send south
      if(ibs.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
        do k=1,nkp1
        do i=1,ni
          south(i,k)=t(i,1,k)
        enddo
        enddo
        call mpi_isend(south,count,MPI_REAL,mysouth,tag,   &
                       MPI_COMM_WORLD,reqs(7),ierr)
      endif

!----------

      if(timestats.ge.1) time_mps1=time_mps1+mytime()

      return
      end

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine comm_1t_end(t,west,newwest,east,neweast,   &
                               south,newsouth,north,newnorth,reqs)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'mpif.h'

      real t(ib:ie,jb:je,kb:ke+1)
      real west(nj,nk+1),newwest(nj,nk+1)
      real east(nj,nk+1),neweast(nj,nk+1)
      real south(ni,nk+1),newsouth(ni,nk+1)
      real north(ni,nk+1),newnorth(ni,nk+1)
      integer reqs(8)

      integer i,j,k
      integer status(MPI_STATUS_SIZE)

!---------------------------------------------------------------------

      if(ibe.eq.0)then
        call MPI_WAIT (reqs(2),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(j,k)
        do k=1,nkp1
        do j=1,nj
          t(ni+1,j,k)=neweast(j,k)
        enddo
        enddo
      endif

      if(ibw.eq.0)then
        call MPI_WAIT (reqs(4),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(j,k)
        do k=1,nkp1
        do j=1,nj
          t(0,j,k)=newwest(j,k)
        enddo
        enddo
      endif

      if(ibs.eq.0)then
        call MPI_WAIT (reqs(6),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,k)
        do k=1,nkp1
        do i=1,ni
          t(i,0,k)=newsouth(i,k)
        enddo
        enddo
      endif

      if(ibn.eq.0)then
        call MPI_WAIT (reqs(8),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,k)
        do k=1,nkp1
        do i=1,ni
          t(i,nj+1,k)=newnorth(i,k)
        enddo
        enddo
      endif

!----------

      if(ibw.eq.0)then
        call MPI_WAIT (reqs(1),status,ierr)
      endif

      if(ibe.eq.0)then
        call MPI_WAIT (reqs(3),status,ierr)
      endif

      if(ibn.eq.0)then
        call MPI_WAIT (reqs(5),status,ierr)
      endif

      if(ibs.eq.0)then
        call MPI_WAIT (reqs(7),status,ierr)
      endif

      if(timestats.ge.1) time_mps2=time_mps2+mytime()

!----------
!  patch for corner

      if( (ebc.eq.2.or.wbc.eq.2).and.(sbc.eq.1.or.nbc.eq.1) )then

        if(ibw.eq.1)then

          if(p2tchsww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nkp1
              t(0,0,k)=t(1,0,k)
            enddo
          endif

          if(p2tchnww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nkp1
              t(0,nj+1,k)=t(1,nj+1,k)
            enddo
          endif

        endif

        if(ibe.eq.1)then

          if(p2tchsee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nkp1
              t(ni+1,0,k)=t(ni,0,k)
            enddo
          endif

          if(p2tchnee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nkp1
              t(ni+1,nj+1,k)=t(ni,nj+1,k)
            enddo
          endif

        endif

      endif

      if( (ebc.eq.1.or.wbc.eq.1).and.(sbc.eq.2.or.nbc.eq.2) )then

        if(ibs.eq.1)then

          if(p2tchsws)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nkp1
              t(0,0,k)=t(0,1,k)
            enddo
          endif

          if(p2tchses)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nkp1
              t(ni+1,0,k)=t(ni+1,1,k)
            enddo
          endif

        endif

        if(ibn.eq.1)then

          if(p2tchnwn)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nkp1
              t(0,nj+1,k)=t(0,nj,k)
            enddo
          endif

          if(p2tchnen)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nkp1
              t(ni+1,nj+1,k)=t(ni+1,nj,k)
            enddo
          endif

        endif

      endif

      if(timestats.ge.1) time_bc=time_bc+mytime()

!----------

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 
      subroutine comm_1u_start(u,uw1,uw2,ue1,ue2,   &
                                 us1,us2,un1,un2,reqs)
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'mpif.h'
 
      real u(ib:ie+1,jb:je,kb:ke)
      real uw1(nj,nk),uw2(nj,nk)
      real ue1(nj,nk),ue2(nj,nk)
      real us1(ni+1,nk),us2(ni+1,nk)
      real un1(ni+1,nk),un2(ni+1,nk)
      integer reqs(8)
 
      integer i,j,k
      integer tag,count
 
!----

      nu=nu+1
      tag=1000+nu
      count=cs1we
 
        ! receive east
        if(ibe.eq.0)then
          call mpi_irecv(ue2,count,MPI_REAL,myeast,tag,   &
                        MPI_COMM_WORLD,reqs(2),ierr)
        endif

        ! send west
        if(ibw.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(j,k)
          do k=1,nk
          do j=1,nj
            uw1(j,k)=u(2,j,k)
          enddo
          enddo
          call mpi_isend(uw1,count,MPI_REAL,mywest,tag,   &
                         MPI_COMM_WORLD,reqs(1),ierr)
        endif

!----

      nu=nu+1
      tag=1000+nu
      count=cs1we
 
        ! receive west
        if(ibw.eq.0)then
          call mpi_irecv(uw2,count,MPI_REAL,mywest,tag,   &
                        MPI_COMM_WORLD,reqs(4),ierr)
        endif

        ! send east
        if(ibe.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(j,k)
          do k=1,nk
          do j=1,nj
            ue1(j,k)=u(ni,j,k)
          enddo
          enddo
          call mpi_isend(ue1,count,MPI_REAL,myeast,tag,   &
                         MPI_COMM_WORLD,reqs(3),ierr)
        endif

!----

      nu=nu+1
      tag=1000+nu
      count=cu1sn
 
        ! receive north
        if(ibn.eq.0)then
          call mpi_irecv(un2,count,MPI_REAL,mynorth,tag,   &
                        MPI_COMM_WORLD,reqs(6),ierr)
        endif

        ! send south
        if(ibs.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
          do k=1,nk
          do i=1,ni+1
            us1(i,k)=u(i,1,k)
          enddo
          enddo
          call mpi_isend(us1,count,MPI_REAL,mysouth,tag,   &
                         MPI_COMM_WORLD,reqs(5),ierr)
        endif

!----

      nu=nu+1
      tag=1000+nu
      count=cu1sn
 
        ! receive south
        if(ibs.eq.0)then
          call mpi_irecv(us2,count,MPI_REAL,mysouth,tag,   &
                        MPI_COMM_WORLD,reqs(8),ierr)
        endif

        ! send north
        if(ibn.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
          do k=1,nk
          do i=1,ni+1
            un1(i,k)=u(i,nj,k)
          enddo
          enddo
          call mpi_isend(un1,count,MPI_REAL,mynorth,tag,   &
                         MPI_COMM_WORLD,reqs(7),ierr)
        endif

!----

      if(timestats.ge.1) time_mpu1=time_mpu1+mytime()
 
      return
      end

!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 
      subroutine comm_1u_end(u,uw1,uw2,ue1,ue2,   &
                               us1,us2,un1,un2,reqs)
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'mpif.h'
 
      real u(ib:ie+1,jb:je,kb:ke)
      real uw1(nj,nk),uw2(nj,nk)
      real ue1(nj,nk),ue2(nj,nk)
      real us1(ni+1,nk),us2(ni+1,nk)
      real un1(ni+1,nk),un2(ni+1,nk)
      integer reqs(8)
 
      integer i,j,k
      integer status(MPI_STATUS_SIZE)

!-----
 
      if(ibe.eq.0)then
        call MPI_WAIT (reqs(2),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(j,k)
        do k=1,nk
        do j=1,nj
          u(ni+2,j,k)=ue2(j,k)
        enddo
        enddo
      endif
 
      if(ibw.eq.0)then
        call MPI_WAIT (reqs(4),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(j,k)
        do k=1,nk
        do j=1,nj
          u(0,j,k)=uw2(j,k)
        enddo
        enddo
      endif

!-----
 
      if(ibn.eq.0)then
        call MPI_WAIT (reqs(6),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,k)
        do k=1,nk
        do i=1,ni+1
          u(i,nj+1,k)=un2(i,k)
        enddo
        enddo
      endif
 
      if(ibs.eq.0)then
        call MPI_WAIT (reqs(8),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,k)
        do k=1,nk
        do i=1,ni+1
          u(i,0,k)=us2(i,k)
        enddo
        enddo
      endif

!-----

      if(ibw.eq.0)then
        call MPI_WAIT (reqs(1),status,ierr)
      endif

      if(ibe.eq.0)then
        call MPI_WAIT (reqs(3),status,ierr)
      endif

      if(ibs.eq.0)then
        call MPI_WAIT (reqs(5),status,ierr)
      endif

      if(ibn.eq.0)then
        call MPI_WAIT (reqs(7),status,ierr)
      endif

      if(timestats.ge.1) time_mpu2=time_mpu2+mytime()

!----------
!  patch for corner
 
      if( (ebc.eq.2.or.wbc.eq.2).and.(sbc.eq.1.or.nbc.eq.1) )then
 
        if(ibw.eq.1)then
 
          if(p2tchsww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              u(0,0,k)=u(1,0,k)
            enddo
          endif
 
          if(p2tchnww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              u(0,nj+1,k)=u(1,nj+1,k)
            enddo
          endif
 
        endif
 
        if(ibe.eq.1)then
 
          if(p2tchsee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              u(ni+2,0,k)=u(ni+1,0,k)
            enddo
          endif
 
          if(p2tchnee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              u(ni+2,nj+1,k)=u(ni+1,nj+1,k)
            enddo
          endif
 
        endif
 
      endif

      if( (ebc.eq.1.or.wbc.eq.1).and.(sbc.eq.2.or.nbc.eq.2) )then
 
        if(ibs.eq.1)then
 
          if(p2tchsws)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              u(0,0,k)=u(0,1,k)
            enddo
          endif
 
          if(p2tchses)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              u(ni+2,0,k)=u(ni+2,1,k)
            enddo
          endif
 
        endif
 
        if(ibn.eq.1)then
 
          if(p2tchnwn)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              u(0,nj+1,k)=u(0,nj,k)
            enddo
          endif
 
          if(p2tchnen)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              u(ni+2,nj+1,k)=u(ni+2,nj,k)
            enddo
          endif
 
        endif
 
      endif

!-----------------------------------------------------------
!  Mirror b.c. patch
!
!      if(ibn.eq.1)then
!!$omp parallel do default(shared)   &
!!$omp private(i,k)
!        do k=1,nk
!        do i=0,ni+2
!          u(i,nj+1,k)=u(i,nj  ,k)
!          u(i,nj+2,k)=u(i,nj-1,k)
!          u(i,nj+3,k)=u(i,nj-2,k)
!        enddo
!        enddo
!      endif
!
!      if(ibw.eq.1)then
!!$omp parallel do default(shared)   &
!!$omp private(i,k)
!        do k=1,nk
!        do j=0,nj+1
!          u(-2,j,k)=-u(4,j,k)
!          u(-1,j,k)=-u(3,j,k)
!          u( 0,j,k)=-u(2,j,k)
!          u( 1,j,k)=0.0
!        enddo
!        enddo
!      endif
!
!-----------------------------------------------------------
 
      if(timestats.ge.1) time_bc=time_bc+mytime()
 
!----------
 
      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 
      subroutine comm_1v_start(v,vw1,vw2,ve1,ve2,   &
                                 vs1,vs2,vn1,vn2,reqs)
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'mpif.h'
 
      real v(ib:ie,jb:je+1,kb:ke)
      real vw1(nj+1,nk),vw2(nj+1,nk)
      real ve1(nj+1,nk),ve2(nj+1,nk)
      real vs1(ni,nk),vs2(ni,nk)
      real vn1(ni,nk),vn2(ni,nk)
      integer reqs(8)
 
      integer i,j,k
      integer tag,count

!-----
 
      nv=nv+1
      tag=2000+nv
      count=cv1we
 
        ! receive east
        if(ibe.eq.0)then
          call mpi_irecv(ve2,count,MPI_REAL,myeast,tag,   &
                        MPI_COMM_WORLD,reqs(2),ierr)
        endif

        ! send west
        if(ibw.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(j,k)
          do k=1,nk
          do j=1,nj+1
            vw1(j,k)=v(1,j,k)
          enddo
          enddo
          call mpi_isend(vw1,count,MPI_REAL,mywest,tag,   &
                         MPI_COMM_WORLD,reqs(1),ierr)
        endif

!-----

 
      nv=nv+1
      tag=2000+nv
      count=cv1we
 
        ! receive west
        if(ibw.eq.0)then
          call mpi_irecv(vw2,count,MPI_REAL,mywest,tag,   &
                        MPI_COMM_WORLD,reqs(4),ierr)
        endif

        ! send east
        if(ibe.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(j,k)
          do k=1,nk
          do j=1,nj+1
            ve1(j,k)=v(ni,j,k)
          enddo
          enddo
          call mpi_isend(ve1,count,MPI_REAL,myeast,tag,   &
                         MPI_COMM_WORLD,reqs(3),ierr)
        endif

!-----

 
      nv=nv+1
      tag=2000+nv
      count=cs1sn

        ! receive north
        if(ibn.eq.0)then
          call mpi_irecv(vn2,count,MPI_REAL,mynorth,tag,   &
                        MPI_COMM_WORLD,reqs(6),ierr)
        endif
 
        ! send south
        if(ibs.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
          do k=1,nk
          do i=1,ni
            vs1(i,k)=v(i,2,k)
          enddo
          enddo
          call mpi_isend(vs1,count,MPI_REAL,mysouth,tag,   &
                         MPI_COMM_WORLD,reqs(5),ierr)
        endif
 
!-----

 
      nv=nv+1
      tag=2000+nv
      count=cs1sn
 
        ! receive south
        if(ibs.eq.0)then
          call mpi_irecv(vs2,count,MPI_REAL,mysouth,tag,   &
                        MPI_COMM_WORLD,reqs(8),ierr)
        endif

        ! send north
        if(ibn.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
          do k=1,nk
          do i=1,ni
            vn1(i,k)=v(i,nj,k)
          enddo
          enddo
          call mpi_isend(vn1,count,MPI_REAL,mynorth,tag,   &
                         MPI_COMM_WORLD,reqs(7),ierr)
        endif
 
!-----

      if(timestats.ge.1) time_mpv1=time_mpv1+mytime()
 
      return
      end

!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 
      subroutine comm_1v_end(v,vw1,vw2,ve1,ve2,   &
                               vs1,vs2,vn1,vn2,reqs)
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'mpif.h'

      real v(ib:ie,jb:je+1,kb:ke)
      real vw1(nj+1,nk),vw2(nj+1,nk)
      real ve1(nj+1,nk),ve2(nj+1,nk)
      real vs1(ni,nk),vs2(ni,nk)
      real vn1(ni,nk),vn2(ni,nk)
      integer reqs(8)
 
      integer i,j,k
      integer status(MPI_STATUS_SIZE)

!-----

      if(ibe.eq.0)then
        call MPI_WAIT (reqs(2),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(j,k)
        do k=1,nk
        do j=1,nj+1
          v(ni+1,j,k)=ve2(j,k)
        enddo
        enddo
      endif
 
      if(ibw.eq.0)then
        call MPI_WAIT (reqs(4),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(j,k)
        do k=1,nk
        do j=1,nj+1
          v(0,j,k)=vw2(j,k)
        enddo
        enddo
      endif
 
!-----
 
      if(ibn.eq.0)then
        call MPI_WAIT (reqs(6),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,k)
        do k=1,nk
        do i=1,ni
          v(i,nj+2,k)=vn2(i,k)
        enddo
        enddo
      endif
 
      if(ibs.eq.0)then
        call MPI_WAIT (reqs(8),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,k)
        do k=1,nk
        do i=1,ni
          v(i,0,k)=vs2(i,k)
        enddo
        enddo
      endif

!-----

      if(ibw.eq.0)then
        call MPI_WAIT (reqs(1),status,ierr)
      endif

      if(ibe.eq.0)then
        call MPI_WAIT (reqs(3),status,ierr)
      endif

      if(ibs.eq.0)then
        call MPI_WAIT (reqs(5),status,ierr)
      endif

      if(ibn.eq.0)then
        call MPI_WAIT (reqs(7),status,ierr)
      endif

      if(timestats.ge.1) time_mpv2=time_mpv2+mytime()

!----------
!  patch for corner
 
      if( (ebc.eq.2.or.wbc.eq.2).and.(sbc.eq.1.or.nbc.eq.1) )then
 
        if(ibw.eq.1)then
 
          if(p2tchsww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              v(0,0,k)=v(1,0,k)
            enddo
          endif
 
          if(p2tchnww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              v(0,nj+2,k)=v(1,nj+2,k)
            enddo
          endif
 
        endif
 
        if(ibe.eq.1)then
 
          if(p2tchsee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              v(ni+1,0,k)=v(ni,0,k)
            enddo
          endif
 
          if(p2tchnee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              v(ni+1,nj+2,k)=v(ni,nj+2,k)
            enddo
          endif
 
        endif
 
      endif

      if( (ebc.eq.1.or.wbc.eq.1).and.(sbc.eq.2.or.nbc.eq.2) )then
 
        if(ibs.eq.1)then
 
          if(p2tchsws)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              v(0,0,k)=v(0,1,k)
            enddo
          endif
 
          if(p2tchses)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              v(ni+1,0,k)=v(ni+1,1,k)
            enddo
          endif
 
        endif
 
        if(ibn.eq.1)then
 
          if(p2tchnwn)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              v(0,nj+2,k)=v(0,nj+1,k)
            enddo
          endif
 
          if(p2tchnen)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=1,nk
              v(ni+1,nj+2,k)=v(ni+1,nj+1,k)
            enddo
          endif
 
        endif
 
      endif

!-----------------------------------------------------------
!  Mirror b.c. patch
!
!      if(ibn.eq.1)then
!!$omp parallel do default(shared)   &
!!$omp private(i,k)
!        do k=1,nk
!        do i=0,ni+1
!          v(i,nj+1,k)=0.0
!          v(i,nj+2,k)=-v(i,nj  ,k)
!          v(i,nj+3,k)=-v(i,nj-1,k)
!          v(i,nj+4,k)=-v(i,nj-2,k)
!        enddo
!        enddo
!      endif
!
!      if(ibw.eq.1)then
!!$omp parallel do default(shared)   &
!!$omp private(i,k)
!        do k=1,nk
!        do j=0,nj+2
!          v(-2,j,k)=v(3,j,k)
!          v(-1,j,k)=v(2,j,k)
!          v( 0,j,k)=v(1,j,k)
!        enddo
!        enddo
!      endif
!
!-----------------------------------------------------------
 
      if(timestats.ge.1) time_bc=time_bc+mytime()
 
!----------

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 
      subroutine comm_1w_start(w,ww1,ww2,we1,we2,   &
                                 ws1,ws2,wn1,wn2,reqs)
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'mpif.h'
 
      real w(ib:ie,jb:je,kb:ke+1)
      real ww1(nj,nk-1),ww2(nj,nk-1)
      real we1(nj,nk-1),we2(nj,nk-1)
      real ws1(ni,nk-1),ws2(ni,nk-1)
      real wn1(ni,nk-1),wn2(ni,nk-1)
      integer reqs(8)
 
      integer i,j,k
      integer tag,count

!-----

      nw=nw+1
      tag=3000+nw
      count=cw1we
 
        ! receive east
        if(ibe.eq.0)then
          call mpi_irecv(we2,count,MPI_REAL,myeast,tag,   &
                        MPI_COMM_WORLD,reqs(2),ierr)
        endif

        ! send west
        if(ibw.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(j,k)
          do k=2,nk
          do j=1,nj
            ww1(j,k-1)=w(1,j,k)
          enddo
          enddo
          call mpi_isend(ww1,count,MPI_REAL,mywest,tag,   &
                         MPI_COMM_WORLD,reqs(1),ierr)
        endif

!-----

      nw=nw+1
      tag=3000+nw
      count=cw1we
 
        ! receive west
        if(ibw.eq.0)then
          call mpi_irecv(ww2,count,MPI_REAL,mywest,tag,   &
                        MPI_COMM_WORLD,reqs(4),ierr)
        endif

        ! send east
        if(ibe.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(j,k)
          do k=2,nk
          do j=1,nj
            we1(j,k-1)=w(ni,j,k)
          enddo
          enddo
          call mpi_isend(we1,count,MPI_REAL,myeast,tag,   &
                         MPI_COMM_WORLD,reqs(3),ierr)
        endif

!-----

      nw=nw+1
      tag=3000+nw
      count=cw1sn
 
        ! receive north
        if(ibn.eq.0)then
          call mpi_irecv(wn2,count,MPI_REAL,mynorth,tag,   &
                        MPI_COMM_WORLD,reqs(6),ierr)
        endif

        ! send south
        if(ibs.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
          do k=2,nk
          do i=1,ni
            ws1(i,k-1)=w(i,1,k)
          enddo
          enddo
          call mpi_isend(ws1,count,MPI_REAL,mysouth,tag,   &
                         MPI_COMM_WORLD,reqs(5),ierr)
        endif

!-----

      nw=nw+1
      tag=3000+nw
      count=cw1sn
 
        ! receive south
        if(ibs.eq.0)then
          call mpi_irecv(ws2,count,MPI_REAL,mysouth,tag,   &
                        MPI_COMM_WORLD,reqs(8),ierr)
        endif

        ! send north
        if(ibn.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
          do k=2,nk
          do i=1,ni
            wn1(i,k-1)=w(i,nj,k)
          enddo
          enddo
          call mpi_isend(wn1,count,MPI_REAL,mynorth,tag,   &
                         MPI_COMM_WORLD,reqs(7),ierr)
        endif

!-----

      if(timestats.ge.1) time_mpw1=time_mpw1+mytime()
 
      return
      end

!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 
      subroutine comm_1w_end(w,ww1,ww2,we1,we2,   &
                               ws1,ws2,wn1,wn2,reqs)
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'mpif.h'
 
      real w(ib:ie,jb:je,kb:ke+1)
      real ww1(nj,nk-1),ww2(nj,nk-1)
      real we1(nj,nk-1),we2(nj,nk-1)
      real ws1(ni,nk-1),ws2(ni,nk-1)
      real wn1(ni,nk-1),wn2(ni,nk-1)
      integer reqs(8)
 
      integer i,j,k
      integer status(MPI_STATUS_SIZE)
 
!-----

      if(ibe.eq.0)then
        call MPI_WAIT (reqs(2),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(j,k)
        do k=2,nk
        do j=1,nj
          w(ni+1,j,k)=we2(j,k-1)
        enddo
        enddo
      endif
 
      if(ibw.eq.0)then
        call MPI_WAIT (reqs(4),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(j,k)
        do k=2,nk
        do j=1,nj
          w(0,j,k)=ww2(j,k-1)
        enddo
        enddo
      endif
 
!-----
 
      if(ibn.eq.0)then
        call MPI_WAIT (reqs(6),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,k)
        do k=2,nk
        do i=1,ni
          w(i,nj+1,k)=wn2(i,k-1)
        enddo
        enddo
      endif
 
      if(ibs.eq.0)then
        call MPI_WAIT (reqs(8),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,k)
        do k=2,nk
        do i=1,ni
          w(i,0,k)=ws2(i,k-1)
        enddo
        enddo
      endif

!-----

      if(ibw.eq.0)then
        call MPI_WAIT (reqs(1),status,ierr)
      endif

      if(ibe.eq.0)then
        call MPI_WAIT (reqs(3),status,ierr)
      endif

      if(ibs.eq.0)then
        call MPI_WAIT (reqs(5),status,ierr)
      endif

      if(ibn.eq.0)then
        call MPI_WAIT (reqs(7),status,ierr)
      endif

      if(timestats.ge.1) time_mpw2=time_mpw2+mytime()

!----------
!  patch for corner
 
      if( (ebc.eq.2.or.wbc.eq.2).and.(sbc.eq.1.or.nbc.eq.1) )then
 
        if(ibw.eq.1)then
 
          if(p2tchsww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=2,nk
              w(0,0,k)=w(1,0,k)
            enddo
          endif
 
          if(p2tchnww)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=2,nk
              w(0,nj+1,k)=w(1,nj+1,k)
            enddo
          endif
 
        endif
 
        if(ibe.eq.1)then
 
          if(p2tchsee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=2,nk
              w(ni+1,0,k)=w(ni,0,k)
            enddo
          endif
 
          if(p2tchnee)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=2,nk
              w(ni+1,nj+1,k)=w(ni,nj+1,k)
            enddo
          endif
 
        endif
 
      endif

      if( (ebc.eq.1.or.wbc.eq.1).and.(sbc.eq.2.or.nbc.eq.2) )then
 
        if(ibs.eq.1)then
 
          if(p2tchsws)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=2,nk
              w(0,0,k)=w(0,1,k)
            enddo
          endif
 
          if(p2tchses)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=2,nk
              w(ni+1,0,k)=w(ni+1,1,k)
            enddo
          endif
 
        endif
 
        if(ibn.eq.1)then
 
          if(p2tchnwn)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=2,nk
              w(0,nj+1,k)=w(0,nj,k)
            enddo
          endif
 
          if(p2tchnen)then
!$omp parallel do default(shared)   &
!$omp private(k)
            do k=2,nk
              w(ni+1,nj+1,k)=w(ni+1,nj,k)
            enddo
          endif
 
        endif
 
      endif

!-----------------------------------------------------------
!  Mirror b.c. patch
!
!      if(ibn.eq.1)then
!!$omp parallel do default(shared)   &
!!$omp private(i,k)
!        do k=2,nk
!        do i=0,ni+1
!          w(i,nj+1,k)=w(i,nj  ,k)
!          w(i,nj+2,k)=w(i,nj-1,k)
!          w(i,nj+3,k)=w(i,nj-2,k)
!        enddo
!        enddo
!      endif
!
!      if(ibw.eq.1)then
!!$omp parallel do default(shared)   &
!!$omp private(i,k)
!        do k=2,nk
!        do j=0,nj+1
!          w(-2,j,k)=w(3,j,k)
!          w(-1,j,k)=w(2,j,k)
!          w( 0,j,k)=w(1,j,k)
!        enddo
!        enddo
!      endif
!
!-----------------------------------------------------------
 
      if(timestats.ge.1) time_bc=time_bc+mytime()
 
!----------

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine comm_2d_start(s,west,newwest,east,neweast,   &
                                 south,newsouth,north,newnorth,reqs)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'mpif.h'

      real, dimension(ib:ie,jb:je) :: s
      real, dimension(3,nj) :: west,newwest,east,neweast
      real, dimension(ni,3) :: south,newsouth,north,newnorth
      integer reqs(8)

      integer i,j
      integer tag,count

!------------------------------------------------

      count=3*nj
      nf=nf+1
      tag=nf

      ! receive east
      if(ibe.eq.0)then
        call mpi_irecv(neweast,count,MPI_REAL,myeast,tag,   &
                      MPI_COMM_WORLD,reqs(2),ierr)
      endif

      ! send west
      if(ibw.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj
        do i=1,3
          west(i,j)=s(i,j)
        enddo
        enddo
        call mpi_isend(west,count,MPI_REAL,mywest,tag,   &
                       MPI_COMM_WORLD,reqs(1),ierr)
      endif

!----------

      count=3*nj
      nf=nf+1
      tag=nf

      ! receive west
      if(ibw.eq.0)then
        call mpi_irecv(newwest,count,MPI_REAL,mywest,tag,   &
                      MPI_COMM_WORLD,reqs(4),ierr)
      endif

      ! send east
      if(ibe.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj
        do i=1,3
          east(i,j)=s(ni-3+i,j)
        enddo
        enddo
        call mpi_isend(east,count,MPI_REAL,myeast,tag,   &
                       MPI_COMM_WORLD,reqs(3),ierr)
      endif

!----------

      count=ni*3
      nf=nf+1
      tag=nf

      ! receive south
      if(ibs.eq.0)then
        call mpi_irecv(newsouth,count,MPI_REAL,mysouth,tag,   &
                      MPI_COMM_WORLD,reqs(6),ierr)
      endif

      ! send north
      if(ibn.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,3
        do i=1,ni
          north(i,j)=s(i,nj-3+j)
        enddo
        enddo
        call mpi_isend(north,count,MPI_REAL,mynorth,tag,   &
                       MPI_COMM_WORLD,reqs(5),ierr)
      endif

!----------

      count=ni*3
      nf=nf+1
      tag=nf

      ! receive north
      if(ibn.eq.0)then
        call mpi_irecv(newnorth,count,MPI_REAL,mynorth,tag,   &
                      MPI_COMM_WORLD,reqs(8),ierr)
      endif

      ! send south
      if(ibs.eq.0)then
!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,3
        do i=1,ni
          south(i,j)=s(i,j)
        enddo
        enddo
        call mpi_isend(south,count,MPI_REAL,mysouth,tag,   &
                       MPI_COMM_WORLD,reqs(7),ierr)
      endif

!----------

      if(timestats.ge.1) time_mpq1=time_mpq1+mytime()

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine comm_2dew_end(s,west,newwest,east,neweast,reqs)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'mpif.h'

      real, dimension(ib:ie,jb:je) :: s
      real, dimension(3,nj) :: west,newwest,east,neweast
      integer reqs(8)

      integer i,j
      integer status(MPI_STATUS_SIZE)

!-------------------------------------------------------------------

      if(ibe.eq.0)then
        call MPI_WAIT (reqs(2),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj
        do i=1,3
          s(ni+i,j)=neweast(i,j)
        enddo
        enddo
      endif

      if(ibw.eq.0)then
        call MPI_WAIT (reqs(4),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj
        do i=1,3
          s(i-3,j)=newwest(i,j)
        enddo
        enddo
      endif

!----------

      if(timestats.ge.1) time_mpq2=time_mpq2+mytime()

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine comm_2dns_end(s,south,newsouth,north,newnorth,reqs)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'mpif.h'

      real, dimension(ib:ie,jb:je) :: s
      real, dimension(ni,3) :: south,newsouth,north,newnorth
      integer reqs(8)

      integer i,j
      integer status(MPI_STATUS_SIZE)

!-------------------------------------------------------------------

      if(ibs.eq.0)then
        call MPI_WAIT (reqs(6),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,3
        do i=1,ni
          s(i,j-3)=newsouth(i,j)
        enddo
        enddo
      endif

      if(ibn.eq.0)then
        call MPI_WAIT (reqs(8),status,ierr)
!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,3
        do i=1,ni
          s(i,nj+j)=newnorth(i,j)
        enddo
        enddo
      endif

!----------

      if(ibw.eq.0)then
        call MPI_WAIT (reqs(1),status,ierr)
      endif

      if(ibe.eq.0)then
        call MPI_WAIT (reqs(3),status,ierr)
      endif

      if(ibn.eq.0)then
        call MPI_WAIT (reqs(5),status,ierr)
      endif

      if(ibs.eq.0)then
        call MPI_WAIT (reqs(7),status,ierr)
      endif

!----------

      if(timestats.ge.1) time_mpq2=time_mpq2+mytime()

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine comm_2d_corner(s)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'mpif.h'

      real, dimension(ib:ie,jb:je) :: s

      integer reqs(8),status(MPI_STATUS_SIZE)
      real :: nw1,nw2,ne1,ne2,sw1,sw2,se1,se2
      integer tag,count

!-----

      tag=5001
      count=1

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call mpi_irecv(nw2,count,MPI_REAL,mynw,tag,MPI_COMM_WORLD,   &
                       reqs(2),ierr)
      endif

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        se1=s(ni,1)
        call mpi_isend(se1,count,MPI_REAL,myse,tag,MPI_COMM_WORLD,   &
                       reqs(1),ierr)
      endif

!-----

      tag=5002
      count=1

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call mpi_irecv(sw2,count,MPI_REAL,mysw,tag,MPI_COMM_WORLD,   &
                       reqs(4),ierr)
      endif

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        ne1=s(ni,nj)
        call mpi_isend(ne1,count,MPI_REAL,myne,tag,MPI_COMM_WORLD,   &
                       reqs(3),ierr)
      endif

!-----

      tag=5003
      count=1

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call mpi_irecv(ne2,count,MPI_REAL,myne,tag,MPI_COMM_WORLD,   &
                       reqs(6),ierr)
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        sw1=s(1,1)
        call mpi_isend(sw1,count,MPI_REAL,mysw,tag,MPI_COMM_WORLD,   &
                       reqs(5),ierr)
      endif

!-----

      tag=5004
      count=1

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call mpi_irecv(se2,count,MPI_REAL,myse,tag,MPI_COMM_WORLD,   &
                       reqs(8),ierr)
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        nw1=s(1,nj)
        call mpi_isend(nw1,count,MPI_REAL,mynw,tag,MPI_COMM_WORLD,   &
                       reqs(7),ierr)
      endif

!-----

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call MPI_WAIT (reqs(2),status,ierr)
        s(0,nj+1)=nw2
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call MPI_WAIT (reqs(4),status,ierr)
        s(0,0)=sw2
      endif

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call MPI_WAIT (reqs(6),status,ierr)
        s(ni+1,nj+1)=ne2
      endif

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call MPI_WAIT (reqs(8),status,ierr)
        s(ni+1,0)=se2
      endif

!-----

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call MPI_WAIT (reqs(1),status,ierr)
      endif

      if((ibe.eq.0.or.ibe.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call MPI_WAIT (reqs(3),status,ierr)
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibs.eq.0.or.ibs.eq.2))then
        call MPI_WAIT (reqs(5),status,ierr)
      endif

      if((ibw.eq.0.or.ibw.eq.2) .and. (ibn.eq.0.or.ibn.eq.2))then
        call MPI_WAIT (reqs(7),status,ierr)
      endif

!-----

      if(timestats.ge.1) time_mptk1=time_mptk1+mytime()

      return
      end


!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine fincomm(qa,q3d,qw1,qw2,qe1,qe2,   &
                                qs1,qs2,qn1,qn2,reqs_q)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, dimension(ib:ie,jb:je,kb:ke) :: qa,q3d
      real, dimension(3,nj,nk) :: qw1,qw2,qe1,qe2
      real, dimension(ni,3,nk) :: qs1,qs2,qn1,qn2
      integer, dimension(8) :: reqs_q

      integer i,j,k

!-----------------------------------------------------------------

      call comm_3s_end(q3d,qw1,qw2,qe1,qe2,   &
                           qs1,qs2,qn1,qn2,reqs_q)

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=0,nk+1
      do j=0,nj+1
      do i=0,ni+1
        qa(i,j,k)=q3d(i,j,k)
      enddo
      enddo
      enddo
      if(timestats.ge.1) time_integ=time_integ+mytime()

!-----------------------------------------------------------------

      return
      end


#endif
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine prepcorners(s)
      implicit none

      include 'input.incl'

      real, dimension(ib:ie,jb:je,kb:ke) :: s

      integer :: i,j

#ifdef MPI
      call getcorner(s)
      call bcs2(s)
#endif
      do j=0,nj+1
      do i=0,ni+1
        s(i,j,0)    = s(i,j,1)
        s(i,j,nk+1) = s(i,j,nk)
      enddo
      enddo

      return
      end



diff2.F/        1298670057  19071 8000  100644  21122     `


      subroutine diff2u(flag,rxh,uh,xf,uf,vh,vf,mh,mf,dumx,dumy,diffx,diffy,epsd,ua,uten)
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      integer flag
      real, dimension(ib:ie) :: rxh,uh
      real, dimension(ib:ie+1) :: xf,uf
      real, dimension(jb:je) :: vh
      real, dimension(jb:je+1) :: vf
      real, dimension(ib:ie,jb:je,kb:ke) :: mh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, dimension(ib:ie,jb:je,kb:ke) :: dumx,dumy,diffx,diffy,epsd
      real, dimension(ib:ie+1,jb:je,kb:ke) :: ua,uten

      integer i,j,k
      real coef

!--------------------------
!
!  flag = 1 does 2nd order artificial diffusion
!  flag = 2 does dns viscosity term
!
!-----------------------------------------------------------------------
!  x-direction

      if(flag.eq.1)then
        coef=kdiff2
      elseif(flag.eq.2)then
        coef=viscosity
      endif

    IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=0,ni+1
        dumx(i,j,k)=(ua(i+1,j,k)-ua(i,j,k))*rdx*uh(i)
      enddo
      enddo
      enddo

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=0,ni+1
        dumx(i,j,k)=(xf(i+1)*ua(i+1,j,k)-xf(i)*ua(i,j,k))*rdx*uh(i)*rxh(i)
      enddo
      enddo
      enddo

    ENDIF

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni+1
        diffx(i,j,k)=coef*(dumx(i,j,k)-dumx(i-1,j,k))*rdx*uf(i)
      enddo
      enddo
      enddo

!-----------------------------------------------------------------------
!  y-direction

      if(flag.eq.1)then
        coef=kdiff2
      elseif(flag.eq.2)then
        coef=viscosity
      endif

    IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj+1
      do i=1,ni+1
        dumy(i,j,k)=(ua(i,j,k)-ua(i,j-1,k))*rdy*vf(j)
      enddo
      enddo
      enddo
 
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni+1
        diffy(i,j,k)=coef*(dumy(i,j+1,k)-dumy(i,j,k))*rdy*vh(j)
      enddo
      enddo
      enddo

    ELSE
 
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj+1
      do i=1,ni+1
        dumy(i,j,k)=0.0
        diffy(i,j,k)=0.0
      enddo
      enddo
      enddo

    ENDIF

!-----------------------------------------------------------------------

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni+1
        uten(i,j,k)=uten(i,j,k)+diffx(i,j,k)+diffy(i,j,k)
      enddo
      enddo
      enddo

      IF(idiss.eq.1)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          epsd(i,j,k)=epsd(i,j,k)+coef*( (dumx(i,j,k)**2)       &
                +0.25*( (dumy(i  ,j,k)**2+dumy(i  ,j+1,k)**2)   &
                       +(dumy(i+1,j,k)**2+dumy(i+1,j+1,k)**2) ) )
        enddo
        enddo
        enddo
      ENDIF

!-----------------------------------------------------------------------
!  z-direction

      IF(vdiff.eq.1.or.flag.eq.2)THEN

        if(flag.eq.1)then
          coef=kdiff2
        elseif(flag.eq.2)then
          coef=viscosity
        endif

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=1,ni+1
          dumx(i,j,k)=(ua(i,j,k)-ua(i,j,k-1))*rdz*0.5*(mf(i-1,j,k)+mf(i,j,k))
        enddo
        enddo
        enddo

        IF(flag.eq.1)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j)
          do j=1,nj
          do i=1,ni+1
            dumx(i,j,1)=0.0
            dumx(i,j,nk+1)=0.0
          enddo
          enddo

        ELSEIF(flag.eq.2)THEN

          if(bc_wind.eq.1)then      ! free slip b.c.

!$omp parallel do default(shared)   &
!$omp private(i,j)
            do j=1,nj
            do i=1,ni+1
              dumx(i,j,1)=0.0
              dumx(i,j,nk+1)=0.0
            enddo
            enddo

          elseif(bc_wind.eq.2)then      ! no slip b.c.

!$omp parallel do default(shared)   &
!$omp private(i,j)
            do j=1,nj
            do i=1,ni+1
              dumx(i,j,1)=2.0*ua(i,j,1)*rdz*0.5*(mf(i-1,j,1)+mf(i,j,1))
            enddo
            enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
            do j=1,nj
            do i=1,ni+1
              dumx(i,j,nk+1)=-2.0*ua(i,j,nk)*rdz*0.5*(mf(i-1,j,nk+1)+mf(i,j,nk+1))
            enddo
            enddo

          endif

        ENDIF
 
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni+1
          uten(i,j,k)=uten(i,j,k)+coef*(dumx(i,j,k+1)-dumx(i,j,k))*rdz*0.5*(mh(i-1,j,k)+mh(i,j,k))
        enddo
        enddo
        enddo

        IF(idiss.eq.1)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            epsd(i,j,k)=epsd(i,j,k)+0.25*coef*(               &
                          (dumx(i,j,k  )**2+dumx(i+1,j,k  )**2)   &
                         +(dumx(i,j,k+1)**2+dumx(i+1,j,k+1)**2)   &
                                              )
          enddo
          enddo
          enddo
        ENDIF

      ENDIF

!-----------------------------------------------------------------------

      if(timestats.ge.1) time_diffu=time_diffu+mytime()

      return
      end


!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC


      subroutine diff2v(flag,xh,uh,rxf,uf,vh,vf,mh,mf,dumx,dumy,diffx,diffy,epsd,va,vten)
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      integer flag
      real, dimension(ib:ie) :: xh,uh
      real, dimension(ib:ie+1) :: rxf,uf
      real, dimension(jb:je) :: vh
      real, dimension(jb:je+1) :: vf
      real, dimension(ib:ie,jb:je,kb:ke) :: mh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, dimension(ib:ie,jb:je,kb:ke) :: dumx,dumy,diffx,diffy,epsd
      real, dimension(ib:ie,jb:je+1,kb:ke) :: va,vten
 
      integer i,j,k
      real coef
 
!--------------------------
!
!  flag = 1 does 2nd order artificial diffusion
!  flag = 2 does dns viscosity term
!
!-----------------------------------------------------------------------
!  x-direction

      if(flag.eq.1)then
        coef=kdiff2
      elseif(flag.eq.2)then
        coef=viscosity
      endif

    IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj+1
      do i=1,ni+1
        dumx(i,j,k)=(va(i,j,k)-va(i-1,j,k))*rdx*uf(i)
      enddo
      enddo
      enddo

    ELSE

!$omp parallel do default(shared)   &
!$omp private(j,k)
      do k=1,nk
      do j=1,nj+1
        dumx(1,j,k)=0.0
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj+1
      do i=2,ni+1
        dumx(i,j,k)=(xh(i)*va(i,j,k)-xh(i-1)*va(i-1,j,k))*rdx*uf(i)*rxf(i)
      enddo
      enddo
      enddo

    ENDIF
 
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj+1
      do i=1,ni
        diffx(i,j,k)=coef*(dumx(i+1,j,k)-dumx(i,j,k))*rdx*uh(i)
      enddo
      enddo
      enddo

!-----------------------------------------------------------------------
!  y-direction

      if(flag.eq.1)then
        coef=kdiff2
      elseif(flag.eq.2)then
        coef=viscosity
      endif

    IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=0,nj+1
      do i=1,ni
        dumy(i,j,k)=(va(i,j+1,k)-va(i,j,k))*rdy*vh(j)
      enddo
      enddo
      enddo
 
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj+1
      do i=1,ni
        diffy(i,j,k)=coef*(dumy(i,j,k)-dumy(i,j-1,k))*rdy*vf(j)
      enddo
      enddo
      enddo

    ELSE
 
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=0,nj+1
      do i=1,ni
        dumy(i,j,k)=0.0
        diffy(i,j,k)=0.0
      enddo
      enddo
      enddo

    ENDIF

!-----------------------------------------------------------------------

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj+1
      do i=1,ni
        vten(i,j,k)=vten(i,j,k)+diffx(i,j,k)+diffy(i,j,k)
      enddo
      enddo
      enddo

      IF(idiss.eq.1)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          epsd(i,j,k)=epsd(i,j,k)+coef*( (dumy(i,j,k)**2)       &
                +0.25*( (dumx(i,j  ,k)**2+dumx(i+1,j  ,k)**2)   &
                       +(dumx(i,j+1,k)**2+dumx(i+1,j+1,k)**2) ) )
        enddo
        enddo
        enddo
      ENDIF

!-----------------------------------------------------------------------
!  z-direction

      IF(vdiff.eq.1.or.flag.eq.2)THEN

        if(flag.eq.1)then
          coef=kdiff2
        elseif(flag.eq.2)then
          coef=viscosity
        endif

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj+1
        do i=1,ni
          dumx(i,j,k)=(va(i,j,k)-va(i,j,k-1))*rdz*0.5*(mf(i,j-1,k)+mf(i,j,k))
        enddo
        enddo
        enddo

        IF(flag.eq.1)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j)
          do j=1,nj+1
          do i=1,ni
            dumx(i,j,1)=0.0
            dumx(i,j,nk+1)=0.0
          enddo
          enddo

        ELSEIF(flag.eq.2)THEN

          if(bc_wind.eq.1)then      ! free slip b.c.

!$omp parallel do default(shared)   &
!$omp private(i,j)
            do j=1,nj+1
            do i=1,ni
              dumx(i,j,1)=0.0
              dumx(i,j,nk+1)=0.0
            enddo
            enddo

          elseif(bc_wind.eq.2)then      ! no slip b.c.

!$omp parallel do default(shared)   &
!$omp private(i,j)
            do j=1,nj+1
            do i=1,ni
              dumx(i,j,1)=2.0*va(i,j,1)*rdz*0.5*(mf(i,j-1,1)+mf(i,j,1))
            enddo
            enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
            do j=1,nj+1
            do i=1,ni
              dumx(i,j,nk+1)=-2.0*va(i,j,nk)*rdz*0.5*(mf(i,j-1,nk+1)+mf(i,j,nk+1))
            enddo
            enddo

          endif

        ENDIF

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj+1
        do i=1,ni
          vten(i,j,k)=vten(i,j,k)+coef*(dumx(i,j,k+1)-dumx(i,j,k))*rdz*0.5*(mh(i,j-1,k)+mh(i,j,k))
        enddo
        enddo
        enddo

        IF(idiss.eq.1)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            epsd(i,j,k)=epsd(i,j,k)+0.25*coef*(               &
                          (dumx(i,j,k  )**2+dumx(i,j+1,k  )**2)   &
                         +(dumx(i,j,k+1)**2+dumx(i,j+1,k+1)**2)   &
                                              )
          enddo
          enddo
          enddo
        ENDIF

      ENDIF
 
!-----------------------------------------------------------------------

      if(timestats.ge.1) time_diffu=time_diffu+mytime()
 
      return
      end


!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC


      subroutine diff2w(flag,dissw,rxh,uh,xf,uf,vh,vf,mh,mf,dumx,dumy,diffx,diffy,epsd,wa,wten)
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      integer flag,dissw
      real, dimension(ib:ie) :: rxh,uh
      real, dimension(ib:ie+1) :: xf,uf
      real, dimension(jb:je) :: vh
      real, dimension(jb:je+1) :: vf
      real, dimension(ib:ie,jb:je,kb:ke) :: mh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, dimension(ib:ie,jb:je,kb:ke) :: dumx,dumy,diffx,diffy,epsd
      real, dimension(ib:ie,jb:je,kb:ke+1) :: wa,wten
 
      integer i,j,k
      real coef

!--------------------------
!
!  flag = 1 does 2nd order artificial diffusion
!  flag = 2 does dns viscosity term
!
!-----------------------------------------------------------------------
!  x-direction

      if(flag.eq.1)then
        coef=kdiff2
      elseif(flag.eq.2)then
        coef=viscosity
      endif

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk+1
      do j=1,nj
      do i=1,ni+1
        dumx(i,j,k)=(wa(i,j,k)-wa(i-1,j,k))*rdx*uf(i)
      enddo
      enddo
      enddo

    IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk+1
      do j=1,nj
      do i=1,ni
        diffx(i,j,k)=coef*(dumx(i+1,j,k)-dumx(i,j,k))*rdx*uh(i)
      enddo
      enddo
      enddo

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk+1
      do j=1,nj
      do i=1,ni
        diffx(i,j,k)=coef*(xf(i+1)*dumx(i+1,j,k)-xf(i)*dumx(i,j,k))*rdx*uh(i)*rxh(i)
      enddo
      enddo
      enddo

    ENDIF

!-----------------------------------------------------------------------
!  y-direction

      if(flag.eq.1)then
        coef=kdiff2
      elseif(flag.eq.2)then
        coef=viscosity
      endif

    IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk+1
      do j=1,nj+1
      do i=1,ni
        dumy(i,j,k)=(wa(i,j,k)-wa(i,j-1,k))*rdy*vf(j)
      enddo
      enddo
      enddo
 
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk+1
      do j=1,nj
      do i=1,ni
        diffy(i,j,k)=coef*(dumy(i,j+1,k)-dumy(i,j,k))*rdy*vh(j)
      enddo
      enddo
      enddo

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk+1
      do j=1,nj+1
      do i=1,ni
        dumy(i,j,k)=0.0
        diffy(i,j,k)=0.0
      enddo
      enddo
      enddo

    ENDIF
 
!-----------------------------------------------------------------------

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk+1
      do j=1,nj
      do i=1,ni
        wten(i,j,k)=wten(i,j,k)+diffx(i,j,k)+diffy(i,j,k)
      enddo
      enddo
      enddo

      IF(idiss.eq.1.and.dissw.eq.1)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          epsd(i,j,k)=epsd(i,j,k)+0.25*coef*(                     &
                      ( (dumx(i,j,k  )**2+dumx(i+1,j,k  )**2)     &
                       +(dumx(i,j,k+1)**2+dumx(i+1,j,k+1)**2) )   &
                     +( (dumy(i,j,k  )**2+dumy(i,j+1,k  )**2)     &
                       +(dumy(i,j,k+1)**2+dumy(i,j+1,k+1)**2) ) )
        enddo
        enddo
        enddo
      ENDIF

!-----------------------------------------------------------------------
!  z-direction

      IF(vdiff.eq.1.or.flag.eq.2)THEN

        if(flag.eq.1)then
          coef=kdiff2
        elseif(flag.eq.2)then
          coef=viscosity
        endif

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          dumx(i,j,k)=(wa(i,j,k+1)-wa(i,j,k))*rdz*mh(i,j,k)
        enddo
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=1,ni
          wten(i,j,k)=wten(i,j,k)+coef*(dumx(i,j,k)-dumx(i,j,k-1))*rdz*mf(i,j,k)
        enddo
        enddo
        enddo

        IF(idiss.eq.1.and.dissw.eq.1)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            epsd(i,j,k)=epsd(i,j,k)+coef*(dumx(i,j,k)**2)
          enddo
          enddo
          enddo
        ENDIF

      ENDIF
 
!-----------------------------------------------------------------------

      if(timestats.ge.1) time_diffu=time_diffu+mytime()
 
      return
      end


!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 
 
      subroutine diff2s(flag,rxh,uh,xf,uf,vh,vf,mh,mf,dumx,dumy,dum,s,sten)
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      integer flag
      real, dimension(ib:ie) :: rxh,uh
      real, dimension(ib:ie+1) :: xf,uf
      real, dimension(jb:je) :: vh
      real, dimension(jb:je+1) :: vf
      real, dimension(ib:ie,jb:je,kb:ke) :: mh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, dimension(ib:ie,jb:je,kb:ke) :: dumx,dumy,dum
      real, dimension(ib:ie,jb:je,kb:ke) :: s,sten
 
      integer i,j,k
      real coef

!--------------------------
!
!  flag = 1 does 2nd order artificial diffusion
!  flag = 2 does dns conduction term
!
!-----------------------------------------------------------------------
!  x-direction

      if(flag.eq.1)then
        coef=kdiff2
      elseif(flag.eq.2)then
        coef=viscosity/pr_num
      endif

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni+1
        dum(i,j,k)=(s(i,j,k)-s(i-1,j,k))*rdx*uf(i)
      enddo
      enddo
      enddo

    IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        dumx(i,j,k)=coef*(dum(i+1,j,k)-dum(i,j,k))*rdx*uh(i)
      enddo
      enddo
      enddo

    ELSEIF(axisymm.eq.1)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        dumx(i,j,k)=coef*(xf(i+1)*dum(i+1,j,k)-xf(i)*dum(i,j,k))*rdx*uh(i)*rxh(i)
      enddo
      enddo
      enddo

    ENDIF

!-----------------------------------------------------------------------
!  y-direction

      if(flag.eq.1)then
        coef=kdiff2
      elseif(flag.eq.2)then
        coef=viscosity/pr_num
      endif

    IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj+1
      do i=1,ni
        dum(i,j,k)=(s(i,j,k)-s(i,j-1,k))*rdy*vf(j)
      enddo
      enddo
      enddo
 
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        dumy(i,j,k)=coef*(dum(i,j+1,k)-dum(i,j,k))*rdy*vh(j)
      enddo
      enddo
      enddo

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        dumy(i,j,k)=0.0
      enddo
      enddo
      enddo

    ENDIF
 
!-----------------------------------------------------------------------

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        sten(i,j,k)=sten(i,j,k)+dumx(i,j,k)+dumy(i,j,k)
      enddo
      enddo
      enddo

!-----------------------------------------------------------------------
!  z-direction

      IF(vdiff.eq.1.or.flag.eq.2)THEN

        if(flag.eq.1)then
          coef=kdiff2
        elseif(flag.eq.2)then
          coef=viscosity/pr_num
        endif

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=1,ni
          dum(i,j,k)=(s(i,j,k)-s(i,j,k-1))*rdz*mf(i,j,k)
        enddo
        enddo
        enddo

        IF(flag.eq.1)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j)
          do j=1,nj
          do i=1,ni
            dum(i,j,1)=0.0
            dum(i,j,nk+1)=0.0
          enddo
          enddo

        ELSEIF(flag.eq.2)THEN

          if(bc_temp.eq.1)then      ! constant theta at boundary

!$omp parallel do default(shared)   &
!$omp private(i,j)
            do j=1,nj
            do i=1,ni
              dum(i,j,1)=2.0*(s(i,j,1)-ptc_bot)*rdz*mf(i,j,1)
            enddo
            enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
            do j=1,nj
            do i=1,ni
              dum(i,j,nk+1)=2.0*(ptc_top-s(i,j,nk))*rdz*mf(i,j,nk+1)
            enddo
            enddo

          elseif(bc_temp.eq.2)then      ! constant flux at boundary

!$omp parallel do default(shared)   &
!$omp private(i,j)
            do j=1,nj
            do i=1,ni
              dum(i,j,1)=ptc_bot
            enddo
            enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
            do j=1,nj
            do i=1,ni
              dum(i,j,nk+1)=ptc_top
            enddo
            enddo

          endif

        ENDIF

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          sten(i,j,k)=sten(i,j,k)+coef*(dum(i,j,k+1)-dum(i,j,k))*rdz*mh(i,j,k)
        enddo
        enddo
        enddo

      ENDIF
 
!-----------------------------------------------------------------------

      if(timestats.ge.1) time_diffu=time_diffu+mytime()
 
      return
      end


diff6.F/        1298670057  19071 8000  100644  17322     `


      subroutine diff6s(dt,s0,dumx,dumy,p,s,sten)
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real :: dt
      real, dimension(ib:ie,jb:je,kb:ke) :: s0
      real, dimension(ib:ie,jb:je,kb:ke) :: dumx,dumy,p
      real, dimension(ib:ie,jb:je,kb:ke) :: s,sten

      integer i,j,k

      real coef
      coef=(kdiff6/64.0/dt)

!------------------------------------------------------------
!  x-direction

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni+1
        p(i,j,k)=( 10.0*(s(i  ,j,k)-s(i-1,j,k))     &
                   -5.0*(s(i+1,j,k)-s(i-2,j,k))     &
                       +(s(i+2,j,k)-s(i-3,j,k)) )
      enddo
      enddo
      enddo

      if(mdiff.eq.1)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni+1
          if( p(i,j,k)*(s(i,j,k)-s(i-1,j,k)).le.0.0 )then
            p(i,j,k)=0.0
          endif
        enddo
        enddo
        enddo
      endif

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        dumx(i,j,k)=coef*(p(i+1,j,k)-p(i,j,k))
      enddo
      enddo
      enddo

!------------------------------------------------------------
!  y-direction

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj+1
      do i=1,ni
        p(i,j,k)=( 10.0*(s(i,j  ,k)-s(i,j-1,k))     &
                   -5.0*(s(i,j+1,k)-s(i,j-2,k))     &
                       +(s(i,j+2,k)-s(i,j-3,k)) )
      enddo
      enddo
      enddo

      if(mdiff.eq.1)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj+1
        do i=1,ni
          if( p(i,j,k)*(s(i,j,k)-s(i,j-1,k)).le.0.0 )then
            p(i,j,k)=0.0
          endif
        enddo
        enddo
        enddo
      endif

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        dumy(i,j,k)=coef*(p(i,j+1,k)-p(i,j,k))
      enddo
      enddo
      enddo

!------------------------------------------------------------

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        sten(i,j,k)=sten(i,j,k)+(dumx(i,j,k)+dumy(i,j,k))
      enddo
      enddo
      enddo

!------------------------------------------------------------
!  z-direction

    IF(vdiff.eq.1)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        dumx(i,j,k)=s(i,j,k)-s0(i,j,k)
      enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=4,nk-2
      do j=1,nj
      do i=1,ni
        p(i,j,k)=( 10.0*(dumx(i,j,k  )-dumx(i,j,k-1))     &
                   -5.0*(dumx(i,j,k+1)-dumx(i,j,k-2))     &
                       +(dumx(i,j,k+2)-dumx(i,j,k-3)) )
      enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
      do j=1,nj
      do i=1,ni
        p(i,j,3)   =-p(i,j,5)
        p(i,j,2)   = p(i,j,4)
        p(i,j,nk  )= p(i,j,nk-2)
        p(i,j,nk-1)=-p(i,j,nk-3)
      enddo
      enddo

      if(mdiff.eq.1)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=1,ni
          if( p(i,j,k)*(dumx(i,j,k)-dumx(i,j,k-1)).le.0.0 )then
            p(i,j,k)=0.0
          endif
        enddo
        enddo
        enddo
      endif

      IF(bcturbs.eq.1)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          p(i,j,1)    = 0.0
          p(i,j,nk+1) = 0.0
        enddo
        enddo

      ELSEIF(bcturbs.eq.2)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          p(i,j,1)    = p(i,j,2)
          p(i,j,nk+1) = p(i,j,nk)
        enddo
        enddo

      ENDIF

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        sten(i,j,k)=sten(i,j,k)+coef*(p(i,j,k+1)-p(i,j,k))
      enddo
      enddo
      enddo

    ENDIF

!------------------------------------------------------------

      if(timestats.ge.1) time_diffu=time_diffu+mytime()
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine diff6u(dt,u0,dumx,dumy,p,u,uten)
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real :: dt
      real, dimension(ib:ie,jb:je,kb:ke) :: dumx,dumy,p
      real, dimension(ib:ie+1,jb:je,kb:ke) :: u0,u,uten
 
      integer i,j,k
 
      real coef
      coef=(kdiff6/64.0/dt)

!------------------------------------------------------------
!  x-direction

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni+2
        p(i,j,k)=( 10.0*(u(i  ,j,k)-u(i-1,j,k))     &
                   -5.0*(u(i+1,j,k)-u(i-2,j,k))     &
                       +(u(i+2,j,k)-u(i-3,j,k)) )
      enddo
      enddo
      enddo

      if(mdiff.eq.1)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni+2
          if( p(i,j,k)*(u(i,j,k)-u(i-1,j,k)).le.0.0 )then
            p(i,j,k)=0.0
          endif
        enddo
        enddo
        enddo
      endif

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni+1
        dumx(i,j,k)=coef*(p(i+1,j,k)-p(i,j,k))
      enddo
      enddo
      enddo

!------------------------------------------------------------
!  y-direction

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj+1
      do i=1,ni+1
        p(i,j,k)=( 10.0*(u(i,j  ,k)-u(i,j-1,k))     &
                   -5.0*(u(i,j+1,k)-u(i,j-2,k))     &
                       +(u(i,j+2,k)-u(i,j-3,k)) )
      enddo
      enddo
      enddo

      if(mdiff.eq.1)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj+1
        do i=1,ni+1
          if( p(i,j,k)*(u(i,j,k)-u(i,j-1,k)).le.0.0 )then
            p(i,j,k)=0.0
          endif
        enddo
        enddo
        enddo
      endif

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni+1
        dumy(i,j,k)=coef*(p(i,j+1,k)-p(i,j,k))
      enddo
      enddo
      enddo

!------------------------------------------------------------

!$omp parallel do default(shared)    &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni+1
        uten(i,j,k)=uten(i,j,k)+(dumx(i,j,k)+dumy(i,j,k))
      enddo
      enddo
      enddo

!------------------------------------------------------------
!  z-direction

    IF(vdiff.eq.1)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni+1
        dumx(i,j,k)=u(i,j,k)-u0(i,j,k)
      enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=4,nk-2
      do j=1,nj
      do i=1,ni+1
        p(i,j,k)=( 10.0*(dumx(i,j,k  )-dumx(i,j,k-1))     &
                   -5.0*(dumx(i,j,k+1)-dumx(i,j,k-2))     &
                       +(dumx(i,j,k+2)-dumx(i,j,k-3)) )
      enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
      do j=1,nj
      do i=1,ni+1
        p(i,j,3)   =-p(i,j,5)
        p(i,j,2)   = p(i,j,4)
        p(i,j,nk  )= p(i,j,nk-2)
        p(i,j,nk-1)=-p(i,j,nk-3)
      enddo
      enddo

      if(mdiff.eq.1)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=1,ni+1
          if( p(i,j,k)*(dumx(i,j,k)-dumx(i,j,k-1)).le.0.0 )then
            p(i,j,k)=0.0
          endif
        enddo
        enddo
        enddo
      endif

      IF(bcturbu.eq.1)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni+1
          p(i,j,1)    = 0.0
          p(i,j,nk+1) = 0.0
        enddo
        enddo

      ELSEIF(bcturbu.eq.2)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni+1
          p(i,j,1)    = p(i,j,2)
          p(i,j,nk+1) = p(i,j,nk)
        enddo
        enddo

      ENDIF

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni+1
        uten(i,j,k)=uten(i,j,k)+coef*(p(i,j,k+1)-p(i,j,k))
      enddo
      enddo
      enddo

    ENDIF

!------------------------------------------------------------
 
      if(timestats.ge.1) time_diffu=time_diffu+mytime()
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine diff6v(dt,v0,dumx,dumy,p,v,vten)
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real :: dt
      real, dimension(ib:ie,jb:je,kb:ke) :: dumx,dumy,p
      real, dimension(ib:ie,jb:je+1,kb:ke) :: v0,v,vten

      integer i,j,k
 
      real coef
      coef=(kdiff6/64.0/dt)

!------------------------------------------------------------
!  x-direction

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj+1
      do i=1,ni+1
        p(i,j,k)=( 10.0*(v(i  ,j,k)-v(i-1,j,k))     &
                   -5.0*(v(i+1,j,k)-v(i-2,j,k))     &
                       +(v(i+2,j,k)-v(i-3,j,k)) )
      enddo
      enddo
      enddo

      if(mdiff.eq.1)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj+1
        do i=1,ni+1
          if( p(i,j,k)*(v(i,j,k)-v(i-1,j,k)).le.0.0 )then
            p(i,j,k)=0.0
          endif
        enddo
        enddo
        enddo
      endif

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj+1
      do i=1,ni
        dumx(i,j,k)=coef*(p(i+1,j,k)-p(i,j,k))
      enddo
      enddo
      enddo

!------------------------------------------------------------
!  y-direction

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj+2
      do i=1,ni
        p(i,j,k)=( 10.0*(v(i,j  ,k)-v(i,j-1,k))     &
                   -5.0*(v(i,j+1,k)-v(i,j-2,k))     &
                       +(v(i,j+2,k)-v(i,j-3,k)) )
      enddo
      enddo
      enddo

      if(mdiff.eq.1)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj+2
        do i=1,ni
          if( p(i,j,k)*(v(i,j,k)-v(i,j-1,k)).le.0.0 )then
            p(i,j,k)=0.0
          endif
        enddo
        enddo
        enddo
      endif

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj+1
      do i=1,ni
        dumy(i,j,k)=coef*(p(i,j+1,k)-p(i,j,k))
      enddo
      enddo
      enddo

!------------------------------------------------------------

!$omp parallel do default(shared)    &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj+1
      do i=1,ni
        vten(i,j,k)=vten(i,j,k)+(dumx(i,j,k)+dumy(i,j,k))
      enddo
      enddo
      enddo

!------------------------------------------------------------
!  z-direction

    IF(vdiff.eq.1)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj+1
      do i=1,ni
        dumx(i,j,k)=v(i,j,k)-v0(i,j,k)
      enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=4,nk-2
      do j=1,nj+1
      do i=1,ni
        p(i,j,k)=( 10.0*(dumx(i,j,k  )-dumx(i,j,k-1))     &
                   -5.0*(dumx(i,j,k+1)-dumx(i,j,k-2))     &
                       +(dumx(i,j,k+2)-dumx(i,j,k-3)) )
      enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
      do j=1,nj+1
      do i=1,ni
        p(i,j,3)   =-p(i,j,5)
        p(i,j,2)   = p(i,j,4)
        p(i,j,nk  )= p(i,j,nk-2)
        p(i,j,nk-1)=-p(i,j,nk-3)
      enddo
      enddo

      if(mdiff.eq.1)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj+1
        do i=1,ni
          if( p(i,j,k)*(dumx(i,j,k)-dumx(i,j,k-1)).le.0.0 )then
            p(i,j,k)=0.0
          endif
        enddo
        enddo
        enddo
      endif

      IF(bcturbu.eq.1)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj+1
        do i=1,ni
          p(i,j,1)    = 0.0
          p(i,j,nk+1) = 0.0
        enddo
        enddo

      ELSEIF(bcturbu.eq.2)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj+1
        do i=1,ni
          p(i,j,1)    = p(i,j,2)
          p(i,j,nk+1) = p(i,j,nk)
        enddo
        enddo

      ENDIF

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj+1
      do i=1,ni
        vten(i,j,k)=vten(i,j,k)+coef*(p(i,j,k+1)-p(i,j,k))
      enddo
      enddo
      enddo

    ENDIF

!------------------------------------------------------------
 
      if(timestats.ge.1) time_diffu=time_diffu+mytime()
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine diff6w(dt,dumx,dumy,p,w,wten)
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real :: dt
      real, dimension(ib:ie,jb:je,kb:ke) :: dumx,dumy,p
      real, dimension(ib:ie,jb:je,kb:ke+1) :: w,wten

      integer i,j,k
 
      real coef
      coef=(kdiff6/64.0/dt)

!------------------------------------------------------------
!  x-direction

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni+1
        p(i,j,k)=( 10.0*(w(i  ,j,k)-w(i-1,j,k))     &
                   -5.0*(w(i+1,j,k)-w(i-2,j,k))     &
                       +(w(i+2,j,k)-w(i-3,j,k)) )
      enddo
      enddo
      enddo

      if(mdiff.eq.1)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=1,ni+1
          if( p(i,j,k)*(w(i,j,k)-w(i-1,j,k)).le.0.0 )then
            p(i,j,k)=0.0
          endif
        enddo
        enddo
        enddo
      endif

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni
        dumx(i,j,k)=coef*(p(i+1,j,k)-p(i,j,k))
      enddo
      enddo
      enddo

!------------------------------------------------------------
!  y-direction

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj+1
      do i=1,ni
        p(i,j,k)=( 10.0*(w(i,j  ,k)-w(i,j-1,k))     &
                   -5.0*(w(i,j+1,k)-w(i,j-2,k))     &
                       +(w(i,j+2,k)-w(i,j-3,k)) )
      enddo
      enddo
      enddo

      if(mdiff.eq.1)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj+1
        do i=1,ni
          if( p(i,j,k)*(w(i,j,k)-w(i,j-1,k)).le.0.0 )then
            p(i,j,k)=0.0
          endif
        enddo
        enddo
        enddo
      endif

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni
        dumy(i,j,k)=coef*(p(i,j+1,k)-p(i,j,k))
      enddo
      enddo
      enddo

!------------------------------------------------------------

!$omp parallel do default(shared)    &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni
        wten(i,j,k)=wten(i,j,k)+(dumx(i,j,k)+dumy(i,j,k))
      enddo
      enddo
      enddo

!------------------------------------------------------------
!  z-direction

    IF(vdiff.eq.1)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=4,nk-1
      do j=1,nj
      do i=1,ni
        p(i,j,k)=( 10.0*(w(i,j,k  )-w(i,j,k-1))     &
                   -5.0*(w(i,j,k+1)-w(i,j,k-2))     &
                       +(w(i,j,k+2)-w(i,j,k-3)) )
      enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
      do j=1,nj
      do i=1,ni
        p(i,j,3)   =-p(i,j,5)
        p(i,j,2)   = p(i,j,4)
        p(i,j,nk+1)= p(i,j,nk-1)
        p(i,j,nk  )=-p(i,j,nk-2)
      enddo
      enddo

      if(mdiff.eq.1)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk+1
        do j=1,nj
        do i=1,ni
          if( p(i,j,k)*(w(i,j,k)-w(i,j,k-1)).le.0.0 )then
            p(i,j,k)=0.0
          endif
        enddo
        enddo
        enddo
      endif

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni
        wten(i,j,k)=wten(i,j,k)+coef*(p(i,j,k+1)-p(i,j,k))
      enddo
      enddo
      enddo

    ENDIF

!------------------------------------------------------------
 
      if(timestats.ge.1) time_diffu=time_diffu+mytime()
 
      return
      end


goddard.F/      1298670057  19071 8000  100644  62215     `
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine satadj_ice(nrk,tcond,tevac,ruh,rvh,rmh,pi0,th0,   &
                            rho,rr,pp3d,prs,th3d,                  &
                            qv3d,qc3d,qr3d,                        &
                            qi3d,qs3d,qg3d)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'goddard.incl'

      integer nrk
      real*8 :: tcond,tevac
      real, dimension(ib:ie) :: ruh
      real, dimension(jb:je) :: rvh
      real, dimension(ib:ie,jb:je,kb:ke) :: rmh,pi0,th0
      real, dimension(ib:ie,jb:je,kb:ke) :: rho,rr,pp3d,prs,th3d
      real, dimension(ibm:iem,jbm:jem,kbm:kem) :: qv3d,qc3d,qr3d
      real, dimension(ibi:iei,jbi:jei,kbi:kei) :: qi3d,qs3d,qg3d

      integer :: i,j,k,n,nmax,iflag
      real :: tnew,qvs,qvnew,qcnew,qinew,thn,pin,cpml,cvml,rm,lhv,lhs
      real :: fliq,fice,tem,thlast,dqv,qsw,qsi,cnd,dep,term1,term2
      real :: converge,t1,t2,p1,p2,d1,d2,dum
      real*8 tem6
      real*8, dimension(nk) :: bud1,bud2
      real rslf,rsif
      logical :: doit

!--------------------------------------------------------------------
!  iterative sat adj.

    nmax=0
    iflag=0

!$omp parallel do default(shared)  &
!$omp private(k)
      do k=1,nk
        bud1(k)=0.0d0
        bud2(k)=0.0d0
      enddo

    IF(neweqts.ge.1)THEN

      if(nrk.eq.4)then
!!!        converge=0.0005
        converge=5.0*tsmall
      else
!!!        converge=0.01
        converge=100.0*tsmall
      endif

!$omp parallel do default(shared)  &
!$omp private(i,j,k,n,tnew,qvs,qvnew,qcnew,qinew,thn,pin,cpml,cvml,rm,   &
!$omp lhv,lhs,fliq,fice,tem,thlast,dqv,qsw,qsi,cnd,dep,term1,term2,      &
!$omp t1,t2,p1,p2,d1,d2,dum,doit)
      do k=1,nk
      do j=1,nj
      do i=1,ni

        tnew=(th0(i,j,k)+th3d(i,j,k))*(pi0(i,j,k)+pp3d(i,j,k))
        fliq=max(min((tnew-t00k)*rt0,1.0),0.0)
        fice=1.0-fliq
        qsw=0.0
        if(tnew.gt.t00k)then
          qsw=fliq*rslf(prs(i,j,k),tnew)
        endif
        qsi=0.0
        if(tnew.lt.t0k)then
          qsi=fice*rsif(prs(i,j,k),tnew)
        endif
        qvs=qsw+qsi

        IF(qc3d(i,j,k).gt.0.0 .or. qi3d(i,j,k).gt.0.0     &
           .or. qv3d(i,j,k).gt.qvs)THEN

          qvnew=qv3d(i,j,k)
          qcnew=qc3d(i,j,k)
          qinew=qi3d(i,j,k)

          thn=th3d(i,j,k)
          pin=pp3d(i,j,k)

          tem=cpl*(qc3d(i,j,k)+qr3d(i,j,k))               &
             +cpi*(qi3d(i,j,k)+qs3d(i,j,k)+qg3d(i,j,k))
          cpml=cp+cpv*qv3d(i,j,k)+tem
          cvml=cv+cvv*qv3d(i,j,k)+tem
          rm=rd+rv*qv3d(i,j,k)
          lhv=lv1-lv2*tnew
          lhs=ls1-ls2*tnew

          t1=1.0/(cpdcv*cvml*(pi0(i,j,k)+pp3d(i,j,k)))
          t2=(th0(i,j,k)+th3d(i,j,k))*(rv/cvml)*(1.0-rovcp*cpml/rm)

          p1=rovcp/(cvml*(th0(i,j,k)+th3d(i,j,k)))
          p2=rovcp*(pi0(i,j,k)+pp3d(i,j,k))*rv*cpml/(rm*cvml)

          d1=t1*(pi0(i,j,k)+pp3d(i,j,k))
          d2=t2*(pi0(i,j,k)+pp3d(i,j,k))

          n=0
          thlast=thn
          doit=.true.

!!!250       continue
          do while( doit )
            n=n+1
            term1=0.0
            if(tnew.gt.t00k)then
              term1=qsw*(fliq*C409/((tnew-C358)**2))
            endif
            term2=0.0
            if(tnew.lt.t0k)then
              term2=qsi*(fice*C580/((tnew-C76)**2))
            endif
            dqv=(qvs-qvnew)/(1.0+((lhv*fliq+lhs*fice)*d1-d2)*(term1+term2) )
            dqv=min(dqv,qcnew+qinew)
            if( (dqv*qcnew.gt.0.0.and.qinew.eq.0.0) .or.   &
                (dqv*qinew.gt.0.0.and.qcnew.eq.0.0) )then
              fliq=qcnew/(qcnew+qinew)
              fice=1.0-fliq
            endif
            if(  (qvnew+dqv).lt.1.0e-20 ) dqv=1.0e-20-qvnew
            cnd=min(fliq*dqv,qcnew)
            dep=min(fice*dqv,qinew)
            dqv=cnd+dep

            qvnew=qvnew+dqv
            qcnew=max(qcnew-cnd,0.0)
            qinew=max(qinew-dep,0.0)

            thn=thn-( (lhv*cnd+lhs*dep)*t1 - dqv*t2 )
            pin=pin-( (lhv*cnd+lhs*dep)*p1 - dqv*p2 )
            prs(i,j,k)=p00*((pi0(i,j,k)+pin)**cpdrd)

            doit = .false.
            if( abs(thn-thlast).gt.converge )then
              thlast=thn
              tnew=(th0(i,j,k)+thn)*(pi0(i,j,k)+pin)
              fliq=max(min((tnew-t00k)*rt0,1.0),0.0)
              fice=1.0-fliq
              qsw=0.0
              if(tnew.gt.t00k)then
                qsw=fliq*rslf(prs(i,j,k),tnew)
              endif
              qsi=0.0
              if(tnew.lt.t0k)then
                qsi=fice*rsif(prs(i,j,k),tnew)
              endif
              qvs=qsw+qsi
!!!              go to 250
              doit = .true.
            endif

            if(n.gt.50.and.n.lt.100)then
              print *,n,thn,pin
            elseif(n.eq.100)then
              print *,'  infinite loop!'
              print *,'  i,j,k=',i,j,k
              iflag=1
              doit=.false.
            endif

          enddo

          dum=ruh(i)*rvh(j)*rmh(i,j,k)

          bud1(k)=bud1(k)+rr(i,j,k)*max(qcnew-qc3d(i,j,k),0.0)*dum
          bud1(k)=bud1(k)+rr(i,j,k)*max(qinew-qi3d(i,j,k),0.0)*dum
          bud2(k)=bud2(k)-rr(i,j,k)*min(qcnew-qc3d(i,j,k),0.0)*dum
          bud2(k)=bud2(k)-rr(i,j,k)*min(qinew-qi3d(i,j,k),0.0)*dum
          
          th3d(i,j,k)=thn
          qc3d(i,j,k)=qcnew
          qv3d(i,j,k)=qvnew
          qi3d(i,j,k)=qinew
          pp3d(i,j,k)=pin
          
          nmax=max(n,nmax)
          
        ENDIF

      enddo
      enddo
      enddo

    ELSE

      nmax=1

!$omp parallel do default(shared)  &
!$omp private(i,j,k,qvnew,qcnew,qinew,tnew,fliq,fice,qvs,lhv,lhs,dqv,   &
!$omp qsw,qsi,cnd,dep,term1,term2,dum)
      do k=1,nk
      do j=1,nj
      do i=1,ni

        qvnew=qv3d(i,j,k)
        qcnew=qc3d(i,j,k)
        qinew=qi3d(i,j,k)
        tnew=(th0(i,j,k)+th3d(i,j,k))*(pi0(i,j,k)+pp3d(i,j,k))
        fliq=max(min((tnew-t00k)*rt0,1.0),0.0)
        fice=1.0-fliq
        qsw=0.0
        term1=0.0
        if(tnew.gt.t00k)then
          qsw=fliq*rslf(prs(i,j,k),tnew)
          term1=qsw*(fliq*C409/((tnew-C358)**2))
        endif
        qsi=0.0
        term2=0.0
        if(tnew.lt.t0k)then
          qsi=fice*rsif(prs(i,j,k),tnew)
          term2=qsi*(fice*C580/((tnew-C76)**2))
        endif
        qvs=qsw+qsi
        lhv=lv1-lv2*tnew
        lhs=ls1-ls2*tnew
        dqv=(qvs-qvnew)/(1.0+(lhv*fliq+lhs*fice)*(term1+term2)*rcp)
        dqv=min(dqv,qcnew+qinew)
        if( (dqv*qcnew.gt.0.0.and.qinew.eq.0.0) .or.   &
            (dqv*qinew.gt.0.0.and.qcnew.eq.0.0) )then
          fliq=qcnew/(qcnew+qinew)
          fice=qinew/(qcnew+qinew)
        endif
        if(  (qvnew+dqv).lt.1.0e-20 ) dqv=1.0e-20-qvnew
        cnd=min(fliq*dqv,qcnew)
        dep=min(fice*dqv,qinew)

        qvnew=qvnew+cnd+dep
        qcnew=qcnew-cnd
        qinew=qinew-dep

        dum=ruh(i)*rvh(j)*rmh(i,j,k)

        bud1(k)=bud1(k)+rr(i,j,k)*max(qcnew-qc3d(i,j,k),0.0)*dum
        bud1(k)=bud1(k)+rr(i,j,k)*max(qinew-qi3d(i,j,k),0.0)*dum
        bud2(k)=bud2(k)-rr(i,j,k)*min(qcnew-qc3d(i,j,k),0.0)*dum
        bud2(k)=bud2(k)-rr(i,j,k)*min(qinew-qi3d(i,j,k),0.0)*dum

        th3d(i,j,k)=th3d(i,j,k)-( (lhv*cnd+lhs*dep)   &
                                 /(cp*(pi0(i,j,k)+pp3d(i,j,k))) )
        qc3d(i,j,k)=qcnew
        qv3d(i,j,k)=qvnew
        qi3d(i,j,k)=qinew
        rho(i,j,k)=prs(i,j,k)   &
           /(rd*(th0(i,j,k)+th3d(i,j,k))*(pi0(i,j,k)+pp3d(i,j,k))*(1.0+qvnew*reps))

      enddo
      enddo
      enddo

    ENDIF

    IF(nrk.ge.3)THEN
      tem6=dx*dy*dz
      do k=1,nk
        tcond=tcond+bud1(k)*tem6
      enddo

      do k=1,nk
        tevac=tevac+bud2(k)*tem6
      enddo
    ENDIF

!!!      print *,'  nmax=',nmax

      if(iflag.ne.0)then
        print *
        print *,' Convergence cannot be reached in satadj_ice subroutine.'
        print *
        print *,' This may be a problem with the algorithm in satadj_ice.'
        print *,' However, the model may have became unstable somewhere'
        print *,' else and the symptoms first appeared here.'
        print *
        print *,' Try decreasing the timestep (dtl and/or nsound).'
        print *
        print *,'  ... stopping cm1 ... '
        print *
        call stopcm1
      endif

      if(timestats.ge.1) time_satadj=time_satadj+mytime()

      RETURN
      END


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine goddard(dt,tauto,taccr,tevar,ruh,rvh,rmh,pi0,th0,   &
                         rhod,rr,prs,pp3d,th3d,                   &
                         qv3d,qc3d,qr3d,vtr,                      &
                         qi3d,vti,qs3d,vts,                       &
                         qg3d,vtg)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'goddard.incl'

      real :: dt
      real*8 :: tauto,taccr,tevar
      real, dimension(ib:ie) :: ruh
      real, dimension(jb:je) :: rvh
      real, dimension(ib:ie,jb:je,kb:ke) :: rmh,pi0,th0
      real, dimension(ib:ie,jb:je,kb:ke) :: rhod,rr,prs,pp3d,th3d,qv3d,qc3d,   &
                                            qr3d,vtr,qi3d,vti,qs3d,vts,qg3d,vtg

!----------------------------------------------------------------------------
!                                                                       
!***********************************************************************
!     LIN ET AL (83) ICE PHASE MICROPHYSICAL PROCESSES                 *
!     MODIFIED AND CODED BY GODDARD CUMULUS ENSEMBLE MODELING GROUP    *
!     TAO, SIMPSON AND MCCUMBER`S SATURATION TECHNIQUE (MWR, 1989)     *
!     TAO AND SIMPSON (JAS, 1989; TAO, 1993),                          *
!     BRAUN AND TAO (MWR, 2000), BRAUN ET AL. (JAM, 2001, submitted)   *
!                                                                      *
!     D2T - LEAPFROG TIME STEP (S)                                     *
!     DPT - DEVIATION POTENTIAL TEMPERATURE FIELD (K)                  *
!     DQV - DEVIATION WATER VAPOR FIELD (G/G)                          *
!     QCL - CLOUD WATER FIELD (G/G)                                    *
!     QRN - RAIN FIELD (G/G)                                           *
!     QCI - CLOUD ICE FIELD (G/G)                                      *
!     QCS - SNOW FIELD (G/G)                                           *
!     QCG - HAIL FIELD (G/G)                                           *
!     RHO - AIR DENSITY (G/CM3)                                        *
!     TA1 - BASE AIR POTENTIAL TEMPERATURE AT THE LEVEL (K)            *
!     QA1 - BASE WATER VAPOR AT THE LEVEL (G/G)                        *
!     P0 - AIR PRESSURE (UB=1.E-3MB)                                   *
!     PI - EXNER FUNCTION (P/1000.E3)**R/CP                            *
!                                                                      *
!     MIX: DIMENSION IN X-DIRECTION                                    *
!     MKX: DIMENSION IN Z-DIRECTION                                    *
!     NOTE: PHYSICAL DOMAIN EXTENDS FROM K=1 TO K=MKX-1                *
!           AND I=2 TO I=MIX-1                                         *
!     C.G.S UNITS                                                      *
!                                                                      *
!     THIS ICE SCHEME HAS BEEN IMPLEMENTED INTO                        *
!     ARPS (CAPS - V. WONG, M. XUE, K. DROEGEMEIER) - 1993             *
!     GODDARD`S SCHLENSINGER MODEL (SIMPSON ET AL., 1991)              *
!     CHEN`S MODEL (C. CHEN) - 1992                                    *
!     GMASS (BIAK ET AL., 1992)                                        *
!     MM5V1 (LIU ET AL., 1994)                                         *
!                                                                      *
!     RECENT CHANGES (6.25.01) BY SCOTT BRAUN INCLUDE                  *
!       * OPTION TO CHOOSE HAIL OR GRAUPEL AS THIRD ICE CATEGORY       *
!	* OPTION OF SATURATION ADJUSTMENT SCHEMES                      *      
!	* NEW FORMULATION OF PSFI                                      *      
!	* REDUCED COLLECTION EFFICIENCIES (EGS) FOR COLLECTION OF SNOW *      
!	  BY GRAUPEL                                                   *      
!	* MODIFICATIONS TO PIDEP, PINT INCLUDING NEW COEFFICIENTS FOR  *      
!	  THE FLETCHER EQ., A LIMIT OF 1 CM**-3 FOR THE NUMBER         *      
!         CONCENTRATION OF ICE NUCLEI, INCLUSION OF A PISUB TERM       *
!	* ELIMINATED THE PGAUT TERM                                    *      
!***********************************************************************
!                                                                       
!     THE FOLLOWINGS ARE LOCALLY USED VARIABLES                         
!                                                                       
      real d2t,VFR,VFS,VFG
      real RHO,P0,PPI,rho0
      integer i,j,k
      real COL,DEP,RGMP,DD,DD1,QVS,DM,RSUB1,WGACR,CND,RQ,             &
       ERN,SCV,TCA,DWV,ZR,VR,ZS,VS,ZG,VG,EGS,ESI,                     &
       QSI,SSI,QSW,SSW,PIHOM,PIDW,PIMLT,PSAUT,PSACI,PSACW,QSACW,      &
       PRACI,PIACR,PRAUT,PRACW,PSFW,PSFI,DGACS,DGACW,DGACI,DGACR,     &
       PGACS,WGACS,QGACW,WGACI,QGACR,PGWET,PGAUT,PRACS,PSACR,QSACR,   &
       PGFR,PSMLT,PGMLT,PSDEP,PSSUB,PGSUB,PINT,PIDEP,PISUB,           &
       PT,QV,QC,QR,QI,QS,QG,TAIR,TAIRC,PR,PS,PG,PRN,                  &
       PSN,DLT1,DLT2,DLT3,RTAIR,DDA,DDB,Y1,Y2,Y3,Y4,Y5,FV

      integer index,IT
      real cmin,cmin1,vgcr,vgcf,r3456,        &
           a2,ee1,ee2,a1,r7r,r8r,del,r11rt,nci
      real tem1,tem2,tem3,tem4
      real rrho,rp0,rpi
      real ene1,ene2,lhv,lhs,lhf
      real tem5,rdt,temp,f1,f2,r1,dum1,cpml,cvml,rm,dum

      real*8 tem6
      real*8, dimension(nk) :: bud1,bud2,bud3

      parameter(cmin=1.e-14)
      parameter(cmin1=1.e-12)
      parameter(r1=1.0/1.0e-9)

      tem5=.5/(SQRT(AMI100)-SQRT(AMI40))
      d2t=dt
      rdt=1.0/D2T

!$omp parallel do default(shared)  &
!$omp private(k)
      do k=1,nk
        bud1(k)=0.0d0
        bud2(k)=0.0d0
        bud3(k)=0.0d0
      enddo
                                                                        
!     ******   TWO CLASS WATER AND THREE CLASS OF ICE-PHASE    *********


!$omp parallel do default(shared)  &
!$omp private(i,j,k,VFR,VFS,VFG,RHO,P0,PPI,rho0,COL,DEP,RGMP,DD,DD1,QVS,    &
!$omp DM,RSUB1,WGACR,CND,RQ,ERN,SCV,TCA,DWV,ZR,VR,ZS,VS,ZG,VG,EGS,ESI,QSI,  &
!$omp SSI,QSW,SSW,PIHOM,PIDW,PIMLT,PSAUT,PSACI,PSACW,QSACW,PRACI,PIACR,     &
!$omp PRAUT,PRACW,PSFW,PSFI,DGACS,DGACW,DGACI,DGACR,PGACS,WGACS,QGACW,      &
!$omp WGACI,QGACR,PGWET,PGAUT,PRACS,PSACR,QSACR,PGFR,PSMLT,PGMLT,PSDEP,     &
!$omp PSSUB,PGSUB,PINT,PIDEP,PISUB,PT,QV,QC,QR,QI,QS,QG,TAIR,TAIRC,PR,PS,   &
!$omp PG,PRN,PSN,DLT1,DLT2,DLT3,RTAIR,DDA,DDB,Y1,Y2,Y3,Y4,Y5,FV,index,IT,   &
!$omp vgcr,vgcf,r3456,a2,ee1,ee2,a1,r7r,r8r,del,r11rt,nci,tem1,tem2,tem3,   &
!$omp tem4,rrho,rp0,rpi,ene1,ene2,lhv,lhs,lhf,temp,f1,f2,dum1,cpml,cvml,    &
!$omp rm,dum)
      DO k=1,nk
      DO j=1,nj
      DO i=1,ni
          rho0=1.0e-3*rhod(i,j,1)

          vtr(i,j,k)=0.0
          vts(i,j,k)=0.0
          vtg(i,j,k)=0.0

        IT=1                                                           
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!C    ******************************************************************
          fv=rho0                                               
          RHO=1.0e-3*rhod(i,j,k)
          PPI=pi0(i,j,k)+pp3d(i,j,k)
          P0=10.0*prs(i,j,k)
          PT=th3d(i,j,k)
          QV=QV3D(I,J,K)
          QC=QC3D(I,J,K)
          QR=QR3D(I,J,K)
          QI=QI3D(I,J,K)
          QS=QS3D(I,J,K)
          QG=QG3D(I,J,K)
          QV=max(QV,cmin1)
          IF(QC.LT.cmin)  QC=0.0                                  
          IF(QR.LT.cmin)  QR=0.0                                  
          IF(QI.LT.cmin)  QI=0.0                                  
          IF(QS.LT.cmin)  QS=0.0                                  
          IF(QG.LT.cmin)  QG=0.0                                  
          TAIR=(th0(i,j,k)+PT)*PPI                                     
          TAIRC=TAIR-T0K                                          
!----------------------------------------------------
!  variables added to improve performance
          tem1=1.0/(sqrt(sqrt(rho)))
          tem2=sqrt(FV/RHO)
          tem3=1.0/(sqrt(rho))
          tem4=sqrt(sqrt(FV/RHO))
          rrho=1.0/rho
          rp0=1.0/p0
          rpi=1.0/ppi
!----------------------------------------------------
!  variables for new equation set
          if(neweqts.ge.1)then
            dum1=cpl*(qc+qr)+cpi*(qi+qs+qg)
            cvml=cv+cvv*qv+dum1
            cpml=cp+cpv*qv+dum1
            rm=rd+rv*qv
            ene1=cv/(cp*cvml*ppi)
            ene2=(th0(i,j,k)+pt)*(rv/cvml)*(1.0-rovcp*cpml/rm)
          else
            ene1=1.0/(cp*ppi)
            ene2=0.0
          endif
          lhv=lv1-lv2*tair
          lhs=ls1-ls2*tair
          lhf=lhs-lhv
!----------------------------------------------------
!     ***   COMPUTE ZR,ZS,ZG,VR,VS,VG      *****************************
          ZR=1.E5*ZRC*tem1
          ZS=1.E5*ZSC*tem1
          ZG=1.E5*ZGC*tem1
          VR=0.0                                                     
          VS=0.0                                                     
          VG=0.0                                                     
          IF(QR.GT.cmin)THEN                                         
            DD=RHO*QR                                          
            Y1=sqrt(sqrt(DD))
            ZR=ZRC/Y1                                             
            temp=r1*min(50.0e-6,max(0.0,DD))
            index=int(temp)
            f1=pwr2(index)
            f2=pwr2(index+1)
            VR=VRC*tem2*(f1+(f2-f1)*(temp-index))
          ENDIF                                                         
          IF(QS.GT.cmin)THEN                                         
            DD=RHO*QS                                          
            Y1=sqrt(sqrt(DD))
            ZS=ZSC/Y1                                             
!!!            VS=VSC*tem2*sqrt(sqrt(y1))
            VS=VSC*tem2*DD**BSQ
          ENDIF                                                         
          if (qg .gt. cmin) then                                     
            dd=rho*qg                                         
            y1=sqrt(sqrt(dd))
            zg=zgc/y1                                             
            if (ihail .eq. 1) then                                      
              vgcr=vgc*tem3
              vg=vgcr*sqrt(y1)
            else                                                        
              vgcf=vgc*tem2
              vg=vgcf*exp(alog(dd)*bgq)
            endif                                                       
          endif                                                         
          VFR=VR                                                
          VFS=VS                                                
          VFG=VG                                                
!     ******************************************************************
!     ***   Y1 : DYNAMIC VISCOSITY OF AIR (U)                           
!     ***   DWV : DIFFUSIVITY OF WATER VAPOR IN AIR (PI)                
!     ***   TCA : THERMAL CONDUCTIVITY OF AIR (KA)                      
!     ***   Y2 : KINETIC VISCOSITY (V)                                  
          Y1=C149*TAIR*sqrt(TAIR)/(TAIR+120.)
          temp=min(150.0,max(0.0,TAIR-173.15))
          index=int(temp)
          f1=pwr81(index)
          f2=pwr81(index+1)
          DWV=C879*rp0*TAIR*(f1+(f2-f1)*(temp-index))
          TCA=C141*Y1                                             
          SCV=exp(alog(RHO/(Y1*DWV**2))*.1666667)
!*  1 * PSAUT : AUTOCONVERSION OF QI TO QS                        ***1**
!*  3 * PSACI : ACCRETION OF QI TO QS                             ***3**
!*  4 * PSACW : ACCRETION OF QC BY QS (RIMING) (QSACW FOR PSMLT)  ***4**
!*  5 * PRACI : ACCRETION OF QI BY QR                             ***5**
!*  6 * PIACR : ACCRETION OF QR OR QG BY QI                       ***6**
          PSAUT=0.0                                                  
          PSACI=0.0                                                  
          PRACI=0.0                                                  
          PIACR=0.0                                                  
          PSACW=0.0                                                  
          QSACW=0.0                                                  
          PRAUT=0.0                                                  
          PRACW=0.0                                                  
          r3456=tem2
!!!          DD=1.0/(sqrt(sqrt(ZS))*ZS**3)
          DD=1.0/ZS**BS3
          IF( (QI.GT.CMIN) .or. (QC.GT.CMIN) )THEN
            temp=exp(alog(ZR)*(-BW3))
          ENDIF
          IF(QI.GT.CMIN) THEN                                        
           IF(TAIR.LT.T0K)THEN                                       
             ESI=EXP(.025*TAIRC)                                  
             PSAUT=MAX(RN1*ESI*(QI-BND1),0.0)                
             PSACI=RN3*R3456*.1*QI*DD                          
             PRACI=RN5*R3456*QI*temp
             PIACR=RN6*R3456*QI*exp(alog(ZR)*(-BW6))
           ENDIF                                                        
          ENDIF                                                         
          IF(QC.GT.CMIN) THEN                                        
            IF(TAIR.LT.T0K)THEN                                      
              PSACW=RN4*R3456*QC*DD                            
            ELSE                                                        
              QSACW=RN4*R3456*QC*DD                            
            ENDIF                                                       
!* 21 * PRAUT : AUTOCONVERSION OF QC TO QR                        **21**
!* 22 * PRACW : ACCRETION OF QC BY QR                             **22**
           PRACW=RN22*tem2*QC*temp
           IF(iautoc.eq.1)THEN
             Y1=QC-BND3                                             
             IF(Y1.GT.cmin)THEN                                        
               PRAUT=RHO*Y1*Y1/(1.2E-4+RN21/Y1)            
             ENDIF                                                        
           ENDIF
          ENDIF                                                         
!* 12 * PSFW : BERGERON PROCESSES FOR QS (KOENING, 1971)          **12**
!* 13 * PSFI : BERGERON PROCESSES FOR QI                          **13**
!* 32 * PIDEP : DEPOSITION OF QI                                  **32**
          PSFW=0.0                                                   
          PSFI=0.0                                                   
          PIDEP=0.0                                                  
          PISUB=0.0                                                  
          IF(TAIR.LT.T0K.AND.QI.GT.cmin)THEN                      
            Y1=MAX(MIN(TAIRC,-1.),-31.)                       
            IT=INT(ABS(Y1))                                       
            Y1=RN12A(IT)                                          
            Y2=RN12B(IT)                                          
            PSFW=MAX(D2T*Y1*(RN12*RHO*QC)*QI,0.0)      
            RTAIR=1./(TAIR-C76)                                   
            Y2=EXP(C218-C580*RTAIR)                               
            QSI=C380*rp0*Y2                                   
            ESI=C610*Y2                                           
            SSI=QV/QSI-1.                                
            NCI=MIN(RN25*EXP(BETA*TAIRC),1.)                       
            DM=QV-QSI                                      
            RSUB1=C580*ASC*QSI*RTAIR*RTAIR                  
            Y3=1./TAIR                                            
            DD=Y3*(RN30A*Y3-RN30B)+RN30C*TAIR/ESI        
            Y1=206.18*SSI/DD                                   
            DEP=DM/(1.+RSUB1)*rdt
            PIDEP=Y1*SQRT(NCI*QI*rrho)                       
            IF(DM.GT.cmin) THEN                                      
               a2=1.                                                    
               if(pidep.gt.dep .and. pidep .gt. cmin) then     
                  a2=dep/pidep                                    
                  pidep=dep                                       
               endif                                                    
               PSFI=a2*QI*Y1*tem5
            ELSEIF(DM.LT.-cmin) THEN                                 
               PISUB=MAX(-QI*rdt,PIDEP)                      
               PISUB=MIN(-PISUB,-DM*rdt)                     
               PIDEP=0.                                              
               PSFI=0.                                               
            ELSE                                                        
               PISUB=0.                                              
               PIDEP=0.                                              
               PSFI=0.                                               
            ENDIF                                                       
          ENDIF                                                         
!TTT***** QG=QG+MIN(PGDRY,PGWET)                                        
!*  9 * PGACS : ACCRETION OF QS BY QG (DGACS,WGACS: DRY AND WET)  ***9**
!* 14 * DGACW : ACCRETION OF QC BY QG (QGACW FOR PGMLT)           **14**
!* 16 * DGACR : ACCRETION OF QR TO QG (QGACR FOR PGMLT)           **16**
          DGACS=0.0                                                  
          WGACS=0.0                                                  
          DGACW=0.0                                                  
          DGACR=0.0                                                  
          PGACS=0.0                                                  
          QGACW=0.0                                                  
          QGACR=0.0                                                  
          DGACI=0.0                                                  
          WGACI=0.0                                                  
          PGWET=0.0                                                  
        IF(QG.GT.CMIN)THEN                                           
                                                                        
          IF(QC+QR.LT.1.e-4) THEN
             EE1=.01
          ELSE
             EE1=1.
          ENDIF
          EE2=0.09                                                      
          EGS=EE1*EXP(EE2*TAIRC)                                  
          IF(TAIR.GE.T0K)EGS=1.0                                  
          Y1=ABS(VG-VS)                                        
          Y2=ZS*ZG                                             
          Y3=5./Y2                                                
          Y4=.08*Y3*Y3                                         
          Y5=.05*Y3*Y4                                         
          DD=Y1*(Y3/ZS**5+Y4/ZS**3+Y5/ZS)       
          PGACS=RN9*rrho*EGS*DD                              
          DGACS=PGACS                                             
          WGACS=RN9*rrho*DD                                     
          IF(IHAIL.EQ.1) THEN                                           
             Y1=1.0/(sqrt(ZG)*ZG**3)
             DGACW=MAX(RN14*QC*Y1*tem3,0.0)          
          ELSE                                                          
             Y1=exp(alog(ZG)*(-BG3))
             DGACW=MAX(RN14*QC*Y1*R3456,0.0)                 
          ENDIF                                                         
          QGACW=DGACW                                             
          Y1=ABS(VG-VR)                                        
          Y2=ZR*ZG                                             
          Y3=5./Y2                                                
          Y4=.08*Y3*Y3                                         
          Y5=.05*Y3*Y4                                         
          DD=Y1*(Y3/ZR**5+Y4/ZR**3+Y5/ZR)*RN16   &
                *rrho                                                  
          DGACR=MAX(DD,0.0)                                     
          QGACR=DGACR                                             
          IF(TAIR.GE.T0K)THEN                                        
            DGACS=0.0                                                
            WGACS=0.0                                                
            DGACW=0.0                                                
            DGACR=0.0                                                
          ELSE                                                          
            PGACS=0.0                                                
            QGACW=0.0                                                
            QGACR=0.0                                                
          ENDIF                                                         
!*******PGDRY : DGACW+DGACI+DGACR+DGACS                           ******
!* 15 * DGACI : ACCRETION OF QI BY QG (WGACI FOR WET GROWTH)      **15**
!* 17 * PGWET : WET GROWTH OF QG                                  **17**
          IF(TAIR.LT.T0K.AND.TAIR.GT.T0K-40.)THEN                 
            IF(IHAIL.EQ.1) THEN                                         
               Y1=QI/(sqrt(ZG)*ZG**3)
               DGACI=Y1*RN15*tem3
               WGACI=Y1*RN15A*tem3
            ELSE                                                        
               Y1=QI/ZG**BG3                                      
               DGACI=Y1*RN15*R3456                                
               WGACI=Y1*RN15A*R3456                               
            ENDIF                                                       
            Y1=1./(ALF+RN17C*TAIRC)                               
            IF(IHAIL.EQ.1) THEN                                         
               Y3=.78/ZG**2+SCV*RN17A*tem1*exp(alog(ZG)*(-BGH5))
            ELSE                                                        
               Y3=.78/ZG**2+SCV*RN17A*tem4*exp(alog(ZG)*(-BGH5))
            ENDIF                                                       
            Y4=RHO*ALV*DWV*(C380*rp0-QV)-TCA*   &
                  TAIRC                                              
            DD=Y1*(Y4*Y3*RN17*rrho+(WGACI+WGACS)*(   &
                  ALF+RN17B*TAIRC))                                  
            PGWET=MAX(DD,0.0)                                   
          ENDIF                                                         
        ENDIF                                                           
!********   HANDLING THE NEGATIVE CLOUD WATER (QC)    ******************
!********   HANDLING THE NEGATIVE CLOUD ICE (QI)      ******************
!********   DIFFERENT FROM LIN ET AL                  ******************
           y1=qc*rdt
          psacw=MIN(y1, psacw)                               
          praut=MIN(y1, praut)                               
          pracw=MIN(y1, pracw)                               
          psfw= MIN(y1, psfw)                                
          dgacw=MIN(y1, dgacw)                               
          qsacw=MIN(y1, qsacw)                               
          qgacw=MIN(y1, qgacw)                               
                                                                        
          Y1=(PSACW+PRAUT+PRACW+PSFW+DGACW+QSACW+   &
                QGACW)*D2T                                           
          QC=QC-Y1                                             
                                                                        
          IF(QC.LT.0.0) THEN                                         
             a1=1.                                                      
              if (y1 .ne. 0.0) A1=QC/Y1+1.                     
            PSACW=PSACW*A1                                        
            PRAUT=PRAUT*A1                                        
            PRACW=PRACW*A1                                        
            PSFW=PSFW*A1                                          
            DGACW=DGACW*A1                                        
            QSACW=QSACW*A1                                        
            QGACW=QGACW*A1                                        
            QC=0.0                                                   
          ENDIF                                                         

          dum=ruh(i)*rvh(j)*rmh(i,j,k)

          bud1(k)=bud1(k)+rr(i,j,k)*PRAUT*dum
          bud2(k)=bud2(k)+rr(i,j,k)*PRACW*dum

!                                                                       
!******** SHED PROCESS (WGACR=PGWET-DGACW-WGACI-WGACS)                  
!     CALCULATIONS OF THIS TERM HAS BEEN MOVED TO THIS LOCATION TO      
!     ACCOUNT FOR RESCALING OF THE DGACW TERM ABOVE. ALTHOUGH RESCALING 
!     OF THE PGWET, WGACI AND WGACS TERMS OCCURS BELOW, THESE CHANGES   
!     ARE EXPECTED TO BE LESS THAN THAT ASSOCIATED WITH DGACW. THIS CALC
!     IS NOT DONE AFTER RESCALING OF ALL TERMS SINCE WGACR IS NEEDED BEL
!     FOR RAIN AND WGACI AND DGACI ARE NEEDED FOR ICE.                  
          WGACR=PGWET-DGACW-WGACI-WGACS                  
          Y2=DGACW+DGACI+DGACR+DGACS                     
          IF(PGWET.GE.Y2)THEN                                     
            WGACR=0.0                                                
            WGACI=0.0                                                
            WGACS=0.0                                                
          ELSE                                                          
            DGACR=0.0                                                
            DGACI=0.0                                                
            DGACS=0.0                                                
          ENDIF                                                         
                                                                        
            y1=qi*rdt
           psaut=MIN(y1, psaut)                              
           psaci=MIN(y1, psaci)                              
           praci=MIN(y1, praci)                              
           psfi= MIN(y1, psfi)                               
           dgaci=MIN(y1, dgaci)                              
           wgaci=MIN(y1, wgaci)                              

          Y1=(PSAUT+PSACI+PRACI+PSFI+DGACI+WGACI   &
                +PISUB)*D2T                                          

           qi=qi-y1+PIDEP*D2T                               
           if(qi.lt.0.0) then                                        
               a2=1.                                                    
                if (y1 .ne. 0.0) a2=qi/y1+1.                   
            psaut=psaut*a2                                        
            psaci=psaci*a2                                        
            praci=praci*a2                                        
            psfi=psfi*a2                                          
            dgaci=dgaci*a2                                        
            wgaci=wgaci*a2                                        
            pisub=pisub*a2                                        
            qi=0.0                                                   
           endif                                                        
!                                                                       
          DLT3=0.0                                                   
          DLT2=0.0                                                   
          IF(TAIR.LT.T0K)THEN                                        
            IF(QR.LT.1.E-4)THEN                                      
              DLT3=1.0                                               
              DLT2=1.0                                               
            ENDIF                                                       
            IF(QS.GE.1.E-4)DLT2=0.0                               
          ENDIF                                                         
          PR=(QSACW+PRAUT+PRACW+QGACW)*D2T               
          PS=(PSAUT+PSACI+PSACW+PSFW+PSFI+DLT3*    &
                PRACI)*D2T                                           
          PG=((1.-DLT3)*PRACI+DGACI+WGACI+DGACW)*D2T  
!*  7 * PRACS : ACCRETION OF QS BY QR                             ***7**
!*  8 * PSACR : ACCRETION OF QR BY QS (QSACR FOR PSMLT)           ***8**
            PRACS=0.0                                                
            PSACR=0.0                                                
            QSACR=0.0                                                
            PGFR=0.0                                                 
            PGAUT=0.0                                                
        IF(QR.GT.CMIN)THEN                                           
          Y1=ABS(VR-VS)                                        
          Y2=ZR*ZS                                             
          Y3=5./Y2                                                
          Y4=.08*Y3*Y3                                         
          Y5=.05*Y3*Y4                                         
          R7R=RN7*rrho                                                
          PRACS=R7R*Y1*(Y3/ZS**5+Y4/ZS**3+Y5/ZS)
          R8R=RN8*rrho                                                
          PSACR=R8R*Y1*(Y3/ZR**5+Y4/ZR**3+Y5/ZR)
          QSACR=PSACR                                             
          IF(TAIR.GE.T0K)THEN                                        
            PRACS=0.0                                                
            PSACR=0.0                                                
          ELSE                                                          
            QSACR=0.0                                                
          ENDIF                                                         
!*  2 * PGAUT : AUTOCONVERSION OF QS TO QG                        ***2**
!* 18 * PGFR  : FREEZING OF QR TO QG                              **18**
          IF(TAIR.LT.T0K)THEN                                        
!           Y1=EXP(.09*TAIRC)                                     
!           if (ihail .eq. 1) PGAUT=MAX(RN2*Y1*(QS-BND2),0.0)
            Y2=EXP(RN18A*(T0K-TAIR))                              
            PGFR=MAX((Y2-1.)*RN18*rrho/ZR**7,0.0)       
          ENDIF                                                         
        ENDIF                                                           
!********   HANDLING THE NEGATIVE RAIN WATER (QR)    *******************
!********   HANDLING THE NEGATIVE SNOW (QS)          *******************
!********   DIFFERENT FROM LIN ET AL                 *******************
          y1=qr*rdt
          Y2=-QG*rdt
         piacr=MIN(y1, piacr)                                
         dgacr=MIN(y1, dgacr)                                
         wgacr=MIN(y1, wgacr)                                
         wgacr=MAX(y2, wgacr)                                
         psacr=MIN(y1, psacr)                                
         pgfr= MIN(y1, pgfr)                                 

         del=0.                                                         
         IF(WGACR.LT.0.) del=1.                                      
          Y1=(PIACR+DGACR+(1.-del)*WGACR+PSACR+          &
                  PGFR)*D2T                                          
          qr=qr+pr-y1-del*WGACR*D2T                      
                                                                        
          if(qr.lt.0.0) then                                         
            a1=1.0                                                      
             if(y1 .ne. 0.) a1=qr/y1+1.                        
            piacr=piacr*a1                                        
            dgacr=dgacr*a1                                        
            if(wgacr.gt.0) wgacr=wgacr*a1                      
            pgfr=pgfr*a1                                          
            psacr=psacr*a1                                        
            qr=0.0                                                   
          endif                                                         

          PRN=D2T*((1.-DLT3)*PIACR+DGACR+WGACR+(1.-      &
                 DLT2)*PSACR+PGFR)                             
          PS=PS+D2T*(DLT3*PIACR+DLT2*PSACR)           

           y1=qs*rdt
          pgacs=MIN(y1, pgacs)                               
          dgacs=MIN(y1, dgacs)                               
          wgacs=MIN(y1, wgacs)                               
          pgaut=MIN(y1, pgaut)                               
          pracs=MIN(y1, pracs)                               

          PRACS=(1.-DLT2)*PRACS                                
          PSN=D2T*(PGACS+DGACS+WGACS+PGAUT+PRACS)     
          QS=QS+PS-PSN                                      
          if(qs .lt. 0.0) then                                       
            a2=1.                                                       
              if(psn .ne. 0.) a2=qs/psn+1.                     
            pgacs=pgacs*a2                                        
            dgacs=dgacs*a2                                        
            wgacs=wgacs*a2                                        
            pgaut=pgaut*a2                                        
            pracs=pracs*a2                                        
            psn=psn*a2                                            
            qs=0.0                                                   
          endif                                                         
          Y2=D2T*(PSACW+PSFW+DGACW+PIACR+DGACR+       &
                WGACR+PSACR+PGFR)                              
          PT=PT+lhf*ene1*Y2                                   
          QG=QG+PG+PRN+PSN                               
!* 11 * PSMLT : MELTING OF QS                                     **11**
!* 19 * PGMLT : MELTING OF QG TO QR                               **19**
          PSMLT=0.0                                                  
          PGMLT=0.0                                                  
          TAIR=(th0(i,j,k)+PT)*PPI                                     
          r3456=tem2
          IF(TAIR.GE.T0K .AND. (QS+QG).GT.CMIN) THEN           
            TAIRC=TAIR-T0K                                        
            Y1=TCA*TAIRC-RHO*ALV*DWV    &
                       *(C380*rp0-QV)
            Y2=.78/ZS**2+RN101*tem4*SCV    &
                 *exp(alog(ZS)*(-BSH5))
            R11RT=RN11*D2T*rrho                                       
            DD=R11RT*Y1*Y2+R11AT*TAIRC*(QSACW+QSACR)  
            PSMLT=MAX(0.0,MIN(DD,QS))                      
            IF(IHAIL.EQ.1) THEN                                         
               Y3=.78/ZG**2+SCV*RN19A*tem1*exp(alog(ZG)*(-BGH5))
            ELSE                                                        
               Y3=.78/ZG**2+SCV*RN19A*tem4*exp(alog(ZG)*(-BGH5))
            ENDIF                                                       
            DD1=Y1*Y3*RN19*D2T*rrho+R19BT*TAIRC*(QGACW   &
                   +QGACR)                                            
            PGMLT=MAX(0.0,MIN(DD1,QG))                     
            PT=PT-lhf*ene1*(PSMLT+PGMLT)
            QR=QR+PSMLT+PGMLT                               
            QS=QS-PSMLT                                        
            QG=QG-PGMLT                                        
          ENDIF                                                         
!* 24 * PIHOM : HOMOGENEOUS FREEZING OF QC TO QI (T < T00K)    **24**   
!* 25 * PIDW : DEPOSITION GROWTH OF QC TO QI ( T0K < T <= T00K)**25**   
!* 26 * PIMLT : MELTING OF QI TO QC (T >= T0K)                 **26**   
          IF(QC.LE.cmin)QC=0.0                                    
          IF(QI.LE.cmin)QI=0.0                                    
          PIHOM=0.                                                   
          PIMLT=0.                                                   
          TAIR=(th0(i,j,k)+PT)*PPI                                     
          IF((TAIR-T00K).LE.0.) PIHOM=QC                       
          IF((TAIR-T0K) .GE.0.) PIMLT=QI                       
          PIDW=0.0                                                   
          IF(TAIR.LT.T0K.AND.TAIR.GT.T00K.AND.QC.GT.CMIN)THEN  
            TAIRC=TAIR-T0K                                        
            Y1=MAX(MIN(TAIRC,-1.),-31.)                       
            Y2=RN25A(INT(ABS(Y1)))                                
            Y3=MIN(RN25*EXP(BETA*TAIRC),1.)                     
            PIDW=MIN(Y2*Y3*D2T*rrho,QC)                 
          ENDIF                                                         
          Y1=PIHOM-PIMLT+PIDW                               
          PT=PT+lhf*ene1*Y1    &
                     +(lhs*ene1-ene2)*(PIDEP-PISUB)*D2T
          QV=QV-(PIDEP-PISUB)*D2T                           
          QC=QC-Y1                                             
          QI=QI+Y1                                             
!* 31 * PINT  : INITIATION OF QI                                  **31**
!****** DIFFERENT FROM LIN ET AL.                                 ******
          PINT=0.0                                                   
          TAIR=(th0(i,j,k)+PT)*PPI                                     
           if (qi .le. cmin) qi=0.0                               
          IF(TAIR.LT.T0K)THEN                                        
            TAIRC=TAIR-T0K                                        
            RTAIR=1./(TAIR-C76)                                   
            Y2=EXP(C218-C580*RTAIR)                               
            QSI=C380*rp0*Y2                                   
            ESI=C610*Y2                                           
            SSI=QV/QSI-1.                                
            NCI=MIN(RN25*EXP(BETA*TAIRC),1.)                       
!     Do not initiate the maximum number of nuclei. Some ice may already
!     present, so only initiate that needed to get up to the maximum num
!     Use ami50 g as mass of 50 micron size particle (assumed to be the 
!     size of ice particles), and use 1.e-9 g as initial mass of ice    
!     particles                                                         
            dd=MAX(1.e-9*nci*rrho-qi*1.e-9/ami50 , 0.)        
            DM=MAX((QV-QSI),0.)                          
            RSUB1=C580*ASC*QSI*RTAIR*RTAIR                  
            PINT=MIN(DD,DM)                                  
            DEP=DM/(1.+RSUB1)                                  
            PINT=MIN(PINT,DEP)                               
            if (pint .le. cmin) pint=0.0                          
            PT=PT+(lhs*ene1-ene2)*PINT
            QV=QV-PINT                                         
            QI=QI+PINT                                         
          ENDIF                                                         
!--------------------------------------
!  cut saturation .... do later
!--------------------------------------
!* 10 * PSDEP : DEPOSITION OR SUBLIMATION OF QS                   **10**
!* 20 * PGSUB : SUBLIMATION OF QG                                 **20**
          PSDEP=0.0                                                  
          PSSUB=0.0                                                  
          PGSUB=0.0                                                  
          r3456=tem2
          TAIR=(th0(i,j,k)+PT)*PPI                                     
          IF((QS+QG).GT.CMIN)THEN              
            IF(QS.LT.cmin) QS=0.0                                 
            IF(QG.LT.cmin) QG=0.0                                 
            RTAIR=1./(TAIR-C76)                                   
            QSI=C380*rp0*EXP(C218-C580*RTAIR)                 
            SSI=QV/QSI-1.                                
            Y1=RN10A*RHO/(TCA*TAIR**2)+1./(DWV*QSI)   
            Y2=.78/ZS**2+RN101*tem4*SCV    &
                 *exp(alog(ZS)*(-BSH5))
            PSDEP=R10T*SSI*Y2/Y1                            
            PSSUB=PSDEP                                           
            PSDEP=MAX(PSDEP,0.)                                 
            PSSUB=MAX(-QS,MIN(PSSUB,0.))                   
            IF(IHAIL.EQ.1) THEN                                         
               Y2=.78/ZG**2+SCV*RN20B*tem1*exp(alog(ZG)*(-BGH5))
            ELSE                                                        
               Y2=.78/ZG**2+SCV*RN20B*tem4*exp(alog(ZG)*(-BGH5))
            ENDIF                                                       
            PGSUB=R20T*SSI*Y2/Y1                            
            DM=QV-QSI                                      
            RSUB1=C580*ASC*QSI*RTAIR*RTAIR                  
!     ********   DEPOSITION OR SUBLIMATION OF QS  **********************
            Y1=DM/(1.+RSUB1)                                   
            PSDEP=MIN(PSDEP,MAX(Y1,0.))                    
            Y2=MIN(Y1,0.)                                       
            PSSUB=MAX(PSSUB,Y2)                              
!     ********   SUBLIMATION OF QG   ***********************************
            DD=MAX((-Y2-QS),0.)                              
            PGSUB=MIN(DD,QG,MAX(PGSUB,0.))              
!      DLT1=CVMGP(1.,0.,QC+QI-1.E-5)                           
            IF((QC+QI-1.E-5).GE.0.)THEN                           
              DLT1=1.                                                
            ELSE                                                        
              DLT1=0.                                                
            ENDIF                                                       
            PSDEP=DLT1*PSDEP                                   
            PSSUB=(1.-DLT1)*PSSUB                              
            PGSUB=(1.-DLT1)*PGSUB                              
            PT=PT+(lhs*ene1-ene2)*(PSDEP+PSSUB-PGSUB)
            QV=QV+PGSUB-PSSUB-PSDEP                      
            QS=QS+PSDEP+PSSUB                               
            QG=QG-PGSUB                                        
          ENDIF                                                         
!* 23 * ERN : EVAPORATION OF QR (SUBSATURATION)                   **23**
          ERN=0.0                                                    
          IF(QR.GT.CMIN)THEN                                         
            TAIR=(th0(i,j,k)+PT)*PPI                                   
            RTAIR=1./(TAIR-C358)                                  
            QSW=C380*rp0*EXP(C172-C409*RTAIR)                 
            SSW=QV/QSW-1.0                               
            DM=QV-QSW                                      
            RSUB1=C409*AVC*QSW*RTAIR*RTAIR                  
            DD1=MAX(-DM/(1.+RSUB1),0.0)                      
            Y1=.78/ZR**2+RN23A*tem4*SCV    &
                 *exp(alog(ZR)*(-BWH5))
            Y2=RN23B*RHO/(TCA*TAIR**2)+1./(DWV*QSW)   
            ERN=R23T*SSW*Y1/Y2                              
            ERN=MIN(DD1,QR,MAX(ERN,0.))                 
            PT=PT-(lhv*ene1-ene2)*ERN
            QV=QV+ERN                                          
            QR=QR-ERN                                          
          ENDIF                                                         
          dum=ruh(i)*rvh(j)*rmh(i,j,k)
          bud3(k)=bud3(k)+rr(i,j,k)*ERN*dum
          IF(QC.LE.cmin)QC=0.                                     
          IF(QR.LE.cmin)QR=0.                                     
          IF(QI.LE.cmin)QI=0.                                     
          IF(QS.LE.cmin)QS=0.                                     
          IF(QG.LE.cmin)QG=0.                                     
        IF(neweqts.ge.1)THEN
          dum1=abs(qv-qv3d(i,j,k))+abs(qc-qc3d(i,j,k))+abs(qr-qr3d(i,j,k))   &
              +abs(qi-qi3d(i,j,k))+abs(qs-qs3d(i,j,k))+abs(qg-qg3d(i,j,k))
          if(dum1.gt.1.0e-7)then
            pp3d(i,j,k)=((rhod(i,j,k)*(rd+rv*qv)*(th0(i,j,k)+pt)*rp00)**rddcv)-pi0(i,j,k)
            prs(i,j,k)=p00*((pi0(i,j,k)+pp3d(i,j,k))**cpdrd)
          endif
        ENDIF

          TH3D(I,J,K)=PT
          QV3D(I,J,K)=QV
          QC3D(I,J,K)=QC
          QR3D(I,J,K)=QR
          QI3D(I,J,K)=QI
          QS3D(I,J,K)=QS
          QG3D(I,J,K)=QG
          vtr(i,j,k)=vfr*0.01
          vts(i,j,k)=vfs*0.01
          vtg(i,j,k)=vfg*0.01
          vti(i,j,k)=0.200

      enddo
      enddo
      enddo

      tem6=dx*dy*dz

      do k=1,nk
        tauto=tauto+bud1(k)*tem6
      enddo

      do k=1,nk
        taccr=taccr+bud2(k)*tem6
      enddo

      do k=1,nk
        tevar=tevar+bud3(k)*tem6
      enddo

      if(timestats.ge.1) time_microphy=time_microphy+mytime()

!C**********************************************************************
!                                                                       
      RETURN                                                            
      END                                                               


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


!***********************************************************************
      SUBROUTINE CONSAT
      implicit none
      include 'input.incl'
      include 'goddard.incl'
!***********************************************************************
!     (LIN) SPECIFY SOME CONSTANTS IN SATICE ROUTINE                   *
!     LIN ET.AL.  J. CLIM. APPL. METEOR.  22, 1065-1092                *
!     MODIFIED AND CODED BY TAO AND SIMPSON (JAS, 1989; TAO, 1993)     *
!     RECENT CHANGES (6.25.01) BY SCOTT BRAUN INCLUDE
!         * OPTION TO CHOOSE HAIL OR GRAUPEL AS THIRD ICE CATEGORY
!         * OPTION OF SATURATION ADJUSTMENT SCHEMES
!         * INCLUSION OF GAMMA FUNCTION FOR EASIER VARIATION OF FALL
!           SPEED COEFFICIENTS
!***********************************************************************

      real A1(31),A2(31)
      DATA A1/.7939E-7,.7841E-6,.3369E-5,.4336E-5,.5285E-5,.3728E-5,       &
         .1852E-5,.2991E-6,.4248E-6,.7434E-6,.1812E-5,.4394E-5,.9145E-5,   &
         .1725E-4,.3348E-4,.1725E-4,.9175E-5,.4412E-5,.2252E-5,.9115E-6,   &
         .4876E-6,.3473E-6,.4758E-6,.6306E-6,.8573E-6,.7868E-6,.7192E-6,   &
         .6513E-6,.5956E-6,.5333E-6,.4834E-6/
      DATA A2/.4006,.4831,.5320,.5307,.5319,.5249,.4888,.3894,.4047,    &
         .4318,.4771,.5183,.5463,.5651,.5813,.5655,.5478,.5203,.4906,   &
         .4447,.4126,.3960,.4149,.4320,.4506,.4483,.4460,.4433,.4413,   &
         .4382,.4361/

      real gamma

      real cp,cpi,cpi2,grvt,tca,dwv,dva,amw,ars,scv,rw,cw,ci,cd1,cd2,     &
           ga3b,ga4b,ga6b,ga5bh,ga3g,ga4g,ga5gh,ga3d,ga4d,ga5dh,esw,      &
           eri,ami,esr,eiw,ui50,ri50,cmn,y1,rn13,egw,egi,egi2,egr,apri,   &
           bpri,erw,cn0

      integer i,k

!
!
!     USE GRAUPEL OR HAIL (0=GRAUPEL, 1=HAIL)
!
!!!!!! 
!!!!!!      IHAIL=1       ! Now specified in namelist.input
!!!!!! 
!
!*****   IWATER=0 USES A SLIGHT VARIANT OF THE ORIGINAL TAO ET AL METHOD
!*****   THE ONLY DIFFERENCE IS THAT THE WEIGHTING BETWEEN THE LIQUID
!*****   AND ICE SATURATION VALUES IS DONE BY TEMPERATURE RATHER THAN MA
!*****   IWATER=1 USES A SEQUENTIAL METHOD IN WHICH THE ADJUSTMENT IS FI
!*****   DONE FOR LIQUID WATER FOR TEMPERATURES WARMER THAN 253K, THEN F
!*****   ICE ONLY WHERE THE TEMPERATURE IS COLDER THAN 258K. THE MAIN EF
!*****   THIS CHANGE IS TO REDUCE THE AMOUNT OF SUPERCOOLED WATER AT VER
!*****   TEMPERATURES
!!!!!! 
!!!!!!      IWATER=1
!!!!!! 
!*****************************************************************
 
!
      CP=1.0057E7
      CPI=4.*ATAN(1.)
      CPI2=CPI*CPI
      GRVT=981.
      TCA=2.43E3
      DWV=.226
      DVA=1.718E-4
      AMW=18.016
      ARS=8.314E7
      SCV=2.2904487
      T0K=273.15
      T00K=233.15
      ALV=2.501000E10
      ALS=2.834000E10
      ALF=ALS-ALV
      AVC=ALV/CP
      AFC=ALF/CP
      ASC=ALS/CP
      RW=4.615E6
      CW=4.190E7
      CI=2.106000E7
      C76=7.66
      C358=29.65
      C172=17.67
      C409=17.67*(273.15-29.65)
      C218=21.8745584
      C580=21.8745584*(273.15-7.66)
      C380=10.0*611.2*287.04/461.5
      C610=6.1078E3
      C149=1.496286E-5
      C879=8.794142
      C141=1.4144354E7
 
!***   DEFINE THE DENSITY AND SIZE DISTRIBUTION OF PRECIPITATION
!***   DEFINE THE COEFFICIENTS USED IN TERMINAL VELOCITY
!**********   HAIL OR GRAUPEL PARAMETERS   **********
      if (ihail .eq. 1) then
        ROQG=.9
        TNG=.0002
        CD1=6.E-1
        CD2=4.*GRVT/(3.*CD1)
        AGG=SQRT(CD2*ROQG)
        BGG=.5
      else
        ROQG=.4
        TNG=.04
        AGG=351.2
        BGG=.37
      endif
!**********         SNOW PARAMETERS        **********
! Note ... see Potter, 1991, JAM, p. 1040 for more info about these changes
      ROQS=.1
      ROQS_POTTER=1.0
      TNSS=1.
!!!      ASS=152.93
!!!      BSS=.25
      ASS=179.2
      BSS=.42
!**********         RAIN PARAMETERS        **********
      ROQR=1.
      TNW=.08
      AWW=2115.
      BWW=.8
!*****************************************************************
!
!
      BGH=.5*BGG
      BSH=.5*BSS
      BWH=.5*BWW
      BGQ=.25*BGG
      BSQ=.25*BSS
      BWQ=.25*BWW
      GA3B=gamma(3.+BWW)
      GA4B=gamma(4.+BWW)
      GA6B=gamma(6.+BWW)
      GA5BH=gamma((5.+BWW)/2.)
      GA3G=gamma(3.+BGG)
      GA4G=gamma(4.+BGG)
      GA5GH=gamma((5.+BGG)/2.)
      GA3D=gamma(3.+BSS)
      GA4D=gamma(4.+BSS)
      GA5DH=gamma((5.+BSS)/2.)
      ZRC=(CPI*ROQR*TNW)**0.25
      ZSC=(CPI*ROQS_POTTER*TNSS)**0.25
      ZGC=(CPI*ROQG*TNG)**0.25
      VRC=AWW*GA4B/(6.*ZRC**BWW)
      VSC=ASS*GA4D/(6.*ZSC**BSS)
      VGC=AGG*GA4G/(6.*ZGC**BGG)
!-------------------------------
!  fudge check
      if(ihail.eq.1 .and. bgg.ne.0.5)then
        print *,'  BGG must be 0.5 for hail (its fudged into code)!'
        print *,'        (sorry)'
        call stopcm1
      endif
!!!      if(bss.ne.0.25)then
!!!        print *,'  BSS must be 0.25 (its fudged into code)!'
!!!        print *,'        (sorry)'
!!!        call stopcm1
!!!      endif
      if(bww.ne.0.8)then
        print *,'  BWW must be 0.8 (its fudged into code)!'
        print *,'        (sorry)'
        call stopcm1
      endif
!-------------------------------
!     ****************************
      RN1=1.E-3
      RN2=1.E-3
      BND1=5.E-4
      BND2=1.25E-3
      RN3=.25*CPI*TNSS*ASS*GA3D
      ESW=1.
      RN4=.25*CPI*ESW*TNSS*ASS*GA3D
      ERI=1.
      RN5=.25*CPI*ERI*TNW*AWW*GA3B
      AMI=1./(24.*4.19E-10)
      RN6=CPI2*ERI*TNW*AWW*ROQR*GA6B*AMI
      ESR=1.
      RN7=CPI2*ESR*TNW*TNSS*ROQS
      RN8=CPI2*ESR*TNW*TNSS*ROQR
      RN9=CPI2*TNSS*TNG*ROQS
      RN10=2.*CPI*TNSS
      RN101=.31*GA5DH*SQRT(ASS)
      RN10A=ALS*ALS/RW
      RN11=2.*CPI*TNSS/ALF
      RN11A=CW/ALF
      AMI40=2.41e-8
      AMI50=3.76e-8
      AMI100=1.51e-7
      EIW=1.
      UI50=20.
      RI50=10.e-3
      CMN=1.05E-15
      RN12=CPI*EIW*UI50*RI50**2
      DO 10 K=1,31
        Y1=1.-A2(K)
        RN13=A1(K)*Y1/(AMI100**Y1-AMI40**Y1)
        RN12A(K)=RN13/AMI100
        RN12B(K)=A1(K)*AMI100**A2(K)
        RN25A(K)=A1(K)*CMN**A2(K)
   10 CONTINUE
      EGW=1.
      EGI=.1
      EGI2=1.
      RN14=.25*CPI*EGW*TNG*GA3G*agg
      RN15=.25*CPI*EGI*TNG*GA3G*agg
      RN15A=.25*CPI*EGI2*TNG*GA3G*agg
      EGR=1.
      RN16=CPI2*EGR*TNG*TNW*ROQR
      RN17=2.*CPI*TNG
      RN17A=.31*GA5GH*sqrt(agg)
      RN17B=CW-CI
      RN17C=CW
      APRI=.66
      BPRI=1.E-4
      RN18=20.*CPI2*BPRI*TNW*ROQR
      RN18A=APRI
      RN19=2.*CPI*TNG/ALF
      RN19A=.31*GA5GH*sqrt(agg)
      RN19B=CW/ALF
      RN20=2.*CPI*TNG
      RN20A=ALS*ALS/RW
      RN20B=.31*GA5GH*sqrt(agg)
      BND3=2.0E-3
      RN21=1.E3*1.569E-12/0.15
      ERW=1.
      RN22=.25*CPI*ERW*AWW*TNW*GA3B
      RN23=2.*CPI*TNW
      RN23A=.31*GA5BH*SQRT(AWW)
      RN23B=ALV*ALV/RW
      CN0=1.E-6
      RN25=CN0
      RN30A=ALV*ALS*AMW/(TCA*ARS)
      RN30B=ALV/TCA
      RN30C=ARS/(DWV*AMW)
      RN31=1.E-17
      BETA=-.46
      RN32=4.*51.545E-4
!-----------------------------------------------
      RT0=1./(T0K-T00K)
      BW3=BWW+3.
      BS3=BSS+3.
      BG3=BGG+3.
      BWH5=2.5+BWH
      BSH5=2.5+BSH
      BGH5=2.5+BGH
      BW6=BWW+6.
      BS6=BSS+6.
      BETAH=.5*BETA
!-----------------------------------------------
!  lookup tables
!
!  for pwr81, temperature range is from -100 to +50 Celsius in increments
!  of 1 Celsius
      do i=0,151
        pwr81(i)=(173.15+i)**0.81
      enddo
!  rho*q from 0 to 50e-6 in increments of 1e-9
      do i=0,50001
        pwr2(i)=(i*1.0e-9)**bwq
      enddo
!-----------------------------------------------
      RETURN
      END


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


!***********************************************************************
      SUBROUTINE CONSAT2(d2t)
      implicit none
      include 'goddard.incl'
      real d2t
      R10T=RN10*D2T
      R11AT=RN11A*D2T
      R19BT=RN19B*D2T
      R20T=-RN20*D2T
      R23T=-RN23*D2T
      RETURN
      END


init3d.F/       1298670057  19071 8000  100644  52064     `


      subroutine init3d(num_soil_layers,qbudget,asq,bsq,                  &
                        xh,rxh,uh,ruh,xf,rxf,uf,ruf,yh,vh,rvh,yf,vf,rvf,  &
                        xfref,yfref,                                      &
                        zh,mh,rmh,zf,mf,rmf,rho0s,pi0s,prs0s,pi0,prs0,rho0,thv0,th0,t0,qv0,   &
                        u0,v0,rh0,qc0,ql0,rr0,rf0,rrf0,                   &
                        zs,gz,rain,sws,svs,sps,srs,sgs,sus,shs, &
                        thflux,qvflux,cdu,cdv,ce,    &
                        radbcw,radbce,radbcs,radbcn,                      &
                        dum1,dum2,dum3,dum4,divx,rho,prs,                 &
                        t11,t12,t13,t22,t23,t33,                          &
                        rru,ua,u3d,uten,uten1,rrv,va,v3d,vten,vten1,      &
                        rrw,wa,w3d,wten,wten1,ppi,pp3d,ppten,sten,        &
                        tha,th3d,thten,thten1,thterm,tk,qa,q3d,qten,      &
                        kmh,kmv,khh,khv,tkea,tke3d,tketen,                &
                        pta,pt3d,ptten,                                   &
#ifdef MICROBURST
                        q1mb,q2mb, &
#endif
                        pdata,cfb,cfa,cfc,ad1,ad2,pdt,deft,rhs,trans)
#ifdef ORFSWATHS
      use orfswathsmod
#endif
      implicit none
 
      include 'input.incl'
      include 'constants.incl'

      integer :: num_soil_layers
      real*8, dimension(nbudget) :: qbudget
      real*8, dimension(numq) :: asq,bsq
      real, dimension(ib:ie) :: xh,rxh,uh,ruh
      real, dimension(ib:ie+1) :: xf,rxf,uf,ruf
      real, dimension(jb:je) :: yh,vh,rvh
      real, dimension(jb:je+1) :: yf,vf,rvf
      real, dimension(-2:nx+4) :: xfref
      real, dimension(-2:ny+4) :: yfref
      real, dimension(ib:ie,jb:je,kb:ke) :: zh,mh,rmh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: zf,mf,rmf
      real, dimension(ib:ie,jb:je) :: rho0s,pi0s,prs0s
      real, dimension(ib:ie,jb:je,kb:ke) :: pi0,prs0,rho0,thv0,th0,t0,qv0,rh0
      real, dimension(ib:ie,jb:je,kb:ke) :: qc0,ql0,rr0,rf0,rrf0
      real, dimension(itb:ite,jtb:jte) :: zs,gz
      real, dimension(ib:ie,jb:je,nrain) :: rain,sws,svs,sps,srs,sgs,sus,shs
      real, dimension(ib:ie,jb:je) :: thflux,qvflux,cdu,cdv,ce
      real, dimension(jb:je,kb:ke) :: radbcw,radbce
      real, dimension(ib:ie,kb:ke) :: radbcs,radbcn
      real, dimension(ib:ie,jb:je,kb:ke) :: dum1,dum2,dum3,dum4
      real, dimension(ib:ie,jb:je,kb:ke) :: divx,rho,prs
      real, dimension(ib:ie,jb:je,kb:ke) :: t11,t12,t13,t22,t23,t33
      real, dimension(ib:ie+1,jb:je,kb:ke) :: u0,rru,ua,u3d,uten,uten1
      real, dimension(ib:ie,jb:je+1,kb:ke) :: v0,rrv,va,v3d,vten,vten1
      real, dimension(ib:ie,jb:je,kb:ke+1) :: rrw,wa,w3d,wten,wten1
      real, dimension(ib:ie,jb:je,kb:ke) :: ppi,pp3d,ppten,sten
      real, dimension(ib:ie,jb:je,kb:ke) :: tha,th3d,thten,thten1,thterm,tk
      real, dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: qa,q3d,qten
      real, dimension(ibc:iec,jbc:jec,kbc:kec) :: kmh,kmv,khh,khv
      real, dimension(ibt:iet,jbt:jet,kbt:ket) :: tkea,tke3d,tketen
      real, dimension(ibp:iep,jbp:jep,kbp:kep,npt) :: pta,pt3d,ptten
      real, dimension(npvals,nparcels) :: pdata
      real, dimension(ipb:ipe,jpb:jpe,kpb:kpe) :: cfb
      real, dimension(kpb:kpe) :: cfa,cfc,ad1,ad2
      complex, dimension(ipb:ipe,jpb:jpe,kpb:kpe) :: pdt,deft
      complex, dimension(ipb:ipe,jpb:jpe) :: rhs,trans
#ifdef MICROBURST 
      real, dimension(ib:ie,jb:je,kb:ke) :: q1mb,q2mb
#endif
 
!-----------------------------------------------------------------------

      integer i,j,k,l,n,nn,nbub,nloop
      integer ic,jc,ifoo,jfoo
      real ric,rjc
      real xc,yc,zc,bhrad,bvrad,bptpert,beta,omega,tmp,zdep
      real thvnew(nk),pinew(nk)
      real thl,ql,qt,th1,t1,ql2,rm,cpm,v1,v2,th2

      real, dimension(:), allocatable :: rref
      real, dimension(:,:), allocatable :: vref,piref,thref,thvref,qvref
      real*8 :: rmax,vmax,frac,angle
      real :: r0,zdd,dd2,dd1,vr,rr,diff,xref,yref,xmax,ymax
      real :: c1,c2,mult,nominal_dx
      integer :: ival,ni1,ni2,ni3
      integer :: i1,i2,ii,nref

      real rmin,foo1,foo2,umax,umin,vmin
      real :: rand,amplitude
      real*8 :: dpi

      logical :: setppi,maintain_rh

!--------------------------

      real rslf

      if(myid.eq.0)then
            write(outfile,*) 'Inside INIT3D'
            write(outfile,*)
      endif


      convinit = 0
      setppi = .true.
      maintain_rh = .false.

!------------------------------------------------------------------
!  Initialize arrays with base state values.

      do n=1,nbudget
        qbudget(n)=0.0d0
      enddo

      do n=1,numq
        asq(n)=0.0d0
        bsq(n)=0.0d0
      enddo

      do n=1,nrain
      do j=jb,je
      do i=ib,ie
        ! these are all positive-definite, so set initial value to zero:
        rain(i,j,n)=0.0
        sws(i,j,n)=0.0
        srs(i,j,n)=0.0
        sgs(i,j,n)=0.0
        shs(i,j,n)=0.0
        ! for sps, we want to get a MINIMUM value at the surface, so...
        ! set sps to an absurdly large number:
        sps(i,j,n)=200000.0
        ! svs and sus can be negative or positive, 
        ! but we want to get a MAXIMUM value, so...
        ! set svs and sus to an absurdly low (negative) number:
        svs(i,j,n)=-1000.0
        sus(i,j,n)=-1000.0
#ifdef ORFSWATHS
!ORF TODO: set appropriately
        orfswaths(i,j,n,1) = 0.0
        orfswaths(i,j,n,2) = 0.0
        orfswaths(i,j,n,3) = 0.0
        orfswaths(i,j,n,4) = 0.0
        orfswaths(i,j,n,5) = 0.0
#endif
      enddo
      enddo
      enddo

      do j=jb,je
      do i=ib,ie
        thflux(i,j)=0.0
        qvflux(i,j)=0.0
           cdu(i,j)=0.0
           cdv(i,j)=0.0
            ce(i,j)=0.0
      enddo
      enddo

      do k=kb,ke
      do j=jb,je
      do i=ib,ie+1
        ua(i,j,k)=u0(i,j,k)
        u3d(i,j,k)=u0(i,j,k)
        rru(i,j,k)=0.0
        uten(i,j,k)=0.0
        uten1(i,j,k)=0.0
      enddo
      enddo
      enddo

      do k=kb,ke
      do j=jb,je+1
      do i=ib,ie
        va(i,j,k)=v0(i,j,k)
        v3d(i,j,k)=v0(i,j,k)
        rrv(i,j,k)=0.0
        vten(i,j,k)=0.0
        vten1(i,j,k)=0.0
      enddo
      enddo
      enddo

      do k=kb,ke+1
      do j=jb,je
      do i=ib,ie
        rrw(i,j,k)=0.0
        wa(i,j,k)=0.0
        w3d(i,j,k)=0.0
        wten(i,j,k)=0.0
        wten1(i,j,k)=0.0
      enddo
      enddo
      enddo

      do k=kb,ke
      do j=jb,je
      do i=ib,ie
        dum1(i,j,k)=0.0
        dum2(i,j,k)=0.0
        dum3(i,j,k)=0.0
        dum4(i,j,k)=0.0
        divx(i,j,k)=0.0
        rho(i,j,k)=rho0(i,j,k)
        prs(i,j,k)=prs0(i,j,k)
        ppi(i,j,k)=0.0
        pp3d(i,j,k)=0.0
        ppten(i,j,k)=0.0
        sten(i,j,k)=0.0
        tha(i,j,k)=0.0
        th3d(i,j,k)=0.0
        thten(i,j,k)=0.0
        thten1(i,j,k)=0.0
        thterm(i,j,k)=0.0
        tk(i,j,k)=0.0
        t11(i,j,k)=0.0
        t12(i,j,k)=0.0
        t13(i,j,k)=0.0
        t22(i,j,k)=0.0
        t23(i,j,k)=0.0
        t33(i,j,k)=0.0
      enddo
      enddo
      enddo

      IF(thsmall.eq.1)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=jb,je
        do i=ib,ie
          tk(i,j,k)=-0.5*rdz*mf(i,j,k)*rf0(i,j,k)*(th0(i,j,k)-th0(i,j,k-1))
        enddo
        enddo
        enddo
!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=jb,je
        do i=ib,ie
          tk(i,j,1)=-0.5*rf0(i,j,1)*(th0(i,j,2)-th0(i,j,1))   &
                                   /( zh(i,j,2)- zh(i,j,1))
          tk(i,j,nk+1)=-0.5*rf0(i,j,nk+1)*(th0(i,j,nk)-th0(i,j,nk-1))   &
                                         /( zh(i,j,nk)- zh(i,j,nk-1))
        enddo
        enddo
      ENDIF

!-----

      ! Start by defining all q arrays to be zero

      do n=1,numq
      do k=kbm,kem
      do j=jbm,jem
      do i=ibm,iem
          qa(i,j,k,n)=0.0
         q3d(i,j,k,n)=0.0
        qten(i,j,k,n)=0.0
      enddo
      enddo
      enddo
      enddo

      ! Now, define the qv arrays

    IF(imoist.eq.1)THEN

      do k=kbm,kem
      do j=jbm,jem
      do i=ibm,iem
        qa(i,j,k,nqv)=qv0(i,j,k)
      enddo
      enddo
      enddo

!---- This is here to ensure that certain idealized cases work ----

      IF( (isnd.eq.4 .or. isnd.eq.9 .or. isnd.eq.10 .or. isnd.eq.11) )THEN

        do k=kbm,kem
        do j=jbm,jem
        do i=ibm,iem
          qa(i,j,k,2)=qc0(i,j,k)
        enddo
        enddo
        enddo

      ENDIF

      IF( (isnd.eq.4 .or. isnd.eq.9 .or. isnd.eq.10) .and. iice.eq.1 )THEN

        do k=kbm,kem
        do j=jbm,jem
        do i=ibm,iem
          qa(i,j,k,4)=ql0(i,j,k)
        enddo
        enddo
        enddo

      ENDIF

    ENDIF

      ! this array must be zero for all cases

      do k=kb,ke
      do j=jb,je
      do i=ib,ie
        ql0(i,j,k)=0.0
      enddo
      enddo
      enddo

!-----

      do k=kbc,kec
      do j=jbc,jec
      do i=ibc,iec
        kmh(i,j,k)=0.0
        kmv(i,j,k)=0.0
        khh(i,j,k)=0.0
        khv(i,j,k)=0.0
      enddo
      enddo
      enddo

      do k=kbt,ket
      do j=jbt,jet
      do i=ibt,iet
        tkea(i,j,k)=0.0
        tke3d(i,j,k)=0.0
        tketen(i,j,k)=0.0
      enddo
      enddo
      enddo

!-----

      do n=1,npt
      do k=kbp,kep
      do j=jbp,jep
      do i=ibp,iep
        pta(i,j,k,n)=0.0
        pt3d(i,j,k,n)=0.0
        ptten(i,j,k,n)=0.0
      enddo
      enddo
      enddo
      enddo

    IF(iptra.eq.1)THEN
      ! define concentrations for passive fluid tracers here:
      do n=1,npt
      do k=kbp,kep
      do j=jbp,jep
      do i=ibp,iep
        if(n.eq.1)then
          pta(i,j,k,n)=0.0
          if(zh(i,j,k).lt.3000.0) pta(i,j,k,n)=0.001
        endif
        if(n.eq.2)then
          pta(i,j,k,n)=0.0
          if(zh(i,j,k).gt.3000.0.and.zh(i,j,k).lt.6000.0) pta(i,j,k,n)=0.001
        endif
        if(n.eq.3)then
          pta(i,j,k,n)=0.0
          if(zh(i,j,k).gt.6000.0.and.zh(i,j,k).lt.9000.0) pta(i,j,k,n)=0.001
        endif
      enddo
      enddo
      enddo
      enddo
    ENDIF

!-----

      do n=1,nparcels
      do i=1,npvals
        pdata(i,n)=0.0
      enddo
      enddo

      IF(iprcl.eq.1)THEN
        ! define initial locations of parcels here:

        if(myid.eq.0)then
              write(outfile,*)
              write(outfile,*) '  Parcels ! '
              write(outfile,*) '  npvals,nparcels = ',npvals,nparcels
              write(outfile,*) '  Initial parcel locations (x,y,z):'
        endif
        n = 0
        do k=1,10
        do j=1,60
        do i=1,60
          n = n + 1
          if(n.gt.nparcels)then
            if(myid.eq.0)then
                  write(outfile,*)
                  write(outfile,*) ' You are trying to define too many parcels'
                  write(outfile,*)
                  write(outfile,*) ' Increase the value of nparcels in namelist.input'
                  write(outfile,*)
            endif
            call stopcm1
          endif
          pdata(1,n) = minx + 2000.0*(i-1)
          pdata(2,n) = miny + 2000.0*(j-1)
          pdata(3,n) = zh(1,1,1) + 1000.0*(k-1)
          if(myid.eq.0)write(outfile,*) n,pdata(1,n),pdata(2,n),pdata(3,n)
        enddo
        enddo
        enddo
        if(myid.eq.0)write(outfile,*)

        do i=1,nparcels
          pdata(ifx,i)=pdata(1,i)
          pdata(ify,i)=pdata(2,i)
          pdata(ifz,i)=pdata(3,i)
        enddo

      ENDIF

!-----

      do k=kb,ke
      do j=jb,je
        radbcw(j,k)=0.0
        radbce(j,k)=0.0
      enddo
      enddo

      do k=kb,ke
      do i=ib,ie
        radbcs(i,k)=0.0
        radbcn(i,k)=0.0
      enddo
      enddo

!-----------------------------------------------------------------------
!  iinit = 1
!  Warm bubble
!  reference:

      IF(iinit.eq.1)THEN

      if(myid.eq.0)then
        write(outfile,*)
        write(outfile,*) '  Warm bubble'
        write(outfile,*)
      endif

        ric     =     var8  ! center of bubble in x-direction (m)
        rjc     =     var9  ! center of bubble in y-direction (m)
        zc      =   1400.0  ! height of center of bubble above ground (m)
        bhrad   =     var7  ! horizontal radius of bubble (m)
        bvrad   =   1400.0  ! vertical radius of bubble (m)
        bptpert =    var10  ! max potential temp perturbation (K)

        ! By default, CM1 sets qv=constant at a constant height level for 
        ! this value of iinit.  If you would rather have rh=constant at 
        ! a constant height level, then set this to .true.
        maintain_rh = .false.

!ORF see George email 11/22/10 subject 'init'
!Bubble is long along its n/s axis (3.0*bhrad)

        do k=1,nk
        do j=1,nj
        do i=1,ni
          beta=sqrt(                             &
                    ((xh(i)-ric)/bhrad)**2       &
                   +((yh(j)-rjc)/(var6*bhrad))**2       &
!                  +((yh(j)-rjc)/(bhrad))**2       &
                   +((zh(i,j,k)-zc)/bvrad)**2)
          if(beta.lt.1.0)then
            tha(i,j,k)=bptpert*(cos(0.5*pi*beta)**2)
          else
            tha(i,j,k)=0.0
          endif
        enddo
        enddo
        enddo

!-----------------------------------------------------------------------
!  iinit = 2
!  Cold pool (dam break style)
!  reference:  

      ELSEIF(iinit.eq.2)THEN

      if(myid.eq.0)then
        write(outfile,*)
        write(outfile,*) '  Cold pool .... periodic in N-S'
        write(outfile,*)
      endif

        ric      =  200000.0   ! eastern edge of cold pool
        zdep     =    2500.0   ! depth of cold pool (m)
        bptpert  =      -6.0   ! max temp perturbation at sfc (K)

        ! By default, CM1 sets qv=constant at a constant height level for 
        ! this value of iinit.  If you would rather have rh=constant at 
        ! a constant height level, then set this to .true.
        maintain_rh = .true.

        do k=1,nk
        do j=1,nj
        do i=1,ni
          if( (xh(i).le.ric).and.(zh(i,j,k).lt.zdep) )then
            tha(i,j,k)=bptpert*(zdep-zh(i,j,k))/zdep
          else
            tha(i,j,k)=0.0
          endif
        enddo
        enddo
        enddo


!-----------------------------------------------------------------------
!  iinit = 3
!  Line of warm bubbles
!  reference:  

      ELSEIF(iinit.eq.3)THEN

      if(myid.eq.0)then
        write(outfile,*)
        write(outfile,*) '  Line of warm bubbles'
        write(outfile,*)
      endif
 
        nbub    =      3     ! number of warm bubbles
        ric     =  30000.0   ! center of bubble in x-direction (m)
        zc      =   1400.0   ! height of center of bubble above ground (m)
        bhrad   =  10000.0   ! horizontal radius of bubble (m)
        bvrad   =   1400.0   ! vertical radius of bubble (m)
        bptpert =      2.0   ! max potential temp perturbation (K)

        ! By default, CM1 sets qv=constant at a constant height level for 
        ! this value of iinit.  If you would rather have rh=constant at 
        ! a constant height level, then set this to .true.
        maintain_rh = .false.

        do k=kb,ke
        do j=jb,je
        do i=ib,ie
          tha(i,j,k)=0.0
        enddo
        enddo
        enddo

        do n=1,nbub

          if(n.eq.1) rjc=  3000.0
          if(n.eq.2) rjc= 33000.0
          if(n.eq.3) rjc= 63000.0

          if(myid.eq.0)write(outfile,*) '  ric,rjc=',n,ric,rjc
 
          do k=kb,ke
          do j=jb,je
          do i=ib,ie
            beta=sqrt(                        &
                    ((xh(i)-ric)/bhrad)**2    &
                   +((yh(j)-rjc)/bhrad)**2    &
                   +((zh(i,j,k)-zc)/bvrad)**2)
            if(beta.lt.1.0)then
              tha(i,j,k)=bptpert*(cos(0.5*pi*beta)**2)
            else
              tha(i,j,k)=max(0.0,tha(i,j,k))
            endif
          enddo
          enddo
          enddo

        enddo


!-----------------------------------------------------------------------
!  iinit = 4
!  moist bubble for moist benchmark
!  reference:  Bryan and Fritsch, 2002, MWR, 130, 2917-2928.

      ELSEIF(iinit.eq.4)THEN

        ! parameters for dry counterpart bubble

        ric      =      0.0       ! x-location of bubble center (m)
        zc       =   2000.0       ! z-location of bubble center (m)
        bhrad    =   2000.0       ! horizontal radius of bubble (m)
        bvrad    =   2000.0       ! vertical radius of bubble (m)
        bptpert  =      2.0       ! maximum potential temp. pert. (K)

        do k=kb,ke
        do j=jb,je
        do i=ib,ie
          beta=sqrt( ((xh(i)-ric)/bhrad)**2    &
                    +((zh(i,j,k)-zc)/bvrad)**2)
          if(beta.lt.1.0)then
            dum1(i,j,k)=bptpert*(cos(0.5*pi*beta)**2)
          else
            dum1(i,j,k)=0.
          endif
        enddo
        enddo
        enddo

        do k=kb,ke
        do j=jb,je
        do i=ib,ie
          tha(i,j,k)=0.
          ppi(i,j,k)=0.
        enddo
        enddo
        enddo

        do nn=1,30
          do k=kb,ke
          do j=jb,je
          do i=ib,ie
            qa(i,j,k,nqv)=rh0(i,j,k)*rslf(prs0(i,j,k),(th0(i,j,k)+tha(i,j,k))*pi0(i,j,k))
          enddo
          enddo
          enddo

          do k=kb,ke
          do j=jb,je
          do i=ib,ie
            qa(i,j,k,2)=max(qt_mb-qa(i,j,k,nqv),0.0)
          enddo
          enddo
          enddo

          do k=kb,ke
          do j=jb,je
          do i=ib,ie
            tha(i,j,k)=( (dum1(i,j,k)/300.)+(1.0+qt_mb)/(1.0+qa(i,j,k,nqv)) )  &
               *thv0(i,j,k)*(1.0+qa(i,j,k,nqv))/(1.0+reps*qa(i,j,k,nqv)) - th0(i,j,k)
            if(abs(tha(i,j,k)).lt.1.e-4) tha(i,j,k)=0.
          enddo
          enddo
          enddo
        enddo

        do k=kb,ke
        do j=jb,je
        do i=ib,ie
          qa(i,j,k,nqv)=rslf(prs0(i,j,k),(th0(i,j,k)+tha(i,j,k))*pi0(i,j,k))
          qa(i,j,k,2  )=max(qt_mb-qa(i,j,k,nqv),0.0)
        enddo
        enddo
        enddo

!-----------------------------------------------------------------
!  iinit = 5
!  density current sim

      ELSEIF(iinit.eq.5)THEN

      if(myid.eq.0)then
        write(outfile,*)
        write(outfile,*) '  Cold pool (elipse, following Straka)'
        write(outfile,*)
      endif

        ric     =     0.0
        rjc     =     0.0
        zc      =  3000.0
        bhrad   =  4000.0
        bvrad   =  2000.0
        bptpert =   -15.0

        do k=kb,ke
        do j=jb,je
        do i=ib,ie
          beta=sqrt(                           &
                     ((xh(i)-ric)/bhrad)**2    &
!!!                    +((yh(j)-rjc)/bhrad)**2    &
                    +((zh(i,j,k)-zc)/bvrad)**2)
          if(beta.lt.1.0)then
            dum1(i,j,k)=bptpert*(cos(pi*beta)+1.0)*0.5
          else
            dum1(i,j,k)=0.0
          endif
        enddo
        enddo
        enddo

        do k=kb,ke
        do j=jb,je
        do i=ib,ie
          tmp=t0(i,j,k)+dum1(i,j,k)
          tha(i,j,k)=tmp/pi0(i,j,k)-th0(i,j,k)
          if(abs(tha(i,j,k)).lt.1.e-4) tha(i,j,k)=0.0
          ppi(i,j,k)=0.0
        enddo
        enddo
        enddo


#ifdef MICROBURST
!-----------------------------------------------------------------
!  iinit = 55
!  ORF microburst. Just sets the cooling function array - forcing
!  occurs in solve.F

      ELSEIF(iinit.eq.55)THEN

        write(outfile,*)
        write(outfile,*) '  Microburst (elipsoid, following Straka)'
        write(outfile,*)
! ORF microburst recreation w/out time dependant forcing
! Colliding microbursts by activating both q1 and q2

!q1
        ric     = 5000.0
        rjc     = 0.0 
        zc      =  2000.0
        bhrad   =  1200.0
        bvrad   =  1800.0
        bptpert = var1 ! K/s not K

        do k=1,nk
        do j=1,nj
        do i=1,ni
        ! 3D
          beta=sqrt(                             &
                    ((xh(i)-ric)/bhrad)**2       &
                   +((yf(j)-rjc)/bhrad)**2       &
                   +((zh(i,j,k)-zc)/bvrad)**2)
! 2D
!         beta=sqrt(                             &
!                   ((xh(i)-ric)/bhrad)**2       &
!                  +((zh(i,j,k)-zc)/bvrad)**2)
          if(beta.lt.1.0)then
            q1mb(i,j,k)=bptpert*(cos(0.5*pi*beta)**2)
          else
            q1mb(i,j,k)=0.0
          endif
          tha(i,j,k)=0.0
        enddo
        enddo
        enddo

!q2
        ric     = 7000.0
        rjc     = 0.0 ! mirror symmetry
        zc      =  2000.0
        bhrad   =  1200.0
        bvrad   =  1800.0
        bptpert = var1 ! K/s not K

        do k=1,nk
        do j=1,nj
        do i=1,ni
        ! 3D
          beta=sqrt(                             &
                    ((xh(i)-ric)/bhrad)**2       &
                   +((yf(j)-rjc)/bhrad)**2       &
                   +((zh(i,j,k)-zc)/bvrad)**2)
! 2D
!         beta=sqrt(                             &
!                   ((xh(i)-ric)/bhrad)**2       &
!                  +((zh(i,j,k)-zc)/bvrad)**2)
          if(beta.lt.1.0)then
            q2mb(i,j,k)=bptpert*(cos(0.5*pi*beta)**2)
          else
            q2mb(i,j,k)=0.0
          endif
          tha(i,j,k)=0.0 !redundant
        enddo
        enddo
        enddo
#endif


!------------------------------------------------------------------
!  Rotunno-Emanuel tropical cyclone vortex
!  (see Rotunno and Emanuel, 1987, JAS, for more information)

      ELSEIF(iinit.eq.7)THEN

        r0     =   412500.0
        rmax   =    82500.0
        vmax   =       15.0
        zdd    =    20000.0

        dd2 = 2.0 * rmax / ( r0 + rmax )

        allocate(  rref(nx)       )
        allocate(  vref(nx,0:nk+1))
        allocate( piref(nx,0:nk+1))
        allocate( thref(nx,0:nk+1))
        allocate(thvref(nx,0:nk+1))
        allocate( qvref(nx,0:nk+1))

          rref=0.0
          vref=0.0
         piref=0.0
         thref=0.0
        thvref=0.0
         qvref=0.0

        IF(ibalance.ne.0)THEN
         if(myid.eq.0)then
          write(outfile,*)
          write(outfile,*) ' Please use ibalance = 0 with iinit=7'
          write(outfile,*)
          write(outfile,*) ' ... stopping inside init3d ... '
          write(outfile,*)
         endif
          call stopcm1
        ENDIF
        IF(terrain_flag)THEN
         if(myid.eq.0)then
          write(outfile,*)
          write(outfile,*) ' iinit=7 is not setup for use with terrain'
          write(outfile,*)
          write(outfile,*) ' ... stopping inside init3d ... '
          write(outfile,*)
         endif
          call stopcm1
        ENDIF

        IF(axisymm.eq.1)THEN
          nref = nx
          xref = 0.0
          do i=1,nref
            rref(i) = 0.5*(xfref(i)+xfref(i+1))
          enddo
        ELSE
          nref = nx/2+1
          xref = xfref(nx/2+1)
          yref = yfref(ny/2+1)
          xmax = 0.5*(xfref(nx)+xfref(nx+1))
          ymax = 0.5*(yfref(ny)+yfref(ny+1))
          do i=1,nref
            rref(i) = 0.5*(xfref(nx/2+i)+xfref(nx/2+i+1))-xref
          enddo
        ENDIF

!!!        print *
!!!        print *,'  v:'
        do k=1,nk
        do i=1,nref
          if(rref(i).lt.r0)then
            dd1 = 2.0 * rmax / ( rref(i) + rmax )
            vr = sqrt( vmax**2 * (rref(i)/rmax)**2     &
            * ( dd1 ** 3 - dd2 ** 3 ) + 0.25*fcor*fcor*rref(i)*rref(i) )   &
                    - 0.5 * fcor * rref(i)
          else
            vr = 0.0
          endif
          if(zh(1,1,k).lt.zdd)then
            vref(i,k) = vr * (zdd-zh(1,1,k))/(zdd-0.0)
          else
            vref(i,k) = 0.0
          endif
!!!          if(k.eq.1) print *,i,xh(ni/2+i),rref(i),vref(i,k)
        enddo
        enddo
!!!        print *

      ! need to iterate for qv to converge:
      DO nloop=1,20

        do k=1,nk
        do i=1,nref
          if(imoist.eq.1)   &
          qvref(i,k) = rh0(1,1,k)*rslf(p00*((pi0(1,1,k)+piref(i,k))**cpdrd),   &
                             (pi0(1,1,k)+piref(i,k))*(th0(1,1,k)+thref(i,k)) )
          thvref(i,k)=(th0(1,1,k)+thref(i,k))*(1.0+reps*qvref(i,k))   &
                                             /(1.0+qvref(i,k))
        enddo
        enddo

!!!        print *,'  pi:'
        do k=1,nk
          piref(nref,k)=0.0
          do i=nref,2,-1
            piref(i-1,k) = piref(i,k)                                       &
         + (rref(i-1)-rref(i))/(cp*0.5*(thvref(i-1,k)+thvref(i,k))) * 0.5 * &
             ( vref(i  ,k)*vref(i  ,k)/rref(i)                              &
              +vref(i-1,k)*vref(i-1,k)/rref(i-1)                            &
               + fcor * ( vref(i,k) + vref(i-1,k) ) )
!!!            if(k.eq.1) print *,i-1,rref(i-1),piref(i-1,k)
          enddo
        enddo
!!!        print *

        do i=1,nref
          piref(i,   0) = piref(i, 1)
          piref(i,nk+1) = piref(i,nk)
        enddo

        do k=2,nk
        do i=1,nref
          thref(i,k) = 0.5*( cp*0.5*(thvref(i,k)+thvref(i,k+1))*(piref(i,k+1)-piref(i,k))*rdz*mf(1,1,k+1)     &
                            +cp*0.5*(thvref(i,k)+thvref(i,k-1))*(piref(i,k)-piref(i,k-1))*rdz*mf(1,1,k) )   &
                          *thv0(1,1,k)/g
          thref(i,k)=(thv0(1,1,k)+thref(i,k))*(1.0+qvref(i,k))/(1.0+reps*qvref(i,k))-th0(1,1,k)
        enddo
        enddo

        k=1
        do i=1,nref
          thref(i,k) = ( cp*0.5*(thvref(i,k)+thvref(i,k+1))*(piref(i,k+1)-piref(i,k))*rdz*mf(1,1,k+1) )   &
                          *thv0(1,1,k)/g
          thref(i,k)=(thv0(1,1,k)+thref(i,k))*(1.0+qvref(i,k))/(1.0+reps*qvref(i,k))-th0(1,1,k)
        enddo

        if(myid.eq.0)write(outfile,*) nloop,thref(1,1),qvref(1,1),piref(1,1)

      ENDDO   ! enddo for iteration

        IF(axisymm.eq.1)THEN

          do k=1,nk
          do i=1,ni
             va(i,1,k) =  vref(i,k)
            ppi(i,1,k) = piref(i,k)
            tha(i,1,k) = thref(i,k)
            if(imoist.eq.1) qa(i,1,k,nqv) = qvref(i,k)
          enddo
          enddo

        ELSE

          do j=1,nj+1
          do i=1,ni+1
            ! scalar points:
            rr = sqrt( (xh(i)-xref)**2 + (yh(j)-yref)**2 )
            rr = min( rr , xmax-xref )
            ! need to account for grid stretching.  Do simple search:
            diff = -1.0e20
            ii = 0
            do while( diff.lt.0.0 )
              ii = ii + 1
              if( ii.gt.nref )then
                write(6,*)
                write(6,*) ' ii,nref = ',ii,nref
                write(6,*) ' rr      = ',rr,xmax,xref
                write(6,*) ' rref    = ',rref(ii-1),rref(ii-1)-rr
                write(6,*)
                call stopcm1
              endif
              diff = rref(ii)-rr
            enddo
            i2 = ii
            i1 = i2-1
            frac = (      rr-rref(i1))   &
                  /(rref(i2)-rref(i1))
            do k=1,nk
              ppi(i,j,k) = piref(i1,k)+(piref(i2,k)-piref(i1,k))*frac
              tha(i,j,k) = thref(i1,k)+(thref(i2,k)-thref(i1,k))*frac
              if(imoist.eq.1) qa(i,j,k,nqv) = qvref(i1,k)+(qvref(i2,k)-qvref(i1,k))*frac
            enddo

            ! u:
            rr = sqrt( (xf(i)-xref)**2 + (yh(j)-yref)**2 )
            rr = min( rr , xmax-xref )
            ! need to account for grid stretching.  Do simple search:
            diff = -1.0e20
            ii = 0
            do while( diff.lt.0.0 )
              ii = ii + 1
              if( ii.gt.nref )then
                write(6,*)
                write(6,*) ' ii,nref = ',ii,nref
                write(6,*) ' rr      = ',rr,xmax,xref
                write(6,*)
                call stopcm1
              endif
              diff = rref(ii)-rr
            enddo
            if( abs(rr-rref(ii)).lt.tsmall .and. ii.eq.1 ) ii = 2
            i2 = ii
            i1 = i2-1
            frac = (      rr-rref(i1))   &
                  /(rref(i2)-rref(i1))
            do k=1,nk
              angle = datan2(dble(yh(j)-yref),dble(xf(i)-xref))
              ua(i,j,k) = -( vref(i1,k)+( vref(i2,k)- vref(i1,k))*frac )*sin(angle)
            enddo

            ! v:
            rr = sqrt( (yf(j)-yref)**2 + (xh(i)-xref)**2 )
            rr = min( rr , xmax-xref )
            ! need to account for grid stretching.  Do simple search:
            diff = -1.0e20
            ii = 0
            do while( diff.lt.0.0 )
              ii = ii + 1
              if( ii.gt.nref )then
                write(6,*)
                write(6,*) ' ii,nref = ',ii,nref
                write(6,*) ' rr      = ',rr,xmax,xref
                write(6,*)
                call stopcm1
              endif
              diff = rref(ii)-rr
            enddo
            if( abs(rr-rref(ii)).lt.tsmall .and. ii.eq.1 ) ii = 2
            i2 = ii
            i1 = i2-1
            frac = (      rr-rref(i1))   &
                  /(rref(i2)-rref(i1))
            do k=1,nk
              angle = datan2(dble(yf(j)-yref),dble(xh(i)-xref))
              va(i,j,k) = (vref(i1,k)+( vref(i2,k)- vref(i1,k))*frac )*cos(angle)
            enddo
          enddo
          enddo

!!!          print *
!!!          print *,'  symmtest:'
!!!          j = nj/2 + 5
!!!          k = 1
!!!          do i=1,nref
!!!            print *,i,j,ua(i,j,k),va(j,i,k),ua(i,j,k)+va(j,i,k)
!!!          enddo
!!!          print *

        ENDIF

        call bcu(ua)
        call bcv(va)
        call bcs(ppi)
        call bcs(tha)

        call calcprs(pi0,prs,ppi)

        deallocate(  rref)
        deallocate(  vref)
        deallocate( piref)
        deallocate( thref)
        deallocate(thvref)
        deallocate( qvref)

        setppi = .false.

!-----------------------------------------------------------------------
!  iinit = 8
!  Line thermal with random small-amplitude perturbations

      ELSEIF(iinit.eq.8)THEN

      if(myid.eq.0)then
        write(outfile,*)
        write(outfile,*) '  Line thermal w/random small ample perturbations (Warm bubble)'
        write(outfile,*)
      endif

        ric     = 150000.0  ! center of bubble in x-direction (m)
        zc      =   1500.0  ! height of center of bubble above ground (m)
        bhrad   =  10000.0  ! horizontal radius of bubble (m)
        bvrad   =   1500.0  ! vertical radius of bubble (m)
        bptpert =      2.0  ! max potential temp perturbation (K)

        ! By default, CM1 sets qv=constant at a constant height level for 
        ! this value of iinit.  If you would rather have rh=constant at 
        ! a constant height level, then set this to .true.
        maintain_rh = .false.

        call random_seed

        do n=1,myid
        do k=1,nk
        do j=1,nj
        do i=1,ni
          call random_number(rand)
        enddo
        enddo
        enddo
        enddo

        do k=1,nk
        do j=1,nj
        do i=1,ni
          call random_number(rand)
          beta=sqrt(                             &
                    ((xh(i)-ric)/bhrad)**2       &
                   +((zh(i,j,k)-zc)/bvrad)**2)
          if(beta.lt.1.0)then
            tha(i,j,k)=bptpert*(cos(0.5*pi*beta)**2)   &
                      +0.2*(2.0*rand-1.0)
          else
            tha(i,j,k)=0.0
          endif
        enddo
        enddo
        enddo

!------------------------------------------------------------------
!  iinit = 9
!  Forced convergence
!  Reference:  Loftus et al, 2008: MWR, v. 136, pp. 2408--2421.

      ELSEIF(iinit.eq.9)THEN

        ! User-defined settings:
        Dmax     =  -1.0e-3     ! maximum divergence (s^{-1})
        zdeep    =  2000.0      ! depth (m) of forced convergence
        lamx     = 10000.0      ! Loftus et al lambda_x parameter
        lamy     = 10000.0      ! Loftus at al lambda_y parameter
        xcent    =     0.0      ! x-location (m)
        ycent    =     0.0      ! y-location (m)
        convtime =   900.0      ! time (s) at beginning of simulation over
                                ! which convergence is applied

        ! Don't change anything below here:
        convinit = 1
        IF( ny.eq.1 )THEN
          ! 2D (x-z):
          Aconv = (-0.5*Dmax)/( (1.0/(lamx**2)) )
          lamy = 1.0e20
        ELSEIF( nx.eq.1 )THEN
          ! 2D (y-z):
          Aconv = (-0.5*Dmax)/( (1.0/(lamy**2)) )
          lamx = 1.0e20
        ELSE
          ! 3D:
          Aconv = (-0.5*Dmax)/( (1.0/(lamx**2))+(1.0/(lamy**2)) )
        ENDIF

!------------------------------------------------------------------

      ENDIF    ! end of iinit options

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

! Random perturbations:

      IF( irandp.eq.1 )THEN

        ! this is the amplitude of the theta perturbations
        ! (plus or minus this value in K)
        amplitude = 0.5

        ! initialize the random number generator
        call random_seed

        ! this makes sure that each processor has a different set
        ! of random numbers for MPI runs
        do n=1,myid
        do k=1,nk
        do j=1,nj
        do i=1,ni
          call random_number(rand)
        enddo
        enddo
        enddo
        enddo

        ! random numbers added here
        ! (can be modified to only place perturbations in certain
        !  locations, but this default code simply puts them
        !  everywhere)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          call random_number(rand)
          tha(i,j,k)=tha(i,j,k)+amplitude*(2.0*rand-1.0)
        enddo
        enddo
        enddo

      ENDIF

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

!----------------------------------------------
!  arrays for elliptic solver

      do k=kpb,kpe
      do j=jpb,jpe
      do i=ipb,ipe
        cfb(i,j,k) = 0.0
      enddo
      enddo
      enddo


      do k=kpb,kpe
        cfa(k) = 0.0
        cfc(k) = 0.0
        ad1(k) = 0.0
        ad2(k) = 0.0
      enddo

      IF( (ibalance.eq.2).or.(psolver.eq.4).or.(psolver.eq.5) )THEN

        dpi = 4.0d0*datan(1.0d0)
        if(myid.eq.0)write(outfile,*) '  dpi = ',dpi

        IF(psolver.le.3)THEN
          do k=1,nk
            cfa(k)=mh(1,1,k)*mf(1,1,k  )*rf0(1,1,k  )*0.5*(thv0(1,1,k-1)+thv0(1,1,k))/(dz*dz*rho0(1,1,k)*thv0(1,1,k))
            cfc(k)=mh(1,1,k)*mf(1,1,k+1)*rf0(1,1,k+1)*0.5*(thv0(1,1,k)+thv0(1,1,k+1))/(dz*dz*rho0(1,1,k)*thv0(1,1,k))
            ad1(k) = 1.0/(cp*rho0(1,1,k)*thv0(1,1,k))
            ad2(k) = 1.0
          enddo
          cfa( 1) = 0.0
          cfc(nk) = 0.0
          do j=jpb,jpe
          do i=ipb,ipe
            do k=1,nk
              cfb(i,j,k)=2.0d0*( dcos(2.0d0*dpi*dble(i-1)/dble(ipe))          &
                                +dcos(2.0d0*dpi*dble(j-1)/dble(jpe))          &
                                -2.0d0)/(dx*dx) - cfa(k) - cfc(k)
            enddo
          enddo
          enddo
        ELSE
          do k=1,nk
            cfa(k)=mh(1,1,k)*mf(1,1,k  )*rf0(1,1,k  )/(dz*dz*rho0(1,1,k-1))
            cfc(k)=mh(1,1,k)*mf(1,1,k+1)*rf0(1,1,k+1)/(dz*dz*rho0(1,1,k+1))
            ad1(k) = 1.0
            ad2(k) = 1.0/rho0(1,1,k)
          enddo
          cfa( 1) = 0.0
          cfc(nk) = 0.0
          do j=jpb,jpe
          do i=ipb,ipe
            do k=2,nk-1
              cfb(i,j,k)=2.0d0*( dcos(2.0d0*dpi*dble(i-1)/dble(ipe))          &
                                +dcos(2.0d0*dpi*dble(j-1)/dble(jpe))          &
                                -2.0d0)/(dx*dx)                               &
                    -mh(1,1,k)*mf(1,1,k+1)*rf0(1,1,k+1)/(dz*dz*rho0(1,1,k))   &
                    -mh(1,1,k)*mf(1,1,k  )*rf0(1,1,k  )/(dz*dz*rho0(1,1,k))
            enddo
            cfb(i,j,1)=2.0d0*( dcos(2.0d0*dpi*dble(i-1)/dble(ipe))          &
                              +dcos(2.0d0*dpi*dble(j-1)/dble(jpe))          &
                              -2.0d0)/(dx*dx)                               &
                  -mh(1,1,1)*mf(1,1,2  )*rf0(1,1,2  )/(dz*dz*rho0(1,1,1))
            cfb(i,j,nk)=2.0d0*( dcos(2.0d0*dpi*dble(i-1)/dble(ipe))          &
                              +dcos(2.0d0*dpi*dble(j-1)/dble(jpe))          &
                              -2.0d0)/(dx*dx)                               &
                  -mh(1,1,nk)*mf(1,1,nk  )*rf0(1,1,nk  )/(dz*dz*rho0(1,1,nk))
          enddo
          enddo
        ENDIF

      ENDIF

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

!-----------------------------------------------------------------
!  Get 3d pressure
      if(imoist.eq.1 .and. maintain_rh)then

        !! maintain rh
        if(myid.eq.0)then
              write(outfile,*)
              write(outfile,*) '  Constant rh across domain:'
              write(outfile,*)
        endif

        do k=kb,ke
        do j=jb,je
        do i=ib,ie
          qa(i,j,k,nqv)=rh0(i,j,k)*rslf(prs0(i,j,k),(th0(i,j,k)+tha(i,j,k))*pi0(i,j,k))
        enddo
        enddo
        enddo

      endif


    IF(setppi)THEN

      do k=kb,ke
      do j=jb,je
      do i=ib,ie
        ppi(i,j,k)=0.0
      enddo
      enddo
      enddo

      IF(ibalance.eq.1)THEN

        ! hydrostatic balance ... integrate top-down

        do j=1,nj
        do i=1,ni
          ! virtual potential temperature

          if(imoist.eq.1)then
            do k=1,nk
              qt=0.0
              do n=nql1,nql2
                qt=qt+qa(i,j,k,n)
              enddo
              if(iice.eq.1)then
                do n=nqs1,nqs2
                  qt=qt+qa(i,j,k,n)
                enddo
              endif
              thvnew(k)=(th0(i,j,k)+tha(i,j,k))*(1.0+reps*qa(i,j,k,nqv))   &
                                               /(1.0+qa(i,j,k,nqv)+qt)
            enddo
          else
            do k=1,nk
              thvnew(k)=th0(i,j,k)+tha(i,j,k)
            enddo
          endif

          ! non-dimensional pressure
          pinew(nk)=pi0(i,j,nk)
          do k=nk-1,1,-1
            pinew(k)=pinew(k+1)+g*(zh(i,j,k+1)-zh(i,j,k))   &
                    /(cp*0.5*(thvnew(k+1)+thvnew(k)))
          enddo

          ! new pressure
          do k=1,nk
            ppi(i,j,k)=pinew(k)-pi0(i,j,k)
            if(abs(ppi(i,j,k)).lt.1.0e-6) ppi(i,j,k)=0.0
          enddo

        enddo
        enddo

      ELSEIF(ibalance.eq.2)THEN

      if(myid.eq.0)then
        write(outfile,*)
        write(outfile,*) '  ibalance = 2'
        write(outfile,*)
      endif

        if(stretch_x.ge.1.or.stretch_y.ge.1)then
          print *,'  this option not supported with horizontal grid stretching'
          print *,'  (yet)'
          call stopcm1
        endif

#ifdef MPI
        print *,'  This option is not (yet) supported in MPI mode'
        print *,'  (sorry)'
        print *
        call stopcm1
#endif

        ! buoyancy pressure

        ! th3d stores theta-v

        if(imoist.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            qt=0.0
            do n=nql1,nql2
              qt=qt+qa(i,j,k,n)
            enddo
            if(iice.eq.1)then
              do n=nqs1,nqs2
                qt=qt+qa(i,j,k,n)
              enddo
            endif
            th3d(i,j,k)=(th0(i,j,k)+tha(i,j,k))*(1.0+reps*qa(i,j,k,nqv))   &
                       /(1.0+qa(i,j,k,nqv)+qt)
          enddo
          enddo
          enddo
        else
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            th3d(i,j,k)=th0(i,j,k)+tha(i,j,k)
          enddo
          enddo
          enddo
        endif

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do j=1,nj
        do i=1,ni
          th3d(i,j,0   ) = th3d(i,j,1)
          th3d(i,j,nk+1) = th3d(i,j,nk)
        enddo
        enddo

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          dum4(i,j,k)=g*( th3d(i,j,k)/thv0(i,j,k)-1.0 )
        enddo
        enddo
        enddo

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do j=1,nj
        do i=1,ni
          dum4(i,j,0   ) = -dum4(i,j,1)
          dum4(i,j,nk+1) = -dum4(i,j,nk)
        enddo
        enddo

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk+1
        do j=1,nj
        do i=1,ni
          wten(i,j,k)=0.5*( dum4(i,j,k-1)+dum4(i,j,k) )
        enddo
        enddo
        enddo

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=kb,ke
        do j=jb,je
        do i=ib,ie
          ppi(i,j,k)=0.0
          dum3(i,j,k)=0.0
          divx(i,j,k)=0.0
          uten(i,j,k)=0.0
          vten(i,j,k)=0.0
        enddo
        enddo
        enddo

        call poiss(uh,vh,mh,rmh,mf,rmf,pi0,thv0,rho0,rf0,    &
                   dum3,divx,ppi,uten,vten,wten,             &
                   cfb,cfa,cfc,ad1,ad2,pdt,deft,rhs,trans,dtl)

        IF(psolver.eq.4.or.psolver.eq.5)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=kb,ke
          do j=jb,je
          do i=ib,ie
            ppi(i,j,k)=((prs0(1,1,k)+ppi(i,j,k)*rho0(1,1,k))*rp00)**rovcp   &
                      -pi0(1,1,k)
            pp3d(i,j,k)=ppi(i,j,k)
          enddo
          enddo
          enddo

        ENDIF

        call bcs(ppi)

      ENDIF

    ENDIF

!------------------------------------------------------------------

      if(myid.eq.0)then
            write(outfile,*)
            write(outfile,*) 'Leaving INIT3D'
            call FFLUSH(outfile)
      endif

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine getset(dzdx,dzdy,pi0,th0,rho0,prs0,rho,prs,               &
                        ua,u3d,va,v3d,wa,w3d,ppi,pp3d,                     &
                        tha,th3d,qa,q3d,tkea,tke3d,pta,pt3d,               &
                        reqs_u,reqs_v,reqs_w,reqs_s,reqs_tk,               &
                        uw31,uw32,ue31,ue32,us31,us32,un31,un32,           &
                        vw31,vw32,ve31,ve32,vs31,vs32,vn31,vn32,           &
                        ww31,ww32,we31,we32,ws31,ws32,wn31,wn32,           &
                        sw31,sw32,se31,se32,ss31,ss32,sn31,sn32,           &
                        tkw1,tkw2,tke1,tke2,tks1,tks2,tkn1,tkn2)
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
#ifdef MPI
      include 'mpif.h'
#endif

      real, dimension(itb:ite,jtb:jte) :: dzdx,dzdy
      real, dimension(ib:ie,jb:je,kb:ke) :: pi0,th0,rho0,prs0
      real, dimension(ib:ie,jb:je,kb:ke) :: rho,prs
      real, dimension(ib:ie+1,jb:je,kb:ke) :: ua,u3d
      real, dimension(ib:ie,jb:je+1,kb:ke) :: va,v3d
      real, dimension(ib:ie,jb:je,kb:ke+1) :: wa,w3d
      real, dimension(ib:ie,jb:je,kb:ke) :: ppi,pp3d
      real, dimension(ib:ie,jb:je,kb:ke) :: tha,th3d
      real, dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: qa,q3d
      real, dimension(ibt:iet,jbt:jet,kbt:ket) :: tkea,tke3d
      real, dimension(ibp:iep,jbp:jep,kbp:kep,npt) :: pta,pt3d
      integer, dimension(rmp) :: reqs_u,reqs_v,reqs_w,reqs_s,reqs_tk
      real, dimension(cmp,jmp,kmp)   :: uw31,uw32,ue31,ue32
      real, dimension(imp+1,cmp,kmp) :: us31,us32,un31,un32
      real, dimension(cmp,jmp+1,kmp) :: vw31,vw32,ve31,ve32
      real, dimension(imp,cmp,kmp)   :: vs31,vs32,vn31,vn32
      real, dimension(cmp,jmp,kmp-1) :: ww31,ww32,we31,we32
      real, dimension(imp,cmp,kmp-1) :: ws31,ws32,wn31,wn32
      real, dimension(cmp,jmp,kmp)   :: sw31,sw32,se31,se32
      real, dimension(imp,cmp,kmp)   :: ss31,ss32,sn31,sn32
      real, dimension(cmp,jmp,kmt)   :: tkw1,tkw2,tke1,tke2
      real, dimension(imp,cmp,kmt)   :: tks1,tks2,tkn1,tkn2

!----------
 
      integer i,j,k,n

!------------------------------------------------------------------
!  Make sure boundary values are set properly

      if(myid.eq.0)then
            write(outfile,*) 'Inside GETSET'
            write(outfile,*)
      endif

      call bcu(ua)
      call bcv(va)
      call bcw(wa,1)
      call bcs(ppi)
      call bcs(tha)
      if(imoist.eq.1)then
        do n=1,numq
          call bcs(qa(ibm,jbm,kbm,n))
        enddo
      endif
      if(iturb.eq.1)then
        call bct(tkea)
      endif
      if(iptra.eq.1)then
        do n=1,npt
          call bcs(pta(ib,jb,kb,n))
        enddo
      endif

#ifdef MPI
!------------------------------------------------------------------

      nf=0
      nu=0
      nv=0
      nw=0

      call comm_3u_start(ua,uw31,uw32,ue31,ue32,   &
                            us31,us32,un31,un32,reqs_u)
      call comm_3u_end(ua,uw31,uw32,ue31,ue32,   &
                          us31,us32,un31,un32,reqs_u)

      call comm_3v_start(va,vw31,vw32,ve31,ve32,   &
                            vs31,vs32,vn31,vn32,reqs_v)
      call comm_3v_end(va,vw31,vw32,ve31,ve32,   &
                          vs31,vs32,vn31,vn32,reqs_v)

      call comm_3w_start(wa,ww31,ww32,we31,we32,   &
                            ws31,ws32,wn31,wn32,reqs_w)
      call comm_3w_end(wa,ww31,ww32,we31,we32,   &
                          ws31,ws32,wn31,wn32,reqs_w)

      call comm_3s_start(ppi,sw31,sw32,se31,se32,   &
                             ss31,ss32,sn31,sn32,reqs_s)
      call comm_3s_end(ppi,sw31,sw32,se31,se32,   &
                           ss31,ss32,sn31,sn32,reqs_s)

      call comm_3s_start(tha,sw31,sw32,se31,se32,   &
                             ss31,ss32,sn31,sn32,reqs_s)
      call comm_3s_end(tha,sw31,sw32,se31,se32,   &
                           ss31,ss32,sn31,sn32,reqs_s)

      IF(imoist.eq.1)THEN
        do n=1,numq
          call comm_3s_start(qa(ibm,jbm,kbm,n),sw31,sw32,se31,se32,   &
                                               ss31,ss32,sn31,sn32,reqs_s)
          call comm_3s_end(qa(ibm,jbm,kbm,n),sw31,sw32,se31,se32,   &
                                             ss31,ss32,sn31,sn32,reqs_s)
        enddo
      ENDIF

      IF(iturb.eq.1)THEN
        call comm_3t_start(tkea,tkw1,tkw2,tke1,tke2,   &
                                tks1,tks2,tkn1,tkn2,reqs_tk)
        call comm_3t_end(tkea,tkw1,tkw2,tke1,tke2,   &
                              tks1,tks2,tkn1,tkn2,reqs_tk)
      ENDIF

      IF(iptra.eq.1)THEN
        do n=1,npt
          call comm_3s_start(pta(ib,jb,kb,n),sw31,sw32,se31,se32,   &
                                             ss31,ss32,sn31,sn32,reqs_s)
          call comm_3s_end(pta(ib,jb,kb,n),sw31,sw32,se31,se32,   &
                                           ss31,ss32,sn31,sn32,reqs_s)
        enddo
      ENDIF

      call MPI_BARRIER (MPI_COMM_WORLD,ierr)

#endif
      if(terrain_flag)then
        call bcwsfc(dzdx,dzdy,ua,va,wa)
        call bc2d(wa(ib,jb,1))
      endif
!------------------------------------------------------------------
!  Get stuff

    IF(psolver.eq.4.or.psolver.eq.5)THEN

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        rho(i,j,k)=rho0(i,j,k)
        prs(i,j,k)=prs0(i,j,k)
      enddo
      enddo
      enddo

    ELSE

      call calcprs(pi0,prs,ppi)
 
      call calcrho(pi0,th0,rho,prs,ppi,tha,qa)

    ENDIF

!------------------------------------------------------------------

      do k=kb,ke
      do j=jb,je
      do i=ib,ie+1
        u3d(i,j,k)=ua(i,j,k)
      enddo
      enddo
      enddo
 
      do k=kb,ke
      do j=jb,je+1
      do i=ib,ie
        v3d(i,j,k)=va(i,j,k)
      enddo
      enddo
      enddo
 
      do k=kb,ke+1
      do j=jb,je
      do i=ib,ie
        w3d(i,j,k)=wa(i,j,k)
      enddo
      enddo
      enddo

      do k=kb,ke
      do j=jb,je
      do i=ib,ie
        pp3d(i,j,k)=ppi(i,j,k)
        th3d(i,j,k)=tha(i,j,k)
      enddo
      enddo
      enddo

      if(imoist.eq.1)then
        do n=1,numq
        do k=kb,ke
        do j=jb,je
        do i=ib,ie
          q3d(i,j,k,n)=qa(i,j,k,n)
        enddo
        enddo
        enddo
        enddo
      endif

      if(iturb.eq.1)then
        do k=kbt,ket
        do j=jbt,jet
        do i=ibt,iet
          tke3d(i,j,k)=tkea(i,j,k)
        enddo
        enddo
        enddo
      endif

      if(iptra.eq.1)then
        do n=1,npt
        do k=kb,ke
        do j=jb,je
        do i=ib,ie
          pt3d(i,j,k,n)=pta(i,j,k,n)
        enddo
        enddo
        enddo
        enddo
      endif

      if(myid.eq.0)then
            write(outfile,*)
            write(outfile,*) 'Leaving GETSET'
      endif
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine convinitu(myid,ib,ie,jb,je,kb,ke,ni,nj,nk,ibw,ibe,   &
                           zdeep,lamx,lamy,xcent,ycent,aconv,    &
                           xf,yh,zh,u0,u3d)
      implicit none

      integer, intent(in) :: myid,ib,ie,jb,je,kb,ke,ni,nj,nk,ibw,ibe
      real, intent(in) :: zdeep,lamx,lamy,xcent,ycent,aconv
      real, intent(in), dimension(ib:ie+1) :: xf
      real, intent(in), dimension(jb:je) :: yh
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: zh
      real, intent(in),    dimension(ib:ie+1,jb:je,kb:ke) :: u0
      real, intent(inout), dimension(ib:ie+1,jb:je,kb:ke) :: u3d

      integer :: i,j,k
      real :: term1,term2,term3,term4,umo

!!!      if(myid.eq.0) print *,'    convinitu '
!$omp parallel do default(shared)   &
!$omp private(i,j,k,term1,term2,term3,term4,umo)
      do k=1,nk
      do j=1,nj
      do i=1,ni+1
        term4 = (zdeep-0.5*(zh(i-1,j,k)+zh(i,j,k)))/zdeep
        if (term4 .gt. 0.0) then
          term1 = -(2.0*Aconv*(xf(i)-xcent))/(lamx**2)
          term2 = -((xf(i)-xcent)/lamx)**2
          term3 = -((yh(j)-ycent)/lamy)**2
          umo = term1*(exp(term2)*exp(term3))*term4
          if( abs(umo).gt.0.01 ) u3d(i,j,k) = u0(i,j,k)+umo
        endif
      enddo
      enddo
      enddo

      return
      end subroutine convinitu


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine convinitv(myid,ib,ie,jb,je,kb,ke,ni,nj,nk,ibs,ibn,   &
                           zdeep,lamx,lamy,xcent,ycent,aconv,    &
                           xh,yf,zh,v0,v3d)
      implicit none

      integer, intent(in) :: myid,ib,ie,jb,je,kb,ke,ni,nj,nk,ibs,ibn
      real, intent(in) :: zdeep,lamx,lamy,xcent,ycent,aconv
      real, intent(in), dimension(ib:ie) :: xh
      real, intent(in), dimension(jb:je+1) :: yf
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: zh
      real, intent(in),    dimension(ib:ie,jb:je+1,kb:ke) :: v0
      real, intent(inout), dimension(ib:ie,jb:je+1,kb:ke) :: v3d

      integer :: i,j,k
      real :: term1,term2,term3,term4,vmo

!!!      if(myid.eq.0) print *,'    convinitv '
!$omp parallel do default(shared)   &
!$omp private(i,j,k,term1,term2,term3,term4,vmo)
      do k=1,nk
      do j=1,nj+1
      do i=1,ni
        term4 = (zdeep-0.5*(zh(i,j-1,k)+zh(i,j,k)))/zdeep
        if (term4 .gt. 0.0) then
          term1 = -(2.0*Aconv*(yf(j)-ycent))/(lamy**2)
          term2 = -((xh(i)-xcent)/lamx)**2
          term3 = -((yf(j)-ycent)/lamy)**2
          vmo = term1*(exp(term2)*exp(term3))*term4
          if( abs(vmo).gt.0.01 ) v3d(i,j,k) = v0(i,j,k)+vmo
        endif
      enddo
      enddo
      enddo

      return
      end subroutine convinitv


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
init_physics.F/ 1298670057  19071 8000  100644  10072     `
      subroutine init_physics(prs0,rf0,cdu,cdv,ce,dum1,dum2,dum3,u0,ua,v0,va,o30,   &
                             lu_index,xland,emiss,thc,albd,znt,mavail,f2d,tsk,u1,v1,w1)
      use module_sf_slab
      use module_sf_sfclay
      implicit none

      include 'input.incl'
      include 'radcst.incl'

      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: prs0,rf0
      real, intent(inout), dimension(ib:ie,jb:je) :: cdu,cdv,ce
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: dum1,dum2,dum3
      real, intent(in), dimension(ib:ie+1,jb:je,kb:ke) :: u0,ua
      real, intent(in), dimension(ib:ie,jb:je+1,kb:ke) :: v0,va
      real, intent(inout), dimension(ibr:ier,jbr:jer,kbr:ker) :: o30
      integer, intent(in), dimension(ibl:iel,jbl:jel) :: lu_index
      real, intent(inout), dimension(ibl:iel,jbl:jel) :: xland,emiss,thc,albd,znt,mavail,f2d
      real, intent(inout), dimension(ib:ie,jb:je) :: tsk,u1,v1,w1

      real :: foo1,foo2,foo3,foo4,foo5,foo6

!-----------------------------------------------------------------------
!-----  USERS SHOULD NOT NEED TO CHANGE ANYTHING IN THIS FILE ----------
!-----  (unless you really, really know what you are doing -------------
!-----------------------------------------------------------------------

      if(radopt.eq.1)then
        ! initialize radiation code:
        call setradwrk(nir,njr,nkr)
        call julday( year, month, day, jday )
        if(myid.eq.0)write(outfile,*) '  jday = ',jday
        call initrad(myid,year,month,day,hour,minute,second,jday,nir,njr,nkr)
        o30 = 1.0e-6
        call fito3(nir,njr,1,1,nkr,dum1(1,1,1),dum2(1,1,1),prs0,o30,ib,ie,jb,je,kb,ke,nk)
        ! Settings from Goddard scheme:
        call getgoddardvars(foo1,foo2,foo3,foo4,foo5,foo6)
        roqr = foo1
        tnw  = foo2
        roqs = foo3
        tns  = foo4
        roqg = foo5
        tng  = foo6
      endif

      IF( idrag.eq.1 .or. isfcflx.eq.1 )THEN
        if( sfcmodel.eq.1 )then
          call getcecd(cdu,cdv,ce,u0,v0,rf0,u1,v1,w1,ua,va)
        elseif( sfcmodel.eq.2 )then
          call sfclayinit
        endif
      ENDIF

      f2d = fcor

!-----------------------------------------------------------------------

      end subroutine init_physics


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine getgoddardvars(foo1,foo2,foo3,foo4,foo5,foo6)
      implicit none
      include 'goddard.incl'

      real, intent(inout) :: foo1,foo2,foo3,foo4,foo5,foo6

      foo1 = roqr
      foo2 = tnw
      foo3 = roqs
      foo4 = tnss
      foo5 = roqg
      foo6 = tng

      end subroutine getgoddardvars


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine initrad(myid,year,month,day,hour,minute,second,jday,   &
                         nir,njr,nkr)
      implicit none

      include 'irrad.incl'
      include 'radzen.incl'
      include 'radmore.incl'

      integer, intent(in) :: myid,year,month,day,hour,minute,second,jday,   &
                             nir,njr,nkr

      integer :: ip,iw,it
      logical :: high

!----------------------------------------------------------------------

  IF ( rlwopt == 0 ) THEN
    high = .false.
  ELSE
    high = .true.
  END IF

  if(myid.eq.0) print *,'  high = ',high

!----------------------------------------------------------------------
!  from zenangl:

    pi2 = 2.0 * pi
    deg2rad = pi/180.0
    rad2deg = 1./deg2rad

    hour0 = FLOAT(hour)                                                 &
          + FLOAT(minute)/60.0                                          &
          + FLOAT(second)/3600.0

    IF ( MOD(year, 4) == 0 ) THEN
      yrday = 366.
    ELSE
      yrday = 365.
    END IF

!!! not using arps MPI code:  GHB, 100720
!!! hard-wire these in, just in case:
    nxmid = 1
    nymid = 1
    source = 0

!----------------------------------------------------------------------
!  from irrad:

!-----tables co2 and h2o are only used with 'high' option

    IF (high) THEN

      DO iw=1,nh
        DO ip=1,nx
          h11(ip,iw,1)=1.0-h11(ip,iw,1)
          h21(ip,iw,1)=1.0-h21(ip,iw,1)
          h71(ip,iw,1)=1.0-h71(ip,iw,1)
        END DO
      END DO

      DO iw=1,nc
        DO ip=1,nx
          c1(ip,iw,1)=1.0-c1(ip,iw,1)
        END DO
      END DO

!-----tables are replicated to avoid memory bank conflicts

      DO it=2,nt
        DO iw=1,nc
          DO ip=1,nx
            c1 (ip,iw,it)= c1(ip,iw,1)
            c2 (ip,iw,it)= c2(ip,iw,1)
            c3 (ip,iw,it)= c3(ip,iw,1)
          END DO
        END DO
        DO iw=1,nh
          DO ip=1,nx
            h11(ip,iw,it)=h11(ip,iw,1)
            h12(ip,iw,it)=h12(ip,iw,1)
            h13(ip,iw,it)=h13(ip,iw,1)
            h21(ip,iw,it)=h21(ip,iw,1)
            h22(ip,iw,it)=h22(ip,iw,1)
            h23(ip,iw,it)=h23(ip,iw,1)
            h71(ip,iw,it)=h71(ip,iw,1)
            h72(ip,iw,it)=h72(ip,iw,1)
            h73(ip,iw,it)=h73(ip,iw,1)
          END DO
        END DO
      END DO

    END IF

!-----always use table look-up for ozone transmittance

    DO iw=1,no
      DO ip=1,nx
        o1(ip,iw,1)=1.0-o1(ip,iw,1)
      END DO
    END DO

    DO it=2,nt
      DO iw=1,no
        DO ip=1,nx
          o1 (ip,iw,it)= o1(ip,iw,1)
          o2 (ip,iw,it)= o2(ip,iw,1)
          o3 (ip,iw,it)= o3(ip,iw,1)
        END DO
      END DO
    END DO

      return
      end subroutine initrad


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine getlanduse(season,myid,ib,ie,jb,je,ibl,iel,jbl,jel,   &
                            lu_index,xland,emiss,thc,albedo,znt,mavail)
      implicit none

#ifdef MPI
      include 'mpif.h'
#endif

      integer, intent(in) :: season,myid,ib,ie,jb,je,ibl,iel,jbl,jel
      integer, intent(in), dimension(ibl:iel,jbl:jel) :: lu_index
      real, intent(inout), dimension(ibl:iel,jbl:jel) :: xland,emiss,thc,albedo,znt,mavail

      integer, parameter :: max_cats = 33    ! max categories
      integer, parameter :: max_seas =  2    ! max seasons

      integer, parameter :: iswater = 16  ! water must be category 16

      real, dimension(:,:), allocatable :: albd,slmo,sfem,sfz0,therin,scfx,sfhc
      integer :: cat,sea

      integer :: i,j,is,isn,ierr

      allocate(   albd(max_cats,max_seas) )
      allocate(   slmo(max_cats,max_seas) )
      allocate(   sfem(max_cats,max_seas) )
      allocate(   sfz0(max_cats,max_seas) )
      allocate( therin(max_cats,max_seas) )
      allocate(   scfx(max_cats,max_seas) )
      allocate(   sfhc(max_cats,max_seas) )

!-----------------------------------------------------------------------

      IF( myid.eq.0 )THEN
        open(unit=11,file='LANDUSE.TBL',status='old',err=888)
        read(11,*)
        read(11,*)
        do isn=1,max_seas
          read(11,*)
          do is=1,max_cats
            read(11,*) i,albd(is,isn),slmo(is,isn),sfem(is,isn),sfz0(is,isn), &
                       therin(is,isn),scfx(is,isn),sfhc(is,isn)
          enddo
        enddo
!        print *
!        print *,'  summer:'
!        print *,'  albd = ',albd(:,1)
!        print *,'  slmo = ',slmo(:,1)
!        print *,'  sfem = ',sfem(:,1)
!        print *,'  sfz0 = ',sfz0(:,1)
!        print *,'  ther = ',therin(:,1)
!        print *,'  scfx = ',scfx(:,1)
!        print *,'  sfhc = ',sfhc(:,1)
!        print *
!        print *,'  winter:'
!        print *,'  albd = ',albd(:,2)
!        print *,'  slmo = ',slmo(:,2)
!        print *,'  sfem = ',sfem(:,2)
!        print *,'  sfz0 = ',sfz0(:,2)
!        print *,'  ther = ',therin(:,2)
!        print *,'  scfx = ',scfx(:,2)
!        print *,'  sfhc = ',sfhc(:,2)
      ENDIF

#ifdef MPI
      call MPI_BCAST(albd  ,max_cats*max_seas,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(slmo  ,max_cats*max_seas,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(sfem  ,max_cats*max_seas,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(sfz0  ,max_cats*max_seas,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(therin,max_cats*max_seas,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(scfx  ,max_cats*max_seas,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(sfhc  ,max_cats*max_seas,MPI_REAL,0,MPI_COMM_WORLD,ierr)
#endif

!-----------------------------------------------------------------------

      ! ISN = season:    summer = 1    winter = 2
      ISN = season

      do j=jb,je
      do i=ib,ie
        IS = lu_index(i,j)
        ! SET NO-DATA POINTS (IS=0) TO WATER
        IF(IS.EQ.0)THEN
          IS=ISWATER
        ENDIF
        if( albd(is,isn).le.0.0 )then
          print *,'  category not found '
          call stopcm1
        endif
        ALBEDO(I,J) = ALBD(IS,ISN)/100.
        THC(i,j) = THERIN(IS,ISN)/100.
        EMISS(I,J) = SFEM(IS,ISN)
        ZNT(I,J) = SFZ0(IS,ISN)/100.
        MAVAIL(I,J) = SLMO(IS,ISN)
        IF(IS.NE.ISWATER)THEN
          XLAND(I,J)=1.0
        ELSE
          XLAND(I,J)=2.0
        ENDIF
      enddo
      enddo

!-----------------------------------------------------------------------

      deallocate(   albd )
      deallocate(   slmo )
      deallocate(   sfem )
      deallocate(   sfz0 )
      deallocate( therin )
      deallocate(   scfx )
      deallocate(   sfhc )


      return

!-----------------------------------------------------------------------

888   print *
      print *,'  There was an error opening the LANDUSE.TBL file '
      print *
      print *,'  Please make sure that LANDUSE.TBL is in the same directory '
      print *,'  as cm1.exe ... it is distributed with CM1 in the "run" directory '
      print *
      call stopcm1
      end subroutine getlanduse
init_surface.F/ 1298670057  19071 8000  100644  7949      `
      subroutine init_surface(num_soil_layers,   &
           dodrag,dosfcflx,xh,ruh,xf,yh,rvh,yf,   &
           lu_index,xland,tsk,slab_zs,slab_dzs,tslb, &
           emiss,thc,albd,znt,mavail,dsxy,prs0s,prs0,   &
           tmn,tml,t0ml,hml,h0ml,huml,hvml,tmoml)
      use module_sf_oml
      implicit none

      include 'input.incl'
      include 'constants.incl'

      integer, intent(in) :: num_soil_layers
      logical, intent(inout) :: dodrag,dosfcflx
      real, intent(in), dimension(ib:ie) :: xh,ruh
      real, intent(in), dimension(ib:ie+1) :: xf
      real, intent(in), dimension(jb:je) :: yh,rvh
      real, intent(in), dimension(jb:je+1) :: yf
      integer, intent(inout), dimension(ibl:iel,jbl:jel) :: lu_index
      real, intent(inout), dimension(ibl:iel,jbl:jel) :: xland
      real, intent(inout), dimension(ib:ie,jb:je) :: tsk
      real, intent(inout), dimension(num_soil_layers) :: slab_zs,slab_dzs
      real, intent(inout), dimension(ibl:iel,jbl:jel,num_soil_layers) :: tslb
      real, intent(inout), dimension(ibl:iel,jbl:jel) :: emiss,thc,albd,znt,mavail,dsxy
      real, intent(in), dimension(ib:ie,jb:je) :: prs0s
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: prs0
      real, intent(inout), dimension(ibl:iel,jbl:jel) :: tmn,tml,t0ml,hml,h0ml,huml,hvml,tmoml

      integer :: i,j,k,l,icm,lm
      real :: wrmax,psfc,qvsatts,rhgs,pterm

!-----------------------------------------------------------------------
!  BEGIN user settings

    IF( sfcmodel.ge.1 )THEN

      ! Initialize the surface:

      ! Key:
      ! tsk      = "skin temperature" (K) of soil/water  (~1 cm deep)
      ! tmn      = deep-layer temperature (K) of soil  (sfcmodel=2 only)
      ! xland    = land/water flag:   1 for land,   2 for water
      ! lu_index = land use index   (1-33) (see LANDUSE.TBL file)

!----------
!  Deafult ... fill in arrays with values from Namelist:

      do j=jb,je
      do i=ib,ie
        tsk(i,j)      = tsk0
      enddo
      enddo

      do j=jbl,jel
      do i=ibl,iel
        tmn(i,j)      = tmn0
        xland(i,j)    = xland0
        lu_index(i,j) = lu0
      enddo
      enddo

!----------
!  Initialize the sea breeze test case from WRF:

      IF( initsfc.eq.2 )THEN 

        ! sea breeze test case from WRF:

        icm = ni/2
        lm = 25

        do j=jb,je
        do i=ib,ie
          if( i.ge.(icm-lm).and.i.lt.(icm+lm) )then
            ! land:
            xland(i,j) = 1.0
            lu_index(i,j) = 18
            tsk(i,j) = 280.0
            tmn(i,j) = 280.0
          else
            ! water:
            xland(i,j) = 2.0
            lu_index(i,j) = 16
            tsk(i,j) = 287.0
            tmn(i,j) = 280.0
          endif
        enddo
        enddo

!----------
!  if initsfc is not 1,2:

      ELSEIF( initsfc.ne.1 .and. initsfc.ne.2 )THEN

        ! build your own initial conditions here:

!!!        do j=jb,je
!!!        do i=ib,ie
!!!          tsk(i,j)      = ?
!!!          tmn(i,j)      = ?
!!!          xland(i,j)    = ?
!!!          lu_index(i,j) = ?
!!!        enddo
!!!        enddo

!----------

      ENDIF     ! endif for initsfc options

!     END of user settings
!-----------------------------------------------------------------------
!     NO NOT CHANGE ANYTHING BELOW HERE

    IF( sfcmodel.eq.2 )THEN

      IF (num_soil_layers.NE.1)THEN
      slab_dzs(1)=.01
      slab_zs(1)=.5*slab_dzs(1)
      DO l=2,num_soil_layers
         slab_dzs(l)=2*slab_dzs(l-1)
         slab_zs(l)=slab_zs(l-1)+.5*slab_dzs(l-1)+.5*slab_dzs(l)
      ENDDO
      DO l=1,num_soil_layers
         DO j=jb,je
            DO i=ib,ie
              tslb(i,j,l)=( tsk(i,j)*(slab_zs(num_soil_layers)-slab_zs(l))   &
                          + tmn(i,j)*(slab_zs(l)-slab_zs(1)) ) / &
                          ( slab_zs(num_soil_layers)-slab_zs(1) )
            ENDDO
         ENDDO
      ENDDO
      ENDIF

    ENDIF

    IF( sfcmodel.ge.1 )THEN

      IF( axisymm.eq.1 .or. ny.eq.1 )THEN

        do j=jb,je
        do i=ib,ie
          dsxy(i,j) = dx*ruh(i)
        enddo
        enddo

      ELSE

        do j=jb,je
        do i=ib,ie
          dsxy(i,j) = sqrt( (dx*ruh(i))**2 + (dy*rvh(j))**2 )
        enddo
        enddo

      ENDIF

    ENDIF

  ENDIF    ! endif for sfcmodel >= 1

!-----------------------------------------------------------------------
! ensure interoperability of surface schemes and turbulence schemes:
!   NOTE:  DO NOT modify anything here unless you really, really
!          know what you are doing

      ! parameters needed in turbtke subroutines:
      dosfcflx = .false.
      dodrag = .false.

      IF(iturb.ge.1)THEN
        if( idrag.eq.1   ) dodrag   = .true.
        if( isfcflx.eq.1 ) dosfcflx = .true.
        if( sfcmodel.eq.2 )then
          dosfcflx = .true.
          dodrag = .true.
        endif
      ENDIF
      IF( ipbl.eq.1 )THEN
        ! sfc flux/drag is handled by pbl subroutine:
        dosfcflx = .false.
        dodrag = .false.
      ENDIF

      if(myid.eq.0)then
            write(outfile,*)
            write(outfile,*) '  Settings used in this simulation:'
            write(outfile,*) '  idrag    = ',idrag
            write(outfile,*) '  isfcflx  = ',isfcflx
            write(outfile,*) '  bcturbu  = ',bcturbu
            write(outfile,*) '  dosfcflx = ',dosfcflx
            write(outfile,*) '  dodrag   = ',dodrag
            write(outfile,*)
      endif

!-----------------------------------------------------------------------
!  Initialize land-surface parameters:

      if( sfcmodel.ge.1 )then
        ! initialize MM5/WRF landuse categories:
        call getlanduse(season,myid,ib,ie,jb,je,ibl,iel,jbl,jel,   &
                        lu_index,xland,emiss,thc,albd,znt,mavail)
      endif

!-----------------------------------------------------------------------
!  reality checks:

      IF( sfcmodel.ge.1 )THEN

        do j=jb,je
        do i=ib,ie
          IF( nint(xland(i,j)).le.0 .or. nint(xland(i,j)).ge.3 )THEN
            print *
            print *,'  Invalid value for xland '
            print *
            print *,'    xland must be 1 (for land) or 2 (for water) '
            print *
            print *,'  Stopping CM1 .... '
            print *
            call stopcm1
          ENDIF
          if( sfcmodel.eq.2 )then
          IF( lu_index(i,j).le.0 .or. lu_index(i,j).ge.34 )THEN
            print *
            print *,'  Invalid value for lu_index '
            print *
            print *,'    lu_index must be between 1 and 33 '
            print *,'    (see LANDUSE.TBL for more info) '
            print *
            print *,'  Stopping CM1 .... '
            print *
            call stopcm1
          ENDIF
          endif
          IF( tsk(i,j).lt.100.0 )THEN
            print *
            print *,'  WARNING:  tsk is less than 100 K '
            print *
            print *,'  Stopping CM1 .... '
            print *
            call stopcm1
          ENDIF
          if( sfcmodel.eq.2 )then
          IF( tmn(i,j).lt.100.0 )THEN
            print *
            print *,'  WARNING:  tmn is less than 100 K '
            print *
            print *,'  Stopping CM1 .... '
            print *
            call stopcm1
          ENDIF
          endif
        enddo
        enddo

      ENDIF

!-----------------------------------------------------------------------
!  Initialize the ocean mixed layer model:

      if(oceanmodel.eq.2)then
        call omlinit(outfile,oml_hml0, tsk,                     &
                       tml,t0ml,hml,h0ml,huml,hvml,tmoml,       &
                       .false.,         .true. ,                &
                         1, ni+1,   1, nj+1,   1, nk+1,         &
                        ib, ie,  jb, je,  kb, ke,               &
                         1, ni,   1, nj,   1, nk                )
      endif

!-----------------------------------------------------------------------

      end subroutine init_surface

init_terrain.F/ 1298670057  19071 8000  100644  9350      `
      subroutine init_terrain(xh,xf,yh,yf,sigma,sigmaf,   &
                              zh,mh,rmh,zf,mf,rmf,zs,gz,dzdx,dzdy,gx,gy)
      implicit none

      include 'input.incl'
      include 'constants.incl'
#ifdef MPI
      include 'mpif.h'
#endif

      real, intent(in), dimension(ib:ie) :: xh
      real, intent(in), dimension(ib:ie+1) :: xf
      real, intent(in), dimension(jb:je) :: yh
      real, intent(in), dimension(jb:je+1) :: yf
      real, intent(inout), dimension(kb:ke) :: sigma
      real, intent(inout), dimension(kb:ke+1) :: sigmaf
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: zh,mh,rmh
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke+1) :: zf,mf,rmf
      real, intent(inout), dimension(itb:ite,jtb:jte) :: zs,gz,dzdx,dzdy
      real, intent(inout), dimension(itb:ite+1,jtb:jte,ktb:kte) :: gx
      real, intent(inout), dimension(itb:ite,jtb:jte+1,ktb:kte) :: gy

      integer :: i,j,k,irec
      real :: hh,aa,xval,xc

#ifdef MPI
      character*50 fname
      integer nabor
      integer, dimension(8) :: reqs,reqs_s,reqs_u,reqs_v
      real, dimension(3,nj) :: west,newwest,east,neweast
      real, dimension(ni,3) :: south,newsouth,north,newnorth
      real, dimension(3,nj,nk) :: sw31,sw32,se31,se32
      real, dimension(ni,3,nk) :: ss31,ss32,sn31,sn32
      real, dimension(3,nj,nk) :: uw31,uw32,ue31,ue32
      real, dimension(ni+1,3,nk) :: us31,us32,un31,un32
      real, dimension(3,nj+1,nk) :: vw31,vw32,ve31,ve32
      real, dimension(ni,3,nk) :: vs31,vs32,vn31,vn32
#endif

!-----------------------------------------------------------------------
!     SPECIFY TERRAIN HERE
!-----------------------------------------------------------------------

!----------------------------------------------------------
!  itern = 1
!  bell-shaped

        IF(itern.eq.1)THEN

          hh =      400.0              ! max. height (m)
          aa =     1000.0              ! half width (m)
          xc =        0.0 + 0.5*dx     ! x-location (m)

          do j=jb,je
          do i=ib,ie
            zs(i,j)=hh/( 1.0+( (xh(i)-xc)/aa )**2 )
          enddo
          enddo

!---------------
!  itern = 2
!  Schaer case

        ELSEIF(itern.eq.2)THEN

          do j=jb,je
          do i=ib,ie
            xval=dx*(i-ni/2)
            zs(i,j)=250.0*exp(-(xval/5000.0)**2)*(cos(pi*xval/4000.0)**2)
          enddo
          enddo

!---------------

        ELSEIF(itern.eq.3)THEN

          hh =      500.0     ! max. height (m)
          aa =    20000.0     ! half width (m)

          do j=jb,je
          do i=ib,ie
            xval = sqrt( (xh(i)-129000.0)**2   &
                        +(yh(j)-129000.0)**2   &
                                             )
            zs(i,j)=hh*( (1.0+(xval/aa)**2 )**(-1.5) )
          enddo
          enddo

!----------------------------------------------------------
!  itern = 4
!  read from GrADS file "perts.dat"

        ELSEIF(itern.eq.4)THEN

          open(unit=73,file='perts.dat',status='old',   &
               form='unformatted',access='direct',recl=4)

          do j=1,nj
          do i=1,ni
            irec=(myj-1)*nx*nj   &
                +(j-1)*nx        &
                +(myi-1)*ni      &
                +i
            read(73,rec=irec) zs(i,j)
          enddo
          enddo

          close(unit=73)

!----------------------------------------------------------

        ENDIF

!--------------------------------------------------------------
!  DO NOT CHANGE ANYTHING BELOW HERE !
!--------------------------------------------------------------

        call bc2d(zs)
#ifdef MPI
        nf=0
        nu=0
        nv=0
        nw=0
        call comm_2d_start(zs,west,newwest,east,neweast,   &
                              south,newsouth,north,newnorth,reqs)
        call comm_2dew_end(zs,west,newwest,east,neweast,reqs)
        call comm_2dns_end(zs,south,newsouth,north,newnorth,reqs)
        call bcs2_2d(zs)
        call comm_2d_corner(zs)
        call bc2d(zs)
#endif

        zt = maxz

        if(stretch_z.ne.1)then

          do k=kb,ke+1
            sigmaf(k)=dz*(k-1)
          enddo

        endif

        if(myid.eq.0) then
              write(outfile,*)
              do k=1,nk+1
                write(outfile,*) '  sigmaf:',k,sigmaf(k)
              enddo
              write(outfile,*)
        endif

        do k=kb,ke
          sigma(k)=0.5*(sigmaf(k)+sigmaf(k+1))
        enddo

        do k=1,nk
        do j=1,nj
        do i=1,ni
          zh(i,j,k)=zs(i,j)+sigma(k)*(zt-zs(i,j))/zt
        enddo
        enddo
        enddo

        do k=kb,ke+1
        do j=jb,je
        do i=ib,ie
          zf(i,j,k)=zs(i,j)+sigmaf(k)*(zt-zs(i,j))/zt
        enddo
        enddo
        enddo

        do j=1,nj
        do i=1,ni
          gz(i,j)=zt/(zt-zs(i,j))
        enddo
        enddo

        do j=1,nj
        do i=1,ni
          dzdx(i,j)=( 45.0*( zs(i+1,j)-zs(i-1,j) )                &
                      -9.0*( zs(i+2,j)-zs(i-2,j) )                &
                          +( zs(i+3,j)-zs(i-3,j) ) )/(60.0*dx)
          dzdy(i,j)=( 45.0*( zs(i,j+1)-zs(i,j-1) )                &
                      -9.0*( zs(i,j+2)-zs(i,j-2) )                &
                          +( zs(i,j+3)-zs(i,j-3) ) )/(60.0*dx)
        enddo
        enddo

!--------------------------------
!  set boundary points

        call bc2d(gz)
        call bc2d(dzdx)
        call bc2d(dzdy)
        call bcs(zh)

#ifdef MPI
        call comm_2d_start(gz,west,newwest,east,neweast,   &
                              south,newsouth,north,newnorth,reqs)
        call comm_2dew_end(gz,west,newwest,east,neweast,reqs)
        call comm_2dns_end(gz,south,newsouth,north,newnorth,reqs)
        call bcs2_2d(gz)
        call comm_2d_corner(gz)
        call bc2d(gz)

        call comm_2d_start(dzdx,west,newwest,east,neweast,   &
                                south,newsouth,north,newnorth,reqs)
        call comm_2dew_end(dzdx,west,newwest,east,neweast,reqs)
        call comm_2dns_end(dzdx,south,newsouth,north,newnorth,reqs)
        call bcs2_2d(dzdx)
        call comm_2d_corner(dzdx)
        call bc2d(dzdx)

        call comm_2d_start(dzdy,west,newwest,east,neweast,   &
                                south,newsouth,north,newnorth,reqs)
        call comm_2dew_end(dzdy,west,newwest,east,neweast,reqs)
        call comm_2dns_end(dzdy,south,newsouth,north,newnorth,reqs)
        call bcs2_2d(dzdy)
        call comm_2d_corner(dzdy)
        call bc2d(dzdy)

        call comm_3s_start(zh,sw31,sw32,se31,se32,   &
                              ss31,ss32,sn31,sn32,reqs_s)
        call comm_3s_end(zh,sw31,sw32,se31,se32,   &
                            ss31,ss32,sn31,sn32,reqs_s)
        call bcs2(zh)
        call getcorner(zh)
        call bcs(zh)

#endif

!--------------------------------

        do k=1,nk
        do j=1,nj
        do i=1,ni+1
          gx(i,j,k)=(zs(i,j)-zs(i-1,j))*rdx*(sigma(k)-zt)    &
                   /(zt-0.5*(zs(i-1,j)+zs(i,j)))
        enddo
        enddo
        enddo

        do k=1,nk
        do j=1,nj+1
        do i=1,ni
          gy(i,j,k)=(zs(i,j)-zs(i,j-1))*rdx*(sigma(k)-zt)    &
                   /(zt-0.5*(zs(i,j-1)+zs(i,j)))
        enddo
        enddo
        enddo

        call bcu(gx)
        call bcv(gy)

#ifdef MPI
        call comm_3u_start(gx,uw31,uw32,ue31,ue32,   &
                              us31,us32,un31,un32,reqs_u)
        call comm_3u_end(gx,uw31,uw32,ue31,ue32,   &
                            us31,us32,un31,un32,reqs_u)
        call bcu2(gx)
        call getcorneru(gx)
        call bcu(gx)

        call comm_3v_start(gy,vw31,vw32,ve31,ve32,   &
                              vs31,vs32,vn31,vn32,reqs_v)
        call comm_3v_end(gy,vw31,vw32,ve31,ve32,   &
                            vs31,vs32,vn31,vn32,reqs_v)
        call bcv2(gy)
        call getcornerv(gy)
        call bcv(gy)
#endif

        do j=jb,je
        do i=ib,ie+1
          gx(i,j, 0)=gx(i,j,1)
          gx(i,j,nk+1)=gx(i,j,nk  )
        enddo
        enddo

        do j=jb,je+1
        do i=ib,ie
          gy(i,j, 0)=gy(i,j,1)
          gy(i,j,nk+1)=gy(i,j,nk  )
        enddo
        enddo

!--------------------------------

        do j=jb,je
        do i=ib,ie
          zf(i,j,0)=zf(i,j,1)-(zf(i,j,2)-zf(i,j,1))
          zf(i,j,nk+2)=zf(i,j,nk+1)+(zf(i,j,nk+1)-zf(i,j,nk))
          zh(i,j,0)=0.5*(zf(i,j,0)+zf(i,j,1))
          zh(i,j,nk+1)=0.5*(zf(i,j,nk+1)+zf(i,j,nk+2))
        enddo
        enddo

        if(myid.eq.0)then
              write(outfile,*)
              do i=ib,ie
                write(outfile,*) '  zs at nj/2:',i,zs(i,nj/2)
              enddo
              write(outfile,*)

              write(outfile,*)
              do j=jb,je
                write(outfile,*) '  zs at ni/2:',j,zs(ni/2,j)
              enddo
              write(outfile,*)
        endif

!---------------------------------------

        do k=kb,ke
        do j=jb,je
        do i=ib,ie
          mh(i,j,k)=mh(i,j,k)*gz(i,j)
          rmh(i,j,k)=1.0/mh(i,j,k)
        enddo
        enddo
        enddo

        do k=kb,ke+1
        do j=jb,je
        do i=ib,ie
          mf(i,j,k)=mf(i,j,k)*gz(i,j)
          rmf(i,j,k)=1.0/mf(i,j,k)
        enddo
        enddo
        enddo

!-----------------------------------------------------------------------

      end subroutine init_terrain
kessler.F/      1298670057  19071 8000  100644  19561     `


      subroutine kessler(dt,tauto,taccr,tevar,ruh,rvh,rmh,pi0,th0,tmp,   &
                         rho,rr,pp3d,th3d,prs,                        &
                         qv3d,qc3d,qr3d)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real :: dt
      real*8 :: tauto,taccr,tevar
      real, dimension(ib:ie) :: ruh
      real, dimension(jb:je) :: rvh
      real, dimension(ib:ie,jb:je,kb:ke) :: rmh,pi0,th0
      real, dimension(ib:ie,jb:je,kb:ke) :: tmp,rho,rr,pp3d,    &
                                            th3d,prs,qv3d,qc3d,qr3d

      integer :: i,j,k
      real :: qvnew,qcnew,qrnew
      real :: ar,cr,qvs,er,term1,cpml,cvml,rm,tem
      real*8 dum
      real*8, dimension(nk) :: bud1,bud2,bud3

      real rslf

!-------------------------------------------------------------------

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        tmp(i,j,k)=(th0(i,j,k)+th3d(i,j,k))*(pi0(i,j,k)+pp3d(i,j,k))
      enddo
      enddo
      enddo

!$omp parallel do default(shared)  &
!$omp private(k)
      do k=1,nk
        bud1(k)=0.0d0
        bud2(k)=0.0d0
        bud3(k)=0.0d0
      enddo

    IF(isnd.ne.4)THEN

!$omp parallel do default(shared)              &
!$omp private(i,j,k,qvnew,qcnew,qrnew,ar,cr,qvs,er,term1,cpml,cvml,rm,tem)
      do k=1,nk
      do j=1,nj
      do i=1,ni

        qvnew=qv3d(i,j,k)
        qcnew=qc3d(i,j,k)
        qrnew=qr3d(i,j,k)

        ar=0.0
        cr=0.0
        er=0.0

        !! autoconversion of cloud to rain
        if(qcnew.gt.0.0)then
          ar=max(0.001*(qcnew-0.001),0.0)
          ar=ar*dt
        endif

        !! accretion of cloud by rain
        if(qcnew.gt.0.0 .and. qrnew.gt.0.0)then
          cr=2.2*qcnew*(qrnew**0.875)
          cr=cr*dt
        endif

        !! evap of rain to vapor
        if(qrnew.gt.0.0)then
          qvs=rslf(prs(i,j,k),tmp(i,j,k))
          if(qvnew.lt.qvs)then
            er=(1.6+30.3922*((rho(i,j,k)*qrnew)**0.2046))*          &
                (1.0-(qvnew/qvs))*                                  &
                ((rho(i,j,k)*qrnew)**0.525)/                        &
               ( (2.03e4+9.584e6/(qvs*prs(i,j,k))) * rho(i,j,k) )
            er=min(er*dt,qrnew)
            if( (qvnew+er).gt.qvs )then
              er=qvs-qvnew
            endif
          endif
        endif

        if((ar+cr).gt.qcnew)then
          term1=ar+cr
          ar=qcnew*ar/term1
          cr=qcnew*cr/term1
        endif

        qvnew=qvnew+er
        qcnew=qcnew-(ar+cr)
        qrnew=qrnew+(ar+cr-er)

      if(er.gt.1.0e-7)then
        if(neweqts.ge.1)then
          cpml=cp+cpv*qvnew+cpl*(qcnew+qrnew)
          cvml=cv+cvv*qvnew+cpl*(qcnew+qrnew)
          rm=rd+rv*qvnew
          th3d(i,j,k)=th3d(i,j,k)-er*(                                     &
                  (lv1-lv2*tmp(i,j,k))/(cpdcv*cvml*(pi0(i,j,k)+pp3d(i,j,k)))   &
                - (th0(i,j,k)+th3d(i,j,k))*(rv/cvml)*(1.0-rovcp*cpml/rm) )
          pp3d(i,j,k)=((rho(i,j,k)*rm*(th0(i,j,k)+th3d(i,j,k))*rp00)**rddcv)-pi0(i,j,k)
          prs(i,j,k)=p00*((pi0(i,j,k)+pp3d(i,j,k))**cpdrd)
        else
          th3d(i,j,k)=th3d(i,j,k)-er*( (lv1-lv2*tmp(i,j,k))         &
                                      /(cp*(pi0(i,j,k)+pp3d(i,j,k))) )
          rho(i,j,k)=prs(i,j,k)   &
             /(rd*(th0(i,j,k)+th3d(i,j,k))*(pi0(i,j,k)+pp3d(i,j,k))*(1.0+qvnew*reps))
        endif
      endif

        tem=ruh(i)*rvh(j)*rmh(i,j,k)

        bud1(k)=bud1(k)+rr(i,j,k)*ar*tem
        bud2(k)=bud2(k)+rr(i,j,k)*cr*tem
        bud3(k)=bud3(k)+rr(i,j,k)*er*tem

        qv3d(i,j,k)=qvnew
        qc3d(i,j,k)=qcnew
        qr3d(i,j,k)=qrnew

      enddo
      enddo
      enddo

    ENDIF

      dum=dx*dy*dz

      do k=1,nk
        tauto=tauto+bud1(k)*dum
      enddo

      do k=1,nk
        taccr=taccr+bud2(k)*dum
      enddo

      do k=1,nk
        tevar=tevar+bud3(k)*dum
      enddo

      if(timestats.ge.1) time_microphy=time_microphy+mytime()
 
      RETURN
      END


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine satadj(nrk,tcond,tevac,ruh,rvh,rmh,pi0,th0,   &
                        rho,rr,pp3d,prs,th3d,q3d)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      integer nrk
      real*8 :: tcond,tevac
      real, dimension(ib:ie) :: ruh
      real, dimension(jb:je) :: rvh
      real, dimension(ib:ie,jb:je,kb:ke) :: rmh,pi0,th0
      real, dimension(ib:ie,jb:je,kb:ke) :: rho,rr,pp3d,prs,th3d
      real, dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: q3d

      integer :: i,j,k,n,nmax,iflag
      real :: tnew,qvs,qvnew,qcnew,thn,pin,cpml,cvml,rm,lhv,thlast,dqv
      real :: converge,t1,p1,d1,tem,ql,qi
      real*8 dum
      real*8, dimension(nk) :: bud1,bud2
      real rslf
      logical :: doit

!--------------------------------------------------------------------
!  iterative sat adj.

    nmax=0
    iflag=0

    IF(nrk.ge.3)THEN
!$omp parallel do default(shared)  &
!$omp private(k)
      do k=1,nk
        bud1(k)=0.0d0
        bud2(k)=0.0d0
      enddo
    ENDIF

    IF(neweqts.ge.1)THEN

      if(nrk.eq.4)then
!!!        converge=0.0005
        converge=5.0*tsmall
      else
!!!        converge=0.01
        converge=100.0*tsmall
      endif

!$omp parallel do default(shared)  &
!$omp private(i,j,k,n,tnew,qvs,qvnew,qcnew,thn,pin,cpml,cvml,rm,lhv,   &
!$omp thlast,dqv,t1,p1,d1,tem,ql,qi,doit)
      do k=1,nk
      do j=1,nj
      do i=1,ni

        tnew=(th0(i,j,k)+th3d(i,j,k))*(pi0(i,j,k)+pp3d(i,j,k))
        qvs=rslf(prs(i,j,k),tnew)
              
        IF(q3d(i,j,k,2).gt.0.0 .or. q3d(i,j,k,nqv).gt.qvs)THEN

          qvnew=q3d(i,j,k,nqv)
          qcnew=q3d(i,j,k,2)
          thn=th3d(i,j,k)
          pin=pp3d(i,j,k)
          ql=0.0
          qi=0.0
          do n=nql1,nql2
            ql=ql+q3d(i,j,k,n)
          enddo
          if(iice.eq.1)then
            do n=nqs1,nqs2
              qi=qi+q3d(i,j,k,n)
            enddo
          endif
          cpml=cp+cpv*qvnew+cpl*ql+cpi*qi
          cvml=cv+cvv*qvnew+cpl*ql+cpi*qi
          rm=rd+rv*q3d(i,j,k,nqv)
          lhv=lv1-lv2*tnew

          t1=lhv/(cpdcv*cvml*(pi0(i,j,k)+pp3d(i,j,k)))   &
            -(th0(i,j,k)+th3d(i,j,k))*(rv/cvml)*(1.0-rovcp*cpml/rm)
          p1=rovcp*( lhv/(cvml*(th0(i,j,k)+th3d(i,j,k)))   &
            -(pi0(i,j,k)+pp3d(i,j,k))*rv*cpml/(rm*cvml) )
!!!          d1=t1*(pi0(i,j,k)+pp3d(i,j,k))*4097.8531
          d1=t1*(pi0(i,j,k)+pp3d(i,j,k))*17.67*243.5

          n=0
          thlast=thn
          doit=.true.

          do while( doit )
            n=n+1
!!!            dqv=(qvs-qvnew)/(1.0+d1*qvs/((tnew-35.86)**2) )
            dqv=(qvs-qvnew)/(1.0+d1*qvs/((tnew-29.65)**2) )
            dqv=min(dqv,qcnew)
            if(  (qvnew+dqv).lt.1.0e-20 ) dqv=1.0e-20-qvnew

            qvnew=qvnew+dqv
            qcnew=qcnew-dqv
            thn=thn-dqv*t1
            pin=pin-dqv*p1
            prs(i,j,k)=p00*((pi0(i,j,k)+pin)**cpdrd)

            doit = .false.
            if( abs(thn-thlast).gt.converge )then
              thlast=thn
              tnew=(th0(i,j,k)+thn)*(pi0(i,j,k)+pin)
              qvs=rslf(prs(i,j,k),tnew)
              doit = .true.
            endif

            if(n.gt.50.and.n.lt.100)then
              print *,n,thn,pin
            elseif(n.eq.100)then
              print *,'  infinite loop!'
              print *,'  i,j,k=',i,j,k
              iflag=1
              doit=.false.
            endif

          enddo

          tem=ruh(i)*rvh(j)*rmh(i,j,k)

          bud1(k)=bud1(k)+rr(i,j,k)*max(qcnew-q3d(i,j,k,2),0.0)*tem
          bud2(k)=bud2(k)+rr(i,j,k)*max(qvnew-q3d(i,j,k,nqv),0.0)*tem

          th3d(i,j,k)=thn
          q3d(i,j,k,2)=qcnew
          q3d(i,j,k,nqv)=qvnew
          pp3d(i,j,k)=pin

          nmax=max(n,nmax)

        ENDIF

      enddo
      enddo
      enddo

    ELSE

      nmax=1

!$omp parallel do default(shared)  &
!$omp private(i,j,k,qvnew,qcnew,tnew,qvs,lhv,dqv,tem)
      do k=1,nk
      do j=1,nj
      do i=1,ni

        qvnew=q3d(i,j,k,nqv)
        qcnew=q3d(i,j,k,2)
        tnew=(th0(i,j,k)+th3d(i,j,k))*(pi0(i,j,k)+pp3d(i,j,k))
        qvs=rslf(prs(i,j,k),tnew)
        lhv=lv1-lv2*tnew
!!!        dqv=(qvs-qvnew)/(1.0+lhv*qvs*4097.8531/(cp*((tnew-35.86)**2)))
        dqv=(qvs-qvnew)/(1.0+lhv*qvs*17.67*243.5/(cp*((tnew-29.65)**2)))
        if(  (qvnew+dqv).lt.1.0e-20 ) dqv=1.0e-20-qvnew
        dqv=min(dqv,max(0.0,qcnew))

        qvnew=qvnew+dqv
        qcnew=qcnew-dqv
        tem=ruh(i)*rvh(j)*rmh(i,j,k)
        bud1(k)=bud1(k)+rr(i,j,k)*max(qcnew-q3d(i,j,k,2),0.0)*tem
        bud2(k)=bud2(k)+rr(i,j,k)*max(qvnew-q3d(i,j,k,nqv),0.0)*tem

        th3d(i,j,k)=th3d(i,j,k)-dqv*( lhv/(cp*(pi0(i,j,k)+pp3d(i,j,k))) )
        q3d(i,j,k,2)=qcnew
        q3d(i,j,k,nqv)=qvnew
        rho(i,j,k)=prs(i,j,k)   &
             /(rd*(th0(i,j,k)+th3d(i,j,k))*(pi0(i,j,k)+pp3d(i,j,k))*(1.0+qvnew*reps))

      enddo
      enddo
      enddo

    ENDIF

    IF(nrk.ge.3)THEN
      dum=dx*dy*dz
      do k=1,nk
        tcond=tcond+bud1(k)*dum
      enddo

      do k=1,nk
        tevac=tevac+bud2(k)*dum
      enddo
    ENDIF

!!!      print *,'  nmax=',nmax

      if(iflag.ne.0)then
        print *
        print *,' Convergence cannot be reached in satadj subroutine.'
        print *
        print *,' This may be a problem with the algorithm in satadj.'
        print *,' However, the model may have became unstable somewhere'
        print *,' else and the symptoms first appeared here.'
        print *
        print *,' Try decreasing the timestep (dtl and/or nsound).'
        print *
        print *,'  ... stopping cm1 ... '
        print *
        call stopcm1
      endif

      if(timestats.ge.1) time_satadj=time_satadj+mytime()

      RETURN
      END


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine k_fallout(rho,qr3d,vr)
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real, dimension(ib:ie,jb:je,kb:ke) :: rho,qr3d,vr
 
      integer i,j,k

!--------------------------------------------------------------------
!  Get fall velocities

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        vr(i,j,k)=0.0
      enddo
      enddo
      enddo

      IF(isnd.ne.4)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          if(qr3d(i,j,k).gt.1.0e-12)then
            vr(i,j,k)=14.34*((rho(i,j,k)*qr3d(i,j,k))**0.1346)    &
                           *sqrt(1.15/rho(i,j,k))
          endif
        enddo
        enddo
        enddo
      ENDIF

      if(timestats.ge.1) time_fall=time_fall+mytime()
 
      RETURN
      END


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine fallout(dt,train,ruh,rvh,zh,mh,mf,rain,rr,rho,   &
                         q3d,vq)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real :: dt
      real*8 :: train
      real, dimension(ib:ie) :: ruh
      real, dimension(jb:je) :: rvh
      real, dimension(ib:ie,jb:je,kb:ke) :: zh,mh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, dimension(ib:ie,jb:je,nrain) :: rain
      real, dimension(ib:ie,jb:je,kb:ke) :: rr,rho,q3d,vq

      integer :: i,j,k,n,nr,nrk
      real :: qmax,f1,f2,f3,b1,b2,b3,w1,w2,w3,dttmp
      real, dimension(-1:nk+3):: rq
      real, dimension(0:nk) :: ffk
      real, dimension(nk) :: qtmp

      integer, dimension(ni,nj) :: nfall
      real :: crmax,dtfall

      real epsilon,onedsix,thdtw
      parameter(epsilon=1.0e-12)
      parameter(onedsix=1.0/6.0)
      parameter(thdtw=13.0/12.0)
      real*8 tem
      real*8 bud(nj)
      real*8 t1,t2,t3

!--------------------------------------------------------------------

!$omp parallel do default(shared)  &
!$omp private(j)
      do j=1,nj
        bud(j)=0.0d0
      enddo

!$omp parallel do default(shared)            &
!$omp private(i,j,k,crmax)
      do j=1,nj
      do i=1,ni
        crmax = 0.0
        do k=1,nk
          crmax = max( crmax , vq(i,j,k)*dt*rdz*mh(i,j,k) )
        enddo
        nfall(i,j) = max( 1 , int(crmax+1.0) )
      enddo
      enddo

!--------------------------------------------------------------------

  IF(ifall.eq.1)THEN

!$omp parallel do default(shared)            &
!$omp private(i,j,k,rq,n,dtfall,nr)
    do j=1,nj
    do i=1,ni
      dtfall=dt/nfall(i,j)
      do n=1,nfall(i,j)
        do k=1,nk
          rq(k)=rho(i,j,k)*vq(i,j,k)*max(0.0,q3d(i,j,k))
        enddo
        rq(nk+1)=0.0
        do k=1,nk
          q3d(i,j,k)=q3d(i,j,k)+dtfall*(rq(k+1)-rq(k))   &
                                     *rdz*mf(i,j,k+1)/rho(i,j,k)
        enddo
        do nr=1,nrain
          rain(i,j,nr)=rain(i,j,nr)+0.1*dtfall*rq(1)
        enddo
        bud(j)=bud(j)+dtfall*rr(i,j,1)*vq(i,j,1)*max(0.0,q3d(i,j,1))*ruh(i)*rvh(j)
      enddo
    enddo
    enddo

!--------------------------------------------------------------------

  ELSEIF(ifall.eq.2)THEN

!$omp parallel do default(shared)            &
!$omp private(i,j,k,rq,n,dtfall,nr)
    do j=1,nj
    do i=1,ni
      dtfall=dt/nfall(i,j)
      do n=1,nfall(i,j)
        do k=1,nk
          rq(k)=rho(i,j,k)*vq(i,j,k)*q3d(i,j,k)
        enddo
        rq(nk+1)=0.0
        do k=2,nk
          q3d(i,j,k)=q3d(i,j,k)+dtfall*(rq(k+1)-rq(k-1))   &
                                     /(zh(i,j,k+1)-zh(i,j,k-1))/rho(i,j,k)
        enddo
        q3d(i,j,1)=q3d(i,j,1)+dtfall*(rq(2)-rq(1))*rdz*mf(i,j,2)/rho(i,j,1)
        do k=1,nk
          q3d(i,j,k)=max(q3d(i,j,k),0.0)
        enddo
        do nr=1,nrain
          rain(i,j,nr)=rain(i,j,nr)+0.1*dtfall*rq(1)
        enddo
        bud(j)=bud(j)+dtfall*rr(i,j,1)*vq(i,j,1)*max(0.0,q3d(i,j,1))*ruh(i)*rvh(j)
      enddo
    enddo
    enddo

!--------------------------------------------------------------------

  ELSEIF(ifall.eq.3)THEN

!$omp parallel do default(shared)            &
!$omp private(i,j,k,nrk,qmax,dttmp,rq,ffk,qtmp,    &
!$omp f1,f2,f3,b1,b2,b3,w1,w2,w3,t1,t2,t3,n,dtfall,nr)
    do j=1,nj
    do i=1,ni
      qmax=0.
      do k=1,nk
        qmax=max(qmax,q3d(i,j,k))
      enddo
      IF(qmax.gt.1.0e-8)THEN
        dtfall=dt/nfall(i,j)
        do n=1,nfall(i,j)
          do k=1,nk
            qtmp(k)=q3d(i,j,k)
          enddo
          do nrk=1,3
            do k=1,nk
              rq(k)=rho(i,j,k)*vq(i,j,k)*max(0.0,qtmp(k))
            enddo
            rq(-1)=rq(1)
            rq( 0)=rq(1)
            rq(nk+1)=0.0
            rq(nk+2)=0.0
            rq(nk+3)=0.0
            do k=0,nk
              f1=(  2*rq(k+3)-7*rq(k+2)+11*rq(k+1) )*onedsix
              f2=( -rq(k+2)+5*rq(k+1)+2*rq(k  ) )*onedsix
              f3=(  2*rq(k+1)+5*rq(k  )-rq(k-1) )*onedsix

              b1=thdtw*(rq(k+3)-2*rq(k+2)+rq(k+1))**2    &
                +0.25*(rq(k+3)-4*rq(k+2)+3*rq(k+1))**2
              b2=thdtw*(rq(k+2)-2*rq(k+1)+rq(k  ))**2    &
                +0.25*(rq(k+2)-rq(k  ))**2
              b3=thdtw*(rq(k+1)-2*rq(k  )+rq(k-1))**2    &
                +0.25*(3*rq(k+1)-4*rq(k  )+rq(k-1))**2

              w1=0.10/((epsilon+b1)**2)
              w2=0.60/((epsilon+b2)**2)
              w3=0.30/((epsilon+b3)**2)

              ffk(k)=((w1*f1)+(w2*f2)+(w3*f3))/(w1+w2+w3)
            enddo
            dttmp=dtfall/(4-nrk)
            do k=1,nk
              qtmp(k)=q3d(i,j,k)+dttmp*(ffk(k)-ffk(k-1))   &
                                    *rdz*mh(i,j,k)/rho(i,j,k)
            enddo
          enddo
          t1=0.0d0
          t2=0.0d0
          do k=1,nk
            t1=t1+rho(i,j,k)*qtmp(k)
            q3d(i,j,k)=max(0.0,qtmp(k))
            t2=t2+rho(i,j,k)*q3d(i,j,k)
          enddo
          t3=(t1+1.0d-20)/(t2+1.0d-20)
          if(t3.lt.0.0) t3=1.0d0
          do k=1,nk
            q3d(i,j,k)=t3*q3d(i,j,k)
          enddo
          do nr=1,nrain
            rain(i,j,nr)=rain(i,j,nr)+0.1*dtfall*max(rq(1),0.0)
          enddo
          bud(j)=bud(j)+dtfall*rr(i,j,1)*vq(i,j,1)*max(0.0,q3d(i,j,1))*ruh(i)*rvh(j)
        enddo
      ENDIF
    enddo
    enddo

  ENDIF

!--------------------------------------------------------------------

      tem=dx*dy
      do j=1,nj
        train=train+bud(j)*tem
      enddo

      if(timestats.ge.1) time_fall=time_fall+mytime()

      RETURN
      END


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine getefall(dt,cpx,ruh,rvh,mf,pi0,th0,t,cvm,rr,   &
                          pp3d,th3d,q3d,vr)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real :: dt,cpx
      real, dimension(ib:ie) :: ruh
      real, dimension(jb:je) :: rvh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, dimension(ib:ie,jb:je,kb:ke) :: pi0,th0
      real, dimension(ib:ie,jb:je,kb:ke) :: t,cvm,rr
      real, dimension(ib:ie,jb:je,kb:ke) :: pp3d,th3d,q3d,vr

      integer :: i,j,k
      real :: ften

!$omp parallel do default(shared)  &
!$omp private(i,j,k,ften)
      do k=1,nk-1
      do j=1,nj
      do i=1,ni
        ften=q3d(i,j,k)*vr(i,j,k)*(                                  &
                     cpx*(t(i,j,k+1)-t(i,j,k))*rdz*mf(i,j,k+1) + g   &
                                  )/cvm(i,j,k)
        th3d(i,j,k)=th3d(i,j,k)+dt*ften/( cpdcv*(pi0(i,j,k)+pp3d(i,j,k)) )
        pp3d(i,j,k)=pp3d(i,j,k)+dt*ften*rovcp/(th0(i,j,k)+th3d(i,j,k))
      enddo
      enddo
      enddo

!-----------------------------------------------------------------------

      if(timestats.ge.1) time_fall=time_fall+mytime()

      RETURN
      END


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine geterain(dt,cpx,lx1,erain,ruh,rvh,t,rr,q3d,vr)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real :: dt,cpx,lx1
      real*8 :: erain
      real, dimension(ib:ie) :: ruh
      real, dimension(jb:je) :: rvh
      real, dimension(ib:ie,jb:je,kb:ke) :: t,rr
      real, dimension(ib:ie,jb:je,kb:ke) :: q3d,vr

      integer :: i,j
      real*8 :: bud(nj)

!$omp parallel do default(shared)  &
!$omp private(j)
      do j=1,nj
        bud(j)=0.0d0
      enddo

!$omp parallel do default(shared)  &
!$omp private(i,j)
      do j=1,nj
      do i=1,ni
        bud(j)=bud(j)+dt*vr(i,j,1)*rr(i,j,1)*q3d(i,j,1)*(cpx*t(i,j,1)-lx1)*ruh(i)*rvh(j)
      enddo
      enddo

      do j=1,nj
        erain=erain+bud(j)*dx*dy
      enddo

!-----------------------------------------------------------------------

      if(timestats.ge.1) time_fall=time_fall+mytime()

      RETURN
      END



lfoice.F/       1298670057  19071 8000  100644  67165     `
!-------------------------------------------------------------------------------
!   lfo_ice_drive
!
!   PURPOSE: To transform the CM1 variables to what 3-ICE expects
!   DATE:   Sept 12, 2006 
!   AUTHOR: Matt Gilmore
!
!-------------------------------------------------------------------------------
!           call lfo_ice_drive(dt, mf, pi0, pp3d, prs, th0, th3d, qv0, rho0, q3d) 

      subroutine lfo_ice_drive(dt, mf, pi0, prs0, pp3d, prs, th0, th3d,    &
                               qv0, rho0, q3d, vq, pn)

      implicit none


! Variable declarations for variables passed from CM1

!(CM1 input.incl common block)
!       ni       # grid points (for tile) in x-direction (east/west)
!       nj       # grid points (for tile) in y-direction (north/south)
!       nk       # grid points (for tile) in vertical
!       dt       model large timestep     (s)
!       rdz      inverse of constant model dz (m^-1)
 
! CM1 INPUT (passed)
!       mf     = 1/[rdz*(zh(k)-zh(k-1)]   (No Dim)    (i,j,k)
!  Note rdz*mf is 1/dzactual for the stretched grid ! zh is scalar ht (m)
!
!       pi0      base state total Exner   (No Dim)    (i,j,k)
!       pp3d     perturbation Exner pressure          (i,j,k)
!       prs      full pressure            (Pascals)   (i,j,k)
!       th0      base state potential temp(K)         (i,j,k)
!       th3d     potential temperature perturb. (K)   (i,j,k)
!       rho0     base state dry air density     (kg/m^3)    (i,j,k)   ! replaced db(kz) in NCOMMAS version
!       qv0      base state vapor mixing ratio        (i,j,k)
!
!       q3d      qv, qc, qr, qi, qs, qh  (kg/kg)      (i,j,k,numq)

      include 'input.incl'     !  dt, ib, ie, jb, je, kb, ke, ibm, ibi, jbm, jbi, kbm, kbi, iem ,iei, jem, jei, kem, kei, ni, nj, nk, numq
!       ni        number of grid pts in the x-direction (east/west)
!       nj        number of grid pts in the y-direction (north/south)
!       nk        number of grid pts in the vertical
!       ib    -2  starting point including 3-point buffer
!       ie  ni+3
!       jb    -2
!       je  nj+3
!       kb     0
!       ke  nk+1

      include 'timestat.incl'   !This will do the timing statistics for the ice micro


      real :: dt
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, dimension(ib:ie,jb:je,kb:ke) :: pi0,prs0,pp3d,prs,th3d,th0,   &
                                            rho0,qv0,pn
      real, dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: q3d,vq
!
! The following are 3-ICE variables/terminology
! We set the dimensions to that of the tile without buffer (not the full domain)
!
      integer nstep          ! Current Model timestep
      parameter (nstep = 1)  !    for now, set to a constant
      real dzc(nk)           ! 1/dz for the stretched grid 
      real rinit(nk)         ! base state density (kg/m^3)
      real pinit(nk)         ! base state pressure (Pa)
      real sb(nk, numq)        ! base state array of th, qv, qc, etc

!-------------------------------------------------------------------------------
!     misc. local variables
!-------------------------------------------------------------------------------

      integer i,j,k,n

!-------------------------------------------------------------------------------

!
! Set up Conversions between CM1 and SAM
!
      sb(:,:)  = 0.0
      rinit(:) = 0.0
      pinit(:) = 0.0
      dzc(:)   = 0.0

!     Set up 1D vertical arrays.  Use corner of domain for no-terrain case.

      i = 1
      j = 1
      DO k = 1,nk                   !MSG might need to change to nk instead of nk-1
       dzc(k)  =   mf(i,j,k)*rdz
       sb(k,1) =  th0(i,j,k)
       sb(k,2) =  qv0(i,j,k)
       rinit(k)= rho0(i,j,k)
       pinit(k)= prs0(i,j,k)
      ENDDO

!     Copy 3-D arrays from CM1 to 3-ICE.

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      DO k = 1, nk
      DO j = 1, nj
      DO i = 1, ni
       pn(i,j,k)   = prs(i,j,k) - pinit(k)       !perturbation pressure (Pascals)
      ENDDO
      ENDDO
      ENDDO

!     Make sure vq array is zero, by default

      DO n = 1, numq
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        DO k = 1, nk
        DO j = 1, nj
        DO i = 1, ni
          vq(i,j,k,n) = 0.0
        ENDDO
        ENDDO
        ENDDO
      ENDDO

! DO MICROPHYSICS

           CALL LFO_ICE (ni,nj,nk,numq,dt,dzc,sb,th3d,q3d,vq,rinit,pn,pinit,nstep, &
                         ib,ie,jb,je,kb,ke,ibm,iem,jbm,jem,kbm,kem)

!-------------------------------------------------------------------------------

! Uncomment the next lines if micro is allowed to feedback on pressure
!  This could also be put directly into LFO_ICE
!     DO k = 1, nk
!     DO j = 1, nj
!     DO i = 1, ni
!       prs(i,j,k) = pn(i,j,k) + prs0(i,j,k)    !total pressure (Pascals)
!       pp3d(i,j,k) = (prs(i,j,k)*rp00)**rovcp  !total pressure (Ekner)
!     ENDDO
!     ENDDO
!     ENDDO

      if(timestats.ge.1) time_microphy=time_microphy+mytime()


      RETURN
      END
!--------------------------------------------------------------------------
!
!
!  3-ICE MODEL
!
!  VERSION: 1.3 with Rates (2/10/05)
!
!  LIN-FARELY-ORVILLE-like "Simple Ice and Liquid Microphysics Scheme"
!   based on Gilmore et al. (2004) Mon. Wea. Rev.
!
!   Copyright (C) <2004>  <Jerry Straka and Matthew Gilmore>
!
!   This library is free software; you can redistribute it and/or
!   modify it under the terms of the GNU Lesser General Public
!   License as published by the Free Software Foundation; either
!   version 2.1 of the License, or (at your option) any later version.
!
!   This library is distributed in the hope that it will be useful,
!   but WITHOUT ANY WARRANTY; without even the implied warranty of
!   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
!   Lesser General Public License for more details.
!
!   If you find this code useful and publish results using it, please reference:
!
!     Gilmore M. S., J. M. Straka, and E. N. Rasmussen,
!           Monthly Weather Review: Vol. 132, No. 8, pp. 1897-1916.
!
!--------------------------------------------------------------------------
!          CALL LFO_ICE (ni,nj,nk,numq,dt,dzc,sb,th3d,q3d,rinit,pn,pinit,nstep, &
!                        ib,ie,jb,je,kb,ke,ibm,iem,jbm,jem,kbm,kem)
      SUBROUTINE LFO_ICE(nx,ny,nz,numq,dtp,dzc,ab,th3d,q3d,vq,   db,pn,   pb,nstep, &
                         ib,ie,jb,je,kb,ke,ibm,iem,jbm,jem,kbm,kem)
!--------------------------------------------------------------------------
! RELEASE NOTES
!
! MSG - 2/10/05 Ported the SAM gather-scatter version to NCOMMAS
!       This is most similar to that actually used in the published manuscripts.
!       This version also provides rate output (labels consistent with Gilmore et al) for post-analysis.
!       Known inconsistencies/omissions: 
!          1) min q criteria applied to some (but not all) processes
!          2) internal rate names and signs differ compared to Gilmore et al. (2004),
!               however, rate output is consistent
!          3) time splitting for fallout omitted
!
!
! MSG - 5/5/05  Added time-splitting fallout.
!
! MSG - 9/12/06c Ported code to CM1 with wrapper routine.  Strategy is to *not* use any common blocks
!                or include files.  Thus, slight mismatch between CM1 constants and herein.  
!                Also, here we assume 1-D base state (faster code) but CM1 is really 3-D base state.
!                See the alternate 9/13/06 version if you wish to use the full 3D base state.
!                Note that this code has internal saturation adjustment and fallout.
!
! GHB - 061021: - Now using common block, using include file 'lfoice.incl'
!                 Several constants are now defined in 'lfoice.incl'
!                 Call to "lfoice_init" has been added to "param"
!
!--------------------------------------------------------------------------
!                                
!
!  general declarations
!
!
      implicit none

      include 'lfoice.incl'

!     include 'param.h'
!--------------------------------------------------------------------------

      integer ix,jy,kz,nx,ny,nz

      integer ib, ie, jb, je, kb, ke
      integer ibm,iem,jbm,jem,kbm,kem
      integer numq

      integer nstep
      real dtp
      integer istag,jstag,kstag
      parameter (istag=0, jstag=0, kstag=0)            !MSG Set these to 1 for NCOMMAS; set to 0 for CM1
      integer      lv,  lc,   lr,   li,   ls,   lh
      parameter (  lv=1,lc=2, lr=3, li=4, ls=5, lh=6)  !MSG indicee numbers consistent with CM1

      real dzc(nz)                                     !MSG weren't defined before

!     real  an(nx,ny,nz,numq)                                !MSG scalars (NCOMMAS)
      real, dimension(ib:ie,jb:je,kb:ke) :: th3d             !MSG TH scalar (CM1)
      real, dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: q3d   !MSG Q scalars (CM1)
      real, dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: vq    !GHB Q fallspeeds (CM1)
      real  ab(nz,numq)                                      !MSG base state for scalars
      real, dimension(ib:ie,jb:je,kb:ke) :: pn               !MSG perturb pressure
      real pb(nz), db(nz)                                    !MSG base state pressure, density
!
!---
! 
!  declarations microphysics and for gather/scatter
!
!   (MSG: In this version, if ngs, the number of gather/scatter points, is smaller than the number of
!         microphysically active gridpoints in an XZ slice, then the code does multiple
!         gather/scatter iterations within a single XZ slice using inumgs and the pointers nxmpb,nzmpb.)
!
      integer jgs,mgs,ngs,numgs,inumgs,nxmpb,nzmpb,nxz      !MSG added innumgs
      parameter ( ngs=500 )
      integer ngscnt,igs(ngs),kgs(ngs)

! Air and particle temperatures (equivalent to each other in LFO version)

      real temp(ngs)
      real temg(ngs),temcg(ngs),theta(ngs),thetap(ngs),theta0(ngs)

! Air pressure, density, & Exner function

      real pbz(ngs),pres(ngs),presp(ngs),pres0(ngs)
      real rho0(ngs),dnz(ngs),pi0n(ngs),piz(ngs)

! Accretions

      real qiacr(ngs)
      real qracw(ngs), qraci(ngs), qracs(ngs)
      real qsacw(ngs), qsaci(ngs),            qsacr(ngs)
      real qhacw(ngs), qhaci(ngs), qhacs(ngs),qhacr(ngs)
      real eri(ngs),erw(ngs),ers(ngs)
      real esw(ngs),esi(ngs)
      real ehw(ngs),ehr(ngs),ehi(ngs),ehs(ngs)

! Biggs Freezing

      real qrfrz(ngs), xrfrz(ngs)

! Bergeron Process

      real qsfw(ngs),qsfi(ngs), eic(ngs)
      real cs9

! Conversions

      real qhcns(ngs), qrcnw(ngs), qscni(ngs), qdiff,argrcnw
      real ehscnv(ngs), esicnv(ngs)

! Evaporation/Deposition/Sublimation

      real qhdsv(ngs),qhdpv(ngs),qhsbv(ngs)
      real qsdsv(ngs),qsdpv(ngs),qssbv(ngs)
      real qrcev(ngs)
      real xav(ngs),xbv,xas(ngs),xbs
      real xrcev2(ngs)
      real xce,xrv,xds
      real xxdsv,xxcev

! Initiation of cloud ice

      real dqisdt(ngs),qiint(ngs),cnnt

! Melting/Wet growth of hail, Melting snow

      real qhmlr(ngs), qsmlr(ngs)
      real xmlt1,xmlt2
      real xhmlt2(ngs), xsmlt2(ngs)
      real xsv, xhv, xhsw

! Wet/dry growth, shedding

      real qhdry(ngs),qhwet(ngs)
      real xhwet1,xhwet2, xcwt,xwt1
      real qhacip(ngs),qhacsp(ngs),qhshr(ngs)

! Water Budgets

      real ptotal(ngs),ptotsat(ngs) 
      real pqcwi(ngs),pqcii(ngs),pqrwi(ngs)
      real pqswi(ngs),pqhwi(ngs),pqwvi(ngs)
      real pqcwd(ngs),pqcid(ngs),pqrwd(ngs)
      real pqswd(ngs),pqhwd(ngs),pqwvd(ngs)
      integer il2(ngs),il3(ngs),il5(ngs)

! Latent Heating Computation

      real psub(ngs),pvap(ngs),pfrz(ngs),ptem(ngs)

! Maximum Depletion Tendencies

      real qc5dt,qi5dt,qr5dt,qs5dt,qh5dt

! Flags
!!!      integer imake                    !prints intercept/density to output file
!!!      save imake
!!!      data imake / 0 /
      integer  ndebug, nrates          !prints debug stuff to output file, prints rates to out file
      integer itfall
      parameter (ndebug = 0, nrates=0) !prints debugging, rate flags
        ! GHB, 061013:  moved fallout to CM1 solve
      parameter (itfall = 0)           !0 no flux fallout, 2: timesplit flux fallout, 1 flux on regular dt

! Fallout, fall velocity parameters/vars

      real dtz1
      ! GHB, 061013:  fallout calculations have been moved to CM1 solve
!!!      real cwflx(ngs), cflux(nx,nz)
!!!      real piflx(ngs), pflux(nx,nz)
!!!      real rwflx(ngs), rflux(nx,nz)
!!!      real swflx(ngs), sflux(nx,nz)
!!!      real hwflx(ngs), hflux(nx,nz)

      real maxfall            ! max fallspeed of qg, qh, qf, qr, qd, qm
      real vtrdzmax           ! input courant                         ! MSG
      real dtsplit            ! small timestep for rain sedimentation ! MSG
      integer nrnstp,inrnstp  ! number of small timesteps, counter    ! MSG

 
!  Distribution parameters, Fallout, Mean diameter's, mass, and mixing ratio's
 
!
!
      real qwv(ngs),qcw(ngs),qci(ngs),qrw(ngs),qsw(ngs),qhw(ngs)
      real ccw(ngs),cci(ngs),crw(ngs),csw(ngs),chw(ngs)
!
      real vtwbar(ngs),cwmas(ngs)
      real vtibar(ngs),cimas(ngs)
      real vtrbar(ngs)
      real vtsbar(ngs)
      real vthbar(ngs)
!
      real cwdia(ngs),cwdia2(ngs)
      real cidia(ngs),cidia2(ngs)
      real rwdia(ngs),rwdia2(ngs)
      real swdia(ngs),swdia2(ngs)
      real hwdia(ngs),hwdia2(ngs)

! Saturation Adjustment

      real qvap(ngs)
      real dqvcnd(ngs),dqwv(ngs),dqcw(ngs),dqci(ngs)
      real gamss,denom1,denom2
      real gamw(ngs),gams(ngs)
      real qwvp(ngs), qv0n(ngs)
      real fraci(ngs),fracl(ngs)
      real cdw, cdi
      integer itertd
      real qwfzi(ngs),qimlw(ngs)
      real qidep(ngs),qisub(ngs)
      real qcevp(ngs), qccnd(ngs)
      real qcevpcnd(ngs), qisubdep(ngs)

! Saturation lookup table, vapor pressures, ratio's

      integer ltemq
      real qvs(ngs),qis(ngs),qss(ngs),pqs(ngs)
      real tsqr(ngs),ssi(ngs),ssw(ngs)

! Misc Variables

      real advisc,schm,tkarwinv,rhoratio,mlttemp
      real wvdf(ngs),akvisc,ci(ngs),tka(ngs)
      real cc3(ngs),cc4(ngs),cc5(ngs)

!  Rate Output (Domain-total g/m^3)

      real hfrz, hdep, hcnd, cevap, cmelt, csub		!MSG added total cooling/heating vars
      real tqva,  tqia,  tqca
      real tqvb,  tqib,  tqcb
      real tqvap, tqsap, tqiap, tqrap, tqcap, tqhap
      real tqvbp, tqsbp, tqibp, tqrbp, tqcbp, tqhbp
      real tvsum, tssum, tisum, trsum, tcsum, thsum, tqc,tqi,tqv,tsumall 
      real suma,  sumb,  psum 
      real trqsacw, trqhacr, trqhshr, trqhmlr, trqsmlr, tiqiint, tiqidep, trqhacs
      real trqhacw, trqhaci, tvqhsbv, tvqcevp, tvqssbv, tvqrcev, trqrcnw, trqracw
      real tcqcmli, tvqisub, tcqccnd, tiqifzc, thqhacs, thqsacr, thqhaci, thqhacr
      real thqhacw, thqhdpv, thqrfrz, thqiacr, thqracs, thqraci, tsqsacw, tsqsacr
      real tsqscni,  tsqsfi,  tsqsfw, tsqsdpv, thqhcns, tsqsaci, tsqraci, tsqiacr, thqhwet 
!     
!
!  read in constants from 'inmicro.jmslfo'
!  [deleted this part - MSG]

      if ( ndebug .eq. 1 ) print*,'Just entered micro...'

!
!  ZERO
!
!
!  totals for source / sink terms
!
!
!  vapor
!
      tvqrcev = 0.0
      tvqssbv = 0.0
      tvqhsbv = 0.0
      tvqcevp = 0.0
      tvqisub = 0.0
!
!  cloud water
!
      tcqccnd = 0.0 
      tcqcmli = 0.0
!
!  rain
!
      trqrcnw = 0.0
      trqracw = 0.0
      trqhmlr = 0.0
      trqsmlr = 0.0
      trqhshr = 0.0
      trqsacw = 0.0
      trqhacr = 0.0
      trqhacw = 0.0
      trqhaci = 0.0
      trqhacs = 0.0

!
!  cloud ice
!
      tiqiint = 0.0
      tiqidep = 0.0
      tiqifzc = 0.0
!
!  snow
!
      tsqsfi  = 0.0
      tsqsfw  = 0.0
      tsqscni = 0.0
      tsqsacw = 0.0
      tsqsacr = 0.0
      tsqraci = 0.0
      tsqiacr = 0.0
      tsqsaci = 0.0
      tsqsdpv = 0.0
!
!  hail
!
      thqhcns = 0.0
      thqhacr = 0.0
      thqhacw = 0.0
      thqhaci = 0.0
      thqhacs = 0.0
      thqsacr = 0.0
      thqracs = 0.0
      thqraci = 0.0
      thqiacr = 0.0
      thqhdpv = 0.0
      thqrfrz = 0.0
      thqhwet = 0.0
!
!  total heating and cooling rates
!
      hfrz    = 0.0
      hdep    = 0.0
      hcnd    = 0.0
      cevap   = 0.0
      cmelt   = 0.0
      csub    = 0.0
!
!
!  various rate budgets
!
      tqvap     = 0.0
      tqcap     = 0.0
      tqiap     = 0.0
      tqrap     = 0.0
      tqsap     = 0.0
      tqhap     = 0.0
!
      tqvbp     = 0.0
      tqcbp     = 0.0
      tqibp     = 0.0
      tqrbp     = 0.0
      tqsbp     = 0.0
      tqhbp     = 0.0
!
      tqva     = 0.0
      tqca     = 0.0
      tqia     = 0.0
!
      tqvb     = 0.0
      tqcb     = 0.0
      tqib     = 0.0
!
      suma      = 0.0
      psum      = 0.0
!
      sumb      = 0.0
!
      tvsum    = 0.0
      tcsum    = 0.0
      tisum    = 0.0
      trsum    = 0.0
      tssum    = 0.0
      thsum    = 0.0
!
      tsumall   = 0.0
      tqv       = 0.0
      tqc       = 0.0
      tqi       = 0.0
!
!
!  end of totals
!
!
!  other constants
!


!      write(6,*) '-----------------------------------------------------------------------'
!
      if ( ndebug .eq. 1 ) print*,'dbg = 0b'

!
!  MSG: These 3 things a function of base state (eventually will be moved to 3-D base state)
!
      do 10 kz = 1,nz-kstag
       pbz(kz) = pb(kz)
       piz(kz) = (pbz(kz)/poo)**rcp
       temp(kz) = piz(kz)*ab(kz,1)
  10  continue
      
      if (ndebug .eq. 1 ) print*,'dbg = 1'
!
      if (ndebug .eq. 1 ) print*,'dbg = 2'
!
!  start jy loop  (for doing XZ slabs)
!
!
      do 9999 jy = 1,ny-jstag
!
!  VERY IMPORTANT:  SET jgs
!
      jgs = jy
!
!  zero precip flux arrays
!
      ! GHB, 061013:  fallout calculations have been moved to CM1 solve
!!!      vtrdzmax = 0.0                     !MSG Courant for the slice
!!!      maxfall = 0.0                      !MSG max fallspeed of any particle for the slice
!!!      if (ndebug .eq. 1 ) print*,'dbg = 3'
!!!      do 95 kz = 1,nz-kstag
!!!      do 96 ix = 1,nx-istag
!!!      hflux(ix,kz) = 0.0
!!!      cflux(ix,kz) = 0.0
!!!      pflux(ix,kz) = 0.0
!!!      rflux(ix,kz) = 0.0
!!!      sflux(ix,kz) = 0.0
!!!  96  continue
!!!  95  continue
!
!..gather microphysics  
!
      if (ndebug .eq. 1 ) print*,'dbg = 4'
      nxmpb = 1
      nzmpb = 1
      nxz = nx*nz
      numgs = nxz/ngs + 1
      do 1000 inumgs = 1,numgs 
      ngscnt = 0
! 061023, GHB:  dunno why the "kstag-1" is here ... removing the -1
!!!      do kz = nzmpb,nz-kstag-1 
      do kz = nzmpb,nz-kstag
      do ix = nxmpb,nx-istag

      theta(kz) = th3d(ix,jy,kz) + ab(kz,1)
      temg(kz) = theta(kz)*( (pn(ix,jy,kz)+pbz(kz)) / poo ) ** rcp
      ltemq = nint((temg(kz)-163.15)/fqsat+1.5)
      ltemq = min(max(ltemq,1),nqsat)         
      pqs(kz) = 380.0/(pn(ix,jy,kz)+pbz(kz))
      qvs(kz) = pqs(kz)*tabqvs(ltemq)        
      qis(kz) = pqs(kz)*tabqis(ltemq)       
      
      if ( temg(kz) .lt. tfr ) then

       qcw(kz) = max(q3d(ix,jy,kz,lc) ,0.0)
       qci(kz) = max(q3d(ix,jy,kz,li) ,0.0)

       if( qcw(kz) .ge. 0.0 .and. qci(kz) .eq. 0.0 ) qss(kz) = qvs(kz)
       if( qcw(kz) .eq. 0.0 .and. qci(kz) .gt. 0.0)  qss(kz) = qis(kz)
       if( qcw(kz) .gt. 0.0 .and. qci(kz) .gt. 0.0)  qss(kz) = (qcw(kz)*qvs(kz) + qci(kz)*qis(kz)) /(qcw(kz) + qci(kz))
      else
       qss(kz) = qvs(kz)
      end if
!
      if ( q3d(ix,jy,kz,lv) .gt. qss(kz) .or.   &
           q3d(ix,jy,kz,lc) .gt. qcmin  .or.    &
           q3d(ix,jy,kz,li) .gt. qimin .or.     &
           q3d(ix,jy,kz,lr) .gt. qrmin .or.     &
           q3d(ix,jy,kz,ls) .gt. qsmin .or.     &
           q3d(ix,jy,kz,lh) .gt. qhmin ) then
      ngscnt = ngscnt + 1
      igs(ngscnt) = ix
      kgs(ngscnt) = kz
      if ( ngscnt .eq. ngs ) goto 1100
      end if
      ENDDO     !MSG - i loop
      nxmpb = 1
      ENDDO     !MSG - k loop
 1100 continue
      if ( ngscnt .eq. 0 ) go to 9998
      if ( ndebug .eq. 1 ) print*,'dbg = 5'
!
!  define temporaries to be used in calculations
!
      do 1010 mgs = 1,ngscnt
      dnz(mgs)   = db(kgs(mgs))
      pres0(mgs) = pbz(kgs(mgs))                    !MSG need to make 3-D base state eventually
      presp(mgs) = pn(igs(mgs),jy,kgs(mgs))
      pres(mgs)  = presp(mgs) + pres0(mgs)
      pi0n(mgs)  = piz(kgs(mgs))                    !MSG need to make 3-D base state eventually
       cc3(mgs)  = cpi*elf/pi0n(mgs)
       cc4(mgs)  = cpi*elv/pi0n(mgs)
       cc5(mgs)  = cpi*els/pi0n(mgs)
      theta0(mgs)= ab(kgs(mgs),1)                   !MSG need to make 3-D base state eventually
      thetap(mgs)= th3d(igs(mgs),jy,kgs(mgs))
      theta(mgs) = thetap(mgs) + theta0(mgs)
      temg(mgs)  = theta(mgs)*( pres(mgs) / poo ) ** rcp      

!      if (IEEE_IS_NAN(temg(mgs))) call stopcm1

      temcg(mgs) = temg(mgs) - tfr
      pqs(mgs)   = 380.0/pres(mgs)
      ltemq      = nint((temg(mgs)-163.15)/fqsat+1.5)
      ltemq      = min(max(ltemq,1),nqsat)
      qvs(mgs)   = pqs(mgs)*tabqvs(ltemq)
      qis(mgs)   = pqs(mgs)*tabqis(ltemq)
      qwv(mgs)   = q3d(igs(mgs),jy,kgs(mgs),lv)
      qv0n(mgs)  = ab(kgs(mgs),2)                   !MSG need to make 3-D base state eventually
      qwvp(mgs)  = qwv(mgs) - qv0n(mgs) 
      qcw(mgs) = max(q3d(igs(mgs),jy,kgs(mgs),lc), 0.0) 
      qci(mgs) = max(q3d(igs(mgs),jy,kgs(mgs),li), 0.0) 
      qrw(mgs) = max(q3d(igs(mgs),jy,kgs(mgs),lr), 0.0) 
      qsw(mgs) = max(q3d(igs(mgs),jy,kgs(mgs),ls), 0.0) 
      qhw(mgs) = max(q3d(igs(mgs),jy,kgs(mgs),lh), 0.0) 
      il2(mgs) = 0
      il3(mgs) = 0
      il5(mgs) = 0
      if ( temg(mgs) .lt. tfr ) then 
       il5(mgs) = 1
       if ( qrw(mgs) .lt. 1.0e-04 .and. qsw(mgs) .lt. 1.0e-04 ) il2(mgs) = 1
       if ( qrw(mgs) .lt. 1.0e-04 ) il3(mgs) = 1
      end if
 1010 continue
!
!
! 
!  other constants for paramerization
!
      do mgs = 1,ngscnt
      advisc     = advisc0*(416.16/(temp(kgs(mgs))+120.0))*(temp(kgs(mgs))/296.0)**(1.5)
      akvisc     = advisc/dnz(mgs)
      ci(mgs)    = (2.118636 + 0.007371*(temp(kgs(mgs))-tfr))*(1.0e+03)     !MSG used in qhwet
      tka(mgs)   = tka0*advisc/advisc1
      wvdf(mgs)  = (2.11e-05)*((temp(kgs(mgs))/tfr)**1.94)*(101325.0/(pbz(kgs(mgs))))
      schm       = akvisc/wvdf(mgs)
      tkarwinv   = 1./(tka(mgs)*rw)
      xav(mgs)   = (elv**2)*tkarwinv
      xas(mgs)   = (els**2)*tkarwinv
      rhoratio   = (dnz00/dnz(mgs))**0.25
      mlttemp    = 0.308*(schm**(1./3.))*(akvisc**(-0.5))
      xhmlt2(mgs)= mlttemp*gf2p75
      xsmlt2(mgs)= mlttemp*gf5ds*(cs**(0.5))*rhoratio
      xrcev2(mgs)= mlttemp*gf5br*(ar**(0.5))*rhoratio
      enddo 

!
      if (ndebug .eq. 1 ) print*,'dbg = 6'
!
! cloud water variables
!
      do 4101 mgs = 1,ngscnt
!     ccw(mgs) = 1.e9    !LFO default (Western Plains)
      ccw(mgs) = .6e9    !Central plains CCN value
!     ccw(mgs) = .3e9    !Maritime CCN value
      cwmas(mgs) = min( max(qcw(mgs)*dnz(mgs)/ccw(mgs),cwmasn),cwmasx )
      cwdia(mgs) = (cwmas(mgs)*cwc1)**c1f3 
      cwdia2(mgs) = cwdia(mgs)**2
      vtwbar(mgs) = (ar*(cwdia(mgs)**br))*(rho00/dnz(mgs))**0.5
 4101 continue
!
! cloud ice variables
!
      do 4201 mgs = 1,ngscnt
!
      cimasx     = 3.23e-8
      cci(mgs)   = max(min(cnit*exp(-temcg(mgs)*bta1),1.e+09),1.0)       !Fletcher's formula
      cimas(mgs) = min( max(qci(mgs)*dnz(mgs)/cci(mgs),cimasn),cimasx )
      if ( temcg(mgs) .gt. 0 ) then
        cidia(mgs) = 0.0
      else
        cidia(mgs) = 16.7*(cimas(mgs)**(0.5))
        cidia(mgs) = max(cidia(mgs), 1.e-5)
        cidia(mgs) = min(cidia(mgs), 3.e-3)
      endif
      cidia2(mgs) = cidia(mgs)**2
      vtibar(mgs) = (cs*(cidia(mgs)**ds))*(rho00/dnz(mgs))**0.5
!
 4201 continue
!
!  mp-distribution information for rain, snow agg's, and graupel/hail
!
!
!  definitions for marshall palmer distribution variables
!  (rain, snow, hail) when mixing ratio only is predicted
!
      if (ndebug .eq. 1 ) print*,'dbg = 7a'
!
      do 4301 mgs = 1,ngscnt
!
      rwdia(mgs) = 1.e-20
      swdia(mgs) = 1.e-20
      hwdia(mgs) = 1.e-20
!
      if ( qrw(mgs) .gt. 1.0e-10 ) rwdia(mgs) = xslop*(dnz(mgs)*qrw(mgs)/(rwdn*xcnor))**(0.25) 
      if ( qsw(mgs) .gt. 1.0e-10 ) swdia(mgs) = xslop*(dnz(mgs)*qsw(mgs)/(swdn*xcnos))**(0.25)
      if ( qhw(mgs) .gt. 1.0e-10 ) hwdia(mgs) = xslop*(dnz(mgs)*qhw(mgs)/(hwdn*xcnoh))**(0.25)
!
      rwdia2(mgs) = rwdia(mgs)**2
      swdia2(mgs) = swdia(mgs)**2
      hwdia2(mgs) = hwdia(mgs)**2
!
      vtrbar(mgs) = xvtr*(dnz(mgs)**(-0.5))*(rwdia(mgs)**br)
      vtsbar(mgs) = xvts*(dnz(mgs)**(-0.5))*(swdia(mgs)**ds)
      vthbar(mgs) = xvth1*(dnz(mgs)**(-0.5))*(xvth3**2)*((hwdn*hwdia(mgs))**(0.5))
!     
      crw(mgs) = xcnor*rwdia(mgs)
      csw(mgs) = xcnos*swdia(mgs)
      chw(mgs) = xcnoh*hwdia(mgs)
!
 4301 continue

      ! GHB, 061013:  fallout calculations have been moved to CM1 solve
!!!      if (itfall .eq. 2) then
!!!        do mgs = 1,ngscnt                                        !MSG Find max fallspeed for later
!!!         maxfall = max(maxfall,vtrbar(mgs))
!!!         maxfall = max(maxfall,vthbar(mgs))
!!!        enddo
!!!      endif

!
      do 5001 mgs = 1,ngscnt 
!
!  maximum depletion tendency by any one source
!
      qc5dt = 0.20*qcw(mgs)/dtp
      qi5dt = 0.20*qci(mgs)/dtp
      qr5dt = 0.20*qrw(mgs)/dtp
      qs5dt = 0.20*qsw(mgs)/dtp
      qh5dt = 0.20*qhw(mgs)/dtp

!
!  collection efficiencies
!
      eic(mgs) = 1.0
      eri(mgs) = 1.0
      erw(mgs) = 1.0
      esi(mgs) = exp(0.025*min(temcg(mgs),0.0))
      esicnv(mgs) = esi(mgs)
      esw(mgs) = 1.0
      ers(mgs) = 1.0
      ehw(mgs) = 1.0
      ehr(mgs) = 1.0
      ehs(mgs) = exp(0.09*min(temcg(mgs),0.0))
      ehscnv(mgs) = ehs(mgs)
      if ( temcg(mgs) .gt. 0.0 ) ehs(mgs) = 1.0
      ehi(mgs) = 0.1

      if ( qcw(mgs) .lt. qcmin .or. qci(mgs) .lt. qimin ) eic(mgs) = 0.0
      if ( qrw(mgs) .lt. qrmin .or. qci(mgs) .lt. qimin ) eri(mgs) = 0.0
      if ( qrw(mgs) .lt. qrmin .or. qcw(mgs) .lt. qcmin ) erw(mgs) = 0.0
      if ( qsw(mgs) .lt. qsmin .or. qci(mgs) .lt. qimin ) esi(mgs) = 0.0
      if ( qsw(mgs) .lt. qsmin .or. qcw(mgs) .lt. qcmin ) esw(mgs) = 0.0
      if ( qsw(mgs) .lt. qsmin .or. qrw(mgs) .lt. qrmin ) ers(mgs) = 0.0
      if ( qhw(mgs) .lt. qhmin .or. qcw(mgs) .lt. qcmin ) ehw(mgs) = 0.0
      if ( qhw(mgs) .lt. qhmin .or. qrw(mgs) .lt. qrmin ) ehr(mgs) = 0.0
      if ( qhw(mgs) .lt. qhmin .or. qsw(mgs) .lt. qsmin ) ehs(mgs) = 0.0
      if ( qhw(mgs) .lt. qhmin .or. qci(mgs) .lt. qimin ) ehi(mgs) = 0.0
!
!  accretions:
!    marshall-palmer size distribution collection 
!    of constant size distribution
!      1)  sink for constant size distribution
!      2)  source for marshall-palmer size distribution
!
      qracw(mgs) =  &
         min(erw(mgs)*qcw(mgs)*xacwi*crw(mgs)*abs(vtrbar(mgs)-vtwbar(mgs))  &
        *(  gf3*rwdia2(mgs) + 2.0*gf2*rwdia(mgs)*cwdia(mgs) + gf1*cwdia2(mgs) )      , qc5dt)
      qsacw(mgs) =  &
         min(esw(mgs)*qcw(mgs)*xacwi*csw(mgs)*abs(vtsbar(mgs)-vtwbar(mgs))  &
        *(  gf3*swdia2(mgs) + 2.0*gf2*swdia(mgs)*cwdia(mgs) + gf1*cwdia2(mgs) )      , qc5dt)
      qhacw(mgs) =  &
         min(ehw(mgs)*qcw(mgs)*xacwi*chw(mgs)*abs(vthbar(mgs)-vtwbar(mgs))  &
        *(  gf3*hwdia2(mgs) + 2.0*gf2*hwdia(mgs)*cwdia(mgs) + gf1*cwdia2(mgs) )      , qc5dt)
      qraci(mgs) =  &
         min(eri(mgs)*qci(mgs)*xacwi*crw(mgs)*abs(vtrbar(mgs)-vtibar(mgs))  &
        *(  gf3*rwdia2(mgs) + 2.0*gf2*rwdia(mgs)*cidia(mgs) + gf1*cidia2(mgs) )      , qi5dt)
      qsaci(mgs) =  &
         min(esi(mgs)*qci(mgs)*xacwi*csw(mgs)*abs(vtsbar(mgs)-vtibar(mgs))  &
        *(  gf3*swdia2(mgs) + 2.0*gf2*swdia(mgs)*cidia(mgs) + gf1*cidia2(mgs) )      , qi5dt)
      qhaci(mgs) =  &
        min(ehi(mgs)*qci(mgs)*xacwi*chw(mgs)*abs(vthbar(mgs)-vtibar(mgs))   &
        *(  gf3*hwdia2(mgs) + 2.0*gf2*hwdia(mgs)*cidia(mgs) + gf1*cidia2(mgs) )      , qi5dt)
      qiacr(mgs) =  &
        min(eri(mgs)*qrw(mgs)* xxacx*cci(mgs)*abs(vtrbar(mgs)-vtibar(mgs))   &
        *(  gf6*rwdia2(mgs) + 2.0*gf5*rwdia(mgs)*cidia(mgs) + gf4*cidia2(mgs) )      , qr5dt) 
!
!  accretions:
!    marshall-palmer size distribution collecting marshall-palmer size
!    distribution
!
      qhacs(mgs) =  &
         min( xxacx*abs(vthbar(mgs)-vtsbar(mgs))*ehs(mgs)*qsw(mgs)*chw(mgs)  &
        *(  gf6*gf1*swdia2(mgs) + 2.0*gf5*gf2*swdia(mgs)*hwdia(mgs) + gf4*gf3*hwdia2(mgs) ) , qs5dt)
      qhacr(mgs) =  &
         min( xxacx*abs(vthbar(mgs)-vtrbar(mgs))*ehr(mgs)*qrw(mgs)*chw(mgs)  &
        *(  gf6*gf1*rwdia2(mgs) + 2.0*gf5*gf2*rwdia(mgs)*hwdia(mgs) + gf4*gf3*hwdia2(mgs) ) , qr5dt)
      qracs(mgs) =  &
         min( xxacx*abs(vtrbar(mgs)-vtsbar(mgs))*ers(mgs)*qsw(mgs)*crw(mgs)  &
        *(  gf6*gf1*swdia2(mgs) + 2.0*gf5*gf2*swdia(mgs)*rwdia(mgs) + gf4*gf3*rwdia2(mgs) ) , qs5dt)
      qsacr(mgs) =  &
         min( xxacx*abs(vtrbar(mgs)-vtsbar(mgs))*ers(mgs)*qrw(mgs)*csw(mgs)  &
        *(  gf6*gf1*rwdia2(mgs) + 2.0*gf5*gf2*rwdia(mgs)*swdia(mgs) + gf4*gf3*swdia2(mgs) ) , qr5dt)
! 
!  bergeron process for snow
!
      ibb = min(max(1,int(-temcg(mgs))),32)
        cs9     = bsfw*dnz(mgs)*(0.001) 
      qsfw(mgs) = qci(mgs)*cs11(ibb)*(cs10(ibb) + eic(mgs)*cs9*qcw(mgs))
      qsfw(mgs) = min(qsfw(mgs),qc5dt)
      qsfi(mgs) = qci(mgs)/cbtim(ibb) 
      qsfi(mgs) = min(qsfi(mgs),qi5dt)
!
!  conversions
!
      qscni(mgs) = 0.001*esicnv(mgs)*max((qci(mgs)-qicrit),0.0)
      qscni(mgs) = min(qscni(mgs),qi5dt)
!
      qhcns(mgs) = 0.001*ehscnv(mgs)*max((qsw(mgs)-qscrit),0.0)
      qhcns(mgs) = min(qhcns(mgs),qs5dt)
!
      xrfrz(mgs) = 20.0*(pi**2)*brz*cwdn/dnz(mgs)
      qrfrz(mgs) = min(xrfrz(mgs)*crw(mgs)*(rwdia(mgs)**6)*(exp(max(-arz*temcg(mgs), 0.0))-1.0), qr5dt)

! Berry (1968) Autoconversion == 0 (critical qc) or ==1 (critical diameter from Ferrier 1994)

      IF( autoconversion .eq. 0 ) THEN
       qdiff  = max((qcw(mgs)-qcmincwrn),0.)
      ELSE
       qccrit = (pi/6.)*((ccw(mgs)*cwdiap**3)*cwdn)/dnz(mgs)
       qdiff  = max((qcw(mgs)-qccrit),0.)
      ENDIF

      qrcnw(mgs) =  0.0
      if ( qdiff .gt. 0.0 ) then
       argrcnw = ((1.2e-4)+(1.596e-12)*ccw(mgs)*(1e-6)/(dnz(mgs)*1.e-3*cwdisp*qdiff))
       qrcnw(mgs) = dnz(mgs)*1e-3*(qdiff**2)/argrcnw
       qrcnw(mgs) = (max(qrcnw(mgs),0.0))
      end if
      qrcnw(mgs) = min(qrcnw(mgs),qc5dt)
!
!  constants for hydrometeor-vapor interactions
!
      ssi(mgs) = qwv(mgs)/qis(mgs)
      ssw(mgs) = qwv(mgs)/qvs(mgs)
      tsqr(mgs) = temg(mgs)**2
!
!  melting of snow and hail
!
      xsv   = (xxmlt1*(swdia(mgs)) + xsmlt2(mgs)*(swdia(mgs)**((3.0+ds)/2.0)))
      xhv   = (xxmlt1*(hwdia(mgs)) + (hwdn**(0.25))*xvth3*xhmlt2(mgs)*(hwdia(mgs)**(1.75)))
      xmlt2 = wvdf(mgs)*elv*dnz(mgs)
      xhsw =(tka(mgs)*temcg(mgs) + xmlt2*(qwv(mgs)-pqs(mgs)))
      xmlt1 = -2.0*pi/(elf*dnz(mgs))
      qsmlr(mgs) = min( (xmlt1*csw(mgs)*xsv*xhsw + temcg(mgs)*xmlt3*(qsacr(mgs)+qsacw(mgs)) ) , 0.0 )
      qhmlr(mgs) = min( (xmlt1*chw(mgs)*xhv*xhsw + temcg(mgs)*xmlt3*(qhacr(mgs)+qhacw(mgs)) ) , 0.0 )
      qsmlr(mgs) = max( qsmlr(mgs), -qs5dt ) 
      qhmlr(mgs) = max( qhmlr(mgs), -qh5dt ) 
!
!  deposition/sublimation of snow and hail
!
      xbs   = (1.0/(dnz(mgs)*wvdf(mgs)))
      xxdsv = 2.0*pi/dnz(mgs)
      xds = xxdsv*(ssi(mgs)-1.0)*(1.0/(xas(mgs)/tsqr(mgs)+xbs/qis(mgs)))
      qsdsv(mgs) =   xds*csw(mgs)*xsv
      qhdsv(mgs) =   xds*chw(mgs)*xhv
      qhsbv(mgs) = max( min(qhdsv(mgs), 0.0), -qh5dt )
      qhdpv(mgs) = max( qhdsv(mgs), 0.0 )
      qssbv(mgs) = max( min(qsdsv(mgs), 0.0), -qs5dt )
      qsdpv(mgs) = max( qsdsv(mgs), 0.0 )

!
! SHEDDING CALCULATION
! New version by MSG closer to JMS original  - Last modified 4/6/03
!       
!
!  compute dry growth rate of hail regardless of location
!
      qhdry(mgs) = qhacr(mgs) + qhacw(mgs) + qhaci(mgs) + qhacs(mgs)
!
!  compute wet growth rate of hail regardless of location
!
      qhacip(mgs)= qhaci(mgs)		!ehi=0 case
      qhacsp(mgs)= qhacs(mgs)		!ehs=0 case
      IF ( ehi(mgs) .gt. 0.0 ) qhacip(mgs) = min(qhaci(mgs)/ehi(mgs),qi5dt)
      IF ( ehs(mgs) .gt. 0.0 ) qhacsp(mgs) = min(qhacs(mgs)/ehs(mgs),qs5dt)

      xcwt = 1.0/( elf +cw*temcg(mgs) )

      xhwet1 = 2.0*pi/dnz(mgs)
      xhwet2 = dnz(mgs)*elv*wvdf(mgs)
      xwt1   = xhwet2*(pqs(mgs)-qwv(mgs)) -tka(mgs)*temcg(mgs)

      qhwet(mgs) =  max( 0.0, ( xhv*chw(mgs)*xwt1*xhwet1*xcwt   &
                                + ( 1.0 -ci(mgs)*temcg(mgs)*xcwt )* ( qhacip(mgs)+qhacsp(mgs) )  )  )

!
!  evaluate shedding rate (effective range is 243 < T < 273 due to other "if" checks below)
!
      qhshr(mgs) = 0.0
      if ( qhwet(mgs) .lt. qhdry(mgs) .and. qhwet(mgs) .gt. 0.0 ) then
        qhdry(mgs) = 0.0                                        ! Wet growth
        qhshr(mgs) = qhwet(mgs) -(qhacw(mgs) +qhacr(mgs))
      else					                ! Dry growth (defaults here if qhwet<0)
        qhwet(mgs) = 0.0
        qhshr(mgs) = 0.0
      endif
!
!  Special shedding case when warmer than freezing
!
      if ( temg(mgs) .gt. tfr ) then 
        qhwet(mgs) = 0.0
        qhdry(mgs) = 0.0
        qhshr(mgs) =  -qhacr(mgs) -qhacw(mgs)-qhacip(mgs)-qhacsp(mgs)
      end if
!
!  Special no-shedding (dry) case when T<243....
!
      if ( temg(mgs) .lt. 243.15 ) then
       qhwet(mgs) = 0.0
       qhshr(mgs) = 0.0
      end if
!
!  Reset some vars if wet particle surface due to shedding....
!
      if ( qhshr(mgs) .lt. 0.0 ) then
       qhaci(mgs) = qhacip(mgs)
       qhacs(mgs) = qhacsp(mgs)
       qhdpv(mgs) = 0.0
       qhsbv(mgs) = 0.0
      end if

!
!  evaporation/condensation on wet snow and hail (NOT USED)
! 

!
!  evaporation of rain
!
      xxcev = 2.0*pi/dnz(mgs)
      xbv   = (1.0/(dnz(mgs)*wvdf(mgs)))
      xce = xxcev*(ssw(mgs)-1.0)*(1.0/(xav(mgs)/tsqr(mgs)+xbv/qvs(mgs)))
      xrv = (xrcev1*(rwdia(mgs)) +  xrcev2(mgs)*(rwdia(mgs)**((3.0+br)/2.0)))
      qrcev(mgs) = max(min(xce*crw(mgs)*xrv, 0.0), -qr5dt)
! 
!  vapor to pristine ice crystals 
!
      qiint(mgs) = 0.0
      IF ( ssi(mgs) .gt. 1.0 ) THEN
        dqisdt(mgs)= (qwv(mgs)-qis(mgs))/ (1.0 + xiint*qis(mgs)/tsqr(mgs))
        cnnt       = cci(mgs)
        qiint(mgs) = (1.0/dtp) *min((1.0e-12)*cnnt/dnz(mgs), 0.50*dqisdt(mgs)) 
      ENDIF
!
!  Domain totals for source terms 
!
!
!  vapor
!
      tvqssbv = tvqssbv - il5(mgs)*qssbv(mgs)*dnz(mgs)   
      tvqhsbv = tvqhsbv - il5(mgs)*qhsbv(mgs)*dnz(mgs)     
      tvqrcev = tvqrcev - qrcev(mgs)*dnz(mgs)             
      tvqcevp = tvqcevp + 0.0	
!     tvqisub = tvqisub + 0.0
!
!  cloud water
!
      tcqccnd = tcqccnd	+ 0.0	
      tcqcmli = tcqcmli	+ 0.0		
!
!  rain
!
      trqracw = trqracw + qracw(mgs)*dnz(mgs)           
      trqrcnw = trqrcnw + qrcnw(mgs)*dnz(mgs)            
      trqsacw = trqsacw + (1-il5(mgs))*qsacw(mgs)*dnz(mgs)
      trqsmlr = trqsmlr - (1-il5(mgs))*qsmlr(mgs)*dnz(mgs) 
      trqhmlr = trqhmlr - (1-il5(mgs))*qhmlr(mgs)*dnz(mgs)
      trqhshr = trqhshr - qhshr(mgs)*dnz(mgs)             
!
!  cloud ice
!
      tiqiint = tiqiint + il5(mgs)*qiint(mgs)*dnz(mgs) 	
      tiqidep = tiqidep + 0.0	
      tiqifzc = tiqifzc + 0.0		
!
!  snow
!
      tsqsacw = tsqsacw + il5(mgs)*qsacw(mgs)*dnz(mgs)    
      tsqscni = tsqscni + il5(mgs)*qscni(mgs)*dnz(mgs)     
      tsqsaci = tsqsaci + il5(mgs)*qsaci(mgs)*dnz(mgs)       
      tsqsfi  = tsqsfi  + il5(mgs)*qsfi(mgs) *dnz(mgs)      
      tsqsfw  = tsqsfw  + il5(mgs)*qsfw(mgs) *dnz(mgs)        
      tsqraci = tsqraci + il5(mgs)*il3(mgs)*qraci(mgs)*dnz(mgs)
      tsqiacr = tsqiacr + il5(mgs)*il3(mgs)*qiacr(mgs)*dnz(mgs)
      tsqsacr = tsqsacr + il5(mgs)*il2(mgs)*qsacr(mgs)*dnz(mgs)
      tsqsdpv = tsqsdpv + il5(mgs)*qsdpv(mgs)*dnz(mgs)         
!
!  hail/graupel
!
      thqhcns = thqhcns + qhcns(mgs)*dnz(mgs)			
      thqiacr = thqiacr + il5(mgs)*(1-il3(mgs))*qiacr(mgs)*dnz(mgs) 
      thqraci = thqraci + il5(mgs)*(1-il3(mgs))*qraci(mgs)*dnz(mgs) 
      thqracs = thqracs + il5(mgs)*(1-il2(mgs))*qracs(mgs)*dnz(mgs) 
      thqsacr = thqsacr + il5(mgs)*(1-il2(mgs))*qsacr(mgs)*dnz(mgs) 
      thqhdpv = thqhdpv + il5(mgs)*qhdpv(mgs)*dnz(mgs)             
      thqrfrz = thqrfrz + il5(mgs)*qrfrz(mgs)*dnz(mgs)   
!     thqhacr = thqhacr + qhacr(mgs)*dnz(mgs)           ! MSG see below instead 2/6/04    
!     thqhacw = thqhacw + qhacw(mgs)*dnz(mgs)           ! MSG see below instead 2/6/04   
!     thqhacs = thqhacs + qhacs(mgs)*dnz(mgs)           ! MSG see below instead 2/6/04
!     thqhaci = thqhaci + qhaci(mgs)*dnz(mgs)           ! MSG see below instead 2/6/04

!
!  hail/graupel and rain (based upon wet growth budget)  !MSG added on 2/6/04
!
!--     
      if ( temg(mgs) .ge. 273.15 ) then
       trqhaci = trqhaci + qhaci(mgs)*dnz(mgs)
       trqhacs = trqhacs + qhacs(mgs)*dnz(mgs)
      else
       thqhaci = thqhaci + qhaci(mgs)*dnz(mgs)
       thqhacs = thqhacs + qhacs(mgs)*dnz(mgs)
      endif

      if ((qhwet(mgs) .gt. 0.0).or.( temg(mgs) .ge. 273.15)) then 
       trqhacw = trqhacw + qhacw(mgs)*dnz(mgs)
       trqhacr = trqhacr + qhacr(mgs)*dnz(mgs)
      else
       thqhacw = thqhacw + qhacw(mgs)*dnz(mgs)
       thqhacr = thqhacr + qhacr(mgs)*dnz(mgs)
      endif

      thqhwet  = thqhwet + qhwet(mgs)*dnz(mgs)    !MSG qhwet is positive or zero here

!--     
!  end of totals
!
 5001 continue
!
 5002 continue
!
!
      if (ndebug .eq. 1 ) print*,'dbg = 8'

 
!  rain, snow, hail fluxes due to gravity    !MSG q3d() was ad() in SAM version
!
!  061013: Moved fallout code to CM1 solve.  Store vtbar info in vq array.
!
      do 5020 mgs = 1,ngscnt 
!!!      hwflx(mgs) = dnz(mgs)*q3d(igs(mgs),jgs,kgs(mgs),lh)*vthbar(mgs)
!!!      piflx(mgs) = dnz(mgs)*q3d(igs(mgs),jgs,kgs(mgs),li)*vtibar(mgs)
!!!      cwflx(mgs) = dnz(mgs)*q3d(igs(mgs),jgs,kgs(mgs),lc)*vtwbar(mgs)
!!!      rwflx(mgs) = dnz(mgs)*q3d(igs(mgs),jgs,kgs(mgs),lr)*vtrbar(mgs)
!!!      swflx(mgs) = dnz(mgs)*q3d(igs(mgs),jgs,kgs(mgs),ls)*vtsbar(mgs)
      vq(igs(mgs),jgs,kgs(mgs),lh) = vthbar(mgs)
      vq(igs(mgs),jgs,kgs(mgs),li) = vtibar(mgs)
      vq(igs(mgs),jgs,kgs(mgs),lc) = vtwbar(mgs)
      vq(igs(mgs),jgs,kgs(mgs),lr) = vtrbar(mgs)
      vq(igs(mgs),jgs,kgs(mgs),ls) = vtsbar(mgs)
 5020 continue

!
!  Compute total-domain content (g/m^3) before production rates
!
      do mgs = 1,ngscnt                        !MSG domain total of each species before microphysics
      tqvbp = tqvbp + qwvp(mgs)*dnz(mgs)
      tqcbp = tqcbp + qcw(mgs)*dnz(mgs)
      tqibp = tqibp + qci(mgs)*dnz(mgs)
      tqrbp = tqrbp + qrw(mgs)*dnz(mgs)
      tqsbp = tqsbp + qsw(mgs)*dnz(mgs)
      tqhbp = tqhbp + qhw(mgs)*dnz(mgs)
      sumb = sumb+tqvbp+tqcbp+tqibp+tqrbp+tqsbp+tqhbp
      end do

!
! CALCULATE RATE TOTALS
!
      do 9000 mgs = 1,ngscnt

!
      pqwvi(mgs) =  il5(mgs)*( -qhsbv(mgs) -qssbv(mgs)              )           - qrcev(mgs)
      pqwvd(mgs) =  il5(mgs)*( -qhdpv(mgs) -qsdpv(mgs) - qiint(mgs) ) 
!
      pqcii(mgs) =  il5(mgs)*qiint(mgs) 
      pqcid(mgs) =  il5(mgs)*( -qscni(mgs) -qsaci(mgs) -qraci(mgs) -qsfi(mgs))  - qhaci(mgs)  
!
      pqcwi(mgs) =  0.0
      pqcwd(mgs) =  (-il5(mgs)*qsfw(mgs))  -qracw(mgs) -qsacw(mgs) -qrcnw(mgs) -qhacw(mgs)
!
      pqrwi(mgs) =  qracw(mgs) +qrcnw(mgs) +(1-il5(mgs))*(qsacw(mgs)-qhmlr(mgs) -qsmlr(mgs)) -qhshr(mgs)
      pqrwd(mgs) =  il5(mgs)*(-qiacr(mgs) -qrfrz(mgs)  -qsacr(mgs)) +qrcev(mgs) -qhacr(mgs)
!
      pqswi(mgs) =  il5(mgs)*( qsacw(mgs) +qscni(mgs) +qsaci(mgs) + qsfi(mgs) +qsfw(mgs)    &
                               +il3(mgs)*(qraci(mgs) +qiacr(mgs)) +il2(mgs)*qsacr(mgs) +qsdpv(mgs)     )
      pqswd(mgs) = -qhcns(mgs) -qhacs(mgs) +(1-il5(mgs))*qsmlr(mgs)  +il5(mgs)*(qssbv(mgs) -(1-il2(mgs))*qracs(mgs)) 
!
      pqhwi(mgs) =  qhcns(mgs) +qhacr(mgs) +qhacw(mgs) +qhacs(mgs) +qhaci(mgs)   &
         + il5(mgs)*( (1-il3(mgs))*(qraci(mgs)+qiacr(mgs)) +(1-il2(mgs))*(qsacr(mgs)+qracs(mgs))+qhdpv(mgs)+qrfrz(mgs))
      pqhwd(mgs) =  qhshr(mgs) +(1-il5(mgs))*qhmlr(mgs) + il5(mgs)*qhsbv(mgs)
!
      ptotal(mgs) = pqwvi(mgs) +pqwvd(mgs) + pqcwi(mgs) +pqcwd(mgs) + pqcii(mgs) +pqcid(mgs) +   &
                    pqrwi(mgs) +pqrwd(mgs) + pqswi(mgs) +pqswd(mgs) + pqhwi(mgs) +pqhwd(mgs) 
!
      if (ndebug .eq. 1) then
       if(abs(ptotal(mgs)).gt.1.e-7)then
         print*,'NOTICE:PTOTAL>1e-7 ', mgs, kgs(mgs), ptotal(mgs)
       end if
      endif
!
      psum = psum + ptotal(mgs)
!
 9000 continue
!
!
!  latent heating from phase changes (except qcw, qci cond, and evap)
!   (22 processes involve phase changes, 10 do not)
!
      do 9010 mgs = 1,ngscnt
      pfrz(mgs) = (1.-il5(mgs))*(qhmlr(mgs) + qsmlr(mgs))   &
                + ( il5(mgs)  )*(qiacr(mgs)+qsacr(mgs)+ qsfw(mgs)+qrfrz(mgs)+qsacw(mgs)+qhacw(mgs)+qhacr(mgs)+qhshr(mgs))
      psub(mgs) = ( il5(mgs)  )*(qhdpv(mgs)+qhsbv(mgs)+qiint(mgs)+qsdpv(mgs)+qssbv(mgs))
      pvap(mgs) = qrcev(mgs)
      ptem(mgs) = cc3(mgs)*pfrz(mgs) + cc5(mgs)*psub(mgs) + cc4(mgs)*pvap(mgs)
      thetap(mgs) = thetap(mgs) + dtp*ptem(mgs)

!
!  partitioned domain-total heating and cooling rates 
!  (all are adjusted again later within saturation adjustment)
!

      hfrz  = hfrz  + ( qiacr(mgs)+qsacr(mgs)+qsfw(mgs)+qsacw(mgs)   &
                       +qhacw(mgs)+qhacr(mgs)+qhshr(mgs)+qrfrz(mgs))*il5(mgs)*cc3(mgs)
      hdep  = hdep  + (qiint(mgs)+qhdpv(mgs)+qsdpv(mgs))*il5(mgs)*cc5(mgs)
      hcnd  = hcnd  + 0.0
      cevap = cevap +  qrcev(mgs)                          *cc4(mgs)
      cmelt = cmelt + (qhmlr(mgs)+qsmlr(mgs))*(1.-il5(mgs))*cc3(mgs)
      csub  = csub  + (qhsbv(mgs)+qssbv(mgs))*il5(mgs)     *cc5(mgs)

 9010 continue
 9004 continue
!
!  sum the sources and sinks for qwvp, qcw, qci, qrw, qsw
!
      do 9100 mgs = 1,ngscnt
      qwvp(mgs)= qwvp(mgs) + dtp*(pqwvi(mgs)+pqwvd(mgs))      !initial qwvp is being adjusted by all source/sink
      qcw(mgs) = qcw(mgs) +  dtp*(pqcwi(mgs)+pqcwd(mgs)) 
      qci(mgs) = qci(mgs) +  dtp*(pqcii(mgs)+pqcid(mgs)) 
      qrw(mgs) = qrw(mgs) +  dtp*(pqrwi(mgs)+pqrwd(mgs)) 
      qsw(mgs) = qsw(mgs) +  dtp*(pqswi(mgs)+pqswd(mgs)) 
      qhw(mgs) = qhw(mgs) +  dtp*(pqhwi(mgs)+pqhwd(mgs)) 
      
 9100 continue
!
!  domain-total content (g/m^3) before saturation adjustment
!
      do mgs = 1,ngscnt
      tqvap = tqvap + qwvp(mgs)*dnz(mgs)
      tqcap = tqcap + qcw(mgs)*dnz(mgs)
      tqiap = tqiap + qci(mgs)*dnz(mgs)
      tqrap = tqrap + qrw(mgs)*dnz(mgs)
      tqsap = tqsap + qsw(mgs)*dnz(mgs)
      tqhap = tqhap + qhw(mgs)*dnz(mgs)
      suma = suma+tqvap+tqcap+tqiap+tqrap+tqsap+tqhap
      end do


! 
      if (ndebug .eq. 1 ) print*,'dbg = 10a'
      
!
!  set up temperature and vapor arrays
!
      if ( ndebug .eq. 1 ) print*,'dbg = 10.1'
!
      do mgs = 1,ngscnt
       pqs(mgs) = (380.0)/(pres(mgs))
       theta(mgs) = thetap(mgs) + theta0(mgs)
       qvap(mgs) = max( (qwvp(mgs) + qv0n(mgs)), 0.0 )         !MSG Current total qwv
       temg(mgs) = theta(mgs)*( pres(mgs) / poo ) ** rcp
      end do
!
!  melting of cloud ice
!
      if ( ndebug .eq. 1 ) print*,'dbg = 10.2'
!
      do mgs = 1,ngscnt
      if( temg(mgs) .gt. tfr .and. qci(mgs) .gt. 0.0 ) then
        qimlw(mgs) = - qci(mgs)/dtp                         !MSG Rate of cloudice melting
        tcqcmli = tcqcmli - qimlw(mgs)*dnz(mgs)        !MSG updated 11/22/03 (domain-total rate of qc increase)
        thetap(mgs) = thetap(mgs) - cc3(mgs)*qci(mgs)  !MSG heat decrease
        cmelt   = cmelt   + cc3(mgs)*qimlw(mgs)        !MGS cooling rate
        qcw(mgs) = qcw(mgs) + qci(mgs)
        qci(mgs) = 0.0
      end if
      end do
!
!
!  homogeneous freezing of cloud water
!
      if ( ndebug .eq. 1 ) print*,'dbg = 10.3'
!
      do mgs = 1,ngscnt
      if( temg(mgs) .lt. thnuc .and. qcw(mgs) .gt. 0.0 ) then
        qwfzi(mgs)  = -qcw(mgs)/dtp                         ! MSG Rate of clouwater freezing
        tiqifzc = tiqifzc - qwfzi(mgs)*dnz(mgs)        ! MSG updated 11/22/03 (domain-total rate of qi increase)
        thetap(mgs) = thetap(mgs) + cc3(mgs)*qcw(mgs)  ! MSG heat increase
        hfrz    = hfrz    + cc3(mgs)*(-qwfzi(mgs))     ! MSG heating rate
        qci(mgs) = qci(mgs) + qcw(mgs)
        qcw(mgs) = 0.0
      end if
      end do

!
!  Saturation adjustment iteration procedure
!
!  Modified Straka adjustment (nearly identical to Tao et al. 1989 MWR)
!
!

!
!  reset temporaries for cloud particles and vapor
!

      if ( ndebug .eq. 1 ) print*,'dbg = 10.4'
      do mgs = 1,ngscnt
       ptotsat(mgs) = 0.0
       qwv(mgs) = max( 0.0, qvap(mgs) )
       qcw(mgs) = max( 0.0, qcw(mgs) )
       qci(mgs) = max( 0.0, qci(mgs) )
       ptotsat(mgs) = qwv(mgs)+qci(mgs)+qcw(mgs)       !MSG updated just before sat adj. (qwv+qci+qcw)
       qcevpcnd(mgs) = 0.0
       qisubdep(mgs) = 0.0
      end do
!
      tqvb = tqvap              !MSG domain-total vapor perturb. prior to sat adj.
      do mgs = 1,ngscnt         !MSG domain-total qcw and qci prior to sat adj.
       tqcb = tqcb + qcw(mgs)*dnz(mgs)
       tqib = tqib + qci(mgs)*dnz(mgs)
      enddo

      do mgs = 1,ngscnt
       theta(mgs) = thetap(mgs) + theta0(mgs)
       temg(mgs) = theta(mgs)*( pres(mgs) / poo ) ** rcp
       temcg(mgs) = temg(mgs) - tfr
       ltemq = nint((temg(mgs)-163.15)/fqsat+1.5)
       ltemq = min(max(ltemq,1),nqsat) 
       qvs(mgs) = pqs(mgs)*tabqvs(ltemq)
       qis(mgs) = pqs(mgs)*tabqis(ltemq)
       if ( temg(mgs) .lt. tfr ) then
        if( qcw(mgs) .ge. 0.0 .and. qci(mgs) .eq. 0.0 ) qss(mgs) = qvs(mgs)
        if( qcw(mgs) .eq. 0.0 .and. qci(mgs) .gt. 0.0)  qss(mgs) = qis(mgs)
        if( qcw(mgs) .gt. 0.0 .and. qci(mgs) .gt. 0.0)  qss(mgs) = (qcw(mgs)*qvs(mgs) + qci(mgs)*qis(mgs))   &	
                                                                 / (qcw(mgs) + qci(mgs))
       else
        qss(mgs) = qvs(mgs)
       end if
      end do
!
!  iterate  adjustment
!
      if ( ndebug .eq. 1 ) print*,'dbg = 10.5'
      do itertd = 1,2
!
      do mgs = 1,ngscnt
!
!  calculate super-saturation
!
      dqcw(mgs) = 0.0
      dqci(mgs) = 0.0
      dqwv(mgs) = ( qwv(mgs) - qss(mgs) )
!
!  evaporation and sublimation adjustment
!
      if( dqwv(mgs) .lt. 0. ) then
       if( qcw(mgs) .gt. -dqwv(mgs) ) then		!Evap some of qc
         dqcw(mgs) = dqwv(mgs)
         dqwv(mgs) = 0.
       else						!Evap all of qc
         dqcw(mgs) = -qcw(mgs)
         dqwv(mgs) = dqwv(mgs) + qcw(mgs)
       end if
!
       if( qci(mgs) .gt. -dqwv(mgs) ) then		!Sublimate some of qi
         dqci(mgs) = dqwv(mgs)
         dqwv(mgs) = 0.
       else						!Sublimate all of qi
         dqci(mgs) = -qci(mgs)
         dqwv(mgs) = dqwv(mgs) + qci(mgs)
       end if
!
       qwvp(mgs) = qwvp(mgs) - ( dqcw(mgs) + dqci(mgs) )	!Increase vapor
      
       qcw(mgs) = qcw(mgs) + dqcw(mgs)			!Decrease cloudwater (dqcw<0)
       qci(mgs) = qci(mgs) + dqci(mgs) 			!Decrease cloudice   (dqci<0)
       thetap(mgs) = thetap(mgs) + cpi/pi0n(mgs)*(elv*dqcw(mgs) +els*dqci(mgs))
       qcevpcnd(mgs) = qcevpcnd(mgs) + (dqcw(mgs)/dtp)
       qisubdep(mgs) = qisubdep(mgs) + (dqci(mgs)/dtp)
      end if
!
! condensation/deposition
!
      if( dqwv(mgs) .ge. 0. ) then
!
       fracl(mgs) = 1.0
       fraci(mgs) = 0.0
       if ( temg(mgs) .lt. tfr .and. temg(mgs) .gt. thnuc ) then
        fracl(mgs) = max(min(1.,(temg(mgs)-233.15)/(20.)),0.0)
        fraci(mgs) = 1.0-fracl(mgs)
       end if
       if ( temg(mgs) .le. thnuc ) then
        fraci(mgs) = 1.0
        fracl(mgs) = 0.0
       end if
       fraci(mgs) = 1.0-fracl(mgs)
!
      gamss = (elv*fracl(mgs) + els*fraci(mgs))/ (pi0n(mgs)*cp)
!
      if ( temg(mgs) .lt. tfr ) then
       if (qcw(mgs) .ge. 0.0 .and. qci(mgs) .le. 0.0 ) then
         dqvcnd(mgs) = dqwv(mgs)/(1. + cqv1*qss(mgs)/((temg(mgs)-cbw)**2))
       end if
       if( qcw(mgs) .eq. 0.0 .and. qci(mgs) .gt. 0.0 ) then
         dqvcnd(mgs) = dqwv(mgs)/(1. + cqv2*qss(mgs)/((temg(mgs)-cbi)**2))
       end if
       if ( qcw(mgs) .gt. 0.0 .and. qci(mgs) .gt. 0.0 ) then
        cdw = caw*pi0n(mgs)*tfrcbw/((temg(mgs)-cbw)**2)
        cdi = cai*pi0n(mgs)*tfrcbi/((temg(mgs)-cbi)**2)
        denom1 = qcw(mgs) + qci(mgs)
        denom2 = 1.0 + gamss*(qcw(mgs)*qvs(mgs)*cdw + qci(mgs)*qis(mgs)*cdi) / denom1
        dqvcnd(mgs) =  dqwv(mgs) / denom2
       end if
      end if

      if ( temg(mgs) .ge. tfr ) then
        dqvcnd(mgs) = dqwv(mgs)/(1. + cqv1*qss(mgs)/ ((temg(mgs)-cbw)**2))
      end if
!
      dqcw(mgs) = dqvcnd(mgs)*fracl(mgs)
      dqci(mgs) = dqvcnd(mgs)*fraci(mgs)
!
      thetap(mgs) = thetap(mgs) + (elv*dqcw(mgs) + els*dqci(mgs))/ (pi0n(mgs)*cp)
      qwvp(mgs) = qwvp(mgs) - ( dqvcnd(mgs) )		!Decrease vapor
      qcw(mgs) = qcw(mgs) + dqcw(mgs)			!Increase cloudwater (dqcw>0)
      qci(mgs) = qci(mgs) + dqci(mgs)			!Increase cloudice   (dqci>0)

      qcevpcnd(mgs) = qcevpcnd(mgs) + (dqcw(mgs)/dtp)
      qisubdep(mgs) = qisubdep(mgs) + (dqci(mgs)/dtp)
      
!
      end if
      end do
!
      if ( ndebug .eq. 1 ) print*,'dbg = 10.51'
      do mgs = 1,ngscnt
       theta(mgs) = thetap(mgs) + theta0(mgs)
       temg(mgs) = theta(mgs)*( pres(mgs) / poo ) ** rcp
       qvap(mgs) =max((qwvp(mgs) + qv0n(mgs)), 0.0)
       temcg(mgs) = temg(mgs) - tfr

       ltemq = nint((temg(mgs)-163.15)/fqsat+1.5)
       ltemq = min(max(ltemq,1),nqsat)
       qvs(mgs) = pqs(mgs)*tabqvs(ltemq)
       qis(mgs) = pqs(mgs)*tabqis(ltemq)
       qcw(mgs) = max( 0.0, qcw(mgs) )
       qwv(mgs) = max( 0.0, qvap(mgs))
       qci(mgs) = max( 0.0, qci(mgs) )      !MSG 
      
       if ( temg(mgs) .lt. tfr ) then
        if( qcw(mgs) .ge. 0.0 .and. qci(mgs) .eq. 0.0 ) qss(mgs) = qvs(mgs)
        if( qcw(mgs) .eq. 0.0 .and. qci(mgs) .gt. 0.0)  qss(mgs) = qis(mgs)
        if( qcw(mgs) .gt. 0.0 .and. qci(mgs) .gt. 0.0)  qss(mgs) = (qcw(mgs)*qvs(mgs) + qci(mgs)*qis(mgs))   &
                                                               / (qcw(mgs) + qci(mgs))
       else
        qss(mgs) = qvs(mgs)
       end if
      end do
      if ( ndebug .eq. 1 ) print*,'dbg = 10.52'
!
!  end the saturation adjustment iteration loop
!
      end do
      if ( ndebug .eq. 1 ) print*,'dbg = 10.6'

      do mgs = 1,ngscnt                     !MSG net at each gpt after all sat adj. iterations are finished
       qcevp(mgs) = min(qcevpcnd(mgs),0.)  ! qcevp <=0
       qisub(mgs) = min(qisubdep(mgs),0.)  ! qisub <=0
       qccnd(mgs) = max(qcevpcnd(mgs),0.)  ! qccnd >=0
       qidep(mgs) = max(qisubdep(mgs),0.)  ! qidep >=0
      end do

      do mgs = 1,ngscnt
       tcqccnd = tcqccnd + qccnd(mgs)*dnz(mgs)    ! MSG updated 2/12/05 domain-total condensation
       tvqcevp = tvqcevp - qcevp(mgs)*dnz(mgs)    ! MSG updated 2/12/05 domain-total qc evaporation
       tvqisub = tvqisub - qisub(mgs)*dnz(mgs)    ! MSG updated 2/12/05 domain-total sublimation
       tiqidep = tiqidep + qidep(mgs)*dnz(mgs)    ! MSG updated 2/12/05 domain-total deposition

          hcnd = hcnd    + qccnd(mgs)*cc4(mgs)    ! MSG Update domain-total heating rate via qc condensation
         cevap = cevap   + qcevp(mgs)*cc4(mgs)    ! MSG Update domain-total cooling rate via qc evap
          csub = csub    + qisub(mgs)*cc5(mgs)    ! MSG Update domain-total cooling rate via qi sublim
          hdep = hdep    + qidep(mgs)*cc5(mgs)    ! MSG Update domain-total heating rate via qi deposition
      end do

!
!  Compute vapor, ice, and cloud totals after saturation adjustment.  
!            
      if (ndebug .eq. 1 ) then
       do mgs = 1,ngscnt
        if(abs(ptotsat(mgs)-qwv(mgs)-qci(mgs)-qcw(mgs)).gt.1.e-7)then
         print*,'NOTICE:PTOTSAT>1e-7 ', mgs, kgs(mgs), ptotsat(mgs),qwv(mgs),qci(mgs),qcw(mgs)
        end if
       end do
      end if

      if (ndebug .eq. 1 ) print*,'dbg = 10b'
! 
      do mgs = 1,ngscnt
        tqva = tqva + qwvp(mgs)*dnz(mgs)
        tqca = tqca +  qcw(mgs)*dnz(mgs)
        tqia = tqia +  qci(mgs)*dnz(mgs)
      end do

      tqv=tqva-tqvb          ! Change in vapor due to sat adj. (Should equal +tvqcevp+tvqisub-tiqidep-tcqccnd  )
      tqc=tqca-tqcb          ! Change in cloud due to sat adj. (Should equal +tcqccnd+tcqcmli-tvqcevp-tiqifzc  )
      tqi=tqia-tqib          ! Change in ice due to sat adj.   (Should equal +tiqidep+tiqifzc-tvqisub-tcqcmli  )
!
!
!
!  end of saturation adjustment
!
!  scatter precipitation fluxes, and thetap, and hydrometeors
!
!DIR$ IVDEP
      do 4001 mgs = 1,ngscnt
      ! GHB, 061013:  fallout calculations have been moved to CM1 solve
!!!      pflux(igs(mgs),kgs(mgs)) = piflx(mgs)
!!!      cflux(igs(mgs),kgs(mgs)) = cwflx(mgs)
!!!      rflux(igs(mgs),kgs(mgs)) = rwflx(mgs)
!!!      sflux(igs(mgs),kgs(mgs)) = swflx(mgs)
!!!      hflux(igs(mgs),kgs(mgs)) = hwflx(mgs)
      th3d(igs(mgs),jy,kgs(mgs))  =  thetap(mgs) 
      q3d(igs(mgs),jy,kgs(mgs),lv) = ab(kgs(mgs),2) +   qwvp(mgs) 
      q3d(igs(mgs),jy,kgs(mgs),lc) = qcw(mgs)  + min( q3d(igs(mgs),jy,kgs(mgs),lc), 0.0 ) !MSG putting any neg Gibbs values back
      q3d(igs(mgs),jy,kgs(mgs),li) = qci(mgs)  + min( q3d(igs(mgs),jy,kgs(mgs),li), 0.0 )  
      q3d(igs(mgs),jy,kgs(mgs),lr) = qrw(mgs)  + min( q3d(igs(mgs),jy,kgs(mgs),lr), 0.0 )  
      q3d(igs(mgs),jy,kgs(mgs),ls) = qsw(mgs)  + min( q3d(igs(mgs),jy,kgs(mgs),ls), 0.0 )  
      q3d(igs(mgs),jy,kgs(mgs),lh) = qhw(mgs)  + min( q3d(igs(mgs),jy,kgs(mgs),lh), 0.0 )  
 4001 continue
!
!
 9998 continue
!
!---------------------------------
! new, 071008, GHB (from MSG):
      if ( (ix+1 .gt. nx-istag) .and. &   ! x&z at end. Exit.       !MSG Corrected logic on 5 Oct 2007
           (kz+1 .gt. nz-kstag-1) ) then
        go to 1200
      else if (ix+1 .gt. nx-istag ) then  ! x at end. Reset x & inc z
        nzmpb = kz+1 
        nxmpb = 1
      else                                ! none at the end.  Inc x.
        nzmpb = kz 
        nxmpb = ix+1
      end if
!---------------------------------
! 061023, GHB:  dunno why the "kstag-1" is here ... removing the -1
!!!      if ( kz .gt. nz-kstag-1 .and. ix .gt. nx-istag ) then
!  old code:
!      if ( kz .gt. nz-kstag .and. ix .gt. nx-istag ) then
!        go to 1200
!      else
!        nzmpb = kz 
!      end if
!      
!      if ( ix+1 .gt. nx ) then
!        nxmpb = 1
!      else
!        nxmpb = ix+1
!      end if
!---------------------------------
      
 1000 continue      !MSG  end of numgs loop
 1200 continue
!
!  end of gather scatter
!
!  precipitation fallout contributions 
!  MSG Technically we probably should really be re-computing the fluxes based upon new mixing ratio's but we don't.
!
      ! GHB, 061013:  fallout is now computed in CM1 solve.

!      if (itfall .gt. 0) then
!       dtsplit = dtp
!       nrnstp  = 1
!
!       if (itfall .eq. 2) then  ! COMPUTE SPLIT-EXPLICIT TIME STEP USING MAX FALLSPEED OF ANY SPECIES IN THE SLICE
!        vtrdzmax = dtp*dzc(kz)*maxfall   ! Courant Number
!        nrnstp = 1 + aint(2.*vtrdzmax)   ! MSG Define number of small steps based upon
!                                         ! fastest falling particles (rain or hail/graupel)
!                                         ! nrnstp for 1 + aint(2*0.45) = 1 (use original timestep)
!                                         ! whereas 1+aint(2*0.55) = 2 (requiring dtp be split into
!                                         ! two smaller timesteps.) Thus if courant number, vtrdzmax>=0.5,
!                                         ! then automatically uses 2 small steps (0.25 courant each).
!                                         ! If vtrdzmax=1.0, then uses 3 small steps (0.33 courant each).
!                                         ! If vtrdzmax=1.5, then uses 4 small steps (0.25 courant, Etc.)
!                                         ! Thus the actual fallout courant ranges 0.25 to 0.5
!        dtsplit = dtp / float( nrnstp )  ! MSG Define small timestep (sec)
!       endif
!
!       DO inrnstp = 1,nrnstp            ! MSG BEGIN OF TIMESPLITTING
!        if (ndebug .eq. 1 ) print*,'dbg = 10g'
! 061023, GHB:  dunno why the "kstag-1" is here ... removing the -1
!!!!        do kz = 1,nz-kstag-1 
!        do kz = 1,nz-kstag
!        do ix = 1,nx-istag
!!         dtz1 = dzc(kz)*dtp/1.0        !MSG old version before timesplitting
!          dtz1 = dzc(kz)*dtsplit
!          q3d(ix,jy,kz,li) = q3d(ix,jy,kz,li) + dtz1*(pflux(ix,kz+1)-pflux(ix,kz))/db(kz)
!          q3d(ix,jy,kz,lc) = q3d(ix,jy,kz,lc) + dtz1*(cflux(ix,kz+1)-cflux(ix,kz))/db(kz)
!          q3d(ix,jy,kz,lr) = q3d(ix,jy,kz,lr) + dtz1*(rflux(ix,kz+1)-rflux(ix,kz))/db(kz)
!          q3d(ix,jy,kz,ls) = q3d(ix,jy,kz,ls) + dtz1*(sflux(ix,kz+1)-sflux(ix,kz))/db(kz)
!          q3d(ix,jy,kz,lh) = q3d(ix,jy,kz,lh) + dtz1*(hflux(ix,kz+1)-hflux(ix,kz))/db(kz)
!        enddo
!        enddo
!       ENDDO      !MSG End of timesplitting on fallout
!
!      endif     !end of itfall check


!
!
!  end of jy loop
!
 9999 continue
!
!
      if (ndebug .eq. 1 ) print*,'dbg = 10h'
!
!
!  WRITE totals for source / sink terms
      if (nrates .eq. 1 ) then
!
        tvsum  = tvqrcev -tiqiint -thqhdpv -tsqsdpv +tvqhsbv +tvqssbv
        tcsum  = -tsqsfw -thqhacw -trqrcnw -trqracw -tsqsacw -trqsacw
        trsum  = -tvqrcev -thqhacr +trqrcnw -thqrfrz +trqhshr +trqhmlr +trqsmlr -tsqiacr -thqiacr -tsqsacr -thqsacr   &
                 +trqracw +trqsacw
        tisum  = -tsqsfi -thqhaci -tsqscni +tiqiint -tsqraci -thqraci  -tsqsaci
        tssum  = tsqsfw +tsqsfi -thqhacs +tsqscni -thqhcns -trqsmlr +tsqiacr +tsqraci +tsqsacr +tsqsdpv -tvqssbv      &
                +tsqsaci +tsqsacw -thqracs
        thsum  = thqhacw +thqhacr +thqhacs +thqhaci +thqhcns +thqrfrz -trqhshr -trqhmlr +thqiacr +thqraci +thqsacr +thqhdpv   &
                 +thqracs -tvqhsbv
        tsumall =  tvsum + tcsum + tisum + trsum + tssum + thsum        !MSG gives ~1e-9 (machine precision)
!
        if (ndebug .eq. 1) then    ! MSG only print details if debugging on
!
        write(6,*) 'Sum species source/sink domain totals for all but Sat. Adj. (kg s^-1 m^-3)'
        write(6,*) 'qv', tvsum            ! Total rate for qv (not including sat adj.)
        write(6,*) 'qc', tcsum
        write(6,*) 'qi', tisum
        write(6,*) 'qr', trsum
        write(6,*) 'qs', tssum
        write(6,*) 'qh', thsum
!
        write(6,*) 'Sum only for saturation adjustment (kg s^-1 m^-3)'
        write(6,*) 'qv', tqv              !MSG total change in vapor only due to sat adj.
        write(6,*) 'qc', tqc              !MSG change in cloud only due to sat adj.
        write(6,*) 'qi', tqi              !MSG change in ice only due to sat adj.
!
        write(6,*) 'Sum all species but not sat. adj. (kg s^-1 m^-3)'
        write(6,*) 'sum', tsumall         !MSG - all sources/sink rates except for sat adj.(comes from tsum rates)
!       write(6,*) 'psum', psum           !MSG - all sources/sink rates except for sat adj.(comes from model rates)
!       write(6,*) 'sumchange', suma-sumb !MSG - change in content (g/m^3) over timestep (not incl. sat adj.)
!
        write(6,*) 'Sum of all rates (kg s^-1 m^-3)'
        write(6,*) 'tsa', tsumall+tqv+tqc+tqi  !MSG all source/sink rates including sat adj.
!       write(6,*) 'psa', psum+tqv+tqc+tqi     !MSG all source/sink rates including sat adj.
!
!       write(6,*) 'tqvp',tqvap-tqvbp          !Changes due to all (except sat adj or fallout)
!       write(6,*) 'tqcp',tqcap-tqcbp
!       write(6,*) 'tqip',tqiap-tqibp
!       write(6,*) 'tqrp',tqrap-tqrbp
!       write(6,*) 'tqsp',tqsap-tqsbp
!       write(6,*) 'tqhp',tqhap-tqhbp
!
        endif
!
!
        write(6,*) 'Individual domain total rates (kg s^-1 m^-3)'
        write(6,*) 'Using Gilmore et al. (2004b) terminology'
        write(6,*) 'vapor sources'
!
        write(6,*) 'qvevr ' , tvqrcev 
        write(6,*) 'qvevw ' , tvqcevp 
        write(6,*) 'qvsbi ' , tvqisub 
        write(6,*) 'qvsbs ' , tvqssbv 
        write(6,*) 'qvsbh ' , tvqhsbv 
!
        write(6,*) 'cloud water sources'
!
        write(6,*) 'qwcdv ' , tcqccnd 
        write(6,*) 'qwmli ' , tcqcmli 
!
        write(6,*) 'rain sources'
!
        write(6,*) 'qrhacr' , trqhacr     !Added 2/6/04  (rain accreted and shed during same timestep)
        write(6,*) 'qrmlh ' , trqhmlr 
        write(6,*) 'qracw ' , trqracw 
        write(6,*) 'qrcnw ' , trqrcnw 
!       write(6,*) 'qrshh ' , trqhshr      !MSG ambiguous since sign can switch. Instead, use 4 individual terms (2/6/04)
        write(6,*) 'qrhacw' , trqhacw     !Added 2/6/04  (from shedding)
        write(6,*) 'qrhacs' , trqhacs     !Added 2/6/04  (from shedding)
        write(6,*) 'qrmls ' , trqsmlr 
        write(6,*) 'qrsacw' , trqsacw
        write(6,*) 'qrhaci' , trqhaci     !Added 2/6/04  (from shedding)
!
        write(6,*) 'cloud ice sources'
!
        write(6,*) 'qidpv ' , tiqidep
        write(6,*) 'qiint ' , tiqiint 
        write(6,*) 'qifzw ' , tiqifzc 
!
        write(6,*) 'snow sources'
!
        write(6,*) 'qsfi  ' , tsqsfi 
        write(6,*) 'qsacw ' , tsqsacw
        write(6,*) 'qsaci ' , tsqsaci
        write(6,*) 'qsdpv ' , tsqsdpv
        write(6,*) 'qsiacr' , tsqiacr
        write(6,*) 'qsacr ' , tsqsacr
        write(6,*) 'qsfw  ' , tsqsfw 
        write(6,*) 'qsraci' , tsqraci
        write(6,*) 'qscni ' , tsqscni
!
        write(6,*) 'hail sources'
!
        write(6,*) 'qhacw ' , thqhacw   ! 2/6/04 (only that which is not shed as rain)
        write(6,*) 'qhacr ' , thqhacr   ! 2/6/04 (only that which is not shed as rain)
        write(6,*) 'qhdpv ' , thqhdpv
        write(6,*) 'qhsacr' , thqsacr
        write(6,*) 'qhwtr ' , thqhwet   ! 2/6/04 (only that which is not shed as rain)
        write(6,*) 'qhacs ' , thqhacs   ! 2/6/04 (only that which is not shed as rain)
        write(6,*) 'qhfzr ' , thqrfrz
        write(6,*) 'qhaci ' , thqhaci   ! 2/6/04 (only that which is not shed as rain)
        write(6,*) 'qhracs' , thqracs
        write(6,*) 'qhcns ' , thqhcns
        write(6,*) 'qhiacr' , thqiacr
        write(6,*) 'qhraci' , thqraci
!
        write(6,*) 'total heating and cooling rates'
!
        write(6,*) 'hfrz'    , hfrz
        write(6,*) 'hdep'    , hdep
        write(6,*) 'hcnd'    , hcnd
        write(6,*) 'cmelt'   , cmelt
        write(6,*) 'cevap'   , cevap
        write(6,*) 'csub'    , csub
      endif
! 
!
!
      if (ndebug .eq. 1 ) print*,'dbg = 11a'

      return
      end
!
!  end of subroutine
!
!--------------------------------------------------------------------------
!
!--------------------------------------------------------------------------
! Routine from Numerical Recipes to replace other gamma function
!  using 32-bit reals, this is accurate to 6th decimal place.

!     REAL FUNCTION GAMMA(xx)

!     implicit none
!     real xx
!     integer j

! Double precision ser,stp,tmp,x,y,cof(6)

!     real*8 ser,stp,tmp,x,y,cof(6)
!     SAVE cof,stp
!     DATA cof,stp/76.18009172947146d+0,
!    $            -86.50532032941677d0,
!    $             24.01409824083091d0,
!    $             -1.231739572450155d0,
!    $              0.1208650973866179d-2,
!    $             -0.5395239384953d-5,
!    $              2.5066282746310005d0/

!     x = xx
!     y = x
!     tmp = x + 5.5d0
!     tmp = (x + 0.5d0)*Log(tmp) - tmp
!     ser = 1.000000000190015d0
!     DO j=1,6
!       y = y + 1.0d0
!       ser = ser + cof(j)/y
!     END DO
!     gamma = Exp(tmp + log(stp*ser/x))

!     RETURN
!     END

!--------------------------------------------------------------------------

      subroutine lfoice_init(dtp)
      implicit none

      include 'lfoice.incl'

      real, intent(in) :: dtp

      outfile=6
#ifdef MPI
      outfile=10
#endif

!
!  constants
!
      poo = 1.0e+05
      ar = 841.99666  
      br = 0.8
      bta1 = 0.6
      cnit = 1.0e-02
      dnz00 = 1.225
      rho00 = 1.225
      cs = 4.83607122
      ds = 0.25
      pi = 4.0*atan(1.0)
      pid4 = pi/4.0 
      qccrit = 2.0e-03
      qscrit = 6.0e-04
      qicrit = 1.0e-03
!      
! Define gamma functions
!
      gf1 = 1.0      !gamma(1.0)
      gf2 = 1.0      !gamma(2.0)
      gf3 = 2.0      !gamma(3.0)
      gf4 = 6.0      !gamma(4.0)
      gf5 = 24.0     !gamma(5.0)
      gf6 = 120.0    !gamma(6.0)
      gf4br = 17.837862  !gamma(4.0+br)
      gf4ds = 8.2850851  !gamma(4.0+ds)
      gf5br = 1.8273551  !gamma((5.0+br)/2.)
      gf5ds = 1.4569332  !gamma((5.0+ds)/2.)
      gf2p75= 1.6083594  !gamma(2.75)
      gf4p5 = 11.631728  !gamma(4.0+0.5)
      
      if ( hwdn .lt. 600.0 ) then
      dragh = 1.00
      else
      dragh = 0.60
      end if

      xcnor = cnor
      xcnos = cnos
      xcnoh = cnoh

!ORF probably can't include input.incl due to conflict in declarations, just
!eliminate output here
!      if(myid.eq.0)then
!             write(outfile,*) '-----------------------------------------------------------------------'
!             write(outfile,*)
!             write(outfile,*) '2004 STRAKA(GILMORE) SAM microphysics'
!             write(outfile,*)
!             write(outfile,*) '3-ICE MICROPHYSICAL CONSTANTS'
!101          Format(1x,a,6(g10.5,2x))
!             write(outfile,101) 'CNOR/DENR:        ',cnor, rwdn
!             write(outfile,101) 'CNOS/DENS:        ',cnos, swdn
!             write(outfile,101) 'CNOH/DENH/DRAGH:  ',cnoh, hwdn,dragh
!             write(outfile,*)   'TIME STEP:        ', dtp
!               IF( autoconversion .eq. 0 ) THEN
!              write(outfile,*) 'Berry (1968) Critical qc g/g for autoconversion= ',qcmincwrn
!               ELSE
!              write(outfile,*) 'Berry (1968) Critical qc diam for autoconversion= ',cwdiap*1e6,' microns'
!               ENDIF
!             write(outfile,*) '-----------------------------------------------------------------------'
!             write(outfile,*)
!       endif

!  constants
!
      c1f3 = 1.0/3.0
!
!  general constants for microphysics
!
      brz = 100.0
      arz = 0.66
      cai = 21.87455
      caw = 17.2693882
      cbi = 7.66
      cbw = 35.86
      qcmin = 1.0e-09
      qimin = 1.0e-12
      qrmin = 1.0e-07
      qsmin = 1.0e-07
      qhmin = 1.0e-07

      tfr = 273.15
      thnuc = 233.15
      advisc0 = 1.832e-05
      advisc1 = 1.718e-05
      tka0 = 2.43e-02
      cpi = 1.0/cp
      tfrcbw = tfr - cbw
      tfrcbi = tfr - cbi

      elv = 2500300. 
      elf = 335717. 
      els = elv + elf
      cw = 4218.0   
      xmlt3 = -cw/elf
      xiint = (elv**2)/(cp*rw)

      xacwi = pid4          
      xxacx = pid4/gf4
      xvth1 = gf4p5/(6.0)
      xxmlt1 = 0.78*gf2
      xrcev1 = 0.78*gf2
      xvth3 = (4.0*g/(3.0*dragh))**(0.25)
      xslop = (1./pi)**(0.25)
      xvtr  = ar*gf4br*(dnz00**0.5)/6.0
      xvts  = cs*gf4ds*(dnz00**0.5)/6.0

      cqv1 = 4097.8531*elv*cpi
      cqv2 = 5807.4743*els*cpi
!
!
!  Saturation Vapor Pressure Lookup Table
!
      do lll = 1,nqsat
      temq = 163.15 + (lll-1)*fqsat
      tabqvs(lll) = exp(caw*(temq-273.15)/(temq-cbw))
      tabqis(lll) = exp(cai*(temq-273.15)/(temq-cbi))
      end do
!
!  cw constants in mks units
!
      cwmasn = 4.25e-15
      cwmasx = 5.25e-10
      cwdn = 1000.0
      cwc1 = 6.0/(pi*cwdn)
!
!  ci constants in mks units
!
      cimasx = 3.23e-8
      cimasn = 4.25e-15
!
!  constants for bergeron process, note in cgs units
!
      cmn = 1.05e-15
      cmi40 = 2.4546e-07
      cmi50 = 4.8e-07
      ri50 = 5.0e-03
      vti50 = 100.0
      bsfw = (ri50**2)*vti50*pi
      cbtim(1) = 1.0e+30
      cs10(1)  = 0.0
      cs11(1)  = 0.0
      do ibb = 2,32
        cm50a = cmi50**bfa2(ibb)
        atemp = 1.0-bfa2(ibb)
        cm40b = cmi40**atemp
        cm50b = cmi50**atemp
        cbtim(ibb) = (cm50b-cm40b)/(bfa1(ibb)*atemp)
        cs10(ibb) = bfa1(ibb)*cm50a
        cs11(ibb) = dtp/(cbtim(ibb)*cmi50)
!       write(6,*) 'ibb, cbtim(ibb)=',ibb, cbtim(ibb)
      ENDDO

      return
      end subroutine lfoice_init

!--------------------------------------------------------------------------

maxmin.F/       1298670057  19071 8000  100644  8829      `
      subroutine maxmin_orf(izz,jzz,kzz,f,fmax,fmin,comm)
      use orfiomod
      implicit none

      include 'input.incl'
      include 'timestat.incl'
#ifdef MPI
      include 'mpif.h'
#endif

      integer :: izz,jzz,kzz
      real fmax,fmin
      real, dimension(1:izz,1:jzz,1:kzz) :: f

!-----------------------------------------------------------------------

      integer :: i,j,k,comm
      integer :: imax,jmax,kmax,imin,jmin,kmin
      integer, dimension(nk+1) :: imaxt,jmaxt,kmaxt,imint,jmint,kmint
      real, dimension(nk+1) :: tmax,tmin
      integer :: loc
      real, dimension(2) :: mmax,nmax,mmin,nmin

!-----------------------------------------------------------------------

!$omp parallel do default(shared)    &
!$omp private(i,j,k)
      do k=1,kzz
        tmax(k)=-99999999.
        tmin(k)= 99999999.
        do j=1,jzz
        do i=1,izz
          if(f(i,j,k).gt.tmax(k))then
            tmax(k)=f(i,j,k)
            imaxt(k)=i
            jmaxt(k)=j
            kmaxt(k)=k
          endif
          if(f(i,j,k).lt.tmin(k))then
            tmin(k)=f(i,j,k)
            imint(k)=i
            jmint(k)=j
            kmint(k)=k
          endif
        enddo
        enddo
      enddo

      fmax=-99999999.
      fmin= 99999999.
      do k=1,kzz
        if(tmax(k).gt.fmax)then
          fmax=tmax(k)
          imax=imaxt(k)
          jmax=jmaxt(k)
          kmax=kmaxt(k)
        endif
        if(tmin(k).lt.fmin)then
          fmin=tmin(k)
          imin=imint(k)
          jmin=jmint(k)
          kmin=kmint(k)
        endif 
      enddo

#ifdef MPI
      mmax(1)=fmax
      mmax(2)=myid
!     print *,"myid, fmax before ALLREDUCE: ",myid,fmax
!NEED TO REDUCE TO LOCAL ROOT PROC! NOT ALLREDUCE
      call MPI_REDUCE(mmax,nmax,1,MPI_2REAL,MPI_MAXLOC,0,comm,ierr)
      loc=nint(nmax(2))
      imax=imax+(myi-1)*ni
      jmax=jmax+(myj-1)*nj
!     call MPI_BARRIER(MPI_COMM_WORLD,ier)
!     if(mysubgrouprank.eq.0)write(*,1111)myid,imax,jmax,nmax(1)
!     call MPI_BARRIER(MPI_COMM_WORLD,ier)
!     call FFLUSH(6)
1111  format("myid = ",i2," imax = ",i4," jmax = ",i4," max = ",f13.6)
!     call MPI_BCAST(imax,1,MPI_INTEGER,loc,comm,ierr)
!     call MPI_BCAST(jmax,1,MPI_INTEGER,loc,comm,ierr)
!     call MPI_BCAST(kmax,1,MPI_INTEGER,loc,comm,ierr)
!     print *,"myid, imax,jmax,kmax after BCASTs : ",myid, imax,jmax,kmax

      mmin(1)=fmin
      mmin(2)=myid
      call MPI_REDUCE(mmin,nmin,1,MPI_2REAL,MPI_MINLOC,0,comm,ierr)
!     call MPI_ALLREDUCE(mmin,nmin,1,MPI_2REAL,MPI_MINLOC,   &
!                        comm,ierr)
      loc=nint(nmin(2))
      imin=imin+(myi-1)*ni
      jmin=jmin+(myj-1)*nj
!     call MPI_BCAST(imin,1,MPI_INTEGER,loc,comm,ierr)
!     call MPI_BCAST(jmin,1,MPI_INTEGER,loc,comm,ierr)
!     call MPI_BCAST(kmin,1,MPI_INTEGER,loc,comm,ierr)
      fmax=nmax(1)
      fmin=nmin(1)
#endif

      if(timestats.ge.1) time_stat=time_stat+mytime()
 
      return
      end



      subroutine maxmin(izz,jzz,kzz,f,nstat,rstat,amax,amin)
      implicit none

      include 'input.incl'
      include 'timestat.incl'
#ifdef MPI
      include 'mpif.h'
#endif

      integer :: izz,jzz,kzz,nstat
      real, dimension(stat_out) :: rstat
      real, dimension(1-ngxy:izz+ngxy,1-ngxy:jzz+ngxy,1-ngz:kzz+ngz) :: f
      character*6 :: amax,amin

!-----------------------------------------------------------------------

      integer :: i,j,k
      integer :: imax,jmax,kmax,imin,jmin,kmin
      integer, dimension(nk+1) :: imaxt,jmaxt,kmaxt,imint,jmint,kmint
      real, dimension(nk+1) :: tmax,tmin
      real :: fmax,fmin,rmax,rmin
      integer :: loc
      real, dimension(2) :: mmax,nmax,mmin,nmin

!-----------------------------------------------------------------------

!$omp parallel do default(shared)    &
!$omp private(i,j,k)
      do k=1,kzz
        tmax(k)=-99999999.
        tmin(k)= 99999999.
        do j=1,jzz
        do i=1,izz
          if(f(i,j,k).gt.tmax(k))then
            tmax(k)=f(i,j,k)
            imaxt(k)=i
            jmaxt(k)=j
            kmaxt(k)=k
          endif
          if(f(i,j,k).lt.tmin(k))then
            tmin(k)=f(i,j,k)
            imint(k)=i
            jmint(k)=j
            kmint(k)=k
          endif
        enddo
        enddo
      enddo

      fmax=-99999999.
      fmin= 99999999.
      do k=1,kzz
        if(tmax(k).gt.fmax)then
          fmax=tmax(k)
          imax=imaxt(k)
          jmax=jmaxt(k)
          kmax=kmaxt(k)
        endif
        if(tmin(k).lt.fmin)then
          fmin=tmin(k)
          imin=imint(k)
          jmin=jmint(k)
          kmin=kmint(k)
        endif 
      enddo

#ifdef MPI
      mmax(1)=fmax
      mmax(2)=myid
      call MPI_ALLREDUCE(mmax,nmax,1,MPI_2REAL,MPI_MAXLOC,   &
                         MPI_COMM_WORLD,ierr)
      loc=nint(nmax(2))
      imax=imax+(myi-1)*ni
      jmax=jmax+(myj-1)*nj
      call MPI_BCAST(imax,1,MPI_INTEGER,loc,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(jmax,1,MPI_INTEGER,loc,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(kmax,1,MPI_INTEGER,loc,MPI_COMM_WORLD,ierr)

      mmin(1)=fmin
      mmin(2)=myid
      call MPI_ALLREDUCE(mmin,nmin,1,MPI_2REAL,MPI_MINLOC,   &
                         MPI_COMM_WORLD,ierr)
      loc=nint(nmin(2))
      imin=imin+(myi-1)*ni
      jmin=jmin+(myj-1)*nj
      call MPI_BCAST(imin,1,MPI_INTEGER,loc,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(jmin,1,MPI_INTEGER,loc,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(kmin,1,MPI_INTEGER,loc,MPI_COMM_WORLD,ierr)

      fmax=nmax(1)
      fmin=nmin(1)

    if(myid.eq.0)then
#endif
      write(6,100) amax,fmax,imax,jmax,kmax,    &
                   amin,fmin,imin,jmin,kmin
100   format(2x,a6,':',1x,f13.6,i5,i5,i5,    &
             4x,a6,':',1x,f13.6,i5,i5,i5)

      nstat = nstat + 1
      rstat(nstat) = fmax
      nstat = nstat + 1
      rstat(nstat) = fmin
#ifdef MPI
    endif
#endif

      if(timestats.ge.1) time_stat=time_stat+mytime()
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine maxmin2d(izz,jzz,f,nstat,rstat,amax,amin)
      implicit none
        
      include 'input.incl'
      include 'timestat.incl'
#ifdef MPI
      include 'mpif.h'
#endif

      integer :: izz,jzz,nstat
      real, dimension(stat_out) :: rstat
      real, dimension(1-ngxy:izz+ngxy,1-ngxy:jzz+ngxy) :: f
      character*6 :: amax,amin
        
!-----------------------------------------------------------------------
          
      integer :: i,j
      integer :: imax,jmax,imin,jmin
      integer, dimension(jzz) :: imaxt,jmaxt,imint,jmint
      real, dimension(jzz) :: tmax,tmin
      real :: fmax,fmin,rmax,rmin
      integer :: loc
      real, dimension(2) :: mmax,nmax,mmin,nmin
          
!-----------------------------------------------------------------------

!$omp parallel do default(shared)    &
!$omp private(i,j)
      do j=1,jzz
        tmax(j)=-99999999.
        tmin(j)= 99999999.
        do i=1,izz
          if(f(i,j).gt.tmax(j))then
            tmax(j)=f(i,j)
            imaxt(j)=i
            jmaxt(j)=j
          endif
          if(f(i,j).lt.tmin(j))then
            tmin(j)=f(i,j)
            imint(j)=i
            jmint(j)=j
          endif
        enddo
      enddo

      fmax=-99999999.
      fmin= 99999999.
      do j=1,jzz
        if(tmax(j).gt.fmax)then
          fmax=tmax(j)
          imax=imaxt(j)
          jmax=jmaxt(j)
        endif
        if(tmin(j).lt.fmin)then
          fmin=tmin(j)
          imin=imint(j)
          jmin=jmint(j)
        endif
      enddo

#ifdef MPI
      mmax(1)=fmax
      mmax(2)=myid
      call MPI_ALLREDUCE(mmax,nmax,1,MPI_2REAL,MPI_MAXLOC,   &
                         MPI_COMM_WORLD,ierr)
      loc=nint(nmax(2))
      imax=imax+(myi-1)*ni
      jmax=jmax+(myj-1)*nj
      call MPI_BCAST(imax,1,MPI_INTEGER,loc,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(jmax,1,MPI_INTEGER,loc,MPI_COMM_WORLD,ierr)

      mmin(1)=fmin
      mmin(2)=myid
      call MPI_ALLREDUCE(mmin,nmin,1,MPI_2REAL,MPI_MINLOC,   &
                         MPI_COMM_WORLD,ierr)
      loc=nint(nmin(2))
      imin=imin+(myi-1)*ni
      jmin=jmin+(myj-1)*nj
      call MPI_BCAST(imin,1,MPI_INTEGER,loc,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(jmin,1,MPI_INTEGER,loc,MPI_COMM_WORLD,ierr)

      fmax=nmax(1)
      fmin=nmin(1)

    if(myid.eq.0)then
#endif
      write(6,100) amax,fmax,imax,jmax,1,    &
                   amin,fmin,imin,jmin,1
100   format(2x,a6,':',1x,f13.6,i5,i5,i5,    &
             4x,a6,':',1x,f13.6,i5,i5,i5)

      nstat = nstat + 1
      rstat(nstat) = fmax
      nstat = nstat + 1
      rstat(nstat) = fmin
#ifdef MPI
    endif
#endif

      if(timestats.ge.1) time_stat=time_stat+mytime()

      return
      end



misclibs.F/     1298670057  19071 8000  100644  63430     `


      subroutine getqli(ip,q,ql,qi)
      implicit none

      include 'input.incl'
      include 'timestat.incl'

      integer :: ip
      real, dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: q
      real, dimension(ib:ie,jb:je,kb:ke) :: ql,qi

      integer :: i,j,k,n

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1-ip,nj+ip
      do i=1-ip,ni+ip
        ql(i,j,k)=0.0
        qi(i,j,k)=0.0
      enddo
      enddo
      enddo

      do n=nql1,nql2
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1-ip,nj+ip
        do i=1-ip,ni+ip
          ql(i,j,k)=ql(i,j,k)+q(i,j,k,n)
        enddo
        enddo
        enddo
      enddo

      IF(iice.eq.1)THEN
        do n=nqs1,nqs2
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1-ip,nj+ip
          do i=1-ip,ni+ip
            qi(i,j,k)=qi(i,j,k)+q(i,j,k,n)
          enddo
          enddo
          enddo
        enddo
      ENDIF

      if(timestats.ge.1) time_misc=time_misc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine pdefq(rmax,asq,ruh,rvh,rmh,rho,q3d)
      implicit none

      include 'input.incl'
      include 'timestat.incl'

      real rmax
      real*8 asq
      real, dimension(ib:ie) :: ruh
      real, dimension(jb:je) :: rvh
      real, dimension(ib:ie,jb:je,kb:ke) :: rmh
      real, dimension(ib:ie,jb:je,kb:ke) :: rho,q3d

      integer i,j,k
      real*8 t1,t2,t3
      real*8 a1,a2,tem
      real*8, dimension(nj) :: budj
      real*8, dimension(nk) :: budk

!----------------------------------------------------------------------

      tem = dx*dy*dz

      IF(pdscheme.eq.1)THEN

!$omp parallel do default(shared)  &
!$omp private(j)
        do j=1,nj
          budj(j)=0.0d0
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k,t1,t2,t3,a1,a2)
        do j=1,nj
        do i=1,ni
          t1=0.0d0
          t2=0.0d0
          a1=0.0d0
          a2=0.0d0
          do k=1,nk
            t1=t1+rho(i,j,k)*q3d(i,j,k)
            a1=a1+rho(i,j,k)*q3d(i,j,k)*ruh(i)*rvh(j)*rmh(i,j,k)
!!!            q3d(i,j,k)=max(0.0,q3d(i,j,k))
            if(q3d(i,j,k).lt.rmax) q3d(i,j,k)=0.0
            t2=t2+rho(i,j,k)*q3d(i,j,k)
          enddo
          t3=(t1+1.0d-20)/(t2+1.0d-20)
          if(t3.lt.0.0) t3=1.0d0
          do k=1,nk
            q3d(i,j,k)=t3*q3d(i,j,k)
            a2=a2+rho(i,j,k)*q3d(i,j,k)*ruh(i)*rvh(j)*rmh(i,j,k)
          enddo
          budj(j)=budj(j)+a2-a1
        enddo
        enddo

        do j=1,nj
          asq=asq+budj(j)*tem
        enddo

      ELSE

!$omp parallel do default(shared)  &
!$omp private(k)
        do k=1,nk
          budk(k)=0.0d0
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k,a1,a2)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          a1=rho(i,j,k)*q3d(i,j,k)*ruh(i)*rvh(j)*rmh(i,j,k)
!!!          q3d(i,j,k)=max(0.0,q3d(i,j,k))
          if(q3d(i,j,k).lt.rmax) q3d(i,j,k)=0.0
          a2=rho(i,j,k)*q3d(i,j,k)*ruh(i)*rvh(j)*rmh(i,j,k)
          budk(k)=budk(k)+a2-a1
        enddo
        enddo
        enddo

        do k=1,nk
          asq=asq+budk(k)*tem
        enddo

      ENDIF

!----------------------------------------------------------------------

      if(timestats.ge.1) time_misc=time_misc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 
      subroutine calcprs(pi0,prs,pp3d)
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real, dimension(ib:ie,jb:je,kb:ke) :: pi0
      real, dimension(ib:ie,jb:je,kb:ke) :: prs,pp3d
 
      integer i,j,k
 
!----------------------------------------------------------------------
 
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        prs(i,j,k)=p00*((pi0(i,j,k)+pp3d(i,j,k))**cpdrd)
      enddo
      enddo
      enddo
 
!----------------------------------------------------------------------
 
      if(timestats.ge.1) time_misc=time_misc+mytime()
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine calcrho(pi0,th0,rho,prs,pp3d,th3d,q3d)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, dimension(ib:ie,jb:je,kb:ke) :: pi0,th0
      real, dimension(ib:ie,jb:je,kb:ke) :: rho,prs,pp3d,th3d
      real, dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: q3d

      integer i,j,k

!----------------------------------------------------------------------

      IF(imoist.eq.1)THEN

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          rho(i,j,k)=prs(i,j,k)                         &
             /( rd*(th0(i,j,k)+th3d(i,j,k))*(pi0(i,j,k)+pp3d(i,j,k))     &
                  *(1.0+max(0.0,q3d(i,j,k,nqv))*reps) )
        enddo
        enddo
        enddo

      ELSE

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          rho(i,j,k)=prs(i,j,k)   &
             /(rd*(th0(i,j,k)+th3d(i,j,k))*(pi0(i,j,k)+pp3d(i,j,k)))
        enddo
        enddo
        enddo

      ENDIF

!----------------------------------------------------------------------

      if(timestats.ge.1) time_misc=time_misc+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine calcdbz(rho,qr,qs,qg,dbz)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'goddard.incl'

      real, dimension(ib:ie,jb:je,kb:ke) :: rho,qr,qs,qg,dbz

      integer :: i,j,k
      real :: n0r,n0g,n0s,rhor,rhog,rhos,gamma,zer,zeg,zes
      real, parameter :: epp = 1.0e-8

  IF(ptype.eq.2)THEN

    rhor = 1000.0 * ROQR
    rhog = 1000.0 * ROQG
    rhos = 1000.0 * ROQS

    n0r = 1.0e8 * TNW
    n0g = 1.0e8 * TNG
    n0s = 1.0e8 * TNSS

!!!    print *,'  rhor,rhog,rhos = ',rhor,rhog,rhos
!!!    print *,'  n0r,n0g,n0s    = ',n0r,n0g,n0s

!$omp parallel do default(shared)  &
!$omp private(i,j,k,gamma,zer,zeg,zes)
    do k=1,nk
    do j=1,nj
    do i=1,ni

    if(qr(i,j,k).ge.epp)then
      !--- rain ---
      gamma=(3.14159*n0r*rhor/(rho(i,j,k)*qr(i,j,k)))**0.25
      zer=720.0*n0r*(gamma**(-7))
    else
      zer=0.0
    endif

    if(qg(i,j,k).ge.epp)then
      !--- graupel/hail ---
      gamma=(3.14159*n0g*rhog/(rho(i,j,k)*qg(i,j,k)))**0.25
      zeg=720.0*n0g*(gamma**(-7))*((rhog/rhor)**2)*0.224
    else
      zeg=0.0
    endif

    if(qs(i,j,k).ge.epp)then
      !--- snow ---
      gamma=(3.14159*n0s*rhos/(rho(i,j,k)*qs(i,j,k)))**0.25
      zes=720.0*n0s*(gamma**(-7))*((rhos/rhor)**2)*0.224
    else
      zes=0.0
    endif

      !--- dbz ---

    if( (zer+zeg+zes).gt.1.0e-18 )then
      dbz(i,j,k)=10.0*log10((zer+zeg+zes)*1.0e18)
    else
      dbz(i,j,k)=0.0
    endif

    enddo
    enddo
    enddo

  ELSE

    if(myid.eq.0)then
         write(outfile,*)
         write(outfile,*) ' ptype = ',ptype
         write(outfile,*)
         write(outfile,*) ' calcdbz is not valid for this value of ptype'
         write(outfile,*)
    endif
    call stopcm1

  ENDIF

      if(timestats.ge.1) time_write=time_write+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine calcuh(uf,vf,zh,zf,ua,va,wa,uh,zeta)
      implicit none

      ! Subroutine to calculate vertically integrated updraft helicity
      ! Reference:  Kain et al, 2008, WAF, p 931

      include 'input.incl'
      include 'timestat.incl'

      ! note:  need zh,zf Above Ground Level

      real, intent(in), dimension(ib:ie+1) :: uf
      real, intent(in), dimension(jb:je+1) :: vf
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: zh
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: zf
      real, intent(in), dimension(ib:ie+1,jb:je,kb:ke) :: ua
      real, intent(in), dimension(ib:ie,jb:je+1,kb:ke) :: va
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: wa
      real, intent(inout), dimension(ib:ie,jb:je) :: uh
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: zeta

      real, parameter :: zz0 = 1000.0     ! bottom of integration layer (m AGL)
      real, parameter :: zzt = 6000.0     ! top of integration layer (m AGL)

      integer :: i,j,k
      real :: wbar,zbar

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
    DO k=1,nk
    DO j=1,nj+1
    DO i=1,ni+1
      zeta(i,j,k) = (va(i,j,k)-va(i-1,j,k))*rdx*uf(i)   &
                   -(ua(i,j,k)-ua(i,j-1,k))*rdy*vf(j)
    ENDDO
    ENDDO
    ENDDO

!$omp parallel do default(shared)  &
!$omp private(i,j,k,wbar,zbar)
    DO j=1,nj
    DO i=1,ni
      uh(i,j) = 0.0
      DO k=1,nk
        IF( zh(i,j,k).ge.zz0 .and. zh(i,j,k).le.zzt )THEN
          ! note:  only consider cyclonically rotating updrafts
          !        (so, w and zeta must both be positive)
          wbar = max( 0.0 , 0.5*(wa(i,j,k)+wa(i,j,k+1)) )
          zbar = max( 0.0 , 0.25*(zeta(i,j,k)+zeta(i+1,j,k)   &
                                 +zeta(i,j+1,k)+zeta(i+1,j+1,k)) )
          uh(i,j) = uh(i,j) + (min(zf(i,j,k+1),zzt)-max(zf(i,j,k),zz0))*wbar*zbar
        ENDIF
      ENDDO
    ENDDO
    ENDDO

      return
      end subroutine calcuh


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine calcvort(xh,xf,uf,vf,zh,mf,zf,ua,va,wa,xvort,yvort,zvort,tem)
      implicit none

      ! Subroutine to calculate 3 components of vorticity
      ! at scalar points.

      include 'input.incl'
      include 'timestat.incl'

      real, intent(in), dimension(ib:ie) :: xh
      real, intent(in), dimension(ib:ie+1) :: xf,uf
      real, intent(in), dimension(jb:je+1) :: vf
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: zh
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: mf,zf
      real, intent(in), dimension(ib:ie+1,jb:je,kb:ke) :: ua
      real, intent(in), dimension(ib:ie,jb:je+1,kb:ke) :: va
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: wa
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: xvort,yvort,zvort,tem

      integer :: i,j,k

        !---
        ! x-vort:
        tem=0.0
        if(axisymm.eq.0)then
          ! Cartesian grid:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=2,nk
          do j=1,nj+1
          do i=1,ni
            tem(i,j,k) = (wa(i,j,k)-wa(i,j-1,k))*rdy*vf(j)   &
                        -(va(i,j,k)-va(i,j,k-1))*rdz*0.5*(mf(i,j-1,k)+mf(i,j,k))
          enddo
          enddo
          enddo
          IF( (iturb.ge.1.and.bcturbu.le.2).or.(dns.eq.1.and.bc_wind.eq.1) )THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
            do j=1,nj+1
            do i=1,ni
              tem(i,j,1)=tem(i,j,2)
              tem(i,j,nk+1)=tem(i,j,nk)
            enddo
            enddo
          ENDIF
          IF( (iturb.ge.1.and.bcturbu.eq.3).or.(dns.eq.1.and.bc_wind.eq.2).or.(ipbl.eq.1) )THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
            do j=1,nj+1
            do i=1,ni
              tem(i,j,1)=-2.0*va(i,j,1)*rdz*0.5*(mf(i,j-1,1)+mf(i,j,1))
              tem(i,j,nk+1)=2.0*va(i,j,nk)*rdz*0.5*(mf(i,j-1,nk+1)+mf(i,j,nk+1))
            enddo
            enddo
          ENDIF
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            xvort(i,j,k) = 0.25*(tem(i,j,k)+tem(i,j+1,k)+tem(i,j,k+1)+tem(i,j+1,k+1))
          enddo
          enddo
          enddo
        else
          ! Axisymmetric grid:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=2,nk
          do j=1,nj
          do i=1,ni
            tem(i,j,k) = -(va(i,j,k)-va(i,j,k-1))*rdz*0.5*(mf(i,j-1,k)+mf(i,j,k))
          enddo
          enddo
          enddo
          IF( (iturb.ge.1.and.bcturbu.le.2).or.(dns.eq.1.and.bc_wind.eq.1) )THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
            do j=1,nj
            do i=1,ni
              tem(i,j,1)=tem(i,j,2)
              tem(i,j,nk+1)=tem(i,j,nk)
            enddo
            enddo
          ENDIF
          IF( (iturb.ge.1.and.bcturbu.eq.3).or.(dns.eq.1.and.bc_wind.eq.2).or.(ipbl.eq.1) )THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
            do j=1,nj
            do i=1,ni
              tem(i,j,1)=-2.0*va(i,j,1)*rdz*0.5*(mf(i,j-1,1)+mf(i,j,1))
              tem(i,j,nk+1)=2.0*va(i,j,nk)*rdz*0.5*(mf(i,j-1,nk+1)+mf(i,j,nk+1))
            enddo
            enddo
          ENDIF
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            xvort(i,j,k) = 0.5*(tem(i,j,k)+tem(i,j,k+1))
          enddo
          enddo
          enddo
        endif


        !---
        ! y-vort:
        tem=0.0
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=2,nk
          do j=1,nj
          do i=1,ni+1
            tem(i,j,k) = (ua(i,j,k)-ua(i,j,k-1))*rdz*0.5*(mf(i-1,j,k)+mf(i,j,k))   &
                        -(wa(i,j,k)-wa(i-1,j,k))*rdx*uf(i)
          enddo
          enddo
          enddo
          IF( (iturb.ge.1.and.bcturbu.le.2).or.(dns.eq.1.and.bc_wind.eq.1) )THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
            do j=1,nj
            do i=1,ni+1
              tem(i,j,1)=tem(i,j,2)
              tem(i,j,nk+1)=tem(i,j,nk)
            enddo
            enddo
          ENDIF
          IF( (iturb.ge.1.and.bcturbu.eq.3).or.(dns.eq.1.and.bc_wind.eq.2).or.(ipbl.eq.1) )THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
            do j=1,nj
            do i=1,ni+1
              tem(i,j,1)=2.0*ua(i,j,1)*rdz*0.5*(mf(i-1,j,1)+mf(i,j,1))
              tem(i,j,nk+1)=-2.0*ua(i,j,nk)*rdz*0.5*(mf(i-1,j,nk+1)+mf(i,j,nk+1))
            enddo
            enddo
          ENDIF
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            yvort(i,j,k) = 0.25*(tem(i,j,k)+tem(i+1,j,k)+tem(i,j,k+1)+tem(i+1,j,k+1))
          enddo
          enddo
          enddo


        !---
        ! z-vort:
        tem=0.0
        if(axisymm.eq.0)then
          ! Cartesian grid:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
            do j=1,nj+1
            do i=1,ni+1
              tem(i,j,k) = (va(i,j,k)-va(i-1,j,k))*rdx*uf(i)   &
                          -(ua(i,j,k)-ua(i,j-1,k))*rdy*vf(j)
            enddo
            enddo
            do j=1,nj
            do i=1,ni
              zvort(i,j,k) = 0.25*(tem(i,j,k)+tem(i+1,j,k)+tem(i,j+1,k)+tem(i+1,j+1,k))
            enddo
            enddo
          enddo
        else
          ! Axisymmetric grid:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
            do j=1,nj
            tem(1,j,k) = 0.0
            do i=2,ni+1
              tem(i,j,k) = (va(i,j,k)*xh(i)-va(i-1,j,k)*xh(i-1))*rdx*uf(i)/xf(i)
            enddo
            enddo
            do j=1,nj
            do i=1,ni
              zvort(i,j,k) = 0.5*(tem(i,j,k)+tem(i+1,j,k))
            enddo
            enddo
          enddo
        endif

      return
      end subroutine calcvort


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine calccpch(zf,th0,qv0,cpc,cph,tha,qa)
      implicit none

      include 'input.incl'
      include 'constants.incl'

      real, intent(in),    dimension(ib:ie,jb:je,kb:ke+1) :: zf
      real, intent(in),    dimension(ib:ie,jb:je,kb:ke) :: th0,qv0
      real, intent(inout), dimension(ib:ie,jb:je) :: cpc,cph
      real, intent(in),    dimension(ib:ie,jb:je,kb:ke) :: tha
      real, intent(in),    dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: qa

      integer :: i,j,k,n
      real :: ql
      real, dimension(nk) :: bb

      ! defines top of cold pool / location to stop calculation of C
      real, parameter :: bcrit = 0.0

!$omp parallel do default(shared)  &
!$omp private(i,j,k,n,ql,bb)
    DO j=1,nj
    DO i=1,ni
      cpc(i,j) = 0.0
      cph(i,j) = 0.0
    ! only calculate cpc/cph if surface theta-pert is at least -1 K
    IF( tha(i,j,1).le.-1.0 )THEN
      bb = 0.0
      if(imoist.eq.1)then
      do k=1,nk
        ql = 0.0
        do n=nql1,nql2
          ql=ql+qa(i,j,k,n)
        enddo
        if(iice.eq.1)then
          do n=nqs1,nqs2
            ql=ql+qa(i,j,k,n)
          enddo
        endif
        bb(k) = g*( tha(i,j,k)/th0(i,j,k)      &
                   + repsm1*(qa(i,j,k,nqv)-qv0(i,j,k)) - ql )
      enddo
      endif
      k = 1
      do while( bb(k).lt.bcrit .and. k.lt.nk )
        if( cpc(i,j).lt.0.0 ) cpc(i,j) = 0.0
        cpc(i,j) = cpc(i,j) - 2.0*bb(k)*(zf(i,j,k+1)-zf(i,j,k))
        k = k + 1
      enddo
      if( cpc(i,j).gt.0.0 )then
        cpc(i,j) = sqrt(cpc(i,j))
        cph(i,j) = zf(i,j,k-1) + (zf(i,j,k)-zf(i,j,k-1))*(bcrit-bb(k-1))   &
                                                        /(bb(k)-bb(k-1))
        ! account for terrain:
        cph(i,j) = cph(i,j) - zf(i,j,1)
      endif
    ENDIF
    ENDDO
    ENDDO

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine calccref(cref,dbz)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(inout), dimension(ib:ie,jb:je) :: cref
      real, intent(in),    dimension(ib:ie,jb:je,kb:ke) :: dbz

      integer :: i,j,k

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do j=1,nj
      do i=1,ni
        cref(i,j)=0.0
        do k=1,nk
          cref(i,j)=max(cref(i,j),dbz(i,j,k))
        enddo
      enddo
      enddo


      if(timestats.ge.1) time_write=time_write+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine calcthe(zh,pi0,th0,the,rh,prs,ppi,tha,qa)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, dimension(ib:ie,jb:je,kb:ke) :: zh,pi0,th0
      real, dimension(ib:ie,jb:je,kb:ke) :: the,rh,prs,ppi,tha
      real, dimension(ib:ie,jb:je,kb:ke,numq) :: qa

      integer i,j,k,n
      real tx,cpm
      real rslf
      real, parameter :: l0 = 2.555e6

! Reference:  Bryan, 2008, MWR, p. 5239

!$omp parallel do default(shared)  &
!$omp private(i,j,k,n,tx,cpm)
      do j=1,nj
      do k=1,nk
      do i=1,ni
        if(zh(i,j,k).le.10000.)then
          tx=(th0(i,j,k)+tha(i,j,k))*(pi0(i,j,k)+ppi(i,j,k))
          cpm=cp
          the(i,j,k)=tx                                              &
            *((p00*(1.0+qa(i,j,k,nqv)*reps)/prs(i,j,k))**(rd/cpm))   &
            *(rh(i,j,k)**(-qa(i,j,k,nqv)*rv/cpm))                    &
            *exp(l0*qa(i,j,k,nqv)/(cpm*tx))
        else
          the(i,j,k)=the(i,j,k-1)
        endif
      enddo
      enddo
      enddo

      if(timestats.ge.1) time_stat=time_stat+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine cloud(nstat,rstat,zh,qci)
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
#ifdef MPI
      include 'mpif.h'
#endif
 
      integer nstat
      real, dimension(stat_out) :: rstat
      real, dimension(ib:ie,jb:je,kb:ke) :: zh
      real, dimension(ib:ie,jb:je,kb:ke) :: qci

      integer i,j,k
      real qcbot(nk),qctop(nk),bot,top,var

!$omp parallel do default(shared)  &
!$omp private(k)
      do k=1,nk
        qcbot(k)=maxz
        qctop(k)=0.0
      enddo

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
        do j=1,nj
        do i=1,ni
          if(qci(i,j,k).ge.clwsat)then
            qctop(k)=max(qctop(k),zh(i,j,k))
            qcbot(k)=min(qcbot(k),zh(i,j,k))
          endif
        enddo
        enddo
      enddo

      top=0.0
      do k=1,nk
        top=max(top,qctop(k))
      enddo

      bot=maxz
      do k=1,nk
        bot=min(bot,qcbot(k))
      enddo

#ifdef MPI
      call MPI_REDUCE(bot,var,1,MPI_REAL,MPI_MIN,0,MPI_COMM_WORLD,ierr)
      bot=var
      call MPI_REDUCE(top,var,1,MPI_REAL,MPI_MAX,0,MPI_COMM_WORLD,ierr)
      top=var
      if(myid.eq.0)then
#endif

      if(bot.eq.maxz) bot=0.0

      write(6,100) 'QCTOP ',top,1,1,1,   &
                   'QCBOT ',bot,1,1,1
100   format(2x,a6,':',1x,f13.6,i5,i5,i5,   &
             4x,a6,':',1x,f13.6,i5,i5,i5)
 
      nstat = nstat + 1
      rstat(nstat) = top
      nstat = nstat + 1
      rstat(nstat) = bot

#ifdef MPI
      endif
#endif

      if(timestats.ge.1) time_stat=time_stat+mytime()
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 
      subroutine vertvort(nstat,rstat,xh,xf,uf,vf,zh,ua,va)
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
#ifdef MPI
      include 'mpif.h'
#endif

      integer nstat
      real, dimension(stat_out) :: rstat
      real, dimension(ib:ie) :: xh
      real, dimension(ib:ie+1) :: xf,uf
      real, dimension(jb:je+1) :: vf
      real, dimension(ib:ie,jb:je,kb:ke) :: zh
      real, dimension(ib:ie+1,jb:je,kb:ke) :: ua
      real, dimension(ib:ie,jb:je+1,kb:ke) :: va

      integer i,j,k,n,n1km,n2km,n3km,n4km,n5km
      real vort,vmax,var
      character*6 text

!-----
!  note:  does not account for terrain

      n1km=0
      n2km=0
      n3km=0
      n4km=0
      n5km=0

      do k=nk,1,-1
        if(zh(1,1,k).ge.1000.0) n1km=k
        if(zh(1,1,k).ge.2000.0) n2km=k
        if(zh(1,1,k).ge.3000.0) n3km=k
        if(zh(1,1,k).ge.4000.0) n4km=k
        if(zh(1,1,k).ge.5000.0) n5km=k
      enddo

      do n=1,6
        if(n.eq.1)then
          k=1
          text='VORSFC'
        elseif(n.eq.2)then
          k=n1km
          text='VOR1KM'
        elseif(n.eq.3)then
          k=n2km
          text='VOR2KM'
        elseif(n.eq.4)then
          k=n3km
          text='VOR3KM'
        elseif(n.eq.5)then
          k=n4km
          text='VOR4KM'
        elseif(n.eq.6)then
          k=n5km
          text='VOR5KM'
        endif
        vmax=-9999999.
      IF( axisymm.ne.1 )THEN
        do j=1+ibs,nj+1-ibn
        do i=1+ibw,ni+1-ibe
          vort=(va(i,j,k)-va(i-1,j,k))*rdx*uf(i)   &
              -(ua(i,j,k)-ua(i,j-1,k))*rdy*vf(j)
          vmax=max(vmax,vort)
        enddo
        enddo
      ELSE
        do j=1,nj+1
        do i=2,ni+1
          vort=(xh(i)*va(i,j,k)-xh(i-1)*va(i-1,j,k))*rdx*uf(i)/xf(i)
          vmax=max(vmax,vort)
        enddo
        enddo
      ENDIF
#ifdef MPI
        call MPI_REDUCE(vmax,var,1,MPI_REAL,MPI_MAX,0,   &
                        MPI_COMM_WORLD,ierr)
        vmax=var
        if(myid.eq.0)then
#endif
        write(6,100) text,vmax
        nstat = nstat + 1
        rstat(nstat) = vmax
#ifdef MPI
        endif
#endif
      ENDDO

100   format(2x,a6,':',1x,e13.6)

      if(timestats.ge.1) time_stat=time_stat+mytime()
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

 
      subroutine calccfl(nstat,rstat,dt,acfl,uf,vf,mf,ua,va,wa,writeit)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
#ifdef MPI
      include 'mpif.h'
#endif
 
      integer nstat
      real, dimension(stat_out) :: rstat
      real :: dt
      real*8 :: acfl
      real, dimension(ib:ie+1) :: uf
      real, dimension(jb:je+1) :: vf
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, dimension(ib:ie+1,jb:je,kb:ke) :: ua
      real, dimension(ib:ie,jb:je+1,kb:ke) :: va
      real, dimension(ib:ie,jb:je,kb:ke+1) :: wa
      integer :: writeit
 
      integer i,j,k
      integer imax,jmax,kmax
      integer imaxt(nk),jmaxt(nk),kmaxt(nk)
      real dtdx,dtdy,dtdz,cfl(nk),fmax
      integer :: loc
      real, dimension(2) :: mmax,nmax
 
      dtdx=dt*rdx
      dtdy=dt*rdy
      dtdz=dt*rdz

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
        cfl(k)=-99999.0
        do j=1,nj
        do i=1,ni+1
          if( abs(ua(i,j,k)*dtdx*uf(i)).gt.cfl(k) )then
            cfl(k)=abs(ua(i,j,k)*dtdx*uf(i))
            imaxt(k)=i
            jmaxt(k)=j
            kmaxt(k)=k
          endif
        enddo
        enddo
      if(axisymm.eq.0)then
        do j=1,nj+1
        do i=1,ni
          if( abs(va(i,j,k)*dtdy*vf(j)).gt.cfl(k) )then
            cfl(k)=abs(va(i,j,k)*dtdy*vf(j))
            imaxt(k)=i
            jmaxt(k)=j
            kmaxt(k)=k
          endif
        enddo
        enddo
      endif
        do j=1,nj
        do i=1,ni
          if( abs(wa(i,j,k)*dtdz*mf(i,j,k)).gt.cfl(k) )then
            cfl(k)=abs(wa(i,j,k)*dtdz*mf(i,j,k))
            imaxt(k)=i
            jmaxt(k)=j
            kmaxt(k)=k
          endif
        enddo
        enddo
      enddo

      fmax=-99999999.
      imax=1
      jmax=1
      kmax=1
      do k=1,nk
        if(cfl(k).gt.fmax)then
          fmax=cfl(k)
          imax=imaxt(k)
          jmax=jmaxt(k)
          kmax=kmaxt(k)
        endif
      enddo

#ifdef MPI
      mmax(1)=fmax
      mmax(2)=myid
      call MPI_ALLREDUCE(mmax,nmax,1,MPI_2REAL,MPI_MAXLOC,   &
                         MPI_COMM_WORLD,ierr)
      loc=nint(nmax(2))
      imax=imax+(myi-1)*ni
      jmax=jmax+(myj-1)*nj
      call MPI_BCAST(imax,1,MPI_INTEGER,loc,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(jmax,1,MPI_INTEGER,loc,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(kmax,1,MPI_INTEGER,loc,MPI_COMM_WORLD,ierr)
      fmax=nmax(1)

      if(myid.eq.0)then
#endif

    IF(writeit.eq.1)THEN
      nstat = nstat + 1
      IF( adapt_dt.eq.1 )THEN
        write(6,100) 'CFLMAX',sngl(acfl),imax,jmax,kmax
        rstat(nstat) = sngl(acfl)
        acfl = 0.0
      ELSE
        write(6,100) 'CFLMAX',fmax,imax,jmax,kmax
        rstat(nstat) = fmax
      ENDIF
100   format(2x,a6,':',1x,f13.6,i5,i5,i5)
    ENDIF

#ifdef MPI
      endif
#endif

      cflmax = fmax

      if(fmax.ge.1.50) stopit=.true.
 
      if(timestats.ge.1) time_stat=time_stat+mytime()
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine calcksmax(nstat,rstat,dt,uh,vh,mf,kmh,kmv,khh,khv)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
#ifdef MPI
      include 'mpif.h'
#endif

      integer nstat
      real, dimension(stat_out) :: rstat
      real :: dt
      real, dimension(ib:ie) :: uh
      real, dimension(jb:je) :: vh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, dimension(ibc:iec,jbc:jec,kbc:kec) :: kmh,kmv,khh,khv

      integer i,j,k
      integer imaxh,jmaxh,kmaxh
      integer imaxv,jmaxv,kmaxv
      integer imaxth(nk),jmaxth(nk),kmaxth(nk)
      integer imaxtv(nk),jmaxtv(nk),kmaxtv(nk)
      real dtdx,dtdy,dtdz,tem,ksh(nk),ksv(nk),fhmax,fvmax
      integer :: loc
      real, dimension(2) :: mmax,nmax

    IF(iturb.ge.1)THEN

      dtdx=dt*rdx*rdx
      dtdy=dt*rdy*rdy
      dtdz=dt*rdz*rdz

!$omp parallel do default(shared)  &
!$omp private(i,j,k,tem)
      do k=2,nk
        ksh(k)=-99999.0
        ksv(k)=-99999.0
        do j=1,nj
        do i=1,ni
!!!          tem = max( abs(kmh(i,j,k))*dtdx*uh(i)*uh(i) ,   &
!!!                     abs(khh(i,j,k))*dtdx*uh(i)*uh(i) )
          tem = khh(i,j,k)*dtdx*uh(i)*uh(i)
          if( tem.gt.ksh(k) )then
            ksh(k)=tem
            imaxth(k)=i
            jmaxth(k)=j
            kmaxth(k)=k
          endif
!!!          tem = max( abs(kmh(i,j,k))*dtdy*vh(j)*vh(j) ,   &
!!!                     abs(khh(i,j,k))*dtdy*vh(j)*vh(j) )
          tem = khh(i,j,k)*dtdy*vh(j)*vh(j)
          if( tem.gt.ksh(k) )then
            ksh(k)=tem
            imaxth(k)=i
            jmaxth(k)=j
            kmaxth(k)=k
          endif
!!!          tem = max( abs(kmv(i,j,k))*dtdz*mf(i,j,k)*mf(i,j,k) ,   &
!!!                     abs(khv(i,j,k))*dtdz*mf(i,j,k)*mf(i,j,k) )
          tem = khv(i,j,k)*dtdz*mf(i,j,k)*mf(i,j,k)
          if( tem.gt.ksv(k) )then
            ksv(k)=tem
            imaxtv(k)=i
            jmaxtv(k)=j
            kmaxtv(k)=k
          endif
        enddo
        enddo
      enddo

      fhmax=-99999999.
      fvmax=-99999999.
      imaxh=1
      jmaxh=1
      kmaxh=1
      imaxv=1
      jmaxv=1
      kmaxv=1
      do k=2,nk
        if(ksh(k).gt.fhmax)then
          fhmax=ksh(k)
          imaxh=imaxth(k)
          jmaxh=jmaxth(k)
          kmaxh=kmaxth(k)
        endif
        if(ksv(k).gt.fvmax)then
          fvmax=ksv(k)
          imaxv=imaxtv(k)
          jmaxv=jmaxtv(k)
          kmaxv=kmaxtv(k)
        endif
      enddo

    ELSE

      fhmax = 0.0
      fvmax = 0.0
      imaxh = 0
      jmaxh = 0
      kmaxh = 0
      imaxv = 0
      jmaxv = 0
      kmaxv = 0

    ENDIF

#ifdef MPI
      mmax(1)=fhmax
      mmax(2)=myid
      call MPI_ALLREDUCE(mmax,nmax,1,MPI_2REAL,MPI_MAXLOC,   &
                         MPI_COMM_WORLD,ierr)
      loc=nint(nmax(2))
      imaxh=imaxh+(myi-1)*ni
      jmaxh=jmaxh+(myj-1)*nj
      call MPI_BCAST(imaxh,1,MPI_INTEGER,loc,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(jmaxh,1,MPI_INTEGER,loc,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(kmaxh,1,MPI_INTEGER,loc,MPI_COMM_WORLD,ierr)
      fhmax=nmax(1)

      mmax(1)=fvmax
      mmax(2)=myid
      call MPI_ALLREDUCE(mmax,nmax,1,MPI_2REAL,MPI_MAXLOC,   &
                         MPI_COMM_WORLD,ierr)
      loc=nint(nmax(2))
      imaxv=imaxv+(myi-1)*ni
      jmaxv=jmaxv+(myj-1)*nj
      call MPI_BCAST(imaxv,1,MPI_INTEGER,loc,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(jmaxv,1,MPI_INTEGER,loc,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(kmaxv,1,MPI_INTEGER,loc,MPI_COMM_WORLD,ierr)
      fvmax=nmax(1)

      if(myid.eq.0)then
#endif

      write(6,100) 'KSHMAX',fhmax,imaxh,jmaxh,kmaxh

      nstat = nstat + 1
      rstat(nstat) = fhmax

      write(6,100) 'KSVMAX',fvmax,imaxv,jmaxv,kmaxv

      nstat = nstat + 1
      rstat(nstat) = fvmax

100   format(2x,a6,':',1x,f13.6,i5,i5,i5)

#ifdef MPI
      endif
#endif

      if(timestats.ge.1) time_stat=time_stat+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine getrmw(nstat,rstat,xh,va)
      implicit none

      include 'input.incl'
      include 'timestat.incl'

      integer :: nstat
      real, dimension(stat_out) :: rstat
      real, dimension(ib:ie) :: xh
      real, dimension(ib:ie,jb:je+1,kb:ke) :: va

      integer :: i,k,imax,jmax,kmax
      real :: rmax,vmax

      integer, dimension(nk) :: imaxt,kmaxt
      real, dimension(nk) :: rmaxt,vmaxt

!$omp parallel do default(shared)  &
!$omp private(i,k)
      do k=1,nk
        vmaxt(k) = 0.0
        do i=1,ni
          IF( va(i,1,k).gt.vmaxt(k) )THEN
            vmaxt(k) = va(i,1,k)
            rmaxt(k) = xh(i)
            imaxt(k) = i
            kmaxt(k) = k
          ENDIF
        enddo
      enddo

      vmax = 0.0
      do k=1,nk
        IF( vmaxt(k).gt.vmax )THEN
          vmax = vmaxt(k)
          rmax = rmaxt(k)
          imax = imaxt(k)
          kmax = kmaxt(k)
        ENDIF
      enddo

      jmax = 1

      write(6,131) 'RMW   ',rmax,imax,jmax,kmax
131   format(2x,a6,':',1x,f13.6,i5,i5,i5)
      nstat = nstat + 1
      rstat(nstat) = rmax

      if(timestats.ge.1) time_stat=time_stat+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine calcmass(nstat,rstat,ruh,rvh,rmh,rho)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
#ifdef MPI
      include 'mpif.h'
#endif
 
      integer nstat
      real, dimension(stat_out) :: rstat
      real, dimension(ib:ie) :: ruh
      real, dimension(jb:je) :: rvh
      real, dimension(ib:ie,jb:je,kb:ke) :: rmh
      real, dimension(ib:ie,jb:je,kb:ke) :: rho
 
      integer i,j,k
      real*8 foo(nk),tmass,var
 
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
        foo(k)=0.0d0
        do j=1,nj
        do i=1,ni
          foo(k)=foo(k)+rho(i,j,k)*ruh(i)*rvh(j)*rmh(i,j,k)
        enddo
        enddo
      enddo
 
      tmass=0.0d0
      do k=1,nk
        tmass=tmass+foo(k)
      enddo

#ifdef MPI
      var=0.0d0
      call MPI_REDUCE(tmass,var,1,MPI_DOUBLE_PRECISION,MPI_SUM,0,   &
                      MPI_COMM_WORLD,ierr)
      tmass=var
      if(myid.eq.0)then
#endif

      tmass=tmass*(dx*dy*dz)
 
      write(6,100) 'TMASS ',tmass
100   format(2x,a6,':',1x,e13.6)
 
      nstat = nstat + 1
      rstat(nstat) = tmass

#ifdef MPI
      endif
#endif
 
      if(timestats.ge.1) time_stat=time_stat+mytime()
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 
      subroutine totmois(nstat,rstat,train,ruh,rvh,rmh,qv,ql,qi,rho)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
#ifdef MPI
      include 'mpif.h'
#endif

      integer nstat
      real, dimension(stat_out) :: rstat
      real*8 :: train
      real, dimension(ib:ie) :: ruh
      real, dimension(jb:je) :: rvh
      real, dimension(ib:ie,jb:je,kb:ke) :: rmh
      real, dimension(ib:ie,jb:je,kb:ke) :: qv,ql,qi,rho
 
      integer i,j,k
      real*8 foo(nk),tmass,var,totrain

!$omp parallel do default(shared)  &
!$omp private(k)
      do k=1,nk
        foo(k)=0.0d0
      enddo
 
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
        do j=1,nj
        do i=1,ni
          foo(k)=foo(k)+rho(i,j,k)*(qv(i,j,k)+ql(i,j,k)+qi(i,j,k))*ruh(i)*rvh(j)*rmh(i,j,k)
        enddo
        enddo
      enddo
 
      tmass=0.0d0
      do k=1,nk
        tmass=tmass+foo(k)
      enddo

      totrain=train
#ifdef MPI
      totrain=0.0d0
      call MPI_REDUCE(train,totrain,1,MPI_DOUBLE_PRECISION,MPI_SUM,0,   &
                      MPI_COMM_WORLD,ierr)
#endif

#ifdef MPI
      var=0.0d0
      call MPI_REDUCE(tmass,var,1,MPI_DOUBLE_PRECISION,MPI_SUM,0,   &
                      MPI_COMM_WORLD,ierr)
      tmass=var
      if(myid.eq.0)then
#endif

      tmass=tmass*(dx*dy*dz)+totrain

      write(6,100) 'TMOIS ',tmass
100   format(2x,a6,':',1x,e13.6)
 
      nstat = nstat + 1
      rstat(nstat) = tmass

#ifdef MPI
      endif
#endif
 
      if(timestats.ge.1) time_stat=time_stat+mytime()
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine totq(nstat,rstat,ruh,rvh,rmh,q,rho,aname)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
#ifdef MPI
      include 'mpif.h'
#endif

      integer nstat
      real, dimension(stat_out) :: rstat
      real, dimension(ib:ie) :: ruh
      real, dimension(jb:je) :: rvh
      real, dimension(ib:ie,jb:je,kb:ke) :: rmh
      real, dimension(ib:ie,jb:je,kb:ke) :: q,rho
      character*6 aname

      integer i,j,k
      real*8 foo(nk),tmass,var

!$omp parallel do default(shared)  &
!$omp private(k)
      do k=1,nk
        foo(k)=0.0d0
      enddo

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        foo(k)=foo(k)+rho(i,j,k)*q(i,j,k)*ruh(i)*rvh(j)*rmh(i,j,k)
      enddo
      enddo
      enddo

      tmass=0.0d0
      do k=1,nk
        tmass=tmass+foo(k)
      enddo

#ifdef MPI
      var=0.0d0
      call MPI_REDUCE(tmass,var,1,MPI_DOUBLE_PRECISION,MPI_SUM,0,   &
                      MPI_COMM_WORLD,ierr)
      tmass=var
      if(myid.eq.0)then
#endif

      tmass=tmass*(dx*dy*dz)

      write(6,100) aname,tmass
100   format(2x,a6,':',1x,e13.6)

      nstat = nstat + 1
      rstat(nstat) = tmass

#ifdef MPI
      endif
#endif

      if(timestats.ge.1) time_stat=time_stat+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 
      subroutine calcener(nstat,rstat,ruh,rvh,zh,rmh,pi0,th0,rho,ua,va,wa,ppi,tha,   &
                          qv,ql,qi,vr)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
#ifdef MPI
      include 'mpif.h'
#endif
 
      integer nstat
      real, dimension(stat_out) :: rstat
      real, dimension(ib:ie) :: ruh
      real, dimension(jb:je) :: rvh
      real, dimension(ib:ie,jb:je,kb:ke) :: zh,rmh,pi0,th0
      real, dimension(ib:ie,jb:je,kb:ke) :: rho
      real, dimension(ib:ie+1,jb:je,kb:ke) :: ua
      real, dimension(ib:ie,jb:je+1,kb:ke) :: va
      real, dimension(ib:ie,jb:je,kb:ke+1) :: wa
      real, dimension(ib:ie,jb:je,kb:ke) :: ppi,tha,qv,ql,qi,vr
 
      integer i,j,k
      real*8 :: u,v,w,tmp,qtot,ek,ei,ep,et,le,var,tem
      real*8, dimension(nk) :: foo1,foo2,foo3,foo4

!$omp parallel do default(shared)  &
!$omp private(i,j,k,u,v,w,tmp,qtot,tem)
      do k=1,nk
        foo1(k)=0.0d0      ! = ek
        foo2(k)=0.0d0      ! = ei
        foo3(k)=0.0d0      ! = ep
        foo4(k)=0.0d0      ! = le
        do j=1,nj
        do i=1,ni
          tem=ruh(i)*rvh(j)*rmh(i,j,k)
          u=umove+0.5*(ua(i,j,k)+ua(i+1,j,k))
          v=vmove+0.5*(va(i,j,k)+va(i,j+1,k))
          w=0.5*(wa(i,j,k)+wa(i,j,k+1))
          qtot=qv(i,j,k)+ql(i,j,k)+qi(i,j,k)
          foo1(k)=foo1(k)+rho(i,j,k)*tem*(1.0+qtot)*0.5*(u*u+v*v+w*w)   &
               +ql(i,j,k)*rho(i,j,k)*tem*0.5*(vr(i,j,k)**2-2.0*w*vr(i,j,k))
          tmp=(th0(i,j,k)+tha(i,j,k))*(pi0(i,j,k)+ppi(i,j,k))
          foo2(k)=foo2(k)+rho(i,j,k)*tem*(cv+cvv*qv(i,j,k))*tmp
          foo3(k)=foo3(k)+rho(i,j,k)*tem*(1.0+qtot)*g*zh(i,j,k)
          foo4(k)=foo4(k)+rho(i,j,k)*tem*ql(i,j,k)*(cpl*tmp-lv1)   &
                         +rho(i,j,k)*tem*qi(i,j,k)*(cpi*tmp-ls1)
        enddo
        enddo
      enddo

      ek=0.0d0
      ei=0.0d0
      ep=0.0d0
      le=0.0d0
 
      do k=1,nk
        ek=ek+foo1(k)
        ei=ei+foo2(k)
        ep=ep+foo3(k)
        le=le+foo4(k)
      enddo

      ek=ek*(dx*dy*dz)
      ei=ei*(dx*dy*dz)
      ep=ep*(dx*dy*dz)
      le=le*(dx*dy*dz)

#ifdef MPI
      var=0.0d0
      call MPI_REDUCE(ek,var,1,MPI_DOUBLE_PRECISION,MPI_SUM,0,   &
                      MPI_COMM_WORLD,ierr)
      ek=var
      var=0.0d0
      call MPI_REDUCE(ei,var,1,MPI_DOUBLE_PRECISION,MPI_SUM,0,   &
                      MPI_COMM_WORLD,ierr)
      ei=var
      var=0.0d0
      call MPI_REDUCE(ep,var,1,MPI_DOUBLE_PRECISION,MPI_SUM,0,   &
                      MPI_COMM_WORLD,ierr)
      ep=var
      var=0.0d0
      call MPI_REDUCE(le,var,1,MPI_DOUBLE_PRECISION,MPI_SUM,0,   &
                      MPI_COMM_WORLD,ierr)
      le=var
      if(myid.eq.0)then
#endif

      et=ek+ei+ep+le
 
      write(6,100) 'TENERG',et
100   format(2x,a6,':',1x,e13.6)

      nstat = nstat + 1
      rstat(nstat) = ek
      nstat = nstat + 1
      rstat(nstat) = ei
      nstat = nstat + 1
      rstat(nstat) = ep
      nstat = nstat + 1
      rstat(nstat) = le
      nstat = nstat + 1
      rstat(nstat) = et

#ifdef MPI
      endif
#endif
 
      if(timestats.ge.1) time_stat=time_stat+mytime()
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 
      subroutine calcmoe(nstat,rstat,ruh,rvh,rmh,rho,ua,va,wa,qv,ql,qi,vr)
      implicit none
 
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
#ifdef MPI
      include 'mpif.h'
#endif
 
      integer nstat
      real, dimension(stat_out) :: rstat
      real, dimension(ib:ie) :: ruh
      real, dimension(jb:je) :: rvh
      real, dimension(ib:ie,jb:je,kb:ke) :: rmh
      real, dimension(ib:ie,jb:je,kb:ke) :: rho
      real, dimension(ib:ie+1,jb:je,kb:ke) :: ua
      real, dimension(ib:ie,jb:je+1,kb:ke) :: va
      real, dimension(ib:ie,jb:je,kb:ke+1) :: wa
      real, dimension(ib:ie,jb:je,kb:ke) :: qv,ql,qi,vr
 
      integer i,j,k
      real*8 :: tmu,tmv,tmw,qtot,var,tem
      real*8, dimension(nk) :: foo1,foo2,foo3

!$omp parallel do default(shared)  &
!$omp private(k)
      do k=1,nk
        foo1(k)=0.0d0
        foo2(k)=0.0d0
        foo3(k)=0.0d0
      enddo
 
!$omp parallel do default(shared)  &
!$omp private(i,j,k,qtot,tem)
      do k=1,nk
        do j=1,nj
        do i=1,ni
          qtot=qv(i,j,k)+ql(i,j,k)+qi(i,j,k)
          tem=ruh(i)*rvh(j)*rmh(i,j,k)
          foo1(k)=foo1(k)   &
                +rho(i,j,k)*tem*(1.0+qtot)*( umove+0.5*(ua(i,j,k)+ua(i+1,j,k)) )
          foo2(k)=foo2(k)   &
                +rho(i,j,k)*tem*(1.0+qtot)*( vmove+0.5*(va(i,j,k)+va(i,j+1,k)) )
          foo3(k)=foo3(k)                                                &
                +rho(i,j,k)*tem*(1.0+qtot)*( 0.5*(wa(i,j,k)+wa(i,j,k+1)) )   &
                -rho(i,j,k)*tem*ql(i,j,k)*vr(i,j,k)
        enddo
        enddo
      enddo

      tmu=0.0d0
      tmv=0.0d0
      tmw=0.0d0
      do k=1,nk
        tmu=tmu+foo1(k)
        tmv=tmv+foo2(k)
        tmw=tmw+foo3(k)
      enddo

#ifdef MPI
      var=0.0d0
      call MPI_REDUCE(tmu,var,1,MPI_DOUBLE_PRECISION,MPI_SUM,0,  &
                      MPI_COMM_WORLD,ierr)
      tmu=var
      var=0.0d0
      call MPI_REDUCE(tmv,var,1,MPI_DOUBLE_PRECISION,MPI_SUM,0,  &
                      MPI_COMM_WORLD,ierr)
      tmv=var
      var=0.0d0
      call MPI_REDUCE(tmw,var,1,MPI_DOUBLE_PRECISION,MPI_SUM,0,  &
                      MPI_COMM_WORLD,ierr)
      tmw=var
      if(myid.eq.0)then
#endif

      tmu=tmu*(dx*dy*dz)
      tmv=tmv*(dx*dy*dz)
      tmw=tmw*(dx*dy*dz)
 
      write(6,100) 'TMU   ',tmu
      write(6,100) 'TMV   ',tmv
      write(6,100) 'TMW   ',tmw
100   format(2x,a6,':',1x,e13.6)
 
      nstat = nstat + 1
      rstat(nstat) = tmu
      nstat = nstat + 1
      rstat(nstat) = tmv
      nstat = nstat + 1
      rstat(nstat) = tmw

#ifdef MPI
      endif
#endif
 
      if(timestats.ge.1) time_stat=time_stat+mytime()
 
      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine tmf(nstat,rstat,ruh,rvh,rho,wa)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
#ifdef MPI
      include 'mpif.h'
#endif

      integer nstat
      real, dimension(stat_out) :: rstat
      real, dimension(ib:ie) :: ruh
      real, dimension(jb:je) :: rvh
      real, dimension(ib:ie,jb:je,kb:ke) :: rho
      real, dimension(ib:ie,jb:je,kb:ke+1) :: wa

      integer i,j,k
      real*8 :: tmfu,tmfd,mf,var
      real*8, dimension(nk) :: foo1,foo2

!$omp parallel do default(shared)  &
!$omp private(i,j,k,mf)
      do k=1,nk
        foo1(k)=0.0d0
        foo2(k)=0.0d0
        do j=1,nj
        do i=1,ni
          mf=rho(i,j,k)*0.5*(wa(i,j,k)+wa(i,j,k+1))*ruh(i)*rvh(j)
          foo1(k)=foo1(k)+max(mf,0.0d0)
          foo2(k)=foo2(k)+min(mf,0.0d0)
        enddo
        enddo
      enddo

      tmfu=0.0d0
      tmfd=0.0d0
      do k=1,nk
        tmfu=tmfu+foo1(k)
        tmfd=tmfd+foo2(k)
      enddo

#ifdef MPI
      var=0.0d0
      call MPI_REDUCE(tmfu,var,1,MPI_DOUBLE_PRECISION,MPI_SUM,0,  &
                      MPI_COMM_WORLD,ierr)
      tmfu=var
      var=0.0d0
      call MPI_REDUCE(tmfd,var,1,MPI_DOUBLE_PRECISION,MPI_SUM,0,  &
                      MPI_COMM_WORLD,ierr)
      tmfd=var
      if(myid.eq.0)then
#endif

      tmfu=tmfu*dx*dy
      tmfd=tmfd*dx*dy

      write(6,100) 'TMFU  ',tmfu
      write(6,100) 'TMFD  ',tmfd
100   format(2x,a6,':',1x,e13.6)

      nstat = nstat + 1
      rstat(nstat) = tmfu
      nstat = nstat + 1
      rstat(nstat) = tmfd

#ifdef MPI
      endif
#endif

      if(timestats.ge.1) time_stat=time_stat+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine zinterp(sigma,zs,zh,dum1,dum2)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, dimension(kb:ke) :: sigma
      real, dimension(ib:ie,jb:je) :: zs
      real, dimension(ib:ie,jb:je,kb:ke) :: zh,dum1,dum2

      integer i,j,k,kk,kup,kdn
      real, dimension(nk) :: zref

      do k=1,nk
!!!        zref(k)=(k*dz-0.5*dz)
        zref(k)=sigma(k)
      enddo

      do k=1,nk
      do j=1,nj
      do i=1,ni
        dum2(i,j,k)=dum1(i,j,k)
      enddo
      enddo
      enddo

      do k=1,nk
      do j=1,nj
      do i=1,ni
        if( (zref(k).lt.zh(i,j,1)).or.(zref(k).gt.zh(i,j,nk)) )then
          dum1(i,j,k)=-99999999.
        elseif(zs(i,j).lt.0.1 .or. zref(k).eq.zh(i,j,1))then
          dum1(i,j,k)=dum2(i,j,k)
        else
          kup=0
          kdn=0
          do kk=1,nk
            if(zref(k).gt.zh(i,j,kk)) kdn=kk
          enddo
          kup=kdn+1
          if(kup.le.0.or.kdn.le.0.or.kup.ge.nk+1.or.kdn.ge.nk+1)then
            print *,kdn,kup
            print *,zs(i,j),zh(i,j,kdn),zref(k),zh(i,j,kup)
            print *,i,j,k
            call stopcm1
          endif
          dum1(i,j,k)=dum2(i,j,kdn)+(dum2(i,j,kup)-dum2(i,j,kdn))   &
                                   *(  zref(k  )  -zh(i,j,kdn))     &
                                   /(  zh(i,j,kup)-zh(i,j,kdn))
        endif
      enddo
      enddo
      enddo

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

!
! ---------------------------------------------------------------------
! THIS FUNCTION CALCULATES THE LIQUID SATURATION VAPOR MIXING RATIO AS
! A FUNCTION OF TEMPERATURE AND PRESSURE
!
      FUNCTION RSLF(P,T)

      IMPLICIT NONE
      include 'input.incl'
      include 'constants.incl'
      REAL ESL,RSLF,X,T,P,C0,C1,C2,C3,C4,C5,C6,C7,C8
      PARAMETER (C0= .611583699E03)
      PARAMETER (C1= .444606896E02)
      PARAMETER (C2= .143177157E01)
      PARAMETER (C3= .264224321E-1)
      PARAMETER (C4= .299291081E-3)
      PARAMETER (C5= .203154182E-5)
      PARAMETER (C6= .702620698E-8)
      PARAMETER (C7= .379534310E-11)
      PARAMETER (C8=-.321582393E-13)

!  Note to self ... this should be changed, somehow, in the future.
!  GHB 060806

    if(ptype.eq.1.or.ptype.eq.2.or.ptype.eq.3.or.ptype.eq.5.or.ptype.eq.6)then

      ! from Bolton (1980, MWR)
      esl=611.2 * EXP( 17.67 * ( T  - 273.15 ) / ( T  - 29.65 ) )
      rslf= eps * ESL /(P-ESL)

    elseif(ptype.eq.4)then

      rslf=380.00*exp(17.2693882-4097.8531/(t-35.86))/p

!    elseif(ptype.eq.3)then
!
!      X=MAX(-80.,T-273.16)
!      ESL=C0+X*(C1+X*(C2+X*(C3+X*(C4+X*(C5+X*(C6+X*(C7+X*C8)))))))
!      RSLF=eps*ESL/(P-ESL)

    else

      esl=611.2 * EXP( 17.67 * ( T  - 273.15 ) / ( T  - 29.65 ) )
      rslf= eps * ESL /(P-ESL)

    endif

      RETURN
      END

!
! ---------------------------------------------------------------------
! THIS FUNCTION CALCULATES THE ICE SATURATION VAPOR MIXING RATIO AS A
! FUNCTION OF TEMPERATURE AND PRESSURE
!
      FUNCTION RSIF(P,T)

      IMPLICIT NONE
      include 'input.incl'
      include 'constants.incl'
      REAL ESI,RSIF,X,T,P,C0,C1,C2,C3,C4,C5,C6,C7,C8
      PARAMETER (C0= .609868993E03)
      PARAMETER (C1= .499320233E02)
      PARAMETER (C2= .184672631E01)
      PARAMETER (C3= .402737184E-1)
      PARAMETER (C4= .565392987E-3)
      PARAMETER (C5= .521693933E-5)
      PARAMETER (C6= .307839583E-7)
      PARAMETER (C7= .105785160E-9)
      PARAMETER (C8= .161444444E-12)

!  Note to self ... this should be changed, somehow, in the future.
!  GHB 060806

    if(ptype.eq.1.or.ptype.eq.2.or.ptype.eq.3.or.ptype.eq.5.or.ptype.eq.6)then

      ! from Tao et al (1989, MWR)
      esi=611.2 * EXP( 21.8745584 * ( T  - 273.15 ) / ( T  - 7.66 ) )
      rsif= eps * ESI /(P-ESI)

    elseif(ptype.eq.4)then

      rsif=380.00*exp(21.87455-5807.4743/(t-7.66))/p

!    elseif(ptype.eq.3)then
!
!      X=MAX(-80.,T-273.16)
!      ESI=C0+X*(C1+X*(C2+X*(C3+X*(C4+X*(C5+X*(C6+X*(C7+X*C8)))))))
!      RSIF=eps*ESI/(P-ESI)

    else

      esi=611.2 * EXP( 21.8745584 * ( T  - 273.15 ) / ( T  - 7.66 ) )
      rsif= eps * ESI /(P-ESI)

    endif

      RETURN
      END


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


! REV PROCESSED 213 LINES OF CODE. PROGRAM DONE.
      REAL FUNCTION GAMMA(X)
      implicit none
!D    DOUBLE PRECISION FUNCTION DGAMMA(X)
!----------------------------------------------------------------------
!
! THIS ROUTINE CALCULATES THE GAMMA FUNCTION FOR A REAL ARGUMENT X.
!   COMPUTATION IS BASED ON AN ALGORITHM OUTLINED IN REFERENCE 1.
!   THE PROGRAM USES RATIONAL FUNCTIONS THAT APPROXIMATE THE GAMMA
!   FUNCTION TO AT LEAST 20 SIGNIFICANT DECIMAL DIGITS.  COEFFICIENTS
!   FOR THE APPROXIMATION OVER THE INTERVAL (1,2) ARE UNPUBLISHED.
!   THOSE FOR THE APPROXIMATION FOR X .GE. 12 ARE FROM REFERENCE 2.
!   THE ACCURACY ACHIEVED DEPENDS ON THE ARITHMETIC SYSTEM, THE
!   COMPILER, THE INTRINSIC FUNCTIONS, AND PROPER SELECTION OF THE
!   MACHINE-DEPENDENT CONSTANTS.
!
!
!*******************************************************************
!*******************************************************************
!
! EXPLANATION OF MACHINE-DEPENDENT CONSTANTS
!
! BETA   - RADIX FOR THE FLOATING-POINT REPRESENTATION
! MAXEXP - THE SMALLEST POSITIVE POWER OF BETA THAT OVERFLOWS
! XBIG   - THE LARGEST ARGUMENT FOR WHICH GAMMA(X) IS REPRESENTABLE
!          IN THE MACHINE, I.E., THE SOLUTION TO THE EQUATION
!                  GAMMA(XBIG) = BETA**MAXEXP
! XINF   - THE LARGEST MACHINE REPRESENTABLE FLOATING-POINT NUMBER;
!          APPROXIMATELY BETA**MAXEXP
! EPS    - THE SMALLEST POSITIVE FLOATING-POINT NUMBER SUCH THAT
!          1.0+EPS .GT. 1.0
! XMININ - THE SMALLEST POSITIVE FLOATING-POINT NUMBER SUCH THAT
!          1/XMININ IS MACHINE REPRESENTABLE
!
!     APPROXIMATE VALUES FOR SOME IMPORTANT MACHINES ARE:
!
!                            BETA       MAXEXP        XBIG
!
! CRAY-1         (S.P.)        2         8191        966.961
! CYBER 180/855
!   UNDER NOS    (S.P.)        2         1070        177.803
! IEEE (IBM/XT,
!   SUN, ETC.)   (S.P.)        2          128        35.040
! IEEE (IBM/XT,
!   SUN, ETC.)   (D.P.)        2         1024        171.624
! IBM 3033       (D.P.)       16           63        57.574
! VAX D-FORMAT   (D.P.)        2          127        34.844
! VAX G-FORMAT   (D.P.)        2         1023        171.489
!
!                            XINF         EPS        XMININ
!
! CRAY-1         (S.P.)   5.45E+2465   7.11E-15    1.84E-2466
! CYBER 180/855
!   UNDER NOS    (S.P.)   1.26E+322    3.55E-15    3.14E-294
! IEEE (IBM/XT,
!   SUN, ETC.)   (S.P.)   3.40E+38     1.19E-7     1.18E-38
! IEEE (IBM/XT,
!   SUN, ETC.)   (D.P.)   1.79D+308    2.22D-16    2.23D-308
! IBM 3033       (D.P.)   7.23D+75     2.22D-16    1.39D-76
! VAX D-FORMAT   (D.P.)   1.70D+38     1.39D-17    5.88D-39
! VAX G-FORMAT   (D.P.)   8.98D+307    1.11D-16    1.12D-308
!
!*******************************************************************
!*******************************************************************
!
! ERROR RETURNS
!
!  THE PROGRAM RETURNS THE VALUE XINF FOR SINGULARITIES OR
!     WHEN OVERFLOW WOULD OCCUR.  THE COMPUTATION IS BELIEVED
!     TO BE FREE OF UNDERFLOW AND OVERFLOW.
!
!
!  INTRINSIC FUNCTIONS REQUIRED ARE:
!
!     INT, DBLE, EXP, LOG, REAL, SIN
!
!
! REFERENCES:  AN OVERVIEW OF SOFTWARE DEVELOPMENT FOR SPECIAL
!              FUNCTIONS   W. J. CODY, LECTURE NOTES IN MATHEMATICS,
!              506, NUMERICAL ANALYSIS DUNDEE, 1975, G. A. WATSON
!              (ED.), SPRINGER VERLAG, BERLIN, 1976.
!
!              COMPUTER APPROXIMATIONS, HART, ET. AL., WILEY AND
!              SONS, NEW YORK, 1968.
!
!  LATEST MODIFICATION: OCTOBER 12, 1989
!
!  AUTHORS: W. J. CODY AND L. STOLTZ
!           APPLIED MATHEMATICS DIVISION
!           ARGONNE NATIONAL LABORATORY
!           ARGONNE, IL 60439
!
!----------------------------------------------------------------------
      INTEGER I,N
      LOGICAL PARITY
      REAL               &
!D    DOUBLE PRECISION   &
          C,CONV,EPS,FACT,HALF,ONE,P,PI,Q,RES,SQRTPI,SUM,TWELVE,   &
          TWO,X,XBIG,XDEN,XINF,XMININ,XNUM,Y,Y1,YSQ,Z,ZERO
      DIMENSION C(7),P(8),Q(8)
!----------------------------------------------------------------------
!  MATHEMATICAL CONSTANTS
!----------------------------------------------------------------------
      DATA ONE,HALF,TWELVE,TWO,ZERO/1.0E0,0.5E0,12.0E0,2.0E0,0.0E0/,   &
           SQRTPI/0.9189385332046727417803297E0/,                      &
           PI/3.1415926535897932384626434E0/
!D    DATA ONE,HALF,TWELVE,TWO,ZERO/1.0D0,0.5D0,12.0D0,2.0D0,0.0D0/,
!D   1     SQRTPI/0.9189385332046727417803297D0/,
!D   2     PI/3.1415926535897932384626434D0/
!----------------------------------------------------------------------
!  MACHINE DEPENDENT PARAMETERS
!----------------------------------------------------------------------
      DATA XBIG,XMININ,EPS/35.040E0,1.18E-38,1.19E-7/,   &
           XINF/3.4E38/
!D    DATA XBIG,XMININ,EPS/171.624D0,2.23D-308,2.22D-16/,
!D   1     XINF/1.79D308/
!----------------------------------------------------------------------
!  NUMERATOR AND DENOMINATOR COEFFICIENTS FOR RATIONAL MINIMAX
!     APPROXIMATION OVER (1,2).
!----------------------------------------------------------------------
      DATA P/-1.71618513886549492533811E+0,2.47656508055759199108314E+1,   &
             -3.79804256470945635097577E+2,6.29331155312818442661052E+2,   &
             8.66966202790413211295064E+2,-3.14512729688483675254357E+4,   &
             -3.61444134186911729807069E+4,6.64561438202405440627855E+4/
      DATA Q/-3.08402300119738975254353E+1,3.15350626979604161529144E+2,   &
            -1.01515636749021914166146E+3,-3.10777167157231109440444E+3,   &
              2.25381184209801510330112E+4,4.75584627752788110767815E+3,   &
            -1.34659959864969306392456E+5,-1.15132259675553483497211E+5/
!D    DATA P/-1.71618513886549492533811D+0,2.47656508055759199108314D+1,
!D   1       -3.79804256470945635097577D+2,6.29331155312818442661052D+2,
!D   2       8.66966202790413211295064D+2,-3.14512729688483675254357D+4,
!D   3       -3.61444134186911729807069D+4,6.64561438202405440627855D+4/
!D    DATA Q/-3.08402300119738975254353D+1,3.15350626979604161529144D+2,
!D   1      -1.01515636749021914166146D+3,-3.10777167157231109440444D+3,
!D   2        2.25381184209801510330112D+4,4.75584627752788110767815D+3,
!D   3      -1.34659959864969306392456D+5,-1.15132259675553483497211D+5/
!----------------------------------------------------------------------
!  COEFFICIENTS FOR MINIMAX APPROXIMATION OVER (12, INF).
!----------------------------------------------------------------------
      DATA C/-1.910444077728E-03,8.4171387781295E-04,                     &
           -5.952379913043012E-04,7.93650793500350248E-04,                &
           -2.777777777777681622553E-03,8.333333333333333331554247E-02,   &
            5.7083835261E-03/
!D    DATA C/-1.910444077728D-03,8.4171387781295D-04,
!D   1     -5.952379913043012D-04,7.93650793500350248D-04,
!D   2     -2.777777777777681622553D-03,8.333333333333333331554247D-02,
!D   3      5.7083835261D-03/
!----------------------------------------------------------------------
!  STATEMENT FUNCTIONS FOR CONVERSION BETWEEN INTEGER AND FLOAT
!----------------------------------------------------------------------
      CONV(I) = REAL(I)
!D    CONV(I) = DBLE(I)
      PARITY=.FALSE.
      FACT=ONE
      N=0
      Y=X
      IF(Y.LE.ZERO)THEN
!----------------------------------------------------------------------
!  ARGUMENT IS NEGATIVE
!----------------------------------------------------------------------
        Y=-X
        Y1=AINT(Y)
        RES=Y-Y1
        IF(RES.NE.ZERO)THEN
          IF(Y1.NE.AINT(Y1*HALF)*TWO)PARITY=.TRUE.
          FACT=-PI/SIN(PI*RES)
          Y=Y+ONE
        ELSE
          RES=XINF
          GOTO 900
        ENDIF
      ENDIF
!----------------------------------------------------------------------
!  ARGUMENT IS POSITIVE
!----------------------------------------------------------------------
      IF(Y.LT.EPS)THEN
!----------------------------------------------------------------------
!  ARGUMENT .LT. EPS
!----------------------------------------------------------------------
        IF(Y.GE.XMININ)THEN
          RES=ONE/Y
        ELSE
          RES=XINF
          GOTO 900
        ENDIF
      ELSEIF(Y.LT.TWELVE)THEN
        Y1=Y
        IF(Y.LT.ONE)THEN
!----------------------------------------------------------------------
!  0.0 .LT. ARGUMENT .LT. 1.0
!----------------------------------------------------------------------
          Z=Y
          Y=Y+ONE
        ELSE
!----------------------------------------------------------------------
!  1.0 .LT. ARGUMENT .LT. 12.0, REDUCE ARGUMENT IF NECESSARY
!----------------------------------------------------------------------
          N=INT(Y)-1
          Y=Y-CONV(N)
          Z=Y-ONE
        ENDIF
!----------------------------------------------------------------------
!  EVALUATE APPROXIMATION FOR 1.0 .LT. ARGUMENT .LT. 2.0
!----------------------------------------------------------------------
        XNUM=ZERO
        XDEN=ONE
        DO 260 I=1,8
          XNUM=(XNUM+P(I))*Z
          XDEN=XDEN*Z+Q(I)
  260   CONTINUE
        RES=XNUM/XDEN+ONE
        IF(Y1.LT.Y)THEN
!----------------------------------------------------------------------
!  ADJUST RESULT FOR CASE  0.0 .LT. ARGUMENT .LT. 1.0
!----------------------------------------------------------------------
          RES=RES/Y1
        ELSEIF(Y1.GT.Y)THEN
!----------------------------------------------------------------------
!  ADJUST RESULT FOR CASE  2.0 .LT. ARGUMENT .LT. 12.0
!----------------------------------------------------------------------
          DO 290 I=1,N
            RES=RES*Y
            Y=Y+ONE
  290     CONTINUE
        ENDIF
      ELSE
!----------------------------------------------------------------------
!  EVALUATE FOR ARGUMENT .GE. 12.0,
!----------------------------------------------------------------------
        IF(Y.LE.XBIG)THEN
          YSQ=Y*Y
          SUM=C(7)
          DO 350 I=1,6
            SUM=SUM/YSQ+C(I)
  350     CONTINUE
          SUM=SUM/Y-Y+SQRTPI
          SUM=SUM+(Y-HALF)*LOG(Y)
          RES=EXP(SUM)
        ELSE
          RES=XINF
          GOTO 900
        ENDIF
      ENDIF
!----------------------------------------------------------------------
!  FINAL ADJUSTMENTS AND RETURN
!----------------------------------------------------------------------
      IF(PARITY)RES=-RES
      IF(FACT.NE.ONE)RES=FACT/RES
  900 GAMMA=RES
!D900 DGAMMA = RES
      RETURN
! ---------- LAST LINE OF GAMMA ----------
      END


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      function mytime()
      implicit none

      include 'timestat.incl'

      integer count,rate,max
      real time_current,rcount

!----------------------------------------------------------
!  Platform-independent timer

      call system_clock(count,rate,max)
      if( count.lt.count_last )then
        ! simple kludge ... do nothing
        ! fix some other day   (GHB, 101018)
!!!        rcount = float(count+max)
!!!        time_current=rcount*clock_rate
!!!        mytime=time_current-time_last
!!!        rcount = float(count)
!!!        time_current=rcount*clock_rate
        rcount = float(count)
        time_current=rcount*clock_rate
        mytime=0.0
      else
        rcount = float(count)
        time_current=rcount*clock_rate
        mytime=time_current-time_last
      endif
      time_last=time_current
      count_last=count

!----------------------------------------------------------

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine stopcm1()
      implicit none

#ifdef MPI
      include 'mpif.h'

      call mpi_abort( mpi_comm_world, 1 )
#endif

      stop

      return
      end


morrison.F/     1298670057  19071 8000  100644  178096    `
!WRF:MODEL_LAYER:PHYSICS
!

! THIS MODULE CONTAINS THE TWO-MOMENT MICROPHYSICS CODE DESCRIBED BY
!     MORRISON ET AL. (2009, MWR)

! CHANGES FOR V3.2, RELATIVE TO MOST RECENT (BUG-FIX) CODE FOR V3.1

! 1) ADDED ACCELERATED MELTING OF GRAUPEL/SNOW DUE TO COLLISION WITH RAIN, FOLLOWING LIN ET AL. (1983)
! 2) INCREASED MINIMUM LAMBDA FOR RAIN, AND ADDED RAIN DROP BREAKUP FOLLOWING MODIFIED VERSION
!     OF VERLINDE AND COTTON (1993)
! 3) CHANGE MINIMUM ALLOWED MIXING RATIOS IN DRY CONDITIONS (RH < 90%), THIS IMPROVES RADAR REFLECTIIVITY
!     IN LOW REFLECTIVITY REGIONS
! 4) BUG FIX TO MAXIMUM ALLOWED PARTICLE FALLSPEEDS AS A FUNCTION OF AIR DENSITY
! 5) BUG FIX TO CALCULATION OF LIQUID WATER SATURATION VAPOR PRESSURE (CHANGE IS VERY MINOR)
! 6) INCLUDE WRF CONSTANTS PER SUGGESTION OF JIMY

! bug fix, 5/12/10
! 7) bug fix for saturation vapor pressure in low pressure, to avoid division by zero
! 8) include 'EP2' WRF constant for saturation mixing ratio calculation, instead of hardwire constant

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! THIS SCHEME IS A BULK DOUBLE-MOMENT SCHEME THAT PREDICTS MIXING
! RATIOS AND NUMBER CONCENTRATIONS OF FIVE HYDROMETEOR SPECIES:
! CLOUD DROPLETS, CLOUD (SMALL) ICE, RAIN, SNOW, AND GRAUPEL.

MODULE MODULE_MP_MORR_TWO_MOMENT
!!!   USE     module_wrf_error
!      USE module_utility, ONLY: WRFU_Clock, WRFU_Alarm  ! GT
!      USE module_domain, ONLY : HISTORY_ALARM, Is_alarm_tstep  ! GT

! USE WRF PHYSICS CONSTANTS
!!!  use module_model_constants, ONLY: CP, G, R => r_d, RV => r_v, EP_2

!  USE module_state_description

   IMPLICIT NONE

   REAL, PARAMETER :: PI = 3.1415926535897932384626434
   REAL, PARAMETER :: SQRTPI = 0.9189385332046727417803297

   PUBLIC  ::  MP_MORR_TWO_MOMENT
   PUBLIC  ::  POLYSVP

   PRIVATE :: GAMMA, DERF1
   PRIVATE :: PI, SQRTPI
   PRIVATE :: MORR_TWO_MOMENT_MICRO

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! SWITCHES FOR MICROPHYSICS SCHEME
! IACT = 1, USE POWER-LAW CCN SPECTRA, NCCN = CS^K
! IACT = 2, USE LOGNORMAL AEROSOL SIZE DIST TO DERIVE CCN SPECTRA

     INTEGER, PRIVATE ::  IACT

! INUM = 0, PREDICT DROPLET CONCENTRATION
! INUM = 1, ASSUME CONSTANT DROPLET CONCENTRATION   
! !!!NOTE: PREDICTED DROPLET CONCENTRATION NOT AVAILABLE IN THIS VERSION
! CONTACT HUGH MORRISON (morrison@ucar.edu) FOR FURTHER INFORMATION

     INTEGER, PRIVATE ::  INUM

! FOR INUM = 1, SET CONSTANT DROPLET CONCENTRATION (CM-3)
     REAL, PRIVATE ::      NDCNST

! SWITCH FOR LIQUID-ONLY RUN
! ILIQ = 0, INCLUDE ICE
! ILIQ = 1, LIQUID ONLY, NO ICE

     INTEGER, PRIVATE ::  ILIQ

! SWITCH FOR ICE NUCLEATION
! INUC = 0, USE FORMULA FROM RASMUSSEN ET AL. 2002 (MID-LATITUDE)
!      = 1, USE MPACE OBSERVATIONS

     INTEGER, PRIVATE ::  INUC

! IBASE = 1, NEGLECT DROPLET ACTIVATION AT LATERAL CLOUD EDGES DUE TO 
!             UNRESOLVED ENTRAINMENT AND MIXING, ACTIVATE
!             AT CLOUD BASE OR IN REGION WITH LITTLE CLOUD WATER USING 
!             NON-EQULIBRIUM SUPERSATURATION, 
!             IN CLOUD INTERIOR ACTIVATE USING EQUILIBRIUM SUPERSATURATION
! IBASE = 2, ASSUME DROPLET ACTIVATION AT LATERAL CLOUD EDGES DUE TO 
!             UNRESOLVED ENTRAINMENT AND MIXING DOMINATES,
!             ACTIVATE DROPLETS EVERYWHERE IN THE CLOUD USING NON-EQUILIBRIUM
!             SUPERSATURATION, BASED ON THE 
!             LOCAL SUB-GRID AND/OR GRID-SCALE VERTICAL VELOCITY 
!             AT THE GRID POINT

! NOTE: ONLY USED FOR PREDICTED DROPLET CONCENTRATION (INUM = 0)

     INTEGER, PRIVATE ::  IBASE

! INCLUDE SUB-GRID VERTICAL VELOCITY IN DROPLET ACTIVATION
! ISUB = 0, INCLUDE SUB-GRID W (RECOMMENDED FOR LOWER RESOLUTION)
! ISUB = 1, EXCLUDE SUB-GRID W, ONLY USE GRID-SCALE W

     INTEGER, PRIVATE ::  ISUB      

! SWITCH FOR GRAUPEL/NO GRAUPEL
! IGRAUP = 0, INCLUDE GRAUPEL
! IGRAUP = 1, NO GRAUPEL

     INTEGER, PRIVATE ::  IGRAUP

! HM ADDED NEW OPTION FOR HAIL
! SWITCH FOR HAIL/GRAUPEL
! IHAIL = 0, DENSE PRECIPITATING ICE IS GRAUPEL
! IHAIL = 1, DENSE PRECIPITATING GICE IS HAIL

     INTEGER, PRIVATE ::  IHAIL

! CLOUD MICROPHYSICS CONSTANTS

     REAL, PRIVATE ::      AI,AC,AS,AR,AG ! 'A' PARAMETER IN FALLSPEED-DIAM RELATIONSHIP
     REAL, PRIVATE ::      BI,BC,BS,BR,BG ! 'B' PARAMETER IN FALLSPEED-DIAM RELATIONSHIP
     REAL, PRIVATE ::      R           ! GAS CONSTANT FOR AIR
     REAL, PRIVATE ::      RV          ! GAS CONSTANT FOR WATER VAPOR
     REAL, PRIVATE ::      CP          ! SPECIFIC HEAT AT CONSTANT PRESSURE FOR DRY AIR
     REAL, PRIVATE ::      EP_2
     ! GHB: Needed for neweqts
     REAL, PRIVATE ::      cv
     REAL, PRIVATE ::      cvv
     REAL, PRIVATE ::      cpl
     REAL, PRIVATE ::      cpi
     ! GHB
     REAL, PRIVATE ::      RHOSU       ! STANDARD AIR DENSITY AT 850 MB
     REAL, PRIVATE ::      RHOW        ! DENSITY OF LIQUID WATER
     REAL, PRIVATE ::      RHOI        ! BULK DENSITY OF CLOUD ICE
     REAL, PRIVATE ::      RHOSN       ! BULK DENSITY OF SNOW
     REAL, PRIVATE ::      RHOG        ! BULK DENSITY OF GRAUPEL
     REAL, PRIVATE ::      AIMM        ! PARAMETER IN BIGG IMMERSION FREEZING
     REAL, PRIVATE ::      BIMM        ! PARAMETER IN BIGG IMMERSION FREEZING
     REAL, PRIVATE ::      ECR         ! COLLECTION EFFICIENCY BETWEEN DROPLETS/RAIN AND SNOW/RAIN
     REAL, PRIVATE ::      DCS         ! THRESHOLD SIZE FOR CLOUD ICE AUTOCONVERSION
     REAL, PRIVATE ::      MI0         ! INITIAL SIZE OF NUCLEATED CRYSTAL
     REAL, PRIVATE ::      MG0         ! MASS OF EMBRYO GRAUPEL
     REAL, PRIVATE ::      F1S         ! VENTILATION PARAMETER FOR SNOW
     REAL, PRIVATE ::      F2S         ! VENTILATION PARAMETER FOR SNOW
     REAL, PRIVATE ::      F1R         ! VENTILATION PARAMETER FOR RAIN
     REAL, PRIVATE ::      F2R         ! VENTILATION PARAMETER FOR RAIN
     REAL, PRIVATE ::      G           ! GRAVITATIONAL ACCELERATION
     REAL, PRIVATE ::      QSMALL      ! SMALLEST ALLOWED HYDROMETEOR MIXING RATIO
     REAL, PRIVATE ::      CI,DI,CS,DS,CG,DG ! SIZE DISTRIBUTION PARAMETERS FOR CLOUD ICE, SNOW, GRAUPEL
     REAL, PRIVATE ::      EII         ! COLLECTION EFFICIENCY, ICE-ICE COLLISIONS
     REAL, PRIVATE ::      ECI         ! COLLECTION EFFICIENCY, ICE-DROPLET COLLISIONS
     REAL, PRIVATE ::      RIN     ! RADIUS OF CONTACT NUCLEI (M)
! hm, add for V3.2
     REAL, PRIVATE ::      CPW     ! SPECIFIC HEAT OF LIQUID WATER

! CCN SPECTRA FOR IACT = 1

     REAL, PRIVATE ::      C1     ! 'C' IN NCCN = CS^K (CM-3)
     REAL, PRIVATE ::      K1     ! 'K' IN NCCN = CS^K

! AEROSOL PARAMETERS FOR IACT = 2

     REAL, PRIVATE ::      MW      ! MOLECULAR WEIGHT WATER (KG/MOL)
     REAL, PRIVATE ::      OSM     ! OSMOTIC COEFFICIENT
     REAL, PRIVATE ::      VI      ! NUMBER OF ION DISSOCIATED IN SOLUTION
     REAL, PRIVATE ::      EPSM    ! AEROSOL SOLUBLE FRACTION
     REAL, PRIVATE ::      RHOA    ! AEROSOL BULK DENSITY (KG/M3)
     REAL, PRIVATE ::      MAP     ! MOLECULAR WEIGHT AEROSOL (KG/MOL)
     REAL, PRIVATE ::      MA      ! MOLECULAR WEIGHT OF 'AIR' (KG/MOL)
     REAL, PRIVATE ::      RR      ! UNIVERSAL GAS CONSTANT
     REAL, PRIVATE ::      BACT    ! ACTIVATION PARAMETER
     REAL, PRIVATE ::      RM1     ! GEOMETRIC MEAN RADIUS, MODE 1 (M)
     REAL, PRIVATE ::      RM2     ! GEOMETRIC MEAN RADIUS, MODE 2 (M)
     REAL, PRIVATE ::      NANEW1  ! TOTAL AEROSOL CONCENTRATION, MODE 1 (M^-3)
     REAL, PRIVATE ::      NANEW2  ! TOTAL AEROSOL CONCENTRATION, MODE 2 (M^-3)
     REAL, PRIVATE ::      SIG1    ! STANDARD DEVIATION OF AEROSOL S.D., MODE 1
     REAL, PRIVATE ::      SIG2    ! STANDARD DEVIATION OF AEROSOL S.D., MODE 2
     REAL, PRIVATE ::      F11     ! CORRECTION FACTOR FOR ACTIVATION, MODE 1
     REAL, PRIVATE ::      F12     ! CORRECTION FACTOR FOR ACTIVATION, MODE 1
     REAL, PRIVATE ::      F21     ! CORRECTION FACTOR FOR ACTIVATION, MODE 2
     REAL, PRIVATE ::      F22     ! CORRECTION FACTOR FOR ACTIVATION, MODE 2     
     REAL, PRIVATE ::      MMULT   ! MASS OF SPLINTERED ICE PARTICLE
     REAL, PRIVATE ::      LAMMAXI,LAMMINI,LAMMAXR,LAMMINR,LAMMAXS,LAMMINS,LAMMAXG,LAMMING
     REAL, PRIVATE ::      D_b     ! cutoff diameter for breakup

! CONSTANTS TO IMPROVE EFFICIENCY

     REAL, PRIVATE :: CONS1,CONS2,CONS3,CONS4,CONS5,CONS6,CONS7,CONS8,CONS9,CONS10
     REAL, PRIVATE :: CONS11,CONS12,CONS13,CONS14,CONS15,CONS16,CONS17,CONS18,CONS19,CONS20
     REAL, PRIVATE :: CONS21,CONS22,CONS23,CONS24,CONS25,CONS26,CONS27,CONS28,CONS29,CONS30
     REAL, PRIVATE :: CONS31,CONS32,CONS33,CONS34,CONS35,CONS36,CONS37,CONS38,CONS39,CONS40
     REAL, PRIVATE :: CONS41

!..Various radar related variables, from GT

!..Lookup table dimensions
      INTEGER, PARAMETER, PRIVATE:: nbins = 100
      INTEGER, PARAMETER, PRIVATE:: nbr = nbins
      INTEGER, PARAMETER, PRIVATE:: nbs = nbins
      INTEGER, PARAMETER, PRIVATE:: nbg = nbins
      DOUBLE PRECISION, DIMENSION(nbins+1):: ddx
      DOUBLE PRECISION, DIMENSION(nbr):: Dr, dtr
      DOUBLE PRECISION, DIMENSION(nbs):: Dds, dts
      DOUBLE PRECISION, DIMENSION(nbg):: Ddg, dtg

      DOUBLE PRECISION, PARAMETER, PRIVATE:: lamda_radar = 0.10         ! in meters
      DOUBLE PRECISION, PRIVATE:: K_w, PI5, lamda4
      COMPLEX*16, PRIVATE:: m_w_0, m_i_0
      DOUBLE PRECISION, DIMENSION(nbins+1), PRIVATE:: simpson
      DOUBLE PRECISION, DIMENSION(3), PARAMETER, PRIVATE:: basis =      &
                           (/1.d0/3.d0, 4.d0/3.d0, 1.d0/3.d0/)

      INTEGER, PARAMETER, PRIVATE:: slen = 20
      CHARACTER(len=slen), PRIVATE::                                    &
              mixingrulestring_s, matrixstring_s, inclusionstring_s,    &
              hoststring_s, hostmatrixstring_s, hostinclusionstring_s,  &
              mixingrulestring_g, matrixstring_g, inclusionstring_g,    &
              hoststring_g, hostmatrixstring_g, hostinclusionstring_g

      REAL, PARAMETER, PRIVATE:: D0r = 50.E-6
      REAL, PARAMETER, PRIVATE:: D0s = 100.E-6
      REAL, PARAMETER, PRIVATE:: D0g = 100.E-6
      CHARACTER*256:: mp_debug

CONTAINS

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
SUBROUTINE MORR_TWO_MOMENT_INIT(cm1hail)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! THIS SUBROUTINE INITIALIZES ALL PHYSICAL CONSTANTS AMND PARAMETERS 
! NEEDED BY THE MICROPHYSICS SCHEME.
! NEEDS TO BE CALLED AT FIRST TIME STEP, PRIOR TO CALL TO MAIN MICROPHYSICS INTERFACE
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      IMPLICIT NONE

      integer, intent(in) :: cm1hail
      integer n,i

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! THE FOLLOWING PARAMETERS ARE USER-DEFINED SWITCHES AND NEED TO BE
! SET PRIOR TO CODE COMPILATION

! INUM = 0, PREDICT DROPLET CONCENTRATION
! INUM = 1, ASSUME CONSTANT DROPLET CONCENTRATION   
! !!!NOTE: PREDICTED DROPLET CONCENTRATION NOT AVAILABLE IN THIS VERSION
! CONTACT HUGH MORRISON (morrison@ucar.edu) FOR FURTHER INFORMATION
! INUM=1 ONLY IN CURRENT VERSION

      INUM = 1

! FOR INUM = 1, SET CONSTANT DROPLET CONCENTRATION (UNITS OF CM-3)

      NDCNST = 250.

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! NOTE, FOLLOWING OPTIONS NOT AVAILABLE IN CURRENT VERSION
! ONLY USED WHEN INUM=0


! IACT = 1, USE POWER-LAW CCN SPECTRA, NCCN = CS^K
! IACT = 2, USE LOGNORMAL AEROSOL SIZE DIST TO DERIVE CCN SPECTRA
! NOTE: ONLY USED FOR PREDICTED DROPLET CONCENTRATION (INUM = 0)

      IACT = 2

! IBASE = 1, NEGLECT DROPLET ACTIVATION AT LATERAL CLOUD EDGES DUE TO 
!             UNRESOLVED ENTRAINMENT AND MIXING, ACTIVATE
!             AT CLOUD BASE OR IN REGION WITH LITTLE CLOUD WATER USING 
!             NON-EQULIBRIUM SUPERSATURATION ASSUMING NO INITIAL CLOUD WATER, 
!             IN CLOUD INTERIOR ACTIVATE USING EQUILIBRIUM SUPERSATURATION
! IBASE = 2, ASSUME DROPLET ACTIVATION AT LATERAL CLOUD EDGES DUE TO 
!             UNRESOLVED ENTRAINMENT AND MIXING DOMINATES,
!             ACTIVATE DROPLETS EVERYWHERE IN THE CLOUD USING NON-EQUILIBRIUM
!             SUPERSATURATION ASSUMING NO INITIAL CLOUD WATER, BASED ON THE 
!             LOCAL SUB-GRID AND/OR GRID-SCALE VERTICAL VELOCITY 
!             AT THE GRID POINT

! NOTE: ONLY USED FOR PREDICTED DROPLET CONCENTRATION (INUM = 0)
 
      IBASE = 2

! INCLUDE SUB-GRID VERTICAL VELOCITY (standard deviation of w) IN DROPLET ACTIVATION
! ISUB = 0, INCLUDE SUB-GRID W (RECOMMENDED FOR LOWER RESOLUTION)
! currently, sub-grid w is constant of 0.5 m/s (not coupled with PBL/turbulence scheme)
! ISUB = 1, EXCLUDE SUB-GRID W, ONLY USE GRID-SCALE W

! NOTE: ONLY USED FOR PREDICTED DROPLET CONCENTRATION (INUM = 0)

      ISUB = 0      
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


! SWITCH FOR LIQUID-ONLY RUN
! ILIQ = 0, INCLUDE ICE
! ILIQ = 1, LIQUID ONLY, NO ICE

      ILIQ = 0

! SWITCH FOR ICE NUCLEATION
! INUC = 0, USE FORMULA FROM RASMUSSEN ET AL. 2002 (MID-LATITUDE)
!      = 1, USE MPACE OBSERVATIONS (ARCTIC ONLY)

      INUC = 0

! SWITCH FOR GRAUPEL/HAIL NO GRAUPEL/HAIL
! IGRAUP = 0, INCLUDE GRAUPEL/HAIL
! IGRAUP = 1, NO GRAUPEL/HAIL

      IGRAUP = 0

! HM ADDED 11/7/07
! SWITCH FOR HAIL/GRAUPEL
! IHAIL = 0, DENSE PRECIPITATING ICE IS GRAUPEL
! IHAIL = 1, DENSE PRECIPITATING ICE IS HAIL
! NOTE ---> RECOMMEND IHAIL = 1 FOR CONTINENTAL DEEP CONVECTION

      IHAIL = cm1hail

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! SET PHYSICAL CONSTANTS

! FALLSPEED PARAMETERS (V=AD^B)
         AI = 700.
         AC = 3.E7
         AS = 11.72
         AR = 841.99667
         BI = 1.
         BC = 2.
         BS = 0.41
         BR = 0.8
         IF (IHAIL.EQ.0) THEN
	 AG = 19.3
	 BG = 0.37
         ELSE ! (MATSUN AND HUGGINS 1980)
         AG = 114.5 
         BG = 0.5
         END IF

! CONSTANTS AND PARAMETERS
         R = 287.04
         RV = 461.5
         CP = 1005.7
         EP_2 = R/RV
         RHOSU = 85000./(287.15*273.15)
         ! GHB: Needed for neweqts
         cv = CP - R
         cvv = 1408.5
         cpl = 4190.0
         cpi = 2106.0
         ! GHB
         RHOW = 997.
         RHOI = 500.
         RHOSN = 100.
         IF (IHAIL.EQ.0) THEN
	 RHOG = 400.
         ELSE
         RHOG = 900.
         END IF
         AIMM = 0.66
         BIMM = 100.
         ECR = 1.
         DCS = 125.E-6
         MI0 = 4./3.*PI*RHOI*(10.E-6)**3
	 MG0 = 1.6E-10
         F1S = 0.86
         F2S = 0.28
         F1R = 0.78
         F2R = 0.32
         G = 9.81
         QSMALL = 1.E-14
         EII = 0.1
         ECI = 0.7
! HM, ADD FOR V3.2
         CPW = cpl

! SIZE DISTRIBUTION PARAMETERS

         CI = RHOI*PI/6.
         DI = 3.
         CS = RHOSN*PI/6.
         DS = 3.
         CG = RHOG*PI/6.
         DG = 3.

! RADIUS OF CONTACT NUCLEI
         RIN = 0.1E-6

         MMULT = 4./3.*PI*RHOI*(5.E-6)**3

! SIZE LIMITS FOR LAMBDA

         LAMMAXI = 1./1.E-6
         LAMMINI = 1./(2.*DCS+100.E-6)
         LAMMAXR = 1./20.E-6
         LAMMINR = 1./2800.E-6

         D_b = 300.e-6  ! cutoff diameter for breakup

         LAMMAXS = 1./10.E-6
         LAMMINS = 1./2000.E-6
         LAMMAXG = 1./20.E-6
         LAMMING = 1./2000.E-6

! CCN SPECTRA FOR IACT = 1

! MARITIME
! MODIFIED FROM RASMUSSEN ET AL. 2002
! NCCN = C*S^K, NCCN IS IN CM-3, S IS SUPERSATURATION RATIO IN %

              K1 = 0.4
              C1 = 120. 

! CONTINENTAL

!              K1 = 0.5
!              C1 = 1000. 

! AEROSOL ACTIVATION PARAMETERS FOR IACT = 2
! PARAMETERS CURRENTLY SET FOR AMMONIUM SULFATE

         MW = 0.018
         OSM = 1.
         VI = 3.
         EPSM = 0.7
         RHOA = 1777.
         MAP = 0.132
         MA = 0.0284
         RR = 8.3187
         BACT = VI*OSM*EPSM*MW*RHOA/(MAP*RHOW)

! AEROSOL SIZE DISTRIBUTION PARAMETERS CURRENTLY SET FOR MPACE 
! (see morrison et al. 2007, JGR)
! MODE 1

         RM1 = 0.052E-6
         SIG1 = 2.04
         NANEW1 = 72.2E6
         F11 = 0.5*EXP(2.5*(LOG(SIG1))**2)
         F21 = 1.+0.25*LOG(SIG1)

! MODE 2

         RM2 = 1.3E-6
         SIG2 = 2.5
         NANEW2 = 1.8E6
         F12 = 0.5*EXP(2.5*(LOG(SIG2))**2)
         F22 = 1.+0.25*LOG(SIG2)

! CONSTANTS FOR EFFICIENCY

         CONS1=GAMMA(1.+DS)*CS
         CONS2=GAMMA(1.+DG)*CG
         CONS3=GAMMA(4.+BS)/6.
         CONS4=GAMMA(4.+BR)/6.
         CONS5=GAMMA(1.+BS)
         CONS6=GAMMA(1.+BR)
         CONS7=GAMMA(4.+BG)/6.
         CONS8=GAMMA(1.+BG)
         CONS9=GAMMA(5./2.+BR/2.)
         CONS10=GAMMA(5./2.+BS/2.)
         CONS11=GAMMA(5./2.+BG/2.)
         CONS12=GAMMA(1.+DI)*CI
         CONS13=GAMMA(BS+3.)*PI/4.*ECI
         CONS14=GAMMA(BG+3.)*PI/4.*ECI
         CONS15=-1108.*EII*PI**((1.-BS)/3.)*RHOSN**((-2.-BS)/3.)/(4.*720.)
         CONS16=GAMMA(BI+3.)*PI/4.*ECI
         CONS17=4.*2.*3.*RHOSU*PI*ECI*ECI*GAMMA(2.*BS+2.)/(8.*(RHOG-RHOSN))
         CONS18=RHOSN*RHOSN
         CONS19=RHOW*RHOW
         CONS20=20.*PI*PI*RHOW*BIMM
         CONS21=4./(DCS*RHOI)
         CONS22=PI*RHOI*DCS**3/6.
         CONS23=PI/4.*EII*GAMMA(BS+3.)
         CONS24=PI/4.*ECR*GAMMA(BR+3.)
         CONS25=PI*PI/24.*RHOW*ECR*GAMMA(BR+6.)
         CONS26=PI/6.*RHOW
         CONS27=GAMMA(1.+BI)
         CONS28=GAMMA(4.+BI)/6.
         CONS29=4./3.*PI*RHOW*(25.E-6)**3
         CONS30=4./3.*PI*RHOW
         CONS31=PI*PI*ECR*RHOSN
         CONS32=PI/2.*ECR
         CONS33=PI*PI*ECR*RHOG
         CONS34=5./2.+BR/2.
         CONS35=5./2.+BS/2.
         CONS36=5./2.+BG/2.
         CONS37=4.*PI*1.38E-23/(6.*PI*RIN)
         CONS38=PI*PI/3.*RHOW
         CONS39=PI*PI/36.*RHOW*BIMM
         CONS40=PI/6.*BIMM
         CONS41=PI*PI*ECR*RHOW

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! variables for radar reflecitivity calculations
!..Create bins of rain (from min diameter up to 5 mm).
      ddx(1) = D0r*1.0d0
      ddx(nbr+1) = 0.005d0
      do n = 2, nbr
         ddx(n) = DEXP(DFLOAT(n-1)/DFLOAT(nbr) &
                  *DLOG(ddx(nbr+1)/ddx(1)) +DLOG(ddx(1)))
      enddo
      do n = 1, nbr
         Dr(n) = DSQRT(ddx(n)*ddx(n+1))
         dtr(n) = ddx(n+1) - ddx(n)
      enddo

!..Create bins of snow (from min diameter up to 2 cm).
      Ddx(1) = D0s*1.0d0
      Ddx(nbs+1) = 0.02d0
      do n = 2, nbs
         Ddx(n) = DEXP(DFLOAT(n-1)/DFLOAT(nbs) &
                  *DLOG(Ddx(nbs+1)/Ddx(1)) +DLOG(Ddx(1)))
      enddo
      do n = 1, nbs
         Dds(n) = DSQRT(Ddx(n)*Ddx(n+1))
         dts(n) = Ddx(n+1) - Ddx(n)
      enddo

!..Create bins of graupel (from min diameter up to 5 cm).
      Ddx(1) = D0g*1.0d0
      Ddx(nbg+1) = 0.05d0
      do n = 2, nbg
         Ddx(n) = DEXP(DFLOAT(n-1)/DFLOAT(nbg) &
                  *DLOG(Ddx(nbg+1)/Ddx(1)) +DLOG(Ddx(1)))
      enddo
      do n = 1, nbg
         Ddg(n) = DSQRT(Ddx(n)*Ddx(n+1))
         dtg(n) = Ddx(n+1) - Ddx(n)
      enddo

      do i = 1, 256
         mp_debug(i:i) = char(0)
      enddo

      call radar_init

END SUBROUTINE MORR_TWO_MOMENT_INIT

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! THIS SUBROUTINE IS MAIN INTERFACE WITH THE TWO-MOMENT MICROPHYSICS SCHEME
! THIS INTERFACE TAKES IN 3D VARIABLES FROM DRIVER MODEL, CONVERTS TO 1D FOR
! CALL TO THE MAIN MICROPHYSICS SUBROUTINE (SUBROUTINE MORR_TWO_MOMENT_MICRO) 
! WHICH OPERATES ON 1D VERTICAL COLUMNS.
! 1D VARIABLES FROM THE MAIN MICROPHYSICS SUBROUTINE ARE THEN REASSIGNED BACK TO 3D FOR OUTPUT
! BACK TO DRIVER MODEL USING THIS INTERFACE.
! MICROPHYSICS TENDENCIES ARE ADDED TO VARIABLES HERE BEFORE BEING PASSED BACK TO DRIVER MODEL.

! THIS CODE WAS WRITTEN BY HUGH MORRISON (NCAR) AND SLAVA TATARSKII (GEORGIA TECH).

! FOR QUESTIONS, CONTACT: HUGH MORRISON, E-MAIL: MORRISON@UCAR.EDU, PHONE:303-497-8916

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

SUBROUTINE MP_MORR_TWO_MOMENT(ITIMESTEP,                       &
                T3D, QV, QC, QR, QI, QS, QG, NNI,     NS, NR, NG,   &
                     P, DT_IN, DDZ, W, RAINNC,                     &
                tcond,tevac,tevar,train,                           &
                ruh,rvh,rmh,rr,dbz3d,getdbz                        &
!!!                TH, QV, QC, QR, QI, QS, QG, NI, NS, NR, NG, &
!!!                RHO, PII, P, DT_IN, DZ, HT, W,          &
!!!                RAINNC, RAINNCV, SR,                    &
!!!                qrcuten, qscuten, qicuten, mu           & ! hm added
!!!               ,IDS,IDE, JDS,JDE, KDS,KDE               & ! domain dims
!!!               ,IMS,IME, JMS,JME, KMS,KME               & ! memory dims
!!!               ,ITS,ITE, JTS,JTE, KTS,KTE               & ! tile   dims            )
                                            )
 
! QV - water vapor mixing ratio (kg/kg)
! QC - cloud water mixing ratio (kg/kg)
! QR - rain water mixing ratio (kg/kg)
! QI - cloud ice mixing ratio (kg/kg)
! QS - snow mixing ratio (kg/kg)
! QG - graupel mixing ratio (KG/KG)
! NI - cloud ice number concentration (1/kg)
! NS - Snow Number concentration (1/kg)
! NR - Rain Number concentration (1/kg)
! NG - Graupel number concentration (1/kg)
! NOTE: RHO AND HT NOT USED BY THIS SCHEME AND DO NOT NEED TO BE PASSED INTO SCHEME!!!!
! P - AIR PRESSURE (PA)
! W - VERTICAL AIR VELOCITY (M/S)
! TH - POTENTIAL TEMPERATURE (K)
! PII - exner function - used to convert potential temp to temp
! DZ - difference in height over interface (m)
! DT_IN - model time step (sec)
! ITIMESTEP - time step counter
! RAINNC - accumulated grid-scale precipitation (mm)
! RAINNCV - one time step grid scale precipitation (mm/time step)
! SR - one time step mass ratio of snow to total precip
! qrcuten, rain tendency from parameterized cumulus convection
! qscuten, snow tendency from parameterized cumulus convection
! qicuten, cloud ice tendency from parameterized cumulus convection

! variables below currently not in use, not coupled to PBL or radiation codes
! TKE - turbulence kinetic energy (m^2 s-2), NEEDED FOR DROPLET ACTIVATION (SEE CODE BELOW)
! NCTEND - droplet concentration tendency from pbl (kg-1 s-1)
! NCTEND - CLOUD ICE concentration tendency from pbl (kg-1 s-1)
! KZH - heat eddy diffusion coefficient from YSU scheme (M^2 S-1), NEEDED FOR DROPLET ACTIVATION (SEE CODE BELOW)
! EFFCS - CLOUD DROPLET EFFECTIVE RADIUS OUTPUT TO RADIATION CODE (micron)
! EFFIS - CLOUD DROPLET EFFECTIVE RADIUS OUTPUT TO RADIATION CODE (micron)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! reflectivity currently not included!!!!
! REFL_10CM - CALCULATED RADAR REFLECTIVITY AT 10 CM (DBZ)
!................................
! GRID_CLOCK, GRID_ALARMS - parameters to limit radar reflectivity calculation only when needed
! otherwise radar reflectivity calculation every time step is too slow
! only needed for coupling with WRF, see code below for details
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! EFFC - DROPLET EFFECTIVE RADIUS (MICRON)
! EFFR - RAIN EFFECTIVE RADIUS (MICRON)
! EFFS - SNOW EFFECTIVE RADIUS (MICRON)
! EFFI - CLOUD ICE EFFECTIVE RADIUS (MICRON)

! ADDITIONAL OUTPUT FROM MICRO - SEDIMENTATION TENDENCIES, NEEDED FOR LIQUID-ICE STATIC ENERGY

! QGSTEN - GRAUPEL SEDIMENTATION TEND (KG/KG/S)
! QRSTEN - RAIN SEDIMENTATION TEND (KG/KG/S)
! QISTEN - CLOUD ICE SEDIMENTATION TEND (KG/KG/S)
! QNISTEN - SNOW SEDIMENTATION TEND (KG/KG/S)
! QCSTEN - CLOUD WATER SEDIMENTATION TEND (KG/KG/S)

! ADDITIONAL INPUT NEEDED BY MICRO
! ********NOTE: WVAR IS SHOULD BE USED IN DROPLET ACTIVATION
! FOR CASES WHEN UPDRAFT IS NOT RESOLVED, EITHER BECAUSE OF
! LOW MODEL RESOLUTION OR CLOUD TYPE
! WVAR - STANDARD DEVIATION OF SUB-GRID VERTICAL VELOCITY (M/S)

   IMPLICIT NONE

   include 'input.incl'
   include 'timestat.incl'

!!!   INTEGER,      INTENT(IN   )    ::   ids, ide, jds, jde, kds, kde , &
!!!                                       ims, ime, jms, jme, kms, kme , &
!!!                                       its, ite, jts, jte, kts, kte
! Temporary changed from INOUT to IN

!!!   REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT):: &
!!!                          qv, qc, qr, qi, qs, qg, ni, ns, nr, TH, NG
!, effcs, effis

!!!   REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN):: &
!!!                          pii, p, dz, rho, w !, tke, nctend, nitend,kzh
   REAL, DIMENSION(ib:ie,jb:je,kb:ke), INTENT(INOUT):: &
                          qv, qc, qr, qi, qs, qg, nni,     ns, nr, T3D, NG,   &
                          dbz3d

   REAL, DIMENSION(ib:ie,jb:je,kb:ke), INTENT(IN):: &
                          rmh, rr,      p, ddz
   REAL, DIMENSION(ib:ie,jb:je,kb:ke+1), INTENT(IN):: &
                          w
   REAL, INTENT(IN):: dt_in
   INTEGER, INTENT(IN):: ITIMESTEP

   real, dimension(ib:ie,jb:je,nrain), INTENT(INOUT) :: rainnc
   real*8 :: tcond,tevac,tevar,train
   real, dimension(ib:ie) :: ruh
   real, dimension(jb:je) :: rvh
   logical :: getdbz

!!!   REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT):: &
!!!                          RAINNC, RAINNCV, SR

!   REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT)::       &  ! GT
!                          refl_10cm

!!!   REAL , DIMENSION( ims:ime , jms:jme ) , INTENT(IN) ::       ht

!      TYPE (WRFU_Clock):: grid_clock                  ! GT
!      TYPE (WRFU_Alarm), POINTER:: grid_alarms(:)     ! GT

   ! LOCAL VARIABLES

!!!   REAL, DIMENSION(its:ite, kts:kte, jts:jte)::                     &
!!!                      effi, effs, effr, EFFG

!!!   REAL, DIMENSION(its:ite, kts:kte, jts:jte)::                     &
!!!                      T, WVAR, EFFC

   REAL, DIMENSION(nk) ::                                                                & 
                            QC_TEND1D, QI_TEND1D, QNI_TEND1D, QR_TEND1D,                      &
                            NI_TEND1D, NS_TEND1D, NR_TEND1D,                                  &
                            QC1D, QI1D, QR1D,NI1D, NS1D, NR1D, QS1D,                          &
                            T_TEND1D,QV_TEND1D, T1D, QV1D, P1D, W1D, WVAR1D,         &
                            EFFC1D, EFFI1D, EFFS1D, EFFR1D,DZ1D,   &
   ! HM ADD GRAUPEL
                            QG_TEND1D, NG_TEND1D, QG1D, NG1D, EFFG1D, &

! ADD SEDIMENTATION TENDENCIES (UNITS OF KG/KG/S)
                            QGSTEN,QRSTEN, QISTEN, QNISTEN, QCSTEN, &
! ADD CUMULUS TENDENCIES
                            QRCU1D, QSCU1D, QICU1D,   &
! HM add reflectivity
                            dbz

! add cumulus tendencies

!!!   REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN):: &
!!!      qrcuten, qscuten, qicuten
!!!   REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN):: &
!!!      mu

! HM add reflectivity      
!                            dbz
                          
   REAL PRECPRT1D, SNOWRT1D

   INTEGER I,K,J,n

   REAL DT

   real, dimension(nk) :: PRE
   real :: tem1
   real*8, dimension(nj) :: bud1,bud2

   LOGICAL:: dBZ_tstep ! GT

   ! Initialize tendencies (all set to 0) and transfer
   ! array to local variables
   DT = DT_IN   

      dBZ_tstep = getdbz

    tem1 = dx*dy*dz

!$omp parallel do default(shared)  &
!$omp private(j)
    do j=1,nj
      bud1(j)=0.0d0
      bud2(j)=0.0d0
    enddo

!   DO I=ITS,ITE
!   DO J=JTS,JTE
!   DO K=KTS,KTE
!       T(I,K,J)        = TH(i,k,j)*PII(i,k,j)
!
!! wvar is the ST. DEV. OF sub-grid vertical velocity, used for calculating droplet 
!! activation rates.
!! WVAR CAN BE DERIVED EITHER FROM PREDICTED TKE (AS IN MYJ PBL SCHEME),
!! OR FROM EDDY DIFFUSION COEFFICIENT KZH (AS IN YSU PBL SCHEME),
!! DEPENDING ON THE PARTICULAR pbl SCHEME DRIVER MODEL IS COUPLED WITH
!! NOTE: IF MODEL HAS HIGH ENOUGH RESOLUTION TO RESOLVE UPDRAFTS, WVAR MAY 
!! NOT BE NEEDED 
!
!! currently assign wvar to 0.5 m/s (not coupled with PBL scheme)
!
!       WVAR(I,K,J)     = 0.5
!
!! currently mixing of number concentrations also is neglected (not coupled with PBL schemes)
!
!   END DO
!   END DO
!   END DO

!$omp parallel do default(shared)  &
!$omp private(i,j,k,n,QC_TEND1D,QI_TEND1D,QNI_TEND1D,QR_TEND1D,     &
!$omp NI_TEND1D,NS_TEND1D,NR_TEND1D,T_TEND1D,QV_TEND1D,QC1D,QI1D,QS1D,QR1D,   &
!$omp NI1D,NS1D,NR1D,QG1D,NG1D,QG_TEND1D,NG_TEND1D,T1D,QV1D,P1D,DZ1D,    &
!$omp W1D,WVAR1D,PRE,dBZ,PRECPRT1D,SNOWRT1D,EFFC1D,EFFI1D,EFFS1D,EFFR1D,  &
!$omp EFFG1D,QGSTEN,QRSTEN,QISTEN,QNISTEN,QCSTEN)
   do j=1,nj         ! j loop (north-south)
   do i=1,ni         ! i loop (east-west)
   !
   ! Transfer 3D arrays into 1D for microphysical calculations
   !

! hm , initialize 1d tendency arrays to zero

          QC_TEND1D  = 0.
          QI_TEND1D  = 0.
          QNI_TEND1D = 0.
          QR_TEND1D  = 0.
          NI_TEND1D  = 0.
          NS_TEND1D  = 0.
          NR_TEND1D  = 0.
          T_TEND1D   = 0.
          QV_TEND1D  = 0.

          QG_TEND1D  = 0.
          NG_TEND1D  = 0.

          WVAR1D     = 0.0
! add cumulus tendencies, decouple from mu
          qrcu1d     = 0.0
          qscu1d     = 0.0
          qicu1d     = 0.0

      do k=1,nk      ! k loop (vertical)

          QC1D(k)       = QC(i,j,k)
          QI1D(k)       = QI(i,j,k)
          QS1D(k)       = QS(i,j,k)
          QR1D(k)       = QR(i,j,k)

          NI1D(k)       = NNI(i,j,k)

          NS1D(k)       = NS(i,j,k)
          NR1D(k)       = NR(i,j,k)
! HM ADD GRAUPEL
          QG1D(K)       = QG(i,j,k)
          NG1D(K)       = NG(i,j,k)

!!!          T1D(k)        = T(i,k,j)
!!!          T1D(k)        = TH(i,j,k)*PII(i,j,k)
          T1D(k)        = T3D(i,j,k)
          QV1D(k)       = QV(i,j,k)
          P1D(k)        = P(i,j,k)
          DZ1D(k)       = DDZ(i,j,k)
!!!          W1D(k)        = W(i,k,j)
          W1D(k)        = 0.5*( w(i,j,k) + w(i,j,k+1) )
      end do

      PRE = 0.0

      call MORR_TWO_MOMENT_MICRO(QC_TEND1D, QI_TEND1D, QNI_TEND1D, QR_TEND1D,            &
       NI_TEND1D, NS_TEND1D, NR_TEND1D,                                                  &
       QC1D, QI1D, QS1D, QR1D,NI1D, NS1D, NR1D,                                          &
       T_TEND1D,QV_TEND1D, T1D, QV1D, P1D, DZ1D, W1D, WVAR1D,                   &
       PRECPRT1D,SNOWRT1D,                                                               &
       EFFC1D,EFFI1D,EFFS1D,EFFR1D,DT,                                                   &
                                              1,ni ,   1,nj ,   1,nk ,                   &
                                              1,ni ,   1,nj ,   1,nk ,                   &
                                    QG_TEND1D,NG_TEND1D,QG1D,NG1D,EFFG1D, &
                                    qrcu1d, qscu1d, qicu1d, &
! ADD SEDIMENTATION TENDENCIES
                                  QGSTEN,QRSTEN,QISTEN,QNISTEN,QCSTEN,PRE,neweqts)

   !
   ! Transfer 1D arrays back into 3D arrays
   !
      do k=1,nk

! hm, add tendencies to update global variables 
! HM, TENDENCIES FOR Q AND N NOW ADDED IN M2005MICRO, SO WE
! ONLY NEED TO TRANSFER 1D VARIABLES BACK TO 3D

          QC(i,j,k)        = QC1D(k)
          QI(i,j,k)        = QI1D(k)
          QS(i,j,k)        = QS1D(k)
          QR(i,j,k)        = QR1D(k)
          NNI(i,j,k)        = NI1D(k)
          NS(i,j,k)        = NS1D(k)          
          NR(i,j,k)        = NR1D(k)
	  QG(i,j,k)        = QG1D(K)
          NG(i,j,k)        = NG1D(K)

!!!          T(i,k,j)         = T1D(k)
!!!          TH(I,K,J)        = T(i,k,j)/PII(i,k,j) ! CONVERT TEMP BACK TO POTENTIAL TEMP
!!!          TH(i,j,k)        = T1D(k)/PII(i,j,k) ! CONVERT TEMP BACK TO POTENTIAL TEMP
          T3D(i,j,k)        = T1D(k)
          QV(i,j,k)        = QV1D(k)

!!!          EFFC(i,k,j)      = EFFC1D(k)
!!!          EFFI(i,k,j)      = EFFI1D(k)
!!!          EFFS(i,k,j)      = EFFS1D(k)
!!!          EFFR(i,k,j)      = EFFR1D(k)
!!!	  EFFG(I,K,j)      = EFFG1D(K)

! EFFECTIVE RADIUS FOR RADIATION CODE (currently not coupled)
! HM, ADD LIMIT TO PREVENT BLOWING UP OPTICAL PROPERTIES, 8/18/07
!          EFFCS(I,K,J)     = MIN(EFFC(I,K,J),50.)
!          EFFCS(I,K,J)     = MAX(EFFCS(I,K,J),1.)
!          EFFIS(I,K,J)     = MIN(EFFI(I,K,J),130.)
!          EFFIS(I,K,J)     = MAX(EFFIS(I,K,J),13.)

      end do

! hm modified so that m2005 precip variables correctly match wrf precip variables
!!!      RAINNC(i,j) = RAINNC(I,J)+PRECPRT1D
!!!      RAINNCV(i,j) = PRECPRT1D
!!!      SR(i,j) = SNOWRT1D/(PRECPRT1D+1.E-12)


         do n = 1,nrain
           RAINNC(i,j,n) = RAINNC(i,j,n) + 0.1*PRECPRT1D
           bud1(j) = bud1(j) + PRECPRT1D*ruh(i)*rvh(j)*dx*dy
         enddo

         do k=1,nk
           bud2(j) = bud2(j) - rr(i,j,k)*PRE(K)*ruh(i)*rvh(j)*rmh(i,j,k)*tem1
         enddo

! add reflectivity calculations
! only calculate if logical parameter dbz_tstep = .true.

         if (dBZ_tstep) then
          call calc_refl10cm (qv1d, qr1d, qs1d, qg1d, t1d, p1d, dBZ,    &
                      1, nk, i, j, nr1d, ns1d, ng1d)
          do k = 1, nk
             dbz3d(i,j,k) = dBZ(k)
          enddo
         endif

   end do
   end do   

   do j=1,nj
     train=train+bud1(j)
     tevar=tevar+bud2(j)
   enddo

   time_microphy=time_microphy+mytime()

END SUBROUTINE MP_MORR_TWO_MOMENT

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE MORR_TWO_MOMENT_MICRO(QC3DTEN,QI3DTEN,QNI3DTEN,QR3DTEN,         &
       NI3DTEN,NS3DTEN,NR3DTEN,QC3D,QI3D,QNI3D,QR3D,NI3D,NS3D,NR3D,              &
       T3DTEN,QV3DTEN,T3D,QV3D,PRES,DZQ,W3D,WVAR,PRECRT,SNOWRT,            &
       EFFC,EFFI,EFFS,EFFR,DT,                                                   &
                                            IMS,IME, JMS,JME, KMS,KME,           &
                                            ITS,ITE, JTS,JTE, KTS,KTE,           & ! ADD GRAUPEL
                        QG3DTEN,NG3DTEN,QG3D,NG3D,EFFG,qrcu1d,qscu1d, qicu1d,    &
                        QGSTEN,QRSTEN,QISTEN,QNISTEN,QCSTEN,PRE,neweqts)

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
! THIS PROGRAM IS THE MAIN TWO-MOMENT MICROPHYSICS SUBROUTINE DESCRIBED BY
! MORRISON ET AL. 2005 JAS; MORRISON AND PINTO 2005 JAS.
! ADDITIONAL CHANGES ARE DESCRIBED IN DETAIL BY MORRISON, THOMPSON, TATARSKII (MWR, SUBMITTED)

! THIS SCHEME IS A BULK DOUBLE-MOMENT SCHEME THAT PREDICTS MIXING
! RATIOS AND NUMBER CONCENTRATIONS OF FIVE HYDROMETEOR SPECIES:
! CLOUD DROPLETS, CLOUD (SMALL) ICE, RAIN, SNOW, AND GRAUPEL.

! CODE STRUCTURE: MAIN SUBROUTINE IS 'MORR_TWO_MOMENT'. ALSO INCLUDED IN THIS FILE IS
! 'FUNCTION POLYSVP', 'FUNCTION DERF1', AND
! 'FUNCTION GAMMA'.

! NOTE: THIS SUBROUTINE USES 1D ARRAY IN VERTICAL (COLUMN), EVEN THOUGH VARIABLES ARE CALLED '3D'......

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

! DECLARATIONS

      IMPLICIT NONE

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
! THESE VARIABLES BELOW MUST BE LINKED WITH THE MAIN MODEL.
! DEFINE ARRAY SIZES

! INPUT NUMBER OF GRID CELLS

! INPUT/OUTPUT PARAMETERS                                 ! DESCRIPTION (UNITS)
      INTEGER, INTENT( IN)  :: IMS,IME, JMS,JME, KMS,KME,          &
                               ITS,ITE, JTS,JTE, KTS,KTE

      REAL, DIMENSION(KTS:KTE) ::  QC3DTEN            ! CLOUD WATER MIXING RATIO TENDENCY (KG/KG/S)
      REAL, DIMENSION(KTS:KTE) ::  QI3DTEN            ! CLOUD ICE MIXING RATIO TENDENCY (KG/KG/S)
      REAL, DIMENSION(KTS:KTE) ::  QNI3DTEN           ! SNOW MIXING RATIO TENDENCY (KG/KG/S)
      REAL, DIMENSION(KTS:KTE) ::  QR3DTEN            ! RAIN MIXING RATIO TENDENCY (KG/KG/S)
      REAL, DIMENSION(KTS:KTE) ::  NI3DTEN            ! CLOUD ICE NUMBER CONCENTRATION (1/KG/S)
      REAL, DIMENSION(KTS:KTE) ::  NS3DTEN            ! SNOW NUMBER CONCENTRATION (1/KG/S)
      REAL, DIMENSION(KTS:KTE) ::  NR3DTEN            ! RAIN NUMBER CONCENTRATION (1/KG/S)
      REAL, DIMENSION(KTS:KTE) ::  QC3D               ! CLOUD WATER MIXING RATIO (KG/KG)
      REAL, DIMENSION(KTS:KTE) ::  QI3D               ! CLOUD ICE MIXING RATIO (KG/KG)
      REAL, DIMENSION(KTS:KTE) ::  QNI3D              ! SNOW MIXING RATIO (KG/KG)
      REAL, DIMENSION(KTS:KTE) ::  QR3D               ! RAIN MIXING RATIO (KG/KG)
      REAL, DIMENSION(KTS:KTE) ::  NI3D               ! CLOUD ICE NUMBER CONCENTRATION (1/KG)
      REAL, DIMENSION(KTS:KTE) ::  NS3D               ! SNOW NUMBER CONCENTRATION (1/KG)
      REAL, DIMENSION(KTS:KTE) ::  NR3D               ! RAIN NUMBER CONCENTRATION (1/KG)
      REAL, DIMENSION(KTS:KTE) ::  T3DTEN             ! TEMPERATURE TENDENCY (K/S)
      REAL, DIMENSION(KTS:KTE) ::  QV3DTEN            ! WATER VAPOR MIXING RATIO TENDENCY (KG/KG/S)
      REAL, DIMENSION(KTS:KTE) ::  T3D                ! TEMPERATURE (K)
      REAL, DIMENSION(KTS:KTE) ::  QV3D               ! WATER VAPOR MIXING RATIO (KG/KG)
      REAL, DIMENSION(KTS:KTE) ::  PRES               ! ATMOSPHERIC PRESSURE (PA)
      REAL, DIMENSION(KTS:KTE) ::  DZQ                ! DIFFERENCE IN HEIGHT ACROSS LEVEL (m)
      REAL, DIMENSION(KTS:KTE) ::  W3D                ! GRID-SCALE VERTICAL VELOCITY (M/S)
      REAL, DIMENSION(KTS:KTE) ::  WVAR               ! SUB-GRID VERTICAL VELOCITY (M/S)

! HM ADDED GRAUPEL VARIABLES
      REAL, DIMENSION(KTS:KTE) ::  QG3DTEN            ! GRAUPEL MIX RATIO TENDENCY (KG/KG/S)
      REAL, DIMENSION(KTS:KTE) ::  NG3DTEN            ! GRAUPEL NUMB CONC TENDENCY (1/KG/S)
      REAL, DIMENSION(KTS:KTE) ::  QG3D            ! GRAUPEL MIX RATIO (KG/KG)
      REAL, DIMENSION(KTS:KTE) ::  NG3D            ! GRAUPEL NUMBER CONC (1/KG)

! HM, ADD 1/16/07, SEDIMENTATION TENDENCIES FOR MIXING RATIO

      REAL, DIMENSION(KTS:KTE) ::  QGSTEN            ! GRAUPEL SED TEND (KG/KG/S)
      REAL, DIMENSION(KTS:KTE) ::  QRSTEN            ! RAIN SED TEND (KG/KG/S)
      REAL, DIMENSION(KTS:KTE) ::  QISTEN            ! CLOUD ICE SED TEND (KG/KG/S)
      REAL, DIMENSION(KTS:KTE) ::  QNISTEN           ! SNOW SED TEND (KG/KG/S)
      REAL, DIMENSION(KTS:KTE) ::  QCSTEN            ! CLOUD WAT SED TEND (KG/KG/S)      

! hm add cumulus tendencies for precip
        REAL, DIMENSION(KTS:KTE) ::   qrcu1d
        REAL, DIMENSION(KTS:KTE) ::   qscu1d
        REAL, DIMENSION(KTS:KTE) ::   qicu1d

      integer, intent(in) :: neweqts

! OUTPUT VARIABLES

        REAL PRECRT                ! TOTAL PRECIP PER TIME STEP (mm)
        REAL SNOWRT                ! SNOW PER TIME STEP (mm)

        REAL, DIMENSION(KTS:KTE) ::   EFFC            ! DROPLET EFFECTIVE RADIUS (MICRON)
        REAL, DIMENSION(KTS:KTE) ::   EFFI            ! CLOUD ICE EFFECTIVE RADIUS (MICRON)
        REAL, DIMENSION(KTS:KTE) ::   EFFS            ! SNOW EFFECTIVE RADIUS (MICRON)
        REAL, DIMENSION(KTS:KTE) ::   EFFR            ! RAIN EFFECTIVE RADIUS (MICRON)
        REAL, DIMENSION(KTS:KTE) ::   EFFG            ! GRAUPEL EFFECTIVE RADIUS (MICRON)

! MODEL INPUT PARAMETERS (FORMERLY IN COMMON BLOCKS)

        REAL DT         ! MODEL TIME STEP (SEC)

!.....................................................................................................
! LOCAL VARIABLES: ALL PARAMETERS BELOW ARE LOCAL TO SCHEME AND DON'T NEED TO COMMUNICATE WITH THE
! REST OF THE MODEL.

! SIZE PARAMETER VARIABLES

     REAL, DIMENSION(KTS:KTE) :: LAMC          ! SLOPE PARAMETER FOR DROPLETS (M-1)
     REAL, DIMENSION(KTS:KTE) :: LAMI          ! SLOPE PARAMETER FOR CLOUD ICE (M-1)
     REAL, DIMENSION(KTS:KTE) :: LAMS          ! SLOPE PARAMETER FOR SNOW (M-1)
     REAL, DIMENSION(KTS:KTE) :: LAMR          ! SLOPE PARAMETER FOR RAIN (M-1)
     REAL, DIMENSION(KTS:KTE) :: LAMG          ! SLOPE PARAMETER FOR GRAUPEL (M-1)
     REAL, DIMENSION(KTS:KTE) :: CDIST1        ! PSD PARAMETER FOR DROPLETS
     REAL, DIMENSION(KTS:KTE) :: N0I           ! INTERCEPT PARAMETER FOR CLOUD ICE (KG-1 M-1)
     REAL, DIMENSION(KTS:KTE) :: N0S           ! INTERCEPT PARAMETER FOR SNOW (KG-1 M-1)
     REAL, DIMENSION(KTS:KTE) :: N0RR          ! INTERCEPT PARAMETER FOR RAIN (KG-1 M-1)
     REAL, DIMENSION(KTS:KTE) :: N0G           ! INTERCEPT PARAMETER FOR GRAUPEL (KG-1 M-1)
     REAL, DIMENSION(KTS:KTE) :: PGAM          ! SPECTRAL SHAPE PARAMETER FOR DROPLETS

! MICROPHYSICAL PROCESSES

     REAL, DIMENSION(KTS:KTE) ::  NSUBC     ! LOSS OF NC DURING EVAP
     REAL, DIMENSION(KTS:KTE) ::  NSUBI     ! LOSS OF NI DURING SUB.
     REAL, DIMENSION(KTS:KTE) ::  NSUBS     ! LOSS OF NS DURING SUB.
     REAL, DIMENSION(KTS:KTE) ::  NSUBR     ! LOSS OF NR DURING EVAP
     REAL, DIMENSION(KTS:KTE) ::  PRD       ! DEP CLOUD ICE
     REAL, DIMENSION(KTS:KTE) ::  PRE       ! EVAP OF RAIN
     REAL, DIMENSION(KTS:KTE) ::  PRDS      ! DEP SNOW
     REAL, DIMENSION(KTS:KTE) ::  NNUCCC    ! CHANGE N DUE TO CONTACT FREEZ DROPLETS
     REAL, DIMENSION(KTS:KTE) ::  MNUCCC    ! CHANGE Q DUE TO CONTACT FREEZ DROPLETS
     REAL, DIMENSION(KTS:KTE) ::  PRA       ! ACCRETION DROPLETS BY RAIN
     REAL, DIMENSION(KTS:KTE) ::  PRC       ! AUTOCONVERSION DROPLETS
     REAL, DIMENSION(KTS:KTE) ::  PCC       ! COND/EVAP DROPLETS
     REAL, DIMENSION(KTS:KTE) ::  NNUCCD    ! CHANGE N FREEZING AEROSOL (PRIM ICE NUCLEATION)
     REAL, DIMENSION(KTS:KTE) ::  MNUCCD    ! CHANGE Q FREEZING AEROSOL (PRIM ICE NUCLEATION)
     REAL, DIMENSION(KTS:KTE) ::  MNUCCR    ! CHANGE Q DUE TO CONTACT FREEZ RAIN
     REAL, DIMENSION(KTS:KTE) ::  NNUCCR    ! CHANGE N DUE TO CONTACT FREEZ RAIN
     REAL, DIMENSION(KTS:KTE) ::  NPRA      ! CHANGE IN N DUE TO DROPLET ACC BY RAIN
     REAL, DIMENSION(KTS:KTE) ::  NRAGG     ! SELF-COLLECTION OF RAIN
     REAL, DIMENSION(KTS:KTE) ::  NSAGG     ! SELF-COLLECTION OF SNOW
     REAL, DIMENSION(KTS:KTE) ::  NPRC      ! CHANGE NC AUTOCONVERSION DROPLETS
     REAL, DIMENSION(KTS:KTE) ::  NPRC1      ! CHANGE NR AUTOCONVERSION DROPLETS
     REAL, DIMENSION(KTS:KTE) ::  PRAI      ! CHANGE Q AUTOCONVERSION CLOUD ICE
     REAL, DIMENSION(KTS:KTE) ::  PRCI      ! CHANGE Q ACCRETION CLOUD ICE BY SNOW
     REAL, DIMENSION(KTS:KTE) ::  PSACWS    ! CHANGE Q DROPLET ACCRETION BY SNOW
     REAL, DIMENSION(KTS:KTE) ::  NPSACWS   ! CHANGE N DROPLET ACCRETION BY SNOW
     REAL, DIMENSION(KTS:KTE) ::  PSACWI    ! CHANGE Q DROPLET ACCRETION BY CLOUD ICE
     REAL, DIMENSION(KTS:KTE) ::  NPSACWI   ! CHANGE N DROPLET ACCRETION BY CLOUD ICE
     REAL, DIMENSION(KTS:KTE) ::  NPRCI     ! CHANGE N AUTOCONVERSION CLOUD ICE BY SNOW
     REAL, DIMENSION(KTS:KTE) ::  NPRAI     ! CHANGE N ACCRETION CLOUD ICE
     REAL, DIMENSION(KTS:KTE) ::  NMULTS    ! ICE MULT DUE TO RIMING DROPLETS BY SNOW
     REAL, DIMENSION(KTS:KTE) ::  NMULTR    ! ICE MULT DUE TO RIMING RAIN BY SNOW
     REAL, DIMENSION(KTS:KTE) ::  QMULTS    ! CHANGE Q DUE TO ICE MULT DROPLETS/SNOW
     REAL, DIMENSION(KTS:KTE) ::  QMULTR    ! CHANGE Q DUE TO ICE RAIN/SNOW
     REAL, DIMENSION(KTS:KTE) ::  PRACS     ! CHANGE Q RAIN-SNOW COLLECTION
     REAL, DIMENSION(KTS:KTE) ::  NPRACS    ! CHANGE N RAIN-SNOW COLLECTION
     REAL, DIMENSION(KTS:KTE) ::  PCCN      ! CHANGE Q DROPLET ACTIVATION
     REAL, DIMENSION(KTS:KTE) ::  PSMLT     ! CHANGE Q MELTING SNOW TO RAIN
     REAL, DIMENSION(KTS:KTE) ::  EVPMS     ! CHNAGE Q MELTING SNOW EVAPORATING
     REAL, DIMENSION(KTS:KTE) ::  NSMLTS    ! CHANGE N MELTING SNOW
     REAL, DIMENSION(KTS:KTE) ::  NSMLTR    ! CHANGE N MELTING SNOW TO RAIN
! HM ADDED 12/13/06
     REAL, DIMENSION(KTS:KTE) ::  PIACR     ! CHANGE QR, ICE-RAIN COLLECTION
     REAL, DIMENSION(KTS:KTE) ::  NIACR     ! CHANGE N, ICE-RAIN COLLECTION
     REAL, DIMENSION(KTS:KTE) ::  PRACI     ! CHANGE QI, ICE-RAIN COLLECTION
     REAL, DIMENSION(KTS:KTE) ::  PIACRS     ! CHANGE QR, ICE RAIN COLLISION, ADDED TO SNOW
     REAL, DIMENSION(KTS:KTE) ::  NIACRS     ! CHANGE N, ICE RAIN COLLISION, ADDED TO SNOW
     REAL, DIMENSION(KTS:KTE) ::  PRACIS     ! CHANGE QI, ICE RAIN COLLISION, ADDED TO SNOW
     REAL, DIMENSION(KTS:KTE) ::  EPRD      ! SUBLIMATION CLOUD ICE
     REAL, DIMENSION(KTS:KTE) ::  EPRDS     ! SUBLIMATION SNOW
! HM ADDED GRAUPEL PROCESSES
     REAL, DIMENSION(KTS:KTE) ::  PRACG    ! CHANGE IN Q COLLECTION RAIN BY GRAUPEL
     REAL, DIMENSION(KTS:KTE) ::  PSACWG    ! CHANGE IN Q COLLECTION DROPLETS BY GRAUPEL
     REAL, DIMENSION(KTS:KTE) ::  PGSACW    ! CONVERSION Q TO GRAUPEL DUE TO COLLECTION DROPLETS BY SNOW
     REAL, DIMENSION(KTS:KTE) ::  PGRACS    ! CONVERSION Q TO GRAUPEL DUE TO COLLECTION RAIN BY SNOW
     REAL, DIMENSION(KTS:KTE) ::  PRDG    ! DEP OF GRAUPEL
     REAL, DIMENSION(KTS:KTE) ::  EPRDG    ! SUB OF GRAUPEL
     REAL, DIMENSION(KTS:KTE) ::  EVPMG    ! CHANGE Q MELTING OF GRAUPEL AND EVAPORATION
     REAL, DIMENSION(KTS:KTE) ::  PGMLT    ! CHANGE Q MELTING OF GRAUPEL
     REAL, DIMENSION(KTS:KTE) ::  NPRACG    ! CHANGE N COLLECTION RAIN BY GRAUPEL
     REAL, DIMENSION(KTS:KTE) ::  NPSACWG    ! CHANGE N COLLECTION DROPLETS BY GRAUPEL
     REAL, DIMENSION(KTS:KTE) ::  NSCNG    ! CHANGE N CONVERSION TO GRAUPEL DUE TO COLLECTION DROPLETS BY SNOW
     REAL, DIMENSION(KTS:KTE) ::  NGRACS    ! CHANGE N CONVERSION TO GRAUPEL DUE TO COLLECTION RAIN BY SNOW
     REAL, DIMENSION(KTS:KTE) ::  NGMLTG    ! CHANGE N MELTING GRAUPEL
     REAL, DIMENSION(KTS:KTE) ::  NGMLTR    ! CHANGE N MELTING GRAUPEL TO RAIN
     REAL, DIMENSION(KTS:KTE) ::  NSUBG    ! CHANGE N SUB/DEP OF GRAUPEL
     REAL, DIMENSION(KTS:KTE) ::  PSACR    ! CONVERSION DUE TO COLL OF SNOW BY RAIN
     REAL, DIMENSION(KTS:KTE) ::  NMULTG    ! ICE MULT DUE TO ACC DROPLETS BY GRAUPEL
     REAL, DIMENSION(KTS:KTE) ::  NMULTRG    ! ICE MULT DUE TO ACC RAIN BY GRAUPEL
     REAL, DIMENSION(KTS:KTE) ::  QMULTG    ! CHANGE Q DUE TO ICE MULT DROPLETS/GRAUPEL
     REAL, DIMENSION(KTS:KTE) ::  QMULTRG    ! CHANGE Q DUE TO ICE MULT RAIN/GRAUPEL

! TIME-VARYING ATMOSPHERIC PARAMETERS

     REAL, DIMENSION(KTS:KTE) ::   KAP   ! THERMAL CONDUCTIVITY OF AIR
     REAL, DIMENSION(KTS:KTE) ::   EVS   ! SATURATION VAPOR PRESSURE
     REAL, DIMENSION(KTS:KTE) ::   EIS   ! ICE SATURATION VAPOR PRESSURE
     REAL, DIMENSION(KTS:KTE) ::   QVS   ! SATURATION MIXING RATIO
     REAL, DIMENSION(KTS:KTE) ::   QVI   ! ICE SATURATION MIXING RATIO
     REAL, DIMENSION(KTS:KTE) ::   QVQVS ! SAUTRATION RATIO
     REAL, DIMENSION(KTS:KTE) ::   QVQVSI! ICE SATURAION RATIO
     REAL, DIMENSION(KTS:KTE) ::   DV    ! DIFFUSIVITY OF WATER VAPOR IN AIR
     REAL, DIMENSION(KTS:KTE) ::   XXLS  ! LATENT HEAT OF SUBLIMATION
     REAL, DIMENSION(KTS:KTE) ::   XXLV  ! LATENT HEAT OF VAPORIZATION
     REAL, DIMENSION(KTS:KTE) ::   CPM   ! SPECIFIC HEAT AT CONST PRESSURE FOR MOIST AIR
     ! GHB
     REAL :: cvm
     REAL, DIMENSION(KTS:KTE) ::   ecnd,edep,efrz
     ! GHB
     REAL, DIMENSION(KTS:KTE) ::   MU    ! VISCOCITY OF AIR
     REAL, DIMENSION(KTS:KTE) ::   SC    ! SCHMIDT NUMBER
     REAL, DIMENSION(KTS:KTE) ::   XLF   ! LATENT HEAT OF FREEZING
     REAL, DIMENSION(KTS:KTE) ::   RHO   ! AIR DENSITY
     REAL, DIMENSION(KTS:KTE) ::   AB    ! CORRECTION TO CONDENSATION RATE DUE TO LATENT HEATING
     REAL, DIMENSION(KTS:KTE) ::   ABI    ! CORRECTION TO DEPOSITION RATE DUE TO LATENT HEATING

! TIME-VARYING MICROPHYSICS PARAMETERS

     REAL, DIMENSION(KTS:KTE) ::   DAP    ! DIFFUSIVITY OF AEROSOL
     REAL    NACNT                    ! NUMBER OF CONTACT IN
     REAL    FMULT                    ! TEMP.-DEP. PARAMETER FOR RIME-SPLINTERING
     REAL    COFFI                    ! ICE AUTOCONVERSION PARAMETER

! FALL SPEED WORKING VARIABLES (DEFINED IN CODE)

      REAL, DIMENSION(KTS:KTE) ::    DUMI,DUMR,DUMFNI,DUMG,DUMFNG
      REAL UNI, UMI,UMR
      REAL, DIMENSION(KTS:KTE) ::    FR, FI, FNI,FG,FNG
      REAL RGVM
      REAL, DIMENSION(KTS:KTE) ::   FALOUTR,FALOUTI,FALOUTNI
      REAL FALTNDR,FALTNDI,FALTNDNI,RHO2
      REAL, DIMENSION(KTS:KTE) ::   DUMQS,DUMFNS
      REAL UMS,UNS
      REAL, DIMENSION(KTS:KTE) ::   FS,FNS, FALOUTS,FALOUTNS,FALOUTG,FALOUTNG
      REAL FALTNDS,FALTNDNS,UNR,FALTNDG,FALTNDNG
      REAL, DIMENSION(KTS:KTE) ::    DUMC,DUMFNC
      REAL UNC,UMC,UNG,UMG
      REAL, DIMENSION(KTS:KTE) ::   FC,FALOUTC,FALOUTNC
      REAL FALTNDC,FALTNDNC
      REAL, DIMENSION(KTS:KTE) ::   FNC,DUMFNR,FALOUTNR
      REAL FALTNDNR
      REAL, DIMENSION(KTS:KTE) ::   FNR

! FALL-SPEED PARAMETER 'A' WITH AIR DENSITY CORRECTION

      REAL, DIMENSION(KTS:KTE) ::    AIN,ARN,ASN,ACN,AGN

! EXTERNAL FUNCTION CALL RETURN VARIABLES

!      REAL GAMMA,      ! EULER GAMMA FUNCTION
!      REAL POLYSVP,    ! SAT. PRESSURE FUNCTION
!      REAL DERF1        ! ERROR FUNCTION

! DUMMY VARIABLES

     REAL DUM,DUM1,DUM2,DUMT,DUMQV,DUMQSS,DUMQSI,DUMS

! PROGNOSTIC SUPERSATURATION

     REAL DQSDT    ! CHANGE OF SAT. MIX. RAT. WITH TEMPERATURE
     REAL DQSIDT   ! CHANGE IN ICE SAT. MIXING RAT. WITH T
     REAL EPSI     ! 1/PHASE REL. TIME (SEE M2005), ICE
     REAL EPSS     ! 1/PHASE REL. TIME (SEE M2005), SNOW
     REAL EPSR     ! 1/PHASE REL. TIME (SEE M2005), RAIN
     REAL EPSG     ! 1/PHASE REL. TIME (SEE M2005), GRAUPEL

! NEW DROPLET ACTIVATION VARIABLES
     REAL TAUC     ! PHASE REL. TIME (SEE M2005), DROPLETS
     REAL TAUR     ! PHASE REL. TIME (SEE M2005), RAIN
     REAL TAUI     ! PHASE REL. TIME (SEE M2005), CLOUD ICE
     REAL TAUS     ! PHASE REL. TIME (SEE M2005), SNOW
     REAL TAUG     ! PHASE REL. TIME (SEE M2005), GRAUPEL
     REAL DUMACT,DUM3

! COUNTING/INDEX VARIABLES

     INTEGER K,NSTEP,N ! ,I

! LTRUE IS ONLY USED TO SPEED UP THE CODE !!
! LTRUE, SWITCH = 0, NO HYDROMETEORS IN COLUMN, 
!               = 1, HYDROMETEORS IN COLUMN

      INTEGER LTRUE

! DROPLET ACTIVATION/FREEZING AEROSOL


     REAL    CT      ! DROPLET ACTIVATION PARAMETER
     REAL    TEMP1   ! DUMMY TEMPERATURE
     REAL    SAT1    ! DUMMY SATURATION
     REAL    SIGVL   ! SURFACE TENSION LIQ/VAPOR
     REAL    KEL     ! KELVIN PARAMETER
     REAL    KC2     ! TOTAL ICE NUCLEATION RATE

       REAL CRY,KRY   ! AEROSOL ACTIVATION PARAMETERS

! MORE WORKING/DUMMY VARIABLES

     REAL DUMQI,DUMNI,DC0,DS0,DG0
     REAL DUMQC,DUMQR,RATIO,SUM_DEP,FUDGEF

! EFFECTIVE VERTICAL VELOCITY  (M/S)
     REAL WEF

! WORKING PARAMETERS FOR ICE NUCLEATION

      REAL ANUC,BNUC

! WORKING PARAMETERS FOR AEROSOL ACTIVATION

        REAL AACT,GAMM,GG,PSI,ETA1,ETA2,SM1,SM2,SMAX,UU1,UU2,ALPHA

! DUMMY SIZE DISTRIBUTION PARAMETERS

        REAL DLAMS,DLAMR,DLAMI,DLAMC,DLAMG,LAMMAX,LAMMIN

        INTEGER IDROP

! DROPLET CONCENTRATION AND ITS TENDENCY
! NOTE: CURRENTLY DROPLET CONCENTRATION IS SPECIFIED !!!!!
! TENDENCY OF NC IS CALCULATED BUT IT IS NOT USED !!!
       REAL, DIMENSION(KTS:KTE) ::  NC3DTEN            ! CLOUD DROPLET NUMBER CONCENTRATION (1/KG/S)
       REAL, DIMENSION(KTS:KTE) ::  NC3D               ! CLOUD DROPLET NUMBER CONCENTRATION (1/KG)

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

! SET LTRUE INITIALLY TO 0

         LTRUE = 0

! ATMOSPHERIC PARAMETERS THAT VARY IN TIME AND HEIGHT
         DO K = KTS,KTE

! NC3DTEN LOCAL ARRAY INITIALIZED
               NC3DTEN(K) = 0.

! LATENT HEAT OF VAPORATION

            XXLV(K) = 3.1484E6-2370.*T3D(K)

! LATENT HEAT OF SUBLIMATION

            XXLS(K) = 3.15E6-2370.*T3D(K)+0.3337E6

            CPM(K) = CP*(1.+0.887*QV3D(K))

            ! GHB
            if(neweqts.ge.1)then
              cvm = cv+cvv*qv3d(k)+cpl*(qc3d(k)+qr3d(k))   &
                                  +cpi*(qi3d(k)+qni3d(k)+qg3d(k))
              ecnd(k) = (XXLV(K)-RV*T3D(K))/cvm
              edep(k) = (XXLS(K)-RV*T3D(K))/cvm
              efrz(k) = (XXLS(K)-XXLV(K))/cvm
            else
              ecnd(k) = XXLV(K)/CPM(K)
              edep(k) = XXLS(K)/CPM(K)
              efrz(k) = (XXLS(K)-XXLV(K))/CPM(K)
            endif
            ! GHB

! SATURATION VAPOR PRESSURE AND MIXING RATIO

! hm, add fix for low pressure, 5/12/10
            EVS(K) = min(0.99*pres(k),POLYSVP(T3D(K),0))   ! PA
            EIS(K) = min(0.99*pres(k),POLYSVP(T3D(K),1))   ! PA

! MAKE SURE ICE SATURATION DOESN'T EXCEED WATER SAT. NEAR FREEZING

            IF (EIS(K).GT.EVS(K)) EIS(K) = EVS(K)

            QVS(K) = EP_2*EVS(K)/(PRES(K)-EVS(K))
            QVI(K) = EP_2*EIS(K)/(PRES(K)-EIS(K))

            QVQVS(K) = QV3D(K)/QVS(K)
            QVQVSI(K) = QV3D(K)/QVI(K)

! AIR DENSITY

            RHO(K) = PRES(K)/(R*T3D(K))

! ADD NUMBER CONCENTRATION DUE TO CUMULUS TENDENCY
! ASSUME N0 ASSOCIATED WITH CUMULUS PARAM RAIN IS 10^7 M^-4
! ASSUME N0 ASSOCIATED WITH CUMULUS PARAM SNOW IS 2 X 10^7 M^-4
! FOR DETRAINED CLOUD ICE, ASSUME MEAN VOLUME DIAM OF 80 MICRON

            IF (QRCU1D(K).GE.1.E-10) THEN
            DUM=1.8e5*(QRCU1D(K)*DT/(PI*RHOW*RHO(K)**3))**0.25
            NR3D(K)=NR3D(K)+DUM
            END IF
            IF (QSCU1D(K).GE.1.E-10) THEN
            DUM=3.e5*(QSCU1D(K)*DT/(CONS1*RHO(K)**3))**(1./(DS+1.))
            NS3D(K)=NS3D(K)+DUM
            END IF
            IF (QICU1D(K).GE.1.E-10) THEN
            DUM=QICU1D(K)*DT/(CI*(80.E-6)**DI)
            NI3D(K)=NI3D(K)+DUM
            END IF

! AT SUBSATURATION, REMOVE SMALL AMOUNTS OF CLOUD/PRECIP WATER
! hm modify 7/0/09 change limit to 1.e-8

             IF (QVQVS(K).LT.0.9) THEN
               IF (QR3D(K).LT.1.E-8) THEN
                  QV3D(K)=QV3D(K)+QR3D(K)
!!!                  T3D(K)=T3D(K)-QR3D(K)*XXLV(K)/CPM(K)
                  T3D(K)=T3D(K)-QR3D(K)*ecnd(k)
                  QR3D(K)=0.
               END IF
               IF (QC3D(K).LT.1.E-8) THEN
                  QV3D(K)=QV3D(K)+QC3D(K)
!!!                  T3D(K)=T3D(K)-QC3D(K)*XXLV(K)/CPM(K)
                  T3D(K)=T3D(K)-QC3D(K)*ecnd(k)
                  QC3D(K)=0.
               END IF
             END IF

             IF (QVQVSI(K).LT.0.9) THEN
               IF (QI3D(K).LT.1.E-8) THEN
                  QV3D(K)=QV3D(K)+QI3D(K)
!!!                  T3D(K)=T3D(K)-QI3D(K)*XXLS(K)/CPM(K)
                  T3D(K)=T3D(K)-QI3D(K)*edep(k)
                  QI3D(K)=0.
               END IF
               IF (QNI3D(K).LT.1.E-8) THEN
                  QV3D(K)=QV3D(K)+QNI3D(K)
!!!                  T3D(K)=T3D(K)-QNI3D(K)*XXLS(K)/CPM(K)
                  T3D(K)=T3D(K)-QNI3D(K)*edep(k)
                  QNI3D(K)=0.
               END IF
               IF (QG3D(K).LT.1.E-8) THEN
                  QV3D(K)=QV3D(K)+QG3D(K)
!!!                  T3D(K)=T3D(K)-QG3D(K)*XXLS(K)/CPM(K)
                  T3D(K)=T3D(K)-QG3D(K)*edep(k)
                  QG3D(K)=0.
               END IF
             END IF

! HEAT OF FUSION

            XLF(K) = XXLS(K)-XXLV(K)

!..................................................................
! IF MIXING RATIO < QSMALL SET MIXING RATIO AND NUMBER CONC TO ZERO

       IF (QC3D(K).LT.QSMALL) THEN
         QC3D(K) = 0.
         NC3D(K) = 0.
         EFFC(K) = 0.
       END IF
       IF (QR3D(K).LT.QSMALL) THEN
         QR3D(K) = 0.
         NR3D(K) = 0.
         EFFR(K) = 0.
       END IF
       IF (QI3D(K).LT.QSMALL) THEN
         QI3D(K) = 0.
         NI3D(K) = 0.
         EFFI(K) = 0.
       END IF
       IF (QNI3D(K).LT.QSMALL) THEN
         QNI3D(K) = 0.
         NS3D(K) = 0.
         EFFS(K) = 0.
       END IF
       IF (QG3D(K).LT.QSMALL) THEN
         QG3D(K) = 0.
         NG3D(K) = 0.
         EFFG(K) = 0.
       END IF

! INITIALIZE SEDIMENTATION TENDENCIES FOR MIXING RATIO

      QRSTEN(K) = 0.
      QISTEN(K) = 0.
      QNISTEN(K) = 0.
      QCSTEN(K) = 0.
      QGSTEN(K) = 0.

!..................................................................
! MICROPHYSICS PARAMETERS VARYING IN TIME/HEIGHT

! FALL SPEED WITH DENSITY CORRECTION (HEYMSFIELD AND BENSSEMER 2006)

            DUM = (RHOSU/RHO(K))**0.54

            AIN(K) = DUM*AI
            ARN(K) = DUM*AR
            ASN(K) = DUM*AS
            ACN(K) = DUM*AC
! HM ADD GRAUPEL 8/28/06
            AGN(K) = DUM*AG

!hm 4/7/09 bug fix, initialize lami to prevent later division by zero
            LAMI(K)=0.

!..................................
! IF THERE IS NO CLOUD/PRECIP WATER, AND IF SUBSATURATED, THEN SKIP MICROPHYSICS
! FOR THIS LEVEL

            IF (QC3D(K).LT.QSMALL.AND.QI3D(K).LT.QSMALL.AND.QNI3D(K).LT.QSMALL &
                 .AND.QR3D(K).LT.QSMALL.AND.QG3D(K).LT.QSMALL) THEN
                 IF (T3D(K).LT.273.15.AND.QVQVSI(K).LT.0.999) GOTO 200
                 IF (T3D(K).GE.273.15.AND.QVQVS(K).LT.0.999) GOTO 200
            END IF

! THERMAL CONDUCTIVITY FOR AIR

            DUM = 1.496E-6*T3D(K)**1.5/(T3D(K)+120.)

!            KAP(K) = 1.414E3*1.496E-6*T3D(K)**1.5/(T3D(K)+120.)
            KAP(K) = 1.414E3*DUM

! DIFFUSIVITY OF WATER VAPOR

            DV(K) = 8.794E-5*T3D(K)**1.81/PRES(K)

! VISCOSITY OF AIR
! SCHMIT NUMBER

!            MU(K) = 1.496E-6*T3D(K)**1.5/(T3D(K)+120.)/RHO(K)
            MU(K) = DUM/RHO(K)
            SC(K) = MU(K)/DV(K)

! PSYCHOMETIC CORRECTIONS

! RATE OF CHANGE SAT. MIX. RATIO WITH TEMPERATURE

            DUM = (RV*T3D(K)**2)

            DQSDT = XXLV(K)*QVS(K)/DUM
            DQSIDT =  XXLS(K)*QVI(K)/DUM

            ABI(K) = 1.+DQSIDT*XXLS(K)/CPM(K)
            AB(K) = 1.+DQSDT*XXLV(K)/CPM(K)

! 
!.....................................................................
!.....................................................................
! CASE FOR TEMPERATURE ABOVE FREEZING

            IF (T3D(K).GE.273.15) THEN

!......................................................................
!HM ADD, ALLOW FOR CONSTANT DROPLET NUMBER
! INUM = 0, PREDICT DROPLET NUMBER
! INUM = 1, SET CONSTANT DROPLET NUMBER

!         IF (INUM.EQ.1) THEN
! CONVERT NDCNST FROM CM-3 TO KG-1
            NC3D(K)=NDCNST*1.E6/RHO(K)
!         END IF

! GET SIZE DISTRIBUTION PARAMETERS

! MELT VERY SMALL SNOW AND GRAUPEL MIXING RATIOS, ADD TO RAIN
       IF (QNI3D(K).LT.1.E-6) THEN
          QR3D(K)=QR3D(K)+QNI3D(K)
          NR3D(K)=NR3D(K)+NS3D(K)
!!!          T3D(K)=T3D(K)-QNI3D(K)*XLF(K)/CPM(K)
          T3D(K)=T3D(K)-QNI3D(K)*efrz(k)
          QNI3D(K) = 0.
          NS3D(K) = 0.
       END IF
       IF (QG3D(K).LT.1.E-6) THEN
          QR3D(K)=QR3D(K)+QG3D(K)
          NR3D(K)=NR3D(K)+NG3D(K)
!!!          T3D(K)=T3D(K)-QG3D(K)*XLF(K)/CPM(K)
          T3D(K)=T3D(K)-QG3D(K)*efrz(k)
          QG3D(K) = 0.
          NG3D(K) = 0.
       END IF

       IF (QC3D(K).LT.QSMALL.AND.QNI3D(K).LT.1.E-8.AND.QR3D(K).LT.QSMALL.AND.QG3D(K).LT.1.E-8) GOTO 300

! MAKE SURE NUMBER CONCENTRATIONS AREN'T NEGATIVE

      NS3D(K) = MAX(0.,NS3D(K))
      NC3D(K) = MAX(0.,NC3D(K))
      NR3D(K) = MAX(0.,NR3D(K))
      NG3D(K) = MAX(0.,NG3D(K))

!......................................................................
! RAIN

      IF (QR3D(K).GE.QSMALL) THEN
      LAMR(K) = (PI*RHOW*NR3D(K)/QR3D(K))**(1./3.)
      N0RR(K) = NR3D(K)*LAMR(K)

! CHECK FOR SLOPE

! ADJUST VARS

      IF (LAMR(K).LT.LAMMINR) THEN

      LAMR(K) = LAMMINR

      N0RR(K) = LAMR(K)**4*QR3D(K)/(PI*RHOW)

      NR3D(K) = N0RR(K)/LAMR(K)
      ELSE IF (LAMR(K).GT.LAMMAXR) THEN
      LAMR(K) = LAMMAXR
      N0RR(K) = LAMR(K)**4*QR3D(K)/(PI*RHOW)

      NR3D(K) = N0RR(K)/LAMR(K)
      END IF
      END IF

!......................................................................
! CLOUD DROPLETS

! MARTIN ET AL. (1994) FORMULA FOR PGAM

      IF (QC3D(K).GE.QSMALL) THEN

         DUM = PRES(K)/(287.15*T3D(K))
         PGAM(K)=0.0005714*(NC3D(K)/1.E6*DUM)+0.2714
         PGAM(K)=1./(PGAM(K)**2)-1.
         PGAM(K)=MAX(PGAM(K),2.)
         PGAM(K)=MIN(PGAM(K),10.)

! CALCULATE LAMC

      LAMC(K) = (CONS26*NC3D(K)*GAMMA(PGAM(K)+4.)/   &
                 (QC3D(K)*GAMMA(PGAM(K)+1.)))**(1./3.)

! LAMMIN, 60 MICRON DIAMETER
! LAMMAX, 1 MICRON

      LAMMIN = (PGAM(K)+1.)/60.E-6
      LAMMAX = (PGAM(K)+1.)/1.E-6

      IF (LAMC(K).LT.LAMMIN) THEN
      LAMC(K) = LAMMIN

      NC3D(K) = EXP(3.*LOG(LAMC(K))+LOG(QC3D(K))+              &
                LOG(GAMMA(PGAM(K)+1.))-LOG(GAMMA(PGAM(K)+4.)))/CONS26
      ELSE IF (LAMC(K).GT.LAMMAX) THEN
      LAMC(K) = LAMMAX

      NC3D(K) = EXP(3.*LOG(LAMC(K))+LOG(QC3D(K))+              &
                LOG(GAMMA(PGAM(K)+1.))-LOG(GAMMA(PGAM(K)+4.)))/CONS26

      END IF

      END IF

!......................................................................
! SNOW

      IF (QNI3D(K).GE.QSMALL) THEN
      LAMS(K) = (CONS1*NS3D(K)/QNI3D(K))**(1./DS)
      N0S(K) = NS3D(K)*LAMS(K)

! CHECK FOR SLOPE

! ADJUST VARS

      IF (LAMS(K).LT.LAMMINS) THEN
      LAMS(K) = LAMMINS
      N0S(K) = LAMS(K)**4*QNI3D(K)/CONS1

      NS3D(K) = N0S(K)/LAMS(K)

      ELSE IF (LAMS(K).GT.LAMMAXS) THEN

      LAMS(K) = LAMMAXS
      N0S(K) = LAMS(K)**4*QNI3D(K)/CONS1

      NS3D(K) = N0S(K)/LAMS(K)
      END IF
      END IF

!......................................................................
! GRAUPEL

      IF (QG3D(K).GE.QSMALL) THEN
      LAMG(K) = (CONS2*NG3D(K)/QG3D(K))**(1./DG)
      N0G(K) = NG3D(K)*LAMG(K)

! ADJUST VARS

      IF (LAMG(K).LT.LAMMING) THEN
      LAMG(K) = LAMMING
      N0G(K) = LAMG(K)**4*QG3D(K)/CONS2

      NG3D(K) = N0G(K)/LAMG(K)

      ELSE IF (LAMG(K).GT.LAMMAXG) THEN

      LAMG(K) = LAMMAXG
      N0G(K) = LAMG(K)**4*QG3D(K)/CONS2

      NG3D(K) = N0G(K)/LAMG(K)
      END IF
      END IF

!.....................................................................
! ZERO OUT PROCESS RATES

            PRC(K) = 0.
            NPRC(K) = 0.
            NPRC1(K) = 0.
            PRA(K) = 0.
            NPRA(K) = 0.
            NRAGG(K) = 0.
            PSMLT(K) = 0.
            NSMLTS(K) = 0.
            NSMLTR(K) = 0.
            EVPMS(K) = 0.
            PCC(K) = 0.
            PRE(K) = 0.
            NSUBC(K) = 0.
            NSUBR(K) = 0.
            PRACG(K) = 0.
            NPRACG(K) = 0.
            PSMLT(K) = 0.
            EVPMS(K) = 0.
            PGMLT(K) = 0.
            EVPMG(K) = 0.
            PRACS(K) = 0.
            NPRACS(K) = 0.
            NGMLTG(K) = 0.
            NGMLTR(K) = 0.

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
! CALCULATION OF MICROPHYSICAL PROCESS RATES, T > 273.15 K

!.................................................................
!.......................................................................
! AUTOCONVERSION OF CLOUD LIQUID WATER TO RAIN
! FORMULA FROM BEHENG (1994)
! USING NUMERICAL SIMULATION OF STOCHASTIC COLLECTION EQUATION
! AND INITIAL CLOUD DROPLET SIZE DISTRIBUTION SPECIFIED
! AS A GAMMA DISTRIBUTION

! USE MINIMUM VALUE OF 1.E-6 TO PREVENT FLOATING POINT ERROR

         IF (QC3D(K).GE.1.E-6) THEN

! HM ADD 12/13/06, REPLACE WITH NEWER FORMULA
! FROM KHAIROUTDINOV AND KOGAN 2000, MWR

                PRC(K)=1350.*QC3D(K)**2.47*  &
           (NC3D(K)/1.e6*RHO(K))**(-1.79)

! note: nprc1 is change in Nr,
! nprc is change in Nc

        NPRC1(K) = PRC(K)/CONS29
        NPRC(K) = PRC(K)/(QC3D(k)/NC3D(K))

                NPRC(K) = MIN(NPRC(K),NC3D(K)/DT)

         END IF

!.......................................................................
! HM ADD 12/13/06, COLLECTION OF SNOW BY RAIN ABOVE FREEZING
! FORMULA FROM IKAWA AND SAITO (1991)

         IF (QR3D(K).GE.1.E-8.AND.QNI3D(K).GE.1.E-8) THEN

            UMS = ASN(K)*CONS3/(LAMS(K)**BS)
            UMR = ARN(K)*CONS4/(LAMR(K)**BR)
            UNS = ASN(K)*CONS5/LAMS(K)**BS
            UNR = ARN(K)*CONS6/LAMR(K)**BR

! SET REASLISTIC LIMITS ON FALLSPEEDS

! bug fix, 10/08/09
            dum=(rhosu/rho(k))**0.54
            UMS=MIN(UMS,1.2*dum)
            UNS=MIN(UNS,1.2*dum)
            UMR=MIN(UMR,9.1*dum)
            UNR=MIN(UNR,9.1*dum)

            PRACS(K) = CONS31*(((1.2*UMR-0.95*UMS)**2+              &
                  0.08*UMS*UMR)**0.5*RHO(K)*                     &
                 N0RR(K)*N0S(K)/LAMS(K)**3*                    &
                  (5./(LAMS(K)**3*LAMR(K))+                    &
                  2./(LAMS(K)**2*LAMR(K)**2)+                  &
                  0.5/(LAMS(K)*LAMR(K)**3)))

            NPRACS(K) = CONS32*RHO(K)*(1.7*(UNR-UNS)**2+            &
                0.3*UNR*UNS)**0.5*N0RR(K)*N0S(K)*              &
                (1./(LAMR(K)**3*LAMS(K))+                      &
                 1./(LAMR(K)**2*LAMS(K)**2)+                   &
                 1./(LAMR(K)*LAMS(K)**3))

         END IF

! ADD COLLECTION OF GRAUPEL BY RAIN ABOVE FREEZING
! ASSUME ALL RAIN COLLECTION BY GRAUPEL ABOVE FREEZING IS SHED
! ASSUME SHED DROPS ARE 1 MM IN SIZE

         IF (QR3D(K).GE.1.E-8.AND.QG3D(K).GE.1.E-8) THEN

            UMG = AGN(K)*CONS7/(LAMG(K)**BG)
            UMR = ARN(K)*CONS4/(LAMR(K)**BR)
            UNG = AGN(K)*CONS8/LAMG(K)**BG
            UNR = ARN(K)*CONS6/LAMR(K)**BR

! SET REASLISTIC LIMITS ON FALLSPEEDS
! bug fix, 10/08/09
            dum=(rhosu/rho(k))**0.54
            UMG=MIN(UMG,20.*dum)
            UNG=MIN(UNG,20.*dum)
            UMR=MIN(UMR,9.1*dum)
            UNR=MIN(UNR,9.1*dum)

! PRACG IS MIXING RATIO OF RAIN PER SEC COLLECTED BY GRAUPEL/HAIL
            PRACG(K) = CONS41*(((1.2*UMR-0.95*UMG)**2+                   &
                  0.08*UMG*UMR)**0.5*RHO(K)*                      &
                  N0RR(K)*N0G(K)/LAMR(K)**3*                              &
                  (5./(LAMR(K)**3*LAMG(K))+                    &
                  2./(LAMR(K)**2*LAMG(K)**2)+				   &
				  0.5/(LAMR(k)*LAMG(k)**3)))

! ASSUME 1 MM DROPS ARE SHED, GET NUMBER SHED PER SEC

            DUM = PRACG(K)/5.2E-7

            NPRACG(K) = CONS32*RHO(K)*(1.7*(UNR-UNG)**2+            &
                0.3*UNR*UNG)**0.5*N0RR(K)*N0G(K)*              &
                (1./(LAMR(K)**3*LAMG(K))+                      &
                 1./(LAMR(K)**2*LAMG(K)**2)+                   &
                 1./(LAMR(K)*LAMG(K)**3))

            NPRACG(K)=MAX(NPRACG(K)-DUM,0.)

	    END IF

!.......................................................................
! ACCRETION OF CLOUD LIQUID WATER BY RAIN
! CONTINUOUS COLLECTION EQUATION WITH
! GRAVITATIONAL COLLECTION KERNEL, DROPLET FALL SPEED NEGLECTED

         IF (QR3D(K).GE.1.E-8 .AND. QC3D(K).GE.1.E-8) THEN

! 12/13/06 HM ADD, REPLACE WITH NEWER FORMULA FROM
! KHAIROUTDINOV AND KOGAN 2000, MWR

           DUM=(QC3D(K)*QR3D(K))
           PRA(K) = 67.*(DUM)**1.15
           NPRA(K) = PRA(K)/(QC3D(K)/NC3D(K))

         END IF
!.......................................................................
! SELF-COLLECTION OF RAIN DROPS
! FROM BEHENG(1994)
! FROM NUMERICAL SIMULATION OF THE STOCHASTIC COLLECTION EQUATION
! AS DESCRINED ABOVE FOR AUTOCONVERSION

         IF (QR3D(K).GE.1.E-8) THEN
! include breakup add 10/09/09
            dum1=D_b
            if (1./lamr(k).lt.dum1) then
            dum=1.
            else if (1./lamr(k).ge.dum1) then
            dum=2.-exp(2300.*(1./lamr(k)-dum1))
            end if
!            NRAGG(K) = -8.*NR3D(K)*QR3D(K)*RHO(K)
            NRAGG(K) = -5.78*dum*NR3D(K)*QR3D(K)*RHO(K)
         END IF

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
! CALCULATE EVAP OF RAIN (RUTLEDGE AND HOBBS 1983)

      IF (QR3D(K).GE.QSMALL) THEN
        EPSR = 2.*PI*N0RR(K)*RHO(K)*DV(K)*                           &
                   (F1R/(LAMR(K)*LAMR(K))+                       &
                    F2R*(ARN(K)*RHO(K)/MU(K))**0.5*                      &
                    SC(K)**(1./3.)*CONS9/                   &
                (LAMR(K)**CONS34))
      ELSE
      EPSR = 0.
      END IF

! NO CONDENSATION ONTO RAIN, ONLY EVAP ALLOWED

           IF (QV3D(K).LT.QVS(K)) THEN
              PRE(K) = EPSR*(QV3D(K)-QVS(K))/AB(K)
              PRE(K) = MIN(PRE(K),0.)
           ELSE
              PRE(K) = 0.
           END IF

!.......................................................................
! MELTING OF SNOW

! SNOW MAY PERSITS ABOVE FREEZING, FORMULA FROM RUTLEDGE AND HOBBS, 1984
! IF WATER SUPERSATURATION, SNOW MELTS TO FORM RAIN

          IF (QNI3D(K).GE.1.E-8) THEN

! HM, MODIFY FOR V3.2, ADD ACCELERATED MELTING DUE TO COLLISION WITH RAIN
             DUM = -CPW/XLF(K)*T3D(K)*PRACS(K)

             PSMLT(K)=2.*PI*N0S(K)*KAP(K)*(273.15-T3D(K))/       &
                    XLF(K)*RHO(K)*(F1S/(LAMS(K)*LAMS(K))+        &
                    F2S*(ASN(K)*RHO(K)/MU(K))**0.5*                      &
                    SC(K)**(1./3.)*CONS10/                   &
                   (LAMS(K)**CONS35))+DUM

! IN WATER SUBSATURATION, SNOW MELTS AND EVAPORATES

      IF (QVQVS(K).LT.1.) THEN
        EPSS = 2.*PI*N0S(K)*RHO(K)*DV(K)*                            &
                   (F1S/(LAMS(K)*LAMS(K))+                       &
                    F2S*(ASN(K)*RHO(K)/MU(K))**0.5*                      &
                    SC(K)**(1./3.)*CONS10/                   &
               (LAMS(K)**CONS35))
! hm fix 8/4/08
        EVPMS(K) = (QV3D(K)-QVS(K))*EPSS/AB(K)    
        EVPMS(K) = MAX(EVPMS(K),PSMLT(K))
        PSMLT(K) = PSMLT(K)-EVPMS(K)
      END IF
      END IF

!.......................................................................
! MELTING OF GRAUPEL

! GRAUPEL MAY PERSITS ABOVE FREEZING, FORMULA FROM RUTLEDGE AND HOBBS, 1984
! IF WATER SUPERSATURATION, GRAUPEL MELTS TO FORM RAIN

          IF (QG3D(K).GE.1.E-8) THEN

! HM, MODIFY FOR V3.2, ADD ACCELERATED MELTING DUE TO COLLISION WITH RAIN
             DUM = -CPW/XLF(K)*T3D(K)*PRACG(K)

             PGMLT(K)=2.*PI*N0G(K)*KAP(K)*(273.15-T3D(K))/ 		 &
                    XLF(K)*RHO(K)*(F1S/(LAMG(K)*LAMG(K))+                &
                    F2S*(AGN(K)*RHO(K)/MU(K))**0.5*                      &
                    SC(K)**(1./3.)*CONS11/                   &
                   (LAMG(K)**CONS36))+DUM

! IN WATER SUBSATURATION, GRAUPEL MELTS AND EVAPORATES

      IF (QVQVS(K).LT.1.) THEN
        EPSG = 2.*PI*N0G(K)*RHO(K)*DV(K)*                                &
                   (F1S/(LAMG(K)*LAMG(K))+                               &
                    F2S*(AGN(K)*RHO(K)/MU(K))**0.5*                      &
                    SC(K)**(1./3.)*CONS11/                   &
               (LAMG(K)**CONS36))
! hm fix 8/4/08
        EVPMG(K) = (QV3D(K)-QVS(K))*EPSG/AB(K)
        EVPMG(K) = MAX(EVPMG(K),PGMLT(K))
        PGMLT(K) = PGMLT(K)-EVPMG(K)
      END IF
      END IF

! HM, V3.2
! RESET PRACG AND PRACS TO ZERO, THIS IS DONE BECAUSE THERE IS NO
! TRANSFER OF MASS FROM SNOW AND GRAUPEL TO RAIN DIRECTLY FROM COLLECTION
! ABOVE FREEZING, IT IS ONLY USED FOR ENHANCEMENT OF MELTING AND SHEDDING

      PRACG(K) = 0.
      PRACS(K) = 0.

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

! FOR CLOUD ICE, ONLY PROCESSES OPERATING AT T > 273.15 IS
! MELTING, WHICH IS ALREADY CONSERVED DURING PROCESS
! CALCULATION

! CONSERVATION OF QC

      DUM = (PRC(K)+PRA(K))*DT

      IF (DUM.GT.QC3D(K).AND.QC3D(K).GE.QSMALL) THEN

        RATIO = QC3D(K)/DUM

        PRC(K) = PRC(K)*RATIO
        PRA(K) = PRA(K)*RATIO

        END IF

! CONSERVATION OF SNOW

        DUM = (-PSMLT(K)-EVPMS(K)+PRACS(K))*DT

        IF (DUM.GT.QNI3D(K).AND.QNI3D(K).GE.QSMALL) THEN

! NO SOURCE TERMS FOR SNOW AT T > FREEZING
        RATIO = QNI3D(K)/DUM

        PSMLT(K) = PSMLT(K)*RATIO
        EVPMS(K) = EVPMS(K)*RATIO
        PRACS(K) = PRACS(K)*RATIO

        END IF

! CONSERVATION OF GRAUPEL

        DUM = (-PGMLT(K)-EVPMG(K)+PRACG(K))*DT

        IF (DUM.GT.QG3D(K).AND.QG3D(K).GE.QSMALL) THEN

! NO SOURCE TERM FOR GRAUPEL ABOVE FREEZING
        RATIO = QG3D(K)/DUM

        PGMLT(K) = PGMLT(K)*RATIO
        EVPMG(K) = EVPMG(K)*RATIO
        PRACG(K) = PRACG(K)*RATIO

        END IF

! CONSERVATION OF QR
! HM 12/13/06, ADDED CONSERVATION OF RAIN SINCE PRE IS NEGATIVE

        DUM = (-PRACS(K)-PRACG(K)-PRE(K)-PRA(K)-PRC(K)+PSMLT(K)+PGMLT(K))*DT

        IF (DUM.GT.QR3D(K).AND.QR3D(K).GE.QSMALL) THEN

        RATIO = (QR3D(K)/DT+PRACS(K)+PRACG(K)+PRA(K)+PRC(K)-PSMLT(K)-PGMLT(K))/ &
                        (-PRE(K))
        PRE(K) = PRE(K)*RATIO
        
        END IF

!....................................

      QV3DTEN(K) = QV3DTEN(K)+(-PRE(K)-EVPMS(K)-EVPMG(K))

!!!      T3DTEN(K) = T3DTEN(K)+(PRE(K)*XXLV(K)+(EVPMS(K)+EVPMG(K))*XXLS(K)+&
!!!                    (PSMLT(K)+PGMLT(K)-PRACS(K)-PRACG(K))*XLF(K))/CPM(K)
      T3DTEN(K) = T3DTEN(K)+(PRE(K)*ecnd(k)+(EVPMS(K)+EVPMG(K))*edep(k)+&
                    (PSMLT(K)+PGMLT(K)-PRACS(K)-PRACG(K))*efrz(k))

      QC3DTEN(K) = QC3DTEN(K)+(-PRA(K)-PRC(K))
      QR3DTEN(K) = QR3DTEN(K)+(PRE(K)+PRA(K)+PRC(K)-PSMLT(K)-PGMLT(K)+PRACS(K)+PRACG(K))
      QNI3DTEN(K) = QNI3DTEN(K)+(PSMLT(K)+EVPMS(K)-PRACS(K))
      QG3DTEN(K) = QG3DTEN(K)+(PGMLT(K)+EVPMG(K)-PRACG(K))
      NS3DTEN(K) = NS3DTEN(K)-NPRACS(K)
! HM, bug fix 5/12/08, npracg is subtracted from nr not ng
!      NG3DTEN(K) = NG3DTEN(K)
      NC3DTEN(K) = NC3DTEN(K)+ (-NPRA(K)-NPRC(K))
      NR3DTEN(K) = NR3DTEN(K)+ (NPRC1(K)+NRAGG(K)-NPRACG(K))

      IF (PRE(K).LT.0.) THEN
         DUM = PRE(K)*DT/QR3D(K)
           DUM = MAX(-1.,DUM)
         NSUBR(K) = DUM*NR3D(K)/DT
      END IF

        IF (EVPMS(K)+PSMLT(K).LT.0.) THEN
         DUM = (EVPMS(K)+PSMLT(K))*DT/QNI3D(K)
           DUM = MAX(-1.,DUM)
         NSMLTS(K) = DUM*NS3D(K)/DT
        END IF
        IF (PSMLT(K).LT.0.) THEN
          DUM = PSMLT(K)*DT/QNI3D(K)
          DUM = MAX(-1.0,DUM)
          NSMLTR(K) = DUM*NS3D(K)/DT
        END IF
        IF (EVPMG(K)+PGMLT(K).LT.0.) THEN
         DUM = (EVPMG(K)+PGMLT(K))*DT/QG3D(K)
           DUM = MAX(-1.,DUM)
         NGMLTG(K) = DUM*NG3D(K)/DT
        END IF
        IF (PGMLT(K).LT.0.) THEN
          DUM = PGMLT(K)*DT/QG3D(K)
          DUM = MAX(-1.0,DUM)
          NGMLTR(K) = DUM*NG3D(K)/DT
        END IF

         NS3DTEN(K) = NS3DTEN(K)+(NSMLTS(K))
         NG3DTEN(K) = NG3DTEN(K)+(NGMLTG(K))
         NR3DTEN(K) = NR3DTEN(K)+(NSUBR(K)-NSMLTR(K)-NGMLTR(K))

 300  CONTINUE

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
! NOW CALCULATE SATURATION ADJUSTMENT TO CONDENSE EXTRA VAPOR ABOVE
! WATER SATURATION

      !---- move to solve ...  GHB, 090930
!!!      DUMT = T3D(K)+DT*T3DTEN(K)
!!!      DUMQV = QV3D(K)+DT*QV3DTEN(K)
!!!! hm, add fix for low pressure, 5/12/10
!!!      dum=min(0.99*pres(k),POLYSVP(DUMT,0))
!!!      DUMQSS = EP_2*dum/(PRES(K)-dum)
!!!      DUMQC = QC3D(K)+DT*QC3DTEN(K)
!!!      DUMQC = MAX(DUMQC,0.)
!!!
!!!! SATURATION ADJUSTMENT FOR LIQUID
!!!
!!!      DUMS = DUMQV-DUMQSS
!!!      PCC(K) = DUMS/(1.+XXLV(K)**2*DUMQSS/(CPM(K)*RV*DUMT**2))/DT
!!!      IF (PCC(K)*DT+DUMQC.LT.0.) THEN
!!!           PCC(K) = -DUMQC/DT
!!!      END IF
!!!
!!!      QV3DTEN(K) = QV3DTEN(K)-PCC(K)
!!!!!!      T3DTEN(K) = T3DTEN(K)+PCC(K)*XXLV(K)/CPM(K)
!!!      T3DTEN(K) = T3DTEN(K)+PCC(K)*ecnd(k)
!!!      QC3DTEN(K) = QC3DTEN(K)+PCC(K)
      ! GHB

!.......................................................................
! ACTIVATION OF CLOUD DROPLETS
! ACTIVATION OF DROPLET CURRENTLY NOT CALCULATED
! DROPLET CONCENTRATION IS SPECIFIED !!!!!

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
! SUBLIMATE, MELT, OR EVAPORATE NUMBER CONCENTRATION
! THIS FORMULATION ASSUMES 1:1 RATIO BETWEEN MASS LOSS AND
! LOSS OF NUMBER CONCENTRATION

!     IF (PCC(K).LT.0.) THEN
!        DUM = PCC(K)*DT/QC3D(K)
!           DUM = MAX(-1.,DUM)
!        NSUBC(K) = DUM*NC3D(K)/DT
!     END IF

! UPDATE TENDENCIES

!        NC3DTEN(K) = NC3DTEN(K)+NSUBC(K)

!.....................................................................
!.....................................................................
         ELSE  ! TEMPERATURE < 273.15

!......................................................................
!HM ADD, ALLOW FOR CONSTANT DROPLET NUMBER
! INUM = 0, PREDICT DROPLET NUMBER
! INUM = 1, SET CONSTANT DROPLET NUMBER

!         IF (INUM.EQ.1) THEN
! CONVERT NDCNST FROM CM-3 TO KG-1
            NC3D(K)=NDCNST*1.E6/RHO(K)
!         END IF

! CALCULATE SIZE DISTRIBUTION PARAMETERS
! MAKE SURE NUMBER CONCENTRATIONS AREN'T NEGATIVE

      NI3D(K) = MAX(0.,NI3D(K))
      NS3D(K) = MAX(0.,NS3D(K))
      NC3D(K) = MAX(0.,NC3D(K))
      NR3D(K) = MAX(0.,NR3D(K))
      NG3D(K) = MAX(0.,NG3D(K))

!......................................................................
! CLOUD ICE

      IF (QI3D(K).GE.QSMALL) THEN
         LAMI(K) = (CONS12*                 &
              NI3D(K)/QI3D(K))**(1./DI)
         N0I(K) = NI3D(K)*LAMI(K)

! CHECK FOR SLOPE

! ADJUST VARS

      IF (LAMI(K).LT.LAMMINI) THEN

      LAMI(K) = LAMMINI

      N0I(K) = LAMI(K)**4*QI3D(K)/CONS12

      NI3D(K) = N0I(K)/LAMI(K)
      ELSE IF (LAMI(K).GT.LAMMAXI) THEN
      LAMI(K) = LAMMAXI
      N0I(K) = LAMI(K)**4*QI3D(K)/CONS12

      NI3D(K) = N0I(K)/LAMI(K)
      END IF
      END IF

!......................................................................
! RAIN

      IF (QR3D(K).GE.QSMALL) THEN
      LAMR(K) = (PI*RHOW*NR3D(K)/QR3D(K))**(1./3.)
      N0RR(K) = NR3D(K)*LAMR(K)

! CHECK FOR SLOPE

! ADJUST VARS

      IF (LAMR(K).LT.LAMMINR) THEN

      LAMR(K) = LAMMINR

      N0RR(K) = LAMR(K)**4*QR3D(K)/(PI*RHOW)

      NR3D(K) = N0RR(K)/LAMR(K)
      ELSE IF (LAMR(K).GT.LAMMAXR) THEN
      LAMR(K) = LAMMAXR
      N0RR(K) = LAMR(K)**4*QR3D(K)/(PI*RHOW)

      NR3D(K) = N0RR(K)/LAMR(K)
      END IF
      END IF

!......................................................................
! CLOUD DROPLETS

! MARTIN ET AL. (1994) FORMULA FOR PGAM

      IF (QC3D(K).GE.QSMALL) THEN

         DUM = PRES(K)/(287.15*T3D(K))
         PGAM(K)=0.0005714*(NC3D(K)/1.E6*DUM)+0.2714
         PGAM(K)=1./(PGAM(K)**2)-1.
         PGAM(K)=MAX(PGAM(K),2.)
         PGAM(K)=MIN(PGAM(K),10.)

! CALCULATE LAMC

      LAMC(K) = (CONS26*NC3D(K)*GAMMA(PGAM(K)+4.)/   &
                 (QC3D(K)*GAMMA(PGAM(K)+1.)))**(1./3.)

! LAMMIN, 60 MICRON DIAMETER
! LAMMAX, 1 MICRON

      LAMMIN = (PGAM(K)+1.)/60.E-6
      LAMMAX = (PGAM(K)+1.)/1.E-6

      IF (LAMC(K).LT.LAMMIN) THEN
      LAMC(K) = LAMMIN

      NC3D(K) = EXP(3.*LOG(LAMC(K))+LOG(QC3D(K))+              &
                LOG(GAMMA(PGAM(K)+1.))-LOG(GAMMA(PGAM(K)+4.)))/CONS26
      ELSE IF (LAMC(K).GT.LAMMAX) THEN
      LAMC(K) = LAMMAX
      NC3D(K) = EXP(3.*LOG(LAMC(K))+LOG(QC3D(K))+              &
                LOG(GAMMA(PGAM(K)+1.))-LOG(GAMMA(PGAM(K)+4.)))/CONS26

      END IF

! TO CALCULATE DROPLET FREEZING

        CDIST1(K) = NC3D(K)/GAMMA(PGAM(K)+1.)

      END IF

!......................................................................
! SNOW

      IF (QNI3D(K).GE.QSMALL) THEN
      LAMS(K) = (CONS1*NS3D(K)/QNI3D(K))**(1./DS)
      N0S(K) = NS3D(K)*LAMS(K)

! CHECK FOR SLOPE

! ADJUST VARS

      IF (LAMS(K).LT.LAMMINS) THEN
      LAMS(K) = LAMMINS
      N0S(K) = LAMS(K)**4*QNI3D(K)/CONS1

      NS3D(K) = N0S(K)/LAMS(K)

      ELSE IF (LAMS(K).GT.LAMMAXS) THEN

      LAMS(K) = LAMMAXS
      N0S(K) = LAMS(K)**4*QNI3D(K)/CONS1

      NS3D(K) = N0S(K)/LAMS(K)
      END IF
      END IF

!......................................................................
! GRAUPEL

      IF (QG3D(K).GE.QSMALL) THEN
      LAMG(K) = (CONS2*NG3D(K)/QG3D(K))**(1./DG)
      N0G(K) = NG3D(K)*LAMG(K)

! CHECK FOR SLOPE

! ADJUST VARS

      IF (LAMG(K).LT.LAMMING) THEN
      LAMG(K) = LAMMING
      N0G(K) = LAMG(K)**4*QG3D(K)/CONS2

      NG3D(K) = N0G(K)/LAMG(K)

      ELSE IF (LAMG(K).GT.LAMMAXG) THEN

      LAMG(K) = LAMMAXG
      N0G(K) = LAMG(K)**4*QG3D(K)/CONS2

      NG3D(K) = N0G(K)/LAMG(K)
      END IF
      END IF

!.....................................................................
! ZERO OUT PROCESS RATES

            MNUCCC(K) = 0.
            NNUCCC(K) = 0.
            PRC(K) = 0.
            NPRC(K) = 0.
            NPRC1(K) = 0.
            NSAGG(K) = 0.
            PSACWS(K) = 0.
            NPSACWS(K) = 0.
            PSACWI(K) = 0.
            NPSACWI(K) = 0.
            PRACS(K) = 0.
            NPRACS(K) = 0.
            NMULTS(K) = 0.
            QMULTS(K) = 0.
            NMULTR(K) = 0.
            QMULTR(K) = 0.
            NMULTG(K) = 0.
            QMULTG(K) = 0.
            NMULTRG(K) = 0.
            QMULTRG(K) = 0.
            MNUCCR(K) = 0.
            NNUCCR(K) = 0.
            PRA(K) = 0.
            NPRA(K) = 0.
            NRAGG(K) = 0.
            PRCI(K) = 0.
            NPRCI(K) = 0.
            PRAI(K) = 0.
            NPRAI(K) = 0.
            NNUCCD(K) = 0.
            MNUCCD(K) = 0.
            PCC(K) = 0.
            PRE(K) = 0.
            PRD(K) = 0.
            PRDS(K) = 0.
            EPRD(K) = 0.
            EPRDS(K) = 0.
            NSUBC(K) = 0.
            NSUBI(K) = 0.
            NSUBS(K) = 0.
            NSUBR(K) = 0.
            PIACR(K) = 0.
            NIACR(K) = 0.
            PRACI(K) = 0.
            PIACRS(K) = 0.
            NIACRS(K) = 0.
            PRACIS(K) = 0.
! HM: ADD GRAUPEL PROCESSES
            PRACG(K) = 0.
            PSACR(K) = 0.
	    PSACWG(K) = 0.
	    PGSACW(K) = 0.
            PGRACS(K) = 0.
	    PRDG(K) = 0.
	    EPRDG(K) = 0.
	    NPRACG(K) = 0.
	    NPSACWG(K) = 0.
	    NSCNG(K) = 0.
 	    NGRACS(K) = 0.
	    NSUBG(K) = 0.

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
! CALCULATION OF MICROPHYSICAL PROCESS RATES
! ACCRETION/AUTOCONVERSION/FREEZING/MELTING/COAG.
!.......................................................................
! FREEZING OF CLOUD DROPLETS
! ONLY ALLOWED BELOW -4 C
        IF (QC3D(K).GE.QSMALL .AND. T3D(K).LT.269.15) THEN

! NUMBER OF CONTACT NUCLEI (M^-3) FROM MEYERS ET AL., 1992
! FACTOR OF 1000 IS TO CONVERT FROM L^-1 TO M^-3

! MEYERS CURVE

           NACNT = EXP(-2.80+0.262*(273.15-T3D(K)))*1000.

! COOPER CURVE
!        NACNT =  5.*EXP(0.304*(273.15-T3D(K)))

! FLECTHER
!     NACNT = 0.01*EXP(0.6*(273.15-T3D(K)))

! CONTACT FREEZING

! MEAN FREE PATH

            DUM = 7.37*T3D(K)/(288.*10.*PRES(K))/100.

! EFFECTIVE DIFFUSIVITY OF CONTACT NUCLEI
! BASED ON BROWNIAN DIFFUSION

            DAP(K) = CONS37*T3D(K)*(1.+DUM/RIN)/MU(K)
 
           MNUCCC(K) = CONS38*DAP(K)*NACNT*EXP(LOG(CDIST1(K))+   &
                   LOG(GAMMA(PGAM(K)+5.))-4.*LOG(LAMC(K)))
           NNUCCC(K) = 2.*PI*DAP(K)*NACNT*CDIST1(K)*           &
                    GAMMA(PGAM(K)+2.)/                         &
                    LAMC(K)

! IMMERSION FREEZING (BIGG 1953)

           MNUCCC(K) = MNUCCC(K)+CONS39*                   &
                  EXP(LOG(CDIST1(K))+LOG(GAMMA(7.+PGAM(K)))-6.*LOG(LAMC(K)))*             &
                   EXP(AIMM*(273.15-T3D(K)))

           NNUCCC(K) = NNUCCC(K)+                                  &
            CONS40*EXP(LOG(CDIST1(K))+LOG(GAMMA(PGAM(K)+4.))-3.*LOG(LAMC(K)))              &
                *EXP(AIMM*(273.15-T3D(K)))

! PUT IN A CATCH HERE TO PREVENT DIVERGENCE BETWEEN NUMBER CONC. AND
! MIXING RATIO, SINCE STRICT CONSERVATION NOT CHECKED FOR NUMBER CONC

           NNUCCC(K) = MIN(NNUCCC(K),NC3D(K)/DT)

        END IF

!.................................................................
!.......................................................................
! AUTOCONVERSION OF CLOUD LIQUID WATER TO RAIN
! FORMULA FROM BEHENG (1994)
! USING NUMERICAL SIMULATION OF STOCHASTIC COLLECTION EQUATION
! AND INITIAL CLOUD DROPLET SIZE DISTRIBUTION SPECIFIED
! AS A GAMMA DISTRIBUTION

! USE MINIMUM VALUE OF 1.E-6 TO PREVENT FLOATING POINT ERROR

         IF (QC3D(K).GE.1.E-6) THEN

! HM ADD 12/13/06, REPLACE WITH NEWER FORMULA
! FROM KHAIROUTDINOV AND KOGAN 2000, MWR

                PRC(K)=1350.*QC3D(K)**2.47*  &
           (NC3D(K)/1.e6*RHO(K))**(-1.79)

! note: nprc1 is change in Nr,
! nprc is change in Nc

        NPRC1(K) = PRC(K)/CONS29
        NPRC(K) = PRC(K)/(QC3D(K)/NC3D(K))

                NPRC(K) = MIN(NPRC(K),NC3D(K)/DT)

         END IF

!.......................................................................
! SELF-COLLECTION OF DROPLET NOT INCLUDED IN KK2000 SCHEME

! SNOW AGGREGATION FROM PASSARELLI, 1978, USED BY REISNER, 1998
! THIS IS HARD-WIRED FOR BS = 0.4 FOR NOW

         IF (QNI3D(K).GE.1.E-8) THEN
             NSAGG(K) = CONS15*ASN(K)*RHO(K)**            &
            ((2.+BS)/3.)*QNI3D(K)**((2.+BS)/3.)*                  &
            (NS3D(K)*RHO(K))**((4.-BS)/3.)/                       &
            (RHO(K))
         END IF

!.......................................................................
! ACCRETION OF CLOUD DROPLETS ONTO SNOW/GRAUPEL
! HERE USE CONTINUOUS COLLECTION EQUATION WITH
! SIMPLE GRAVITATIONAL COLLECTION KERNEL IGNORING

! SNOW

         IF (QNI3D(K).GE.1.E-8 .AND. QC3D(K).GE.QSMALL) THEN

           PSACWS(K) = CONS13*ASN(K)*QC3D(K)*RHO(K)*               &
                  N0S(K)/                        &
                  LAMS(K)**(BS+3.)
           NPSACWS(K) = CONS13*ASN(K)*NC3D(K)*RHO(K)*              &
                  N0S(K)/                        &
                  LAMS(K)**(BS+3.)

         END IF

!............................................................................
! COLLECTION OF CLOUD WATER BY GRAUPEL

         IF (QG3D(K).GE.1.E-8 .AND. QC3D(K).GE.QSMALL) THEN

           PSACWG(K) = CONS14*AGN(K)*QC3D(K)*RHO(K)*               &
                  N0G(K)/                        &
                  LAMG(K)**(BG+3.)
           NPSACWG(K) = CONS14*AGN(K)*NC3D(K)*RHO(K)*              &
                  N0G(K)/                        &
                  LAMG(K)**(BG+3.)
	    END IF

!.......................................................................
! HM, ADD 12/13/06
! CLOUD ICE COLLECTING DROPLETS, ASSUME THAT CLOUD ICE MEAN DIAM > 100 MICRON
! BEFORE RIMING CAN OCCUR
! ASSUME THAT RIME COLLECTED ON CLOUD ICE DOES NOT LEAD
! TO HALLET-MOSSOP SPLINTERING

         IF (QI3D(K).GE.1.E-8 .AND. QC3D(K).GE.QSMALL) THEN

! PUT IN SIZE DEPENDENT COLLECTION EFFICIENCY BASED ON STOKES LAW
! FROM THOMPSON ET AL. 2004, MWR

            IF (1./LAMI(K).GE.100.E-6) THEN

           PSACWI(K) = CONS16*AIN(K)*QC3D(K)*RHO(K)*               &
                  N0I(K)/                        &
                  LAMI(K)**(BI+3.)
           NPSACWI(K) = CONS16*AIN(K)*NC3D(K)*RHO(K)*              &
                  N0I(K)/                        &
                  LAMI(K)**(BI+3.)
           END IF
         END IF

!.......................................................................
! ACCRETION OF RAIN WATER BY SNOW
! FORMULA FROM IKAWA AND SAITO, 1991, USED BY REISNER ET AL, 1998

         IF (QR3D(K).GE.1.E-8.AND.QNI3D(K).GE.1.E-8) THEN

            UMS = ASN(K)*CONS3/(LAMS(K)**BS)
            UMR = ARN(K)*CONS4/(LAMR(K)**BR)
            UNS = ASN(K)*CONS5/LAMS(K)**BS
            UNR = ARN(K)*CONS6/LAMR(K)**BR

! SET REASLISTIC LIMITS ON FALLSPEEDS

! bug fix, 10/08/09
            dum=(rhosu/rho(k))**0.54
            UMS=MIN(UMS,1.2*dum)
            UNS=MIN(UNS,1.2*dum)
            UMR=MIN(UMR,9.1*dum)
            UNR=MIN(UNR,9.1*dum)

            PRACS(K) = CONS41*(((1.2*UMR-0.95*UMS)**2+                   &
                  0.08*UMS*UMR)**0.5*RHO(K)*                      &
                  N0RR(K)*N0S(K)/LAMR(K)**3*                              &
                  (5./(LAMR(K)**3*LAMS(K))+                    &
                  2./(LAMR(K)**2*LAMS(K)**2)+                  &				 
                  0.5/(LAMR(k)*LAMS(k)**3)))

            NPRACS(K) = CONS32*RHO(K)*(1.7*(UNR-UNS)**2+            &
                0.3*UNR*UNS)**0.5*N0RR(K)*N0S(K)*              &
                (1./(LAMR(K)**3*LAMS(K))+                      &
                 1./(LAMR(K)**2*LAMS(K)**2)+                   &
                 1./(LAMR(K)*LAMS(K)**3))

! MAKE SURE PRACS DOESN'T EXCEED TOTAL RAIN MIXING RATIO
! AS THIS MAY OTHERWISE RESULT IN TOO MUCH TRANSFER OF WATER DURING
! RIME-SPLINTERING

            PRACS(K) = MIN(PRACS(K),QR3D(K)/DT)

! COLLECTION OF SNOW BY RAIN - NEEDED FOR GRAUPEL CONVERSION CALCULATIONS
! ONLY CALCULATE IF SNOW AND RAIN MIXING RATIOS EXCEED 0.1 G/KG

! ASSUME COLLECTION OF SNOW BY RAIN PRODUCES GRAUPEL NOT HAIL

! HM MODIFY FOR WRFV3.1
!            IF (IHAIL.EQ.0) THEN
            IF (QNI3D(K).GE.0.1E-3.AND.QR3D(K).GE.0.1E-3) THEN
            PSACR(K) = CONS31*(((1.2*UMR-0.95*UMS)**2+              &
                  0.08*UMS*UMR)**0.5*RHO(K)*                     &
                 N0RR(K)*N0S(K)/LAMS(K)**3*                               &
                  (5./(LAMS(K)**3*LAMR(K))+                    &
                  2./(LAMS(K)**2*LAMR(K)**2)+                  &
                  0.5/(LAMS(K)*LAMR(K)**3)))            
            END IF
!            END IF

         END IF

!.......................................................................

! COLLECTION OF RAINWATER BY GRAUPEL, FROM IKAWA AND SAITO 1990, 
! USED BY REISNER ET AL 1998
         IF (QR3D(K).GE.1.E-8.AND.QG3D(K).GE.1.E-8) THEN

            UMG = AGN(K)*CONS7/(LAMG(K)**BG)
            UMR = ARN(K)*CONS4/(LAMR(K)**BR)
            UNG = AGN(K)*CONS8/LAMG(K)**BG
            UNR = ARN(K)*CONS6/LAMR(K)**BR

! SET REASLISTIC LIMITS ON FALLSPEEDS
! bug fix, 10/08/09
            dum=(rhosu/rho(k))**0.54
            UMG=MIN(UMG,20.*dum)
            UNG=MIN(UNG,20.*dum)
            UMR=MIN(UMR,9.1*dum)
            UNR=MIN(UNR,9.1*dum)

            PRACG(K) = CONS41*(((1.2*UMR-0.95*UMG)**2+                   &
                  0.08*UMG*UMR)**0.5*RHO(K)*                      &
                  N0RR(K)*N0G(K)/LAMR(K)**3*                              &
                  (5./(LAMR(K)**3*LAMG(K))+                    &
                  2./(LAMR(K)**2*LAMG(K)**2)+				   &
				  0.5/(LAMR(k)*LAMG(k)**3)))

            NPRACG(K) = CONS32*RHO(K)*(1.7*(UNR-UNG)**2+            &
                0.3*UNR*UNG)**0.5*N0RR(K)*N0G(K)*              &
                (1./(LAMR(K)**3*LAMG(K))+                      &
                 1./(LAMR(K)**2*LAMG(K)**2)+                   &
                 1./(LAMR(K)*LAMG(K)**3))

! MAKE SURE PRACG DOESN'T EXCEED TOTAL RAIN MIXING RATIO
! AS THIS MAY OTHERWISE RESULT IN TOO MUCH TRANSFER OF WATER DURING
! RIME-SPLINTERING

            PRACG(K) = MIN(PRACG(K),QR3D(K)/DT)

	    END IF

!.......................................................................
! RIME-SPLINTERING - SNOW
! HALLET-MOSSOP (1974)
! NUMBER OF SPLINTERS FORMED IS BASED ON MASS OF RIMED WATER

! DUM1 = MASS OF INDIVIDUAL SPLINTERS

! HM ADD THRESHOLD SNOW AND DROPLET MIXING RATIO FOR RIME-SPLINTERING
! TO LIMIT RIME-SPLINTERING IN STRATIFORM CLOUDS
! THESE THRESHOLDS CORRESPOND WITH GRAUPEL THRESHOLDS IN RH 1984

!v1.4
         IF (QNI3D(K).GE.0.1E-3) THEN
         IF (QC3D(K).GE.0.5E-3.OR.QR3D(K).GE.0.1E-3) THEN
         IF (PSACWS(K).GT.0..OR.PRACS(K).GT.0.) THEN
            IF (T3D(K).LT.270.16 .AND. T3D(K).GT.265.16) THEN

               IF (T3D(K).GT.270.16) THEN
                  FMULT = 0.
               ELSE IF (T3D(K).LE.270.16.AND.T3D(K).GT.268.16)  THEN
                  FMULT = (270.16-T3D(K))/2.
               ELSE IF (T3D(K).GE.265.16.AND.T3D(K).LE.268.16)   THEN
                  FMULT = (T3D(K)-265.16)/3.
               ELSE IF (T3D(K).LT.265.16) THEN
                  FMULT = 0.
               END IF

! 1000 IS TO CONVERT FROM KG TO G

! SPLINTERING FROM DROPLETS ACCRETED ONTO SNOW

               IF (PSACWS(K).GT.0.) THEN
                  NMULTS(K) = 35.E4*PSACWS(K)*FMULT*1000.
                  QMULTS(K) = NMULTS(K)*MMULT

! CONSTRAIN SO THAT TRANSFER OF MASS FROM SNOW TO ICE CANNOT BE MORE MASS
! THAN WAS RIMED ONTO SNOW

                  QMULTS(K) = MIN(QMULTS(K),PSACWS(K))
                  PSACWS(K) = PSACWS(K)-QMULTS(K)

               END IF

! RIMING AND SPLINTERING FROM ACCRETED RAINDROPS

               IF (PRACS(K).GT.0.) THEN
                   NMULTR(K) = 35.E4*PRACS(K)*FMULT*1000.
                   QMULTR(K) = NMULTR(K)*MMULT

! CONSTRAIN SO THAT TRANSFER OF MASS FROM SNOW TO ICE CANNOT BE MORE MASS
! THAN WAS RIMED ONTO SNOW

                   QMULTR(K) = MIN(QMULTR(K),PRACS(K))

                   PRACS(K) = PRACS(K)-QMULTR(K)

               END IF

            END IF
         END IF
         END IF
         END IF

!.......................................................................
! RIME-SPLINTERING - GRAUPEL 
! HALLET-MOSSOP (1974)
! NUMBER OF SPLINTERS FORMED IS BASED ON MASS OF RIMED WATER

! DUM1 = MASS OF INDIVIDUAL SPLINTERS

! HM ADD THRESHOLD SNOW MIXING RATIO FOR RIME-SPLINTERING
! TO LIMIT RIME-SPLINTERING IN STRATIFORM CLOUDS

! ONLY CALCULATE FOR GRAUPEL NOT HAIL
!         IF (IHAIL.EQ.0) THEN
! v1.4
         IF (QG3D(K).GE.0.1E-3) THEN
         IF (QC3D(K).GE.0.5E-3.OR.QR3D(K).GE.0.1E-3) THEN
         IF (PSACWG(K).GT.0..OR.PRACG(K).GT.0.) THEN
            IF (T3D(K).LT.270.16 .AND. T3D(K).GT.265.16) THEN

               IF (T3D(K).GT.270.16) THEN
                  FMULT = 0.
               ELSE IF (T3D(K).LE.270.16.AND.T3D(K).GT.268.16)  THEN
                  FMULT = (270.16-T3D(K))/2.
               ELSE IF (T3D(K).GE.265.16.AND.T3D(K).LE.268.16)   THEN
                  FMULT = (T3D(K)-265.16)/3.
               ELSE IF (T3D(K).LT.265.16) THEN
                  FMULT = 0.
               END IF

! 1000 IS TO CONVERT FROM KG TO G

! SPLINTERING FROM DROPLETS ACCRETED ONTO GRAUPEL

               IF (PSACWG(K).GT.0.) THEN
                  NMULTG(K) = 35.E4*PSACWG(K)*FMULT*1000.
                  QMULTG(K) = NMULTG(K)*MMULT

! CONSTRAIN SO THAT TRANSFER OF MASS FROM GRAUPEL TO ICE CANNOT BE MORE MASS
! THAN WAS RIMED ONTO GRAUPEL

                  QMULTG(K) = MIN(QMULTG(K),PSACWG(K))
                  PSACWG(K) = PSACWG(K)-QMULTG(K)

               END IF

! RIMING AND SPLINTERING FROM ACCRETED RAINDROPS

               IF (PRACG(K).GT.0.) THEN
                   NMULTRG(K) = 35.E4*PRACG(K)*FMULT*1000.
                   QMULTRG(K) = NMULTRG(K)*MMULT

! CONSTRAIN SO THAT TRANSFER OF MASS FROM GRAUPEL TO ICE CANNOT BE MORE MASS
! THAN WAS RIMED ONTO GRAUPEL

                   QMULTRG(K) = MIN(QMULTRG(K),PRACG(K))
                   PRACG(K) = PRACG(K)-QMULTRG(K)

               END IF
               END IF
               END IF
            END IF
            END IF
!         END IF

!........................................................................
! CONVERSION OF RIMED CLOUD WATER ONTO SNOW TO GRAUPEL
! ASSUME CONVERTED SNOW FORMS GRAUPEL NOT HAIL
! HAIL ASSUMED TO ONLY FORM BY FREEZING OF RAIN
! OR COLLISIONS OF RAIN WITH CLOUD ICE

!           IF (IHAIL.EQ.0) THEN
	   IF (PSACWS(K).GT.0.) THEN
! ONLY ALLOW CONVERSION IF QNI > 0.1 AND QC > 0.5 G/KG FOLLOWING RUTLEDGE AND HOBBS (1984)
              IF (QNI3D(K).GE.0.1E-3.AND.QC3D(K).GE.0.5E-3) THEN

! PORTION OF RIMING CONVERTED TO GRAUPEL (REISNER ET AL. 1998, ORIGINALLY IS1991)
	     PGSACW(K) = MIN(PSACWS(K),CONS17*DT*N0S(K)*QC3D(K)*QC3D(K)* &
                          ASN(K)*ASN(K)/ &
                           (RHO(K)*LAMS(K)**(2.*BS+2.))) 

! MIX RAT CONVERTED INTO GRAUPEL AS EMBRYO (REISNER ET AL. 1998, ORIG M1990)
	     DUM = MAX(RHOSN/(RHOG-RHOSN)*PGSACW(K),0.) 

! NUMBER CONCENTRAITON OF EMBRYO GRAUPEL FROM RIMING OF SNOW
	     NSCNG(K) = DUM/MG0*RHO(K)
! LIMIT MAX NUMBER CONVERTED TO SNOW NUMBER
             NSCNG(K) = MIN(NSCNG(K),NS3D(K)/DT)

! PORTION OF RIMING LEFT FOR SNOW
             PSACWS(K) = PSACWS(K) - PGSACW(K)
             END IF
	   END IF

! CONVERSION OF RIMED RAINWATER ONTO SNOW CONVERTED TO GRAUPEL

	   IF (PRACS(K).GT.0.) THEN
! ONLY ALLOW CONVERSION IF QNI > 0.1 AND QR > 0.1 G/KG FOLLOWING RUTLEDGE AND HOBBS (1984)
              IF (QNI3D(K).GE.0.1E-3.AND.QR3D(K).GE.0.1E-3) THEN
! PORTION OF COLLECTED RAINWATER CONVERTED TO GRAUPEL (REISNER ET AL. 1998)
	      DUM = CONS18*(4./LAMS(K))**3*(4./LAMS(K))**3 &    
                   /(CONS18*(4./LAMS(K))**3*(4./LAMS(K))**3+ &  
                   CONS19*(4./LAMR(K))**3*(4./LAMR(K))**3)
              DUM=MIN(DUM,1.)
              DUM=MAX(DUM,0.)
	      PGRACS(K) = (1.-DUM)*PRACS(K)
            NGRACS(K) = (1.-DUM)*NPRACS(K)
! LIMIT MAX NUMBER CONVERTED TO MIN OF EITHER RAIN OR SNOW NUMBER CONCENTRATION
            NGRACS(K) = MIN(NGRACS(K),NR3D(K)/DT)
            NGRACS(K) = MIN(NGRACS(K),NS3D(K)/DT)

! AMOUNT LEFT FOR SNOW PRODUCTION
            PRACS(K) = PRACS(K) - PGRACS(K)
            NPRACS(K) = NPRACS(K) - NGRACS(K)
! CONVERSION TO GRAUPEL DUE TO COLLECTION OF SNOW BY RAIN
            PSACR(K)=PSACR(K)*(1.-DUM)
            END IF
	   END IF
!           END IF

!.......................................................................
! FREEZING OF RAIN DROPS
! FREEZING ALLOWED BELOW -4 C

         IF (T3D(K).LT.269.15.AND.QR3D(K).GE.QSMALL) THEN

! IMMERSION FREEZING (BIGG 1953)
            MNUCCR(K) = CONS20*NR3D(K)*EXP(AIMM*(273.15-T3D(K)))/LAMR(K)**3 &
                 /LAMR(K)**3

            NNUCCR(K) = PI*NR3D(K)*BIMM*EXP(AIMM*(273.15-T3D(K)))/LAMR(K)**3

! PREVENT DIVERGENCE BETWEEN MIXING RATIO AND NUMBER CONC
            NNUCCR(K) = MIN(NNUCCR(K),NR3D(K)/DT)

         END IF

!.......................................................................
! ACCRETION OF CLOUD LIQUID WATER BY RAIN
! CONTINUOUS COLLECTION EQUATION WITH
! GRAVITATIONAL COLLECTION KERNEL, DROPLET FALL SPEED NEGLECTED

         IF (QR3D(K).GE.1.E-8 .AND. QC3D(K).GE.1.E-8) THEN

! 12/13/06 HM ADD, REPLACE WITH NEWER FORMULA FROM
! KHAIROUTDINOV AND KOGAN 2000, MWR

           DUM=(QC3D(K)*QR3D(K))
           PRA(K) = 67.*(DUM)**1.15
           NPRA(K) = PRA(K)/(QC3D(K)/NC3D(K))

         END IF
!.......................................................................
! SELF-COLLECTION OF RAIN DROPS
! FROM BEHENG(1994)
! FROM NUMERICAL SIMULATION OF THE STOCHASTIC COLLECTION EQUATION
! AS DESCRINED ABOVE FOR AUTOCONVERSION

         IF (QR3D(K).GE.1.E-8) THEN
! include breakup add 10/09/09
            dum1=D_b
            if (1./lamr(k).lt.dum1) then
            dum=1.
            else if (1./lamr(k).ge.dum1) then
            dum=2.-exp(2300.*(1./lamr(k)-dum1))
            end if
!            NRAGG(K) = -8.*NR3D(K)*QR3D(K)*RHO(K)
            NRAGG(K) = -5.78*dum*NR3D(K)*QR3D(K)*RHO(K)
         END IF

!.......................................................................
! AUTOCONVERSION OF CLOUD ICE TO SNOW
! FOLLOWING HARRINGTON ET AL. (1995) WITH MODIFICATION
! HERE IT IS ASSUMED THAT AUTOCONVERSION CAN ONLY OCCUR WHEN THE
! ICE IS GROWING, I.E. IN CONDITIONS OF ICE SUPERSATURATION

         IF (QI3D(K).GE.1.E-8 .AND.QVQVSI(K).GE.1.) THEN

!           COFFI = 2./LAMI(K)
!           IF (COFFI.GE.DCS) THEN
              NPRCI(K) = CONS21*(QV3D(K)-QVI(K))*RHO(K)                         &
                *N0I(K)*EXP(-LAMI(K)*DCS)*DV(K)/ABI(K)
              PRCI(K) = CONS22*NPRCI(K)
              NPRCI(K) = MIN(NPRCI(K),NI3D(K)/DT)

!           END IF
         END IF

!.......................................................................
! ACCRETION OF CLOUD ICE BY SNOW
! FOR THIS CALCULATION, IT IS ASSUMED THAT THE VS >> VI
! AND DS >> DI FOR CONTINUOUS COLLECTION

         IF (QNI3D(K).GE.1.E-8 .AND. QI3D(K).GE.QSMALL) THEN
            PRAI(K) = CONS23*ASN(K)*QI3D(K)*RHO(K)*N0S(K)/     &
                     LAMS(K)**(BS+3.)
            NPRAI(K) = CONS23*ASN(K)*NI3D(K)*                                       &
                  RHO(K)*N0S(K)/                                 &
                  LAMS(K)**(BS+3.)
            NPRAI(K)=MIN(NPRAI(K),NI3D(K)/DT)
         END IF

!.......................................................................
! HM, ADD 12/13/06, COLLISION OF RAIN AND ICE TO PRODUCE SNOW OR GRAUPEL
! FOLLOWS REISNER ET AL. 1998
! ASSUMED FALLSPEED AND SIZE OF ICE CRYSTAL << THAN FOR RAIN

         IF (QR3D(K).GE.1.E-8.AND.QI3D(K).GE.1.E-8.AND.T3D(K).LE.273.15) THEN

! ALLOW GRAUPEL FORMATION FROM RAIN-ICE COLLISIONS ONLY IF RAIN MIXING RATIO > 0.1 G/KG,
! OTHERWISE ADD TO SNOW

            IF (QR3D(K).GE.0.1E-3) THEN
            NIACR(K)=CONS24*NI3D(K)*N0RR(K)*ARN(K) &
                /LAMR(K)**(BR+3.)*RHO(K)
            PIACR(K)=CONS25*NI3D(K)*N0RR(K)*ARN(K) &
                /LAMR(K)**(BR+3.)/LAMR(K)**3*RHO(K)
            PRACI(K)=CONS24*QI3D(K)*N0RR(K)*ARN(K)/ &
                LAMR(K)**(BR+3.)*RHO(K)
            NIACR(K)=MIN(NIACR(K),NR3D(K)/DT)
            NIACR(K)=MIN(NIACR(K),NI3D(K)/DT)
            ELSE 
            NIACRS(K)=CONS24*NI3D(K)*N0RR(K)*ARN(K) &
                /LAMR(K)**(BR+3.)*RHO(K)
            PIACRS(K)=CONS25*NI3D(K)*N0RR(K)*ARN(K) &
                /LAMR(K)**(BR+3.)/LAMR(K)**3*RHO(K)
            PRACIS(K)=CONS24*QI3D(K)*N0RR(K)*ARN(K)/ &
                LAMR(K)**(BR+3.)*RHO(K)
            NIACRS(K)=MIN(NIACRS(K),NR3D(K)/DT)
            NIACRS(K)=MIN(NIACRS(K),NI3D(K)/DT)
            END IF
         END IF

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
! NUCLEATION OF CLOUD ICE FROM HOMOGENEOUS AND HETEROGENEOUS FREEZING ON AEROSOL

         IF (INUC.EQ.0) THEN

! FREEZING OF AEROSOL ONLY ALLOWED BELOW -5 C
! AND ABOVE DELIQUESCENCE THRESHOLD OF 80%
! AND ABOVE ICE SATURATION

! add threshold according to Greg Thomspon

         if ((QVQVS(K).GE.0.999.and.T3D(K).le.265.15).or. &
              QVQVSI(K).ge.1.08) then

! hm, modify dec. 5, 2006, replace with cooper curve
      kc2 = 0.005*exp(0.304*(273.15-T3D(K)))*1000. ! convert from L-1 to m-3
! limit to 500 L-1
      kc2 = min(kc2,500.e3)
      kc2=MAX(kc2/rho(k),0.)  ! convert to kg-1

          IF (KC2.GT.NI3D(K)+NS3D(K)+NG3D(K)) THEN
             NNUCCD(K) = (KC2-NI3D(K)-NS3D(K)-NG3D(K))/DT
             MNUCCD(K) = NNUCCD(K)*MI0
          END IF

          END IF

          ELSE IF (INUC.EQ.1) THEN

          IF (T3D(K).LT.273.15.AND.QVQVSI(K).GT.1.) THEN

             KC2 = 0.16*1000./RHO(K)  ! CONVERT FROM L-1 TO KG-1
          IF (KC2.GT.NI3D(K)+NS3D(K)+NG3D(K)) THEN
             NNUCCD(K) = (KC2-NI3D(K)-NS3D(K)-NG3D(K))/DT
             MNUCCD(K) = NNUCCD(K)*MI0
          END IF
          END IF

         END IF

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

 101      CONTINUE

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
! CALCULATE EVAP/SUB/DEP TERMS FOR QI,QNI,QR

! NO VENTILATION FOR CLOUD ICE

        IF (QI3D(K).GE.QSMALL) THEN

         EPSI = 2.*PI*N0I(K)*RHO(K)*DV(K)/(LAMI(K)*LAMI(K))

      ELSE
         EPSI = 0.
      END IF

      IF (QNI3D(K).GE.QSMALL) THEN
        EPSS = 2.*PI*N0S(K)*RHO(K)*DV(K)*                            &
                   (F1S/(LAMS(K)*LAMS(K))+                       &
                    F2S*(ASN(K)*RHO(K)/MU(K))**0.5*                      &
                    SC(K)**(1./3.)*CONS10/                   &
               (LAMS(K)**CONS35))
      ELSE
      EPSS = 0.
      END IF

      IF (QG3D(K).GE.QSMALL) THEN
        EPSG = 2.*PI*N0G(K)*RHO(K)*DV(K)*                                &
                   (F1S/(LAMG(K)*LAMG(K))+                               &
                    F2S*(AGN(K)*RHO(K)/MU(K))**0.5*                      &
                    SC(K)**(1./3.)*CONS11/                   &
               (LAMG(K)**CONS36))


      ELSE
      EPSG = 0.
      END IF

      IF (QR3D(K).GE.QSMALL) THEN
        EPSR = 2.*PI*N0RR(K)*RHO(K)*DV(K)*                           &
                   (F1R/(LAMR(K)*LAMR(K))+                       &
                    F2R*(ARN(K)*RHO(K)/MU(K))**0.5*                      &
                    SC(K)**(1./3.)*CONS9/                   &
                (LAMR(K)**CONS34))
      ELSE
      EPSR = 0.
      END IF

! ONLY INCLUDE REGION OF ICE SIZE DIST < DCS
! DUM IS FRACTION OF D*N(D) < DCS

! LOGIC BELOW FOLLOWS THAT OF HARRINGTON ET AL. 1995 (JAS)
              IF (QI3D(K).GE.QSMALL) THEN              
              DUM=(1.-EXP(-LAMI(K)*DCS)*(1.+LAMI(K)*DCS))
              PRD(K) = EPSI*(QV3D(K)-QVI(K))/ABI(K)*DUM
              ELSE
              DUM=0.
              END IF
! ADD DEPOSITION IN TAIL OF ICE SIZE DIST TO SNOW IF SNOW IS PRESENT
              IF (QNI3D(K).GE.QSMALL) THEN
              PRDS(K) = EPSS*(QV3D(K)-QVI(K))/ABI(K)+ &
                EPSI*(QV3D(K)-QVI(K))/ABI(K)*(1.-DUM)
! OTHERWISE ADD TO CLOUD ICE
              ELSE
              PRD(K) = PRD(K)+EPSI*(QV3D(K)-QVI(K))/ABI(K)*(1.-DUM)
              END IF
! VAPOR DPEOSITION ON GRAUPEL
              PRDG(K) = EPSG*(QV3D(K)-QVI(K))/ABI(K)

! NO CONDENSATION ONTO RAIN, ONLY EVAP

           IF (QV3D(K).LT.QVS(K)) THEN
              PRE(K) = EPSR*(QV3D(K)-QVS(K))/AB(K)
              PRE(K) = MIN(PRE(K),0.)
           ELSE
              PRE(K) = 0.
           END IF

! MAKE SURE NOT PUSHED INTO ICE SUPERSAT/SUBSAT
! FORMULA FROM REISNER 2 SCHEME

           DUM = (QV3D(K)-QVI(K))/DT

           FUDGEF = 0.9999
           SUM_DEP = PRD(K)+PRDS(K)+MNUCCD(K)+PRDG(K)

           IF( (DUM.GT.0. .AND. SUM_DEP.GT.DUM*FUDGEF) .OR.                      &
               (DUM.LT.0. .AND. SUM_DEP.LT.DUM*FUDGEF) ) THEN
               MNUCCD(K) = FUDGEF*MNUCCD(K)*DUM/SUM_DEP
               PRD(K) = FUDGEF*PRD(K)*DUM/SUM_DEP
               PRDS(K) = FUDGEF*PRDS(K)*DUM/SUM_DEP
	       PRDG(K) = FUDGEF*PRDG(K)*DUM/SUM_DEP
           ENDIF

! IF CLOUD ICE/SNOW/GRAUPEL VAP DEPOSITION IS NEG, THEN ASSIGN TO SUBLIMATION PROCESSES

           IF (PRD(K).LT.0.) THEN
              EPRD(K)=PRD(K)
              PRD(K)=0.
           END IF
           IF (PRDS(K).LT.0.) THEN
              EPRDS(K)=PRDS(K)
              PRDS(K)=0.
           END IF
           IF (PRDG(K).LT.0.) THEN
              EPRDG(K)=PRDG(K)
              PRDG(K)=0.
           END IF

!.......................................................................
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

! CONSERVATION OF WATER
! THIS IS ADOPTED LOOSELY FROM MM5 RESINER CODE. HOWEVER, HERE WE
! ONLY ADJUST PROCESSES THAT ARE NEGATIVE, RATHER THAN ALL PROCESSES.

! IF MIXING RATIOS LESS THAN QSMALL, THEN NO DEPLETION OF WATER
! THROUGH MICROPHYSICAL PROCESSES, SKIP CONSERVATION

! NOTE: CONSERVATION CHECK NOT APPLIED TO NUMBER CONCENTRATION SPECIES. ADDITIONAL CATCH
! BELOW WILL PREVENT NEGATIVE NUMBER CONCENTRATION
! FOR EACH MICROPHYSICAL PROCESS WHICH PROVIDES A SOURCE FOR NUMBER, THERE IS A CHECK
! TO MAKE SURE THAT CAN'T EXCEED TOTAL NUMBER OF DEPLETED SPECIES WITH THE TIME
! STEP

!****SENSITIVITY - NO ICE

      IF (ILIQ.EQ.1) THEN
      MNUCCC(K)=0.
      NNUCCC(K)=0.
      MNUCCR(K)=0.
      NNUCCR(K)=0.
      MNUCCD(K)=0.
      NNUCCD(K)=0.
      END IF

! ****SENSITIVITY - NO GRAUPEL
      IF (IGRAUP.EQ.1) THEN
            PRACG(K) = 0.
            PSACR(K) = 0.
	    PSACWG(K) = 0.
	    PGSACW(K) = 0.
            PGRACS(K) = 0.
	    PRDG(K) = 0.
	    EPRDG(K) = 0.
            EVPMG(K) = 0.
            PGMLT(K) = 0.
	    NPRACG(K) = 0.
	    NPSACWG(K) = 0.
	    NSCNG(K) = 0.
 	    NGRACS(K) = 0.
	    NSUBG(K) = 0.
	    NGMLTG(K) = 0.
            NGMLTR(K) = 0.
       END IF

! CONSERVATION OF QC

      DUM = (PRC(K)+PRA(K)+MNUCCC(K)+PSACWS(K)+PSACWI(K)+QMULTS(K)+PSACWG(K)+PGSACW(K)+QMULTG(K))*DT

      IF (DUM.GT.QC3D(K).AND.QC3D(K).GE.QSMALL) THEN
        RATIO = QC3D(K)/DUM

        PRC(K) = PRC(K)*RATIO
        PRA(K) = PRA(K)*RATIO
        MNUCCC(K) = MNUCCC(K)*RATIO
        PSACWS(K) = PSACWS(K)*RATIO
        PSACWI(K) = PSACWI(K)*RATIO
        QMULTS(K) = QMULTS(K)*RATIO
        QMULTG(K) = QMULTG(K)*RATIO
        PSACWG(K) = PSACWG(K)*RATIO
	PGSACW(K) = PGSACW(K)*RATIO
        END IF
 
! CONSERVATION OF QI

      DUM = (-PRD(K)-MNUCCC(K)+PRCI(K)+PRAI(K)-QMULTS(K)-QMULTG(K)-QMULTR(K)-QMULTRG(K) &
                -MNUCCD(K)+PRACI(K)+PRACIS(K)-EPRD(K)-PSACWI(K))*DT

      IF (DUM.GT.QI3D(K).AND.QI3D(K).GE.QSMALL) THEN

        RATIO = (QI3D(K)/DT+PRD(K)+MNUCCC(K)+QMULTS(K)+QMULTG(K)+QMULTR(K)+QMULTRG(K)+ &
                     MNUCCD(K)+PSACWI(K))/ &
                      (PRCI(K)+PRAI(K)+PRACI(K)+PRACIS(K)-EPRD(K))

        PRCI(K) = PRCI(K)*RATIO
        PRAI(K) = PRAI(K)*RATIO
        PRACI(K) = PRACI(K)*RATIO
        PRACIS(K) = PRACIS(K)*RATIO
        EPRD(K) = EPRD(K)*RATIO

        END IF

! CONSERVATION OF QR

      DUM=((PRACS(K)-PRE(K))+(QMULTR(K)+QMULTRG(K)-PRC(K))+(MNUCCR(K)-PRA(K))+ &
             PIACR(K)+PIACRS(K)+PGRACS(K)+PRACG(K))*DT

      IF (DUM.GT.QR3D(K).AND.QR3D(K).GE.QSMALL) THEN

        RATIO = (QR3D(K)/DT+PRC(K)+PRA(K))/ &
             (-PRE(K)+QMULTR(K)+QMULTRG(K)+PRACS(K)+MNUCCR(K)+PIACR(K)+PIACRS(K)+PGRACS(K)+PRACG(K))

        PRE(K) = PRE(K)*RATIO
        PRACS(K) = PRACS(K)*RATIO
        QMULTR(K) = QMULTR(K)*RATIO
        QMULTRG(K) = QMULTRG(K)*RATIO
        MNUCCR(K) = MNUCCR(K)*RATIO
        PIACR(K) = PIACR(K)*RATIO
        PIACRS(K) = PIACRS(K)*RATIO
        PGRACS(K) = PGRACS(K)*RATIO
        PRACG(K) = PRACG(K)*RATIO

        END IF

! CONSERVATION OF QNI
! CONSERVATION FOR GRAUPEL SCHEME

        IF (IGRAUP.EQ.0) THEN

      DUM = (-PRDS(K)-PSACWS(K)-PRAI(K)-PRCI(K)-PRACS(K)-EPRDS(K)+PSACR(K)-PIACRS(K)-PRACIS(K))*DT

      IF (DUM.GT.QNI3D(K).AND.QNI3D(K).GE.QSMALL) THEN

        RATIO = (QNI3D(K)/DT+PRDS(K)+PSACWS(K)+PRAI(K)+PRCI(K)+PRACS(K)+PIACRS(K)+PRACIS(K))/(-EPRDS(K)+PSACR(K))

       EPRDS(K) = EPRDS(K)*RATIO
       PSACR(K) = PSACR(K)*RATIO

       END IF

! FOR NO GRAUPEL, NEED TO INCLUDE FREEZING OF RAIN FOR SNOW
       ELSE IF (IGRAUP.EQ.1) THEN

      DUM = (-PRDS(K)-PSACWS(K)-PRAI(K)-PRCI(K)-PRACS(K)-EPRDS(K)+PSACR(K)-PIACRS(K)-PRACIS(K)-MNUCCR(K))*DT

      IF (DUM.GT.QNI3D(K).AND.QNI3D(K).GE.QSMALL) THEN

       RATIO = (QNI3D(K)/DT+PRDS(K)+PSACWS(K)+PRAI(K)+PRCI(K)+PRACS(K)+PIACRS(K)+PRACIS(K)+MNUCCR(K))/(-EPRDS(K)+PSACR(K))

       EPRDS(K) = EPRDS(K)*RATIO
       PSACR(K) = PSACR(K)*RATIO

       END IF

       END IF

! CONSERVATION OF QG

      DUM = (-PSACWG(K)-PRACG(K)-PGSACW(K)-PGRACS(K)-PRDG(K)-MNUCCR(K)-EPRDG(K)-PIACR(K)-PRACI(K)-PSACR(K))*DT

      IF (DUM.GT.QG3D(K).AND.QG3D(K).GE.QSMALL) THEN

        RATIO = (QG3D(K)/DT+PSACWG(K)+PRACG(K)+PGSACW(K)+PGRACS(K)+PRDG(K)+MNUCCR(K)+PSACR(K)+&
                  PIACR(K)+PRACI(K))/(-EPRDG(K))

       EPRDG(K) = EPRDG(K)*RATIO

      END IF

! TENDENCIES

      QV3DTEN(K) = QV3DTEN(K)+(-PRE(K)-PRD(K)-PRDS(K)-MNUCCD(K)-EPRD(K)-EPRDS(K)-PRDG(K)-EPRDG(K))
!!!      T3DTEN(K) = T3DTEN(K)+(PRE(K)                                 &
!!!               *XXLV(K)+(PRD(K)+PRDS(K)+                            &
!!!                MNUCCD(K)+EPRD(K)+EPRDS(K)+PRDG(K)+EPRDG(K))*XXLS(K)+         &
!!!               (PSACWS(K)+PSACWI(K)+MNUCCC(K)+MNUCCR(K)+                      &
!!!                QMULTS(K)+QMULTG(K)+QMULTR(K)+QMULTRG(K)+PRACS(K) &
!!!                +PSACWG(K)+PRACG(K)+PGSACW(K)+PGRACS(K))*XLF(K))/CPM(K)
      T3DTEN(K) = T3DTEN(K)+(PRE(K)                                 &
               *ecnd(k)+(PRD(K)+PRDS(K)+                            &
                MNUCCD(K)+EPRD(K)+EPRDS(K)+PRDG(K)+EPRDG(K))*edep(k)+         &
               (PSACWS(K)+PSACWI(K)+MNUCCC(K)+MNUCCR(K)+                      &
                QMULTS(K)+QMULTG(K)+QMULTR(K)+QMULTRG(K)+PRACS(K) &
                +PSACWG(K)+PRACG(K)+PGSACW(K)+PGRACS(K))*efrz(k))

      QC3DTEN(K) = QC3DTEN(K)+                                      &
                 (-PRA(K)-PRC(K)-MNUCCC(K)+PCC(K)-                  &
                  PSACWS(K)-PSACWI(K)-QMULTS(K)-QMULTG(K)-PSACWG(K)-PGSACW(K))
      QI3DTEN(K) = QI3DTEN(K)+                                      &
         (PRD(K)+EPRD(K)+PSACWI(K)+MNUCCC(K)-PRCI(K)-                                 &
                  PRAI(K)+QMULTS(K)+QMULTG(K)+QMULTR(K)+QMULTRG(K)+MNUCCD(K)-PRACI(K)-PRACIS(K))
      QR3DTEN(K) = QR3DTEN(K)+                                      &
                 (PRE(K)+PRA(K)+PRC(K)-PRACS(K)-MNUCCR(K)-QMULTR(K)-QMULTRG(K) &
             -PIACR(K)-PIACRS(K)-PRACG(K)-PGRACS(K))

      IF (IGRAUP.EQ.0) THEN

      QNI3DTEN(K) = QNI3DTEN(K)+                                    &
           (PRAI(K)+PSACWS(K)+PRDS(K)+PRACS(K)+PRCI(K)+EPRDS(K)-PSACR(K)+PIACRS(K)+PRACIS(K))
      NS3DTEN(K) = NS3DTEN(K)+(NSAGG(K)+NPRCI(K)-NSCNG(K)-NGRACS(K)+NIACRS(K))
      QG3DTEN(K) = QG3DTEN(K)+(PRACG(K)+PSACWG(K)+PGSACW(K)+PGRACS(K)+ &
                    PRDG(K)+EPRDG(K)+MNUCCR(K)+PIACR(K)+PRACI(K)+PSACR(K))
      NG3DTEN(K) = NG3DTEN(K)+(NSCNG(K)+NGRACS(K)+NNUCCR(K)+NIACR(K))

! FOR NO GRAUPEL, NEED TO INCLUDE FREEZING OF RAIN FOR SNOW
      ELSE IF (IGRAUP.EQ.1) THEN

      QNI3DTEN(K) = QNI3DTEN(K)+                                    &
           (PRAI(K)+PSACWS(K)+PRDS(K)+PRACS(K)+PRCI(K)+EPRDS(K)-PSACR(K)+PIACRS(K)+PRACIS(K)+MNUCCR(K))
      NS3DTEN(K) = NS3DTEN(K)+(NSAGG(K)+NPRCI(K)-NSCNG(K)-NGRACS(K)+NIACRS(K)+NNUCCR(K))

      END IF

      NC3DTEN(K) = NC3DTEN(K)+(-NNUCCC(K)-NPSACWS(K)                &
            -NPRA(K)-NPRC(K)-NPSACWI(K)-NPSACWG(K))

      NI3DTEN(K) = NI3DTEN(K)+                                      &
       (NNUCCC(K)-NPRCI(K)-NPRAI(K)+NMULTS(K)+NMULTG(K)+NMULTR(K)+NMULTRG(K)+ &
               NNUCCD(K)-NIACR(K)-NIACRS(K))

      NR3DTEN(K) = NR3DTEN(K)+(NPRC1(K)-NPRACS(K)-NNUCCR(K)      &
                   +NRAGG(K)-NIACR(K)-NIACRS(K)-NPRACG(K)-NGRACS(K))

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
! NOW CALCULATE SATURATION ADJUSTMENT TO CONDENSE EXTRA VAPOR ABOVE
! WATER SATURATION

      !---- move to solve ...  GHB, 090930
!!!      DUMT = T3D(K)+DT*T3DTEN(K)
!!!      DUMQV = QV3D(K)+DT*QV3DTEN(K)
!!!! hm, add fix for low pressure, 5/12/10
!!!      dum=min(0.99*pres(k),POLYSVP(DUMT,0))
!!!      DUMQSS = EP_2*dum/(PRES(K)-dum)
!!!      DUMQC = QC3D(K)+DT*QC3DTEN(K)
!!!      DUMQC = MAX(DUMQC,0.)
!!!
!!!! SATURATION ADJUSTMENT FOR LIQUID
!!!
!!!      DUMS = DUMQV-DUMQSS
!!!      PCC(K) = DUMS/(1.+XXLV(K)**2*DUMQSS/(CPM(K)*RV*DUMT**2))/DT
!!!      IF (PCC(K)*DT+DUMQC.LT.0.) THEN
!!!           PCC(K) = -DUMQC/DT
!!!      END IF
!!!
!!!      QV3DTEN(K) = QV3DTEN(K)-PCC(K)
!!!!!!      T3DTEN(K) = T3DTEN(K)+PCC(K)*XXLV(K)/CPM(K)
!!!      T3DTEN(K) = T3DTEN(K)+PCC(K)*ecnd(k)
!!!      QC3DTEN(K) = QC3DTEN(K)+PCC(K)
      ! GHB

!.......................................................................
! ACTIVATION OF CLOUD DROPLETS
! ACTIVATION OF DROPLET CURRENTLY NOT CALCULATED
! DROPLET CONCENTRATION IS SPECIFIED !!!!!

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
! SUBLIMATE, MELT, OR EVAPORATE NUMBER CONCENTRATION
! THIS FORMULATION ASSUMES 1:1 RATIO BETWEEN MASS LOSS AND
! LOSS OF NUMBER CONCENTRATION

!     IF (PCC(K).LT.0.) THEN
!        DUM = PCC(K)*DT/QC3D(K)
!           DUM = MAX(-1.,DUM)
!        NSUBC(K) = DUM*NC3D(K)/DT
!     END IF

      IF (EPRD(K).LT.0.) THEN
         DUM = EPRD(K)*DT/QI3D(K)
            DUM = MAX(-1.,DUM)
         NSUBI(K) = DUM*NI3D(K)/DT
      END IF
      IF (EPRDS(K).LT.0.) THEN
         DUM = EPRDS(K)*DT/QNI3D(K)
           DUM = MAX(-1.,DUM)
         NSUBS(K) = DUM*NS3D(K)/DT
      END IF
      IF (PRE(K).LT.0.) THEN
         DUM = PRE(K)*DT/QR3D(K)
           DUM = MAX(-1.,DUM)
         NSUBR(K) = DUM*NR3D(K)/DT
      END IF
      IF (EPRDG(K).LT.0.) THEN
         DUM = EPRDG(K)*DT/QG3D(K)
           DUM = MAX(-1.,DUM)
         NSUBG(K) = DUM*NG3D(K)/DT
      END IF

!        nsubr(k)=0.
!        nsubs(k)=0.
!        nsubg(k)=0.

! UPDATE TENDENCIES

!        NC3DTEN(K) = NC3DTEN(K)+NSUBC(K)
         NI3DTEN(K) = NI3DTEN(K)+NSUBI(K)
         NS3DTEN(K) = NS3DTEN(K)+NSUBS(K)
         NG3DTEN(K) = NG3DTEN(K)+NSUBG(K)
         NR3DTEN(K) = NR3DTEN(K)+NSUBR(K)

         END IF !!!!!! TEMPERATURE

! SWITCH LTRUE TO 1, SINCE HYDROMETEORS ARE PRESENT
         LTRUE = 1

 200     CONTINUE

        END DO

! INITIALIZE PRECIP AND SNOW RATES
      PRECRT = 0.
      SNOWRT = 0.

! IF THERE ARE NO HYDROMETEORS, THEN SKIP TO END OF SUBROUTINE

        IF (LTRUE.EQ.0) GOTO 400

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!.......................................................................
! CALCULATE SEDIMENATION
! THE NUMERICS HERE FOLLOW FROM REISNER ET AL. (1998)
! FALLOUT TERMS ARE CALCULATED ON SPLIT TIME STEPS TO ENSURE NUMERICAL
! STABILITY, I.E. COURANT# < 1

!.......................................................................

      NSTEP = 1

      DO K = KTS,KTE

        DUMI(K) = QI3D(K)+QI3DTEN(K)*DT
        DUMQS(K) = QNI3D(K)+QNI3DTEN(K)*DT
        DUMR(K) = QR3D(K)+QR3DTEN(K)*DT
        DUMFNI(K) = NI3D(K)+NI3DTEN(K)*DT
        DUMFNS(K) = NS3D(K)+NS3DTEN(K)*DT
        DUMFNR(K) = NR3D(K)+NR3DTEN(K)*DT
        DUMC(K) = QC3D(K)+QC3DTEN(K)*DT
        DUMFNC(K) = NC3D(K)+NC3DTEN(K)*DT
	DUMG(K) = QG3D(K)+QG3DTEN(K)*DT
	DUMFNG(K) = NG3D(K)+NG3DTEN(K)*DT

! SWITCH FOR CONSTANT DROPLET NUMBER
!        IF (INUM.EQ.1) THEN
        DUMFNC(K) = NC3D(K)
!        END IF

! GET DUMMY LAMDA FOR SEDIMENTATION CALCULATIONS

! MAKE SURE NUMBER CONCENTRATIONS ARE POSITIVE
      DUMFNI(K) = MAX(0.,DUMFNI(K))
      DUMFNS(K) = MAX(0.,DUMFNS(K))
      DUMFNC(K) = MAX(0.,DUMFNC(K))
      DUMFNR(K) = MAX(0.,DUMFNR(K))
      DUMFNG(K) = MAX(0.,DUMFNG(K))

!......................................................................
! CLOUD ICE

      IF (DUMI(K).GE.QSMALL) THEN
        DLAMI = (CONS12*DUMFNI(K)/DUMI(K))**(1./DI)
        DLAMI=MAX(DLAMI,LAMMINI)
        DLAMI=MIN(DLAMI,LAMMAXI)
      END IF
!......................................................................
! RAIN

      IF (DUMR(K).GE.QSMALL) THEN
        DLAMR = (PI*RHOW*DUMFNR(K)/DUMR(K))**(1./3.)
        DLAMR=MAX(DLAMR,LAMMINR)
        DLAMR=MIN(DLAMR,LAMMAXR)
      END IF
!......................................................................
! CLOUD DROPLETS

      IF (DUMC(K).GE.QSMALL) THEN
         DUM = PRES(K)/(287.15*T3D(K))
         PGAM(K)=0.0005714*(NC3D(K)/1.E6*DUM)+0.2714
         PGAM(K)=1./(PGAM(K)**2)-1.
         PGAM(K)=MAX(PGAM(K),2.)
         PGAM(K)=MIN(PGAM(K),10.)

        DLAMC = (CONS26*DUMFNC(K)*GAMMA(PGAM(K)+4.)/(DUMC(K)*GAMMA(PGAM(K)+1.)))**(1./3.)
        LAMMIN = (PGAM(K)+1.)/60.E-6
        LAMMAX = (PGAM(K)+1.)/1.E-6
        DLAMC=MAX(DLAMC,LAMMIN)
        DLAMC=MIN(DLAMC,LAMMAX)
      END IF
!......................................................................
! SNOW

      IF (DUMQS(K).GE.QSMALL) THEN
        DLAMS = (CONS1*DUMFNS(K)/ DUMQS(K))**(1./DS)
        DLAMS=MAX(DLAMS,LAMMINS)
        DLAMS=MIN(DLAMS,LAMMAXS)
      END IF
!......................................................................
! GRAUPEL

      IF (DUMG(K).GE.QSMALL) THEN
        DLAMG = (CONS2*DUMFNG(K)/ DUMG(K))**(1./DG)
        DLAMG=MAX(DLAMG,LAMMING)
        DLAMG=MIN(DLAMG,LAMMAXG)
      END IF

!......................................................................
! CALCULATE NUMBER-WEIGHTED AND MASS-WEIGHTED TERMINAL FALL SPEEDS

! CLOUD WATER

      IF (DUMC(K).GE.QSMALL) THEN
      UNC =  ACN(K)*GAMMA(1.+BC+PGAM(K))/ (DLAMC**BC*GAMMA(PGAM(K)+1.))
      UMC = ACN(K)*GAMMA(4.+BC+PGAM(K))/  (DLAMC**BC*GAMMA(PGAM(K)+4.))
      ELSE
      UMC = 0.
      UNC = 0.
      END IF

      IF (DUMI(K).GE.QSMALL) THEN
      UNI =  AIN(K)*CONS27/DLAMI**BI
      UMI = AIN(K)*CONS28/(DLAMI**BI)
      ELSE
      UMI = 0.
      UNI = 0.
      END IF

      IF (DUMR(K).GE.QSMALL) THEN
      UNR = ARN(K)*CONS6/DLAMR**BR
      UMR = ARN(K)*CONS4/(DLAMR**BR)
      ELSE
      UMR = 0.
      UNR = 0.
      END IF

      IF (DUMQS(K).GE.QSMALL) THEN
      UMS = ASN(K)*CONS3/(DLAMS**BS)
      UNS = ASN(K)*CONS5/DLAMS**BS
      ELSE
      UMS = 0.
      UNS = 0.
      END IF

      IF (DUMG(K).GE.QSMALL) THEN
      UMG = AGN(K)*CONS7/(DLAMG**BG)
      UNG = AGN(K)*CONS8/DLAMG**BG
      ELSE
      UMG = 0.
      UNG = 0.
      END IF

! SET REALISTIC LIMITS ON FALLSPEED

! bug fix, 10/08/09
        dum=(rhosu/rho(k))**0.54
        UMS=MIN(UMS,1.2*dum)
        UNS=MIN(UNS,1.2*dum)
        UMI=MIN(UMI,1.2*dum)
        UNI=MIN(UNI,1.2*dum)
        UMR=MIN(UMR,9.1*dum)
        UNR=MIN(UNR,9.1*dum)
        UMG=MIN(UMG,20.*dum)
        UNG=MIN(UNG,20.*dum)

      FR(K) = UMR
      FI(K) = UMI
      FNI(K) = UNI
      FS(K) = UMS
      FNS(K) = UNS
      FNR(K) = UNR
      FC(K) = UMC
      FNC(K) = UNC
      FG(K) = UMG
      FNG(K) = UNG

! CALCULATE NUMBER OF SPLIT TIME STEPS

      RGVM = MAX(FR(K),FI(K),FS(K),FC(K),FNI(K),FNR(K),FNS(K),FNC(K),FG(K),FNG(K))
! VVT CHANGED IFIX -> INT (GENERIC FUNCTION)
      NSTEP = MAX(INT(RGVM*DT/DZQ(K)+1.),NSTEP)

! MULTIPLY VARIABLES BY RHO
      DUMR(k) = DUMR(k)*RHO(K)
      DUMI(k) = DUMI(k)*RHO(K)
      DUMFNI(k) = DUMFNI(K)*RHO(K)
      DUMQS(k) = DUMQS(K)*RHO(K)
      DUMFNS(k) = DUMFNS(K)*RHO(K)
      DUMFNR(k) = DUMFNR(K)*RHO(K)
      DUMC(k) = DUMC(K)*RHO(K)
      DUMFNC(k) = DUMFNC(K)*RHO(K)
      DUMG(k) = DUMG(K)*RHO(K)
      DUMFNG(k) = DUMFNG(K)*RHO(K)

      END DO

      DO N = 1,NSTEP

      DO K = KTS,KTE
      FALOUTR(K) = FR(K)*DUMR(K)
      FALOUTI(K) = FI(K)*DUMI(K)
      FALOUTNI(K) = FNI(K)*DUMFNI(K)
      FALOUTS(K) = FS(K)*DUMQS(K)
      FALOUTNS(K) = FNS(K)*DUMFNS(K)
      FALOUTNR(K) = FNR(K)*DUMFNR(K)
      FALOUTC(K) = FC(K)*DUMC(K)
      FALOUTNC(K) = FNC(K)*DUMFNC(K)
      FALOUTG(K) = FG(K)*DUMG(K)
      FALOUTNG(K) = FNG(K)*DUMFNG(K)
      END DO

! TOP OF MODEL

      K = KTE
      FALTNDR = FALOUTR(K)/DZQ(k)
      FALTNDI = FALOUTI(K)/DZQ(k)
      FALTNDNI = FALOUTNI(K)/DZQ(k)
      FALTNDS = FALOUTS(K)/DZQ(k)
      FALTNDNS = FALOUTNS(K)/DZQ(k)
      FALTNDNR = FALOUTNR(K)/DZQ(k)
      FALTNDC = FALOUTC(K)/DZQ(k)
      FALTNDNC = FALOUTNC(K)/DZQ(k)
      FALTNDG = FALOUTG(K)/DZQ(k)
      FALTNDNG = FALOUTNG(K)/DZQ(k)
! ADD FALLOUT TERMS TO EULERIAN TENDENCIES

      QRSTEN(K) = QRSTEN(K)-FALTNDR/NSTEP/RHO(k)
      QISTEN(K) = QISTEN(K)-FALTNDI/NSTEP/RHO(k)
      NI3DTEN(K) = NI3DTEN(K)-FALTNDNI/NSTEP/RHO(k)
      QNISTEN(K) = QNISTEN(K)-FALTNDS/NSTEP/RHO(k)
      NS3DTEN(K) = NS3DTEN(K)-FALTNDNS/NSTEP/RHO(k)
      NR3DTEN(K) = NR3DTEN(K)-FALTNDNR/NSTEP/RHO(k)
      QCSTEN(K) = QCSTEN(K)-FALTNDC/NSTEP/RHO(k)
      NC3DTEN(K) = NC3DTEN(K)-FALTNDNC/NSTEP/RHO(k)
      QGSTEN(K) = QGSTEN(K)-FALTNDG/NSTEP/RHO(k)
      NG3DTEN(K) = NG3DTEN(K)-FALTNDNG/NSTEP/RHO(k)

      DUMR(K) = DUMR(K)-FALTNDR*DT/NSTEP
      DUMI(K) = DUMI(K)-FALTNDI*DT/NSTEP
      DUMFNI(K) = DUMFNI(K)-FALTNDNI*DT/NSTEP
      DUMQS(K) = DUMQS(K)-FALTNDS*DT/NSTEP
      DUMFNS(K) = DUMFNS(K)-FALTNDNS*DT/NSTEP
      DUMFNR(K) = DUMFNR(K)-FALTNDNR*DT/NSTEP
      DUMC(K) = DUMC(K)-FALTNDC*DT/NSTEP
      DUMFNC(K) = DUMFNC(K)-FALTNDNC*DT/NSTEP
      DUMG(K) = DUMG(K)-FALTNDG*DT/NSTEP
      DUMFNG(K) = DUMFNG(K)-FALTNDNG*DT/NSTEP

      DO K = KTE-1,KTS,-1
      FALTNDR = (FALOUTR(K+1)-FALOUTR(K))/DZQ(K)
      FALTNDI = (FALOUTI(K+1)-FALOUTI(K))/DZQ(K)
      FALTNDNI = (FALOUTNI(K+1)-FALOUTNI(K))/DZQ(K)
      FALTNDS = (FALOUTS(K+1)-FALOUTS(K))/DZQ(K)
      FALTNDNS = (FALOUTNS(K+1)-FALOUTNS(K))/DZQ(K)
      FALTNDNR = (FALOUTNR(K+1)-FALOUTNR(K))/DZQ(K)
      FALTNDC = (FALOUTC(K+1)-FALOUTC(K))/DZQ(K)
      FALTNDNC = (FALOUTNC(K+1)-FALOUTNC(K))/DZQ(K)
      FALTNDG = (FALOUTG(K+1)-FALOUTG(K))/DZQ(K)
      FALTNDNG = (FALOUTNG(K+1)-FALOUTNG(K))/DZQ(K)

! ADD FALLOUT TERMS TO EULERIAN TENDENCIES

      QRSTEN(K) = QRSTEN(K)+FALTNDR/NSTEP/RHO(k)
      QISTEN(K) = QISTEN(K)+FALTNDI/NSTEP/RHO(k)
      NI3DTEN(K) = NI3DTEN(K)+FALTNDNI/NSTEP/RHO(k)
      QNISTEN(K) = QNISTEN(K)+FALTNDS/NSTEP/RHO(k)
      NS3DTEN(K) = NS3DTEN(K)+FALTNDNS/NSTEP/RHO(k)
      NR3DTEN(K) = NR3DTEN(K)+FALTNDNR/NSTEP/RHO(k)
      QCSTEN(K) = QCSTEN(K)+FALTNDC/NSTEP/RHO(k)
      NC3DTEN(K) = NC3DTEN(K)+FALTNDNC/NSTEP/RHO(k)
      QGSTEN(K) = QGSTEN(K)+FALTNDG/NSTEP/RHO(k)
      NG3DTEN(K) = NG3DTEN(K)+FALTNDNG/NSTEP/RHO(k)

      DUMR(K) = DUMR(K)+FALTNDR*DT/NSTEP
      DUMI(K) = DUMI(K)+FALTNDI*DT/NSTEP
      DUMFNI(K) = DUMFNI(K)+FALTNDNI*DT/NSTEP
      DUMQS(K) = DUMQS(K)+FALTNDS*DT/NSTEP
      DUMFNS(K) = DUMFNS(K)+FALTNDNS*DT/NSTEP
      DUMFNR(K) = DUMFNR(K)+FALTNDNR*DT/NSTEP
      DUMC(K) = DUMC(K)+FALTNDC*DT/NSTEP
      DUMFNC(K) = DUMFNC(K)+FALTNDNC*DT/NSTEP
      DUMG(K) = DUMG(K)+FALTNDG*DT/NSTEP
      DUMFNG(K) = DUMFNG(K)+FALTNDNG*DT/NSTEP

      END DO

! GET PRECIPITATION AND SNOWFALL ACCUMULATION DURING THE TIME STEP
! FACTOR OF 1000 CONVERTS FROM M TO MM, BUT DIVISION BY DENSITY
! OF LIQUID WATER CANCELS THIS FACTOR OF 1000

        PRECRT = PRECRT+(FALOUTR(KTS)+FALOUTC(KTS)+FALOUTS(KTS)+FALOUTI(KTS)+FALOUTG(KTS))  &
                     *DT/NSTEP
        SNOWRT = SNOWRT+(FALOUTS(KTS)+FALOUTI(KTS)+FALOUTG(KTS))*DT/NSTEP

      END DO

        DO K=KTS,KTE

! ADD ON SEDIMENTATION TENDENCIES FOR MIXING RATIO TO REST OF TENDENCIES

        QR3DTEN(K)=QR3DTEN(K)+QRSTEN(K)
        QI3DTEN(K)=QI3DTEN(K)+QISTEN(K)
        QC3DTEN(K)=QC3DTEN(K)+QCSTEN(K)
        QG3DTEN(K)=QG3DTEN(K)+QGSTEN(K)
        QNI3DTEN(K)=QNI3DTEN(K)+QNISTEN(K)

! PUT ALL CLOUD ICE IN SNOW CATEGORY IF MEAN DIAMETER EXCEEDS 2 * dcs

!hm 4/7/09 bug fix
!        IF (QI3D(K).GE.QSMALL.AND.T3D(K).LT.273.15) THEN
        IF (QI3D(K).GE.QSMALL.AND.T3D(K).LT.273.15.AND.LAMI(K).GE.1.E-10) THEN
        IF (1./LAMI(K).GE.2.*DCS) THEN
           QNI3DTEN(K) = QNI3DTEN(K)+QI3D(K)/DT+ QI3DTEN(K)
           NS3DTEN(K) = NS3DTEN(K)+NI3D(K)/DT+   NI3DTEN(K)
           QI3DTEN(K) = -QI3D(K)/DT
           NI3DTEN(K) = -NI3D(K)/DT
        END IF
        END IF

! hm add tendencies here, then call sizeparameter
! to ensure consisitency between mixing ratio and number concentration

          QC3D(k)        = QC3D(k)+QC3DTEN(k)*DT
          QI3D(k)        = QI3D(k)+QI3DTEN(k)*DT
          QNI3D(k)        = QNI3D(k)+QNI3DTEN(k)*DT
          QR3D(k)        = QR3D(k)+QR3DTEN(k)*DT
!          NC3D(k)        = NC3D(k)+NC3DTEN(k)*DT
          NI3D(k)        = NI3D(k)+NI3DTEN(k)*DT
          NS3D(k)        = NS3D(k)+NS3DTEN(k)*DT
          NR3D(k)        = NR3D(k)+NR3DTEN(k)*DT

          IF (IGRAUP.EQ.0) THEN
          QG3D(k)        = QG3D(k)+QG3DTEN(k)*DT
          NG3D(k)        = NG3D(k)+NG3DTEN(k)*DT
          END IF

! ADD TEMPERATURE AND WATER VAPOR TENDENCIES FROM MICROPHYSICS
          T3D(K)         = T3D(K)+T3DTEN(k)*DT
          QV3D(K)        = QV3D(K)+QV3DTEN(k)*DT

! SATURATION VAPOR PRESSURE AND MIXING RATIO

! hm, add fix for low pressure, 5/12/10
            EVS(K) = min(0.99*pres(k),POLYSVP(T3D(K),0))   ! PA
            EIS(K) = min(0.99*pres(k),POLYSVP(T3D(K),1))   ! PA

! MAKE SURE ICE SATURATION DOESN'T EXCEED WATER SAT. NEAR FREEZING

            IF (EIS(K).GT.EVS(K)) EIS(K) = EVS(K)

            QVS(K) = EP_2*EVS(K)/(PRES(K)-EVS(K))
            QVI(K) = EP_2*EIS(K)/(PRES(K)-EIS(K))

            QVQVS(K) = QV3D(K)/QVS(K)
            QVQVSI(K) = QV3D(K)/QVI(K)

! AT SUBSATURATION, REMOVE SMALL AMOUNTS OF CLOUD/PRECIP WATER
! hm 7/9/09 change limit to 1.e-8

             IF (QVQVS(K).LT.0.9) THEN
               IF (QR3D(K).LT.1.E-8) THEN
                  QV3D(K)=QV3D(K)+QR3D(K)
!!!                  T3D(K)=T3D(K)-QR3D(K)*XXLV(K)/CPM(K)
                  T3D(K)=T3D(K)-QR3D(K)*ecnd(k)
                  QR3D(K)=0.
               END IF
               IF (QC3D(K).LT.1.E-8) THEN
                  QV3D(K)=QV3D(K)+QC3D(K)
!!!                  T3D(K)=T3D(K)-QC3D(K)*XXLV(K)/CPM(K)
                  T3D(K)=T3D(K)-QC3D(K)*ecnd(k)
                  QC3D(K)=0.
               END IF
             END IF

             IF (QVQVSI(K).LT.0.9) THEN
               IF (QI3D(K).LT.1.E-8) THEN
                  QV3D(K)=QV3D(K)+QI3D(K)
!!!                  T3D(K)=T3D(K)-QI3D(K)*XXLS(K)/CPM(K)
                  T3D(K)=T3D(K)-QI3D(K)*edep(k)
                  QI3D(K)=0.
               END IF
               IF (QNI3D(K).LT.1.E-8) THEN
                  QV3D(K)=QV3D(K)+QNI3D(K)
!!!                  T3D(K)=T3D(K)-QNI3D(K)*XXLS(K)/CPM(K)
                  T3D(K)=T3D(K)-QNI3D(K)*edep(k)
                  QNI3D(K)=0.
               END IF
               IF (QG3D(K).LT.1.E-8) THEN
                  QV3D(K)=QV3D(K)+QG3D(K)
!!!                  T3D(K)=T3D(K)-QG3D(K)*XXLS(K)/CPM(K)
                  T3D(K)=T3D(K)-QG3D(K)*edep(k)
                  QG3D(K)=0.
               END IF
             END IF

!..................................................................
! IF MIXING RATIO < QSMALL SET MIXING RATIO AND NUMBER CONC TO ZERO

       IF (QC3D(K).LT.QSMALL) THEN
         QC3D(K) = 0.
         NC3D(K) = 0.
         EFFC(K) = 0.
       END IF
       IF (QR3D(K).LT.QSMALL) THEN
         QR3D(K) = 0.
         NR3D(K) = 0.
         EFFR(K) = 0.
       END IF
       IF (QI3D(K).LT.QSMALL) THEN
         QI3D(K) = 0.
         NI3D(K) = 0.
         EFFI(K) = 0.
       END IF
       IF (QNI3D(K).LT.QSMALL) THEN
         QNI3D(K) = 0.
         NS3D(K) = 0.
         EFFS(K) = 0.
       END IF
       IF (QG3D(K).LT.QSMALL) THEN
         QG3D(K) = 0.
         NG3D(K) = 0.
         EFFG(K) = 0.
       END IF

!..................................
! IF THERE IS NO CLOUD/PRECIP WATER, THEN SKIP CALCULATIONS

            IF (QC3D(K).LT.QSMALL.AND.QI3D(K).LT.QSMALL.AND.QNI3D(K).LT.QSMALL &
                 .AND.QR3D(K).LT.QSMALL.AND.QG3D(K).LT.QSMALL) GOTO 500

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
! CALCULATE INSTANTANEOUS PROCESSES

! ADD MELTING OF CLOUD ICE TO FORM RAIN

        IF (QI3D(K).GE.QSMALL.AND.T3D(K).GE.273.15) THEN
           QR3D(K) = QR3D(K)+QI3D(K)
!!!           T3D(K) = T3D(K)-QI3D(K)*XLF(K)/CPM(K)
           T3D(K) = T3D(K)-QI3D(K)*efrz(k)
           QI3D(K) = 0.
           NR3D(K) = NR3D(K)+NI3D(K)
           NI3D(K) = 0.
        END IF

! ****SENSITIVITY - NO ICE
        IF (ILIQ.EQ.1) GOTO 778

! HOMOGENEOUS FREEZING OF CLOUD WATER

        IF (T3D(K).LE.233.15.AND.QC3D(K).GE.QSMALL) THEN
           QI3D(K)=QI3D(K)+QC3D(K)
!!!           T3D(K)=T3D(K)+QC3D(K)*XLF(K)/CPM(K)
           T3D(K)=T3D(K)+QC3D(K)*efrz(k)
           QC3D(K)=0.
           NI3D(K)=NI3D(K)+NC3D(K)
           NC3D(K)=0.
        END IF

! HOMOGENEOUS FREEZING OF RAIN

        IF (IGRAUP.EQ.0) THEN

        IF (T3D(K).LE.233.15.AND.QR3D(K).GE.QSMALL) THEN
           QG3D(K) = QG3D(K)+QR3D(K)
!!!           T3D(K) = T3D(K)+QR3D(K)*XLF(K)/CPM(K)
           T3D(K) = T3D(K)+QR3D(K)*efrz(k)
           QR3D(K) = 0.
           NG3D(K) = NG3D(K)+ NR3D(K)
           NR3D(K) = 0.
        END IF

        ELSE IF (IGRAUP.EQ.1) THEN

        IF (T3D(K).LE.233.15.AND.QR3D(K).GE.QSMALL) THEN
           QNI3D(K) = QNI3D(K)+QR3D(K)
!!!           T3D(K) = T3D(K)+QR3D(K)*XLF(K)/CPM(K)
           T3D(K) = T3D(K)+QR3D(K)*efrz(k)
           QR3D(K) = 0.
           NS3D(K) = NS3D(K)+NR3D(K)
           NR3D(K) = 0.
        END IF

        END IF

 778    CONTINUE

! MAKE SURE NUMBER CONCENTRATIONS AREN'T NEGATIVE

      NI3D(K) = MAX(0.,NI3D(K))
      NS3D(K) = MAX(0.,NS3D(K))
      NC3D(K) = MAX(0.,NC3D(K))
      NR3D(K) = MAX(0.,NR3D(K))
      NG3D(K) = MAX(0.,NG3D(K))

!......................................................................
! CLOUD ICE

      IF (QI3D(K).GE.QSMALL) THEN
         LAMI(K) = (CONS12*                 &
              NI3D(K)/QI3D(K))**(1./DI)

! CHECK FOR SLOPE

! ADJUST VARS

      IF (LAMI(K).LT.LAMMINI) THEN

      LAMI(K) = LAMMINI

      N0I(K) = LAMI(K)**4*QI3D(K)/CONS12

      NI3D(K) = N0I(K)/LAMI(K)
      ELSE IF (LAMI(K).GT.LAMMAXI) THEN
      LAMI(K) = LAMMAXI
      N0I(K) = LAMI(K)**4*QI3D(K)/CONS12

      NI3D(K) = N0I(K)/LAMI(K)
      END IF
      END IF

!......................................................................
! RAIN

      IF (QR3D(K).GE.QSMALL) THEN
      LAMR(K) = (PI*RHOW*NR3D(K)/QR3D(K))**(1./3.)

! CHECK FOR SLOPE

! ADJUST VARS

      IF (LAMR(K).LT.LAMMINR) THEN

      LAMR(K) = LAMMINR

      N0RR(K) = LAMR(K)**4*QR3D(K)/(PI*RHOW)

      NR3D(K) = N0RR(K)/LAMR(K)
      ELSE IF (LAMR(K).GT.LAMMAXR) THEN
      LAMR(K) = LAMMAXR
      N0RR(K) = LAMR(K)**4*QR3D(K)/(PI*RHOW)

      NR3D(K) = N0RR(K)/LAMR(K)
      END IF

      END IF

!......................................................................
! CLOUD DROPLETS

! MARTIN ET AL. (1994) FORMULA FOR PGAM

      IF (QC3D(K).GE.QSMALL) THEN

         DUM = PRES(K)/(287.15*T3D(K))
         PGAM(K)=0.0005714*(NC3D(K)/1.E6*DUM)+0.2714
         PGAM(K)=1./(PGAM(K)**2)-1.
         PGAM(K)=MAX(PGAM(K),2.)
         PGAM(K)=MIN(PGAM(K),10.)

! CALCULATE LAMC

      LAMC(K) = (CONS26*NC3D(K)*GAMMA(PGAM(K)+4.)/   &
                 (QC3D(K)*GAMMA(PGAM(K)+1.)))**(1./3.)

! LAMMIN, 60 MICRON DIAMETER
! LAMMAX, 1 MICRON

      LAMMIN = (PGAM(K)+1.)/60.E-6
      LAMMAX = (PGAM(K)+1.)/1.E-6

      IF (LAMC(K).LT.LAMMIN) THEN
      LAMC(K) = LAMMIN
      NC3D(K) = EXP(3.*LOG(LAMC(K))+LOG(QC3D(K))+              &
                LOG(GAMMA(PGAM(K)+1.))-LOG(GAMMA(PGAM(K)+4.)))/CONS26

      ELSE IF (LAMC(K).GT.LAMMAX) THEN
      LAMC(K) = LAMMAX
      NC3D(K) = EXP(3.*LOG(LAMC(K))+LOG(QC3D(K))+              &
                LOG(GAMMA(PGAM(K)+1.))-LOG(GAMMA(PGAM(K)+4.)))/CONS26

      END IF

      END IF

!......................................................................
! SNOW

      IF (QNI3D(K).GE.QSMALL) THEN
      LAMS(K) = (CONS1*NS3D(K)/QNI3D(K))**(1./DS)

! CHECK FOR SLOPE

! ADJUST VARS

      IF (LAMS(K).LT.LAMMINS) THEN
      LAMS(K) = LAMMINS
      N0S(K) = LAMS(K)**4*QNI3D(K)/CONS1

      NS3D(K) = N0S(K)/LAMS(K)

      ELSE IF (LAMS(K).GT.LAMMAXS) THEN

      LAMS(K) = LAMMAXS
      N0S(K) = LAMS(K)**4*QNI3D(K)/CONS1
      NS3D(K) = N0S(K)/LAMS(K)
      END IF

      END IF

!......................................................................
! GRAUPEL

      IF (QG3D(K).GE.QSMALL) THEN
      LAMG(K) = (CONS2*NG3D(K)/QG3D(K))**(1./DG)

! CHECK FOR SLOPE

! ADJUST VARS

      IF (LAMG(K).LT.LAMMING) THEN
      LAMG(K) = LAMMING
      N0G(K) = LAMG(K)**4*QG3D(K)/CONS2

      NG3D(K) = N0G(K)/LAMG(K)

      ELSE IF (LAMG(K).GT.LAMMAXG) THEN

      LAMG(K) = LAMMAXG
      N0G(K) = LAMG(K)**4*QG3D(K)/CONS2

      NG3D(K) = N0G(K)/LAMG(K)
      END IF

      END IF

 500  CONTINUE

! CALCULATE EFFECTIVE RADIUS

      IF (QI3D(K).GE.QSMALL) THEN
         EFFI(K) = 3./LAMI(K)/2.*1.E6
      ELSE
         EFFI(K) = 25.
      END IF

      IF (QNI3D(K).GE.QSMALL) THEN
         EFFS(K) = 3./LAMS(K)/2.*1.E6
      ELSE
         EFFS(K) = 25.
      END IF

      IF (QR3D(K).GE.QSMALL) THEN
         EFFR(K) = 3./LAMR(K)/2.*1.E6
      ELSE
         EFFR(K) = 25.
      END IF

      IF (QC3D(K).GE.QSMALL) THEN
      EFFC(K) = GAMMA(PGAM(K)+4.)/                        &
             GAMMA(PGAM(K)+3.)/LAMC(K)/2.*1.E6
      ELSE
      EFFC(K) = 25.
      END IF

      IF (QG3D(K).GE.QSMALL) THEN
         EFFG(K) = 3./LAMG(K)/2.*1.E6
      ELSE
         EFFG(K) = 25.
      END IF

! HM ADD 1/10/06, ADD UPPER BOUND ON ICE NUMBER, THIS IS NEEDED
! TO PREVENT VERY LARGE ICE NUMBER DUE TO HOMOGENEOUS FREEZING
! OF DROPLETS, ESPECIALLY WHEN INUM = 1, SET MAX AT 10 CM-3
          NI3D(K) = MIN(NI3D(K),10.E6/RHO(K))
! ADD BOUND ON DROPLET NUMBER - CANNOT EXCEED AEROSOL CONCENTRATION
          IF (INUM.EQ.0.AND.IACT.EQ.2) THEN
          NC3D(K) = MIN(NC3D(K),(NANEW1+NANEW2)/RHO(K))
          END IF
! SWITCH FOR CONSTANT DROPLET NUMBER
!          IF (INUM.EQ.1) THEN
! CHANGE NDCNST FROM CM-3 TO KG-1
             NC3D(K) = NDCNST*1.E6/RHO(K)
!          END IF

      END DO !!! K LOOP

 400         CONTINUE

! ALL DONE !!!!!!!!!!!
      RETURN
      END SUBROUTINE MORR_TWO_MOMENT_MICRO

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      REAL FUNCTION POLYSVP (T,TYPE)

!-------------------------------------------

!  COMPUTE SATURATION VAPOR PRESSURE

!  POLYSVP RETURNED IN UNITS OF PA.
!  T IS INPUT IN UNITS OF K.
!  TYPE REFERS TO SATURATION WITH RESPECT TO LIQUID (0) OR ICE (1)

! REPLACE GOFF-GRATCH WITH FASTER FORMULATION FROM FLATAU ET AL. 1992, TABLE 4 (RIGHT-HAND COLUMN)

      IMPLICIT NONE

      REAL DUM
      REAL T
      INTEGER TYPE
! ice
      real a0i,a1i,a2i,a3i,a4i,a5i,a6i,a7i,a8i 
      data a0i,a1i,a2i,a3i,a4i,a5i,a6i,a7i,a8i /&
	6.11147274, 0.503160820, 0.188439774e-1, &
        0.420895665e-3, 0.615021634e-5,0.602588177e-7, &
        0.385852041e-9, 0.146898966e-11, 0.252751365e-14/	

! liquid
      real a0,a1,a2,a3,a4,a5,a6,a7,a8 

! V1.7
      data a0,a1,a2,a3,a4,a5,a6,a7,a8 /&
	6.11239921, 0.443987641, 0.142986287e-1, &
        0.264847430e-3, 0.302950461e-5, 0.206739458e-7, &
        0.640689451e-10,-0.952447341e-13,-0.976195544e-15/
      real dt

! ICE

      IF (TYPE.EQ.1) THEN

!         POLYSVP = 10.**(-9.09718*(273.16/T-1.)-3.56654*                &
!          LOG10(273.16/T)+0.876793*(1.-T/273.16)+						&
!          LOG10(6.1071))*100.


!!!      dt = max(-80.,t-273.16)
!!!      polysvp = a0i + dt*(a1i+dt*(a2i+dt*(a3i+dt*(a4i+dt*(a5i+dt*(a6i+dt*(a7i+a8i*dt))))))) 
!!!      polysvp = polysvp*100.

        ! GHB ... needed for consistency with CM1 satadj scheme
        polysvp = 611.2 * EXP( 21.8745584 * ( T  - 273.15 ) / ( T  - 7.66 ) )

      END IF

! LIQUID

      IF (TYPE.EQ.0) THEN

!!!       dt = max(-80.,t-273.16)
!!!       polysvp = a0 + dt*(a1+dt*(a2+dt*(a3+dt*(a4+dt*(a5+dt*(a6+dt*(a7+a8*dt)))))))
!!!       polysvp = polysvp*100.

!         POLYSVP = 10.**(-7.90298*(373.16/T-1.)+                        &
!             5.02808*LOG10(373.16/T)-									&
!             1.3816E-7*(10**(11.344*(1.-T/373.16))-1.)+				&
!             8.1328E-3*(10**(-3.49149*(373.16/T-1.))-1.)+				&
!             LOG10(1013.246))*100.

           ! GHB ... needed for consistency with CM1 satadj scheme
           polysvp = 611.2 * EXP( 17.67 * ( T  - 273.15 ) / ( T  - 29.65 ) )

         END IF


      END FUNCTION POLYSVP

!------------------------------------------------------------------------------

      REAL FUNCTION GAMMA(X)
!----------------------------------------------------------------------
!
! THIS ROUTINE CALCULATES THE GAMMA FUNCTION FOR A REAL ARGUMENT X.
!   COMPUTATION IS BASED ON AN ALGORITHM OUTLINED IN REFERENCE 1.
!   THE PROGRAM USES RATIONAL FUNCTIONS THAT APPROXIMATE THE GAMMA
!   FUNCTION TO AT LEAST 20 SIGNIFICANT DECIMAL DIGITS.  COEFFICIENTS
!   FOR THE APPROXIMATION OVER THE INTERVAL (1,2) ARE UNPUBLISHED.
!   THOSE FOR THE APPROXIMATION FOR X .GE. 12 ARE FROM REFERENCE 2.
!   THE ACCURACY ACHIEVED DEPENDS ON THE ARITHMETIC SYSTEM, THE
!   COMPILER, THE INTRINSIC FUNCTIONS, AND PROPER SELECTION OF THE
!   MACHINE-DEPENDENT CONSTANTS.
!
!
!*******************************************************************
!*******************************************************************
!
! EXPLANATION OF MACHINE-DEPENDENT CONSTANTS
!
! BETA   - RADIX FOR THE FLOATING-POINT REPRESENTATION
! MAXEXP - THE SMALLEST POSITIVE POWER OF BETA THAT OVERFLOWS
! XBIG   - THE LARGEST ARGUMENT FOR WHICH GAMMA(X) IS REPRESENTABLE
!          IN THE MACHINE, I.E., THE SOLUTION TO THE EQUATION
!                  GAMMA(XBIG) = BETA**MAXEXP
! XINF   - THE LARGEST MACHINE REPRESENTABLE FLOATING-POINT NUMBER;
!          APPROXIMATELY BETA**MAXEXP
! EPS    - THE SMALLEST POSITIVE FLOATING-POINT NUMBER SUCH THAT
!          1.0+EPS .GT. 1.0
! XMININ - THE SMALLEST POSITIVE FLOATING-POINT NUMBER SUCH THAT
!          1/XMININ IS MACHINE REPRESENTABLE
!
!     APPROXIMATE VALUES FOR SOME IMPORTANT MACHINES ARE:
!
!                            BETA       MAXEXP        XBIG
!
! CRAY-1         (S.P.)        2         8191        966.961
! CYBER 180/855
!   UNDER NOS    (S.P.)        2         1070        177.803
! IEEE (IBM/XT,
!   SUN, ETC.)   (S.P.)        2          128        35.040
! IEEE (IBM/XT,
!   SUN, ETC.)   (D.P.)        2         1024        171.624
! IBM 3033       (D.P.)       16           63        57.574
! VAX D-FORMAT   (D.P.)        2          127        34.844
! VAX G-FORMAT   (D.P.)        2         1023        171.489
!
!                            XINF         EPS        XMININ
!
! CRAY-1         (S.P.)   5.45E+2465   7.11E-15    1.84E-2466
! CYBER 180/855
!   UNDER NOS    (S.P.)   1.26E+322    3.55E-15    3.14E-294
! IEEE (IBM/XT,
!   SUN, ETC.)   (S.P.)   3.40E+38     1.19E-7     1.18E-38
! IEEE (IBM/XT,
!   SUN, ETC.)   (D.P.)   1.79D+308    2.22D-16    2.23D-308
! IBM 3033       (D.P.)   7.23D+75     2.22D-16    1.39D-76
! VAX D-FORMAT   (D.P.)   1.70D+38     1.39D-17    5.88D-39
! VAX G-FORMAT   (D.P.)   8.98D+307    1.11D-16    1.12D-308
!
!*******************************************************************
!*******************************************************************
!
! ERROR RETURNS
!
!  THE PROGRAM RETURNS THE VALUE XINF FOR SINGULARITIES OR
!     WHEN OVERFLOW WOULD OCCUR.  THE COMPUTATION IS BELIEVED
!     TO BE FREE OF UNDERFLOW AND OVERFLOW.
!
!
!  INTRINSIC FUNCTIONS REQUIRED ARE:
!
!     INT, DBLE, EXP, LOG, REAL, SIN
!
!
! REFERENCES:  AN OVERVIEW OF SOFTWARE DEVELOPMENT FOR SPECIAL
!              FUNCTIONS   W. J. CODY, LECTURE NOTES IN MATHEMATICS,
!              506, NUMERICAL ANALYSIS DUNDEE, 1975, G. A. WATSON
!              (ED.), SPRINGER VERLAG, BERLIN, 1976.
!
!              COMPUTER APPROXIMATIONS, HART, ET. AL., WILEY AND
!              SONS, NEW YORK, 1968.
!
!  LATEST MODIFICATION: OCTOBER 12, 1989
!
!  AUTHORS: W. J. CODY AND L. STOLTZ
!           APPLIED MATHEMATICS DIVISION
!           ARGONNE NATIONAL LABORATORY
!           ARGONNE, IL 60439
!
!----------------------------------------------------------------------
      implicit none
      INTEGER I,N
      LOGICAL PARITY
      REAL                                                          &
          CONV,EPS,FACT,HALF,ONE,RES,SUM,TWELVE,                    &
          TWO,X,XBIG,XDEN,XINF,XMININ,XNUM,Y,Y1,YSQ,Z,ZERO
      REAL, DIMENSION(7) :: C
      REAL, DIMENSION(8) :: P
      REAL, DIMENSION(8) :: Q
!----------------------------------------------------------------------
!  MATHEMATICAL CONSTANTS
!----------------------------------------------------------------------
      DATA ONE,HALF,TWELVE,TWO,ZERO/1.0E0,0.5E0,12.0E0,2.0E0,0.0E0/


!----------------------------------------------------------------------
!  MACHINE DEPENDENT PARAMETERS
!----------------------------------------------------------------------
      DATA XBIG,XMININ,EPS/35.040E0,1.18E-38,1.19E-7/,XINF/3.4E38/
!----------------------------------------------------------------------
!  NUMERATOR AND DENOMINATOR COEFFICIENTS FOR RATIONAL MINIMAX
!     APPROXIMATION OVER (1,2).
!----------------------------------------------------------------------
      DATA P/-1.71618513886549492533811E+0,2.47656508055759199108314E+1,  &
             -3.79804256470945635097577E+2,6.29331155312818442661052E+2,  &
             8.66966202790413211295064E+2,-3.14512729688483675254357E+4,  &
             -3.61444134186911729807069E+4,6.64561438202405440627855E+4/
      DATA Q/-3.08402300119738975254353E+1,3.15350626979604161529144E+2,  &
             -1.01515636749021914166146E+3,-3.10777167157231109440444E+3, &
              2.25381184209801510330112E+4,4.75584627752788110767815E+3,  &
            -1.34659959864969306392456E+5,-1.15132259675553483497211E+5/
!----------------------------------------------------------------------
!  COEFFICIENTS FOR MINIMAX APPROXIMATION OVER (12, INF).
!----------------------------------------------------------------------
      DATA C/-1.910444077728E-03,8.4171387781295E-04,                      &
           -5.952379913043012E-04,7.93650793500350248E-04,				   &
           -2.777777777777681622553E-03,8.333333333333333331554247E-02,	   &
            5.7083835261E-03/
!----------------------------------------------------------------------
!  STATEMENT FUNCTIONS FOR CONVERSION BETWEEN INTEGER AND FLOAT
!----------------------------------------------------------------------
      CONV(I) = REAL(I)
      PARITY=.FALSE.
      FACT=ONE
      N=0
      Y=X
      IF(Y.LE.ZERO)THEN
!----------------------------------------------------------------------
!  ARGUMENT IS NEGATIVE
!----------------------------------------------------------------------
        Y=-X
        Y1=AINT(Y)
        RES=Y-Y1
        IF(RES.NE.ZERO)THEN
          IF(Y1.NE.AINT(Y1*HALF)*TWO)PARITY=.TRUE.
          FACT=-PI/SIN(PI*RES)
          Y=Y+ONE
        ELSE
          RES=XINF
          GOTO 900
        ENDIF
      ENDIF
!----------------------------------------------------------------------
!  ARGUMENT IS POSITIVE
!----------------------------------------------------------------------
      IF(Y.LT.EPS)THEN
!----------------------------------------------------------------------
!  ARGUMENT .LT. EPS
!----------------------------------------------------------------------
        IF(Y.GE.XMININ)THEN
          RES=ONE/Y
        ELSE
          RES=XINF
          GOTO 900
        ENDIF
      ELSEIF(Y.LT.TWELVE)THEN
        Y1=Y
        IF(Y.LT.ONE)THEN
!----------------------------------------------------------------------
!  0.0 .LT. ARGUMENT .LT. 1.0
!----------------------------------------------------------------------
          Z=Y
          Y=Y+ONE
        ELSE
!----------------------------------------------------------------------
!  1.0 .LT. ARGUMENT .LT. 12.0, REDUCE ARGUMENT IF NECESSARY
!----------------------------------------------------------------------
          N=INT(Y)-1
          Y=Y-CONV(N)
          Z=Y-ONE
        ENDIF
!----------------------------------------------------------------------
!  EVALUATE APPROXIMATION FOR 1.0 .LT. ARGUMENT .LT. 2.0
!----------------------------------------------------------------------
        XNUM=ZERO
        XDEN=ONE
        DO I=1,8
          XNUM=(XNUM+P(I))*Z
          XDEN=XDEN*Z+Q(I)
        END DO
        RES=XNUM/XDEN+ONE
        IF(Y1.LT.Y)THEN
!----------------------------------------------------------------------
!  ADJUST RESULT FOR CASE  0.0 .LT. ARGUMENT .LT. 1.0
!----------------------------------------------------------------------
          RES=RES/Y1
        ELSEIF(Y1.GT.Y)THEN
!----------------------------------------------------------------------
!  ADJUST RESULT FOR CASE  2.0 .LT. ARGUMENT .LT. 12.0
!----------------------------------------------------------------------
          DO I=1,N
            RES=RES*Y
            Y=Y+ONE
          END DO
        ENDIF
      ELSE
!----------------------------------------------------------------------
!  EVALUATE FOR ARGUMENT .GE. 12.0,
!----------------------------------------------------------------------
        IF(Y.LE.XBIG)THEN
          YSQ=Y*Y
          SUM=C(7)
          DO I=1,6
            SUM=SUM/YSQ+C(I)
          END DO
          SUM=SUM/Y-Y+SQRTPI
          SUM=SUM+(Y-HALF)*LOG(Y)
          RES=EXP(SUM)
        ELSE
          RES=XINF
          GOTO 900
        ENDIF
      ENDIF
!----------------------------------------------------------------------
!  FINAL ADJUSTMENTS AND RETURN
!----------------------------------------------------------------------
      IF(PARITY)RES=-RES
      IF(FACT.NE.ONE)RES=FACT/RES
  900 GAMMA=RES
      RETURN
! ---------- LAST LINE OF GAMMA ----------
      END FUNCTION GAMMA


      REAL FUNCTION DERF1(X)
      IMPLICIT NONE
      REAL X
      REAL, DIMENSION(0 : 64) :: A, B
      REAL W,T,Y
      INTEGER K,I
      DATA A/                                                 &
         0.00000000005958930743E0, -0.00000000113739022964E0, &
         0.00000001466005199839E0, -0.00000016350354461960E0, &
         0.00000164610044809620E0, -0.00001492559551950604E0, &
         0.00012055331122299265E0, -0.00085483269811296660E0, &
         0.00522397762482322257E0, -0.02686617064507733420E0, &
         0.11283791670954881569E0, -0.37612638903183748117E0, &
         1.12837916709551257377E0,	                          &
         0.00000000002372510631E0, -0.00000000045493253732E0, &
         0.00000000590362766598E0, -0.00000006642090827576E0, &
         0.00000067595634268133E0, -0.00000621188515924000E0, &
         0.00005103883009709690E0, -0.00037015410692956173E0, &
         0.00233307631218880978E0, -0.01254988477182192210E0, &
         0.05657061146827041994E0, -0.21379664776456006580E0, &
         0.84270079294971486929E0,							  &
         0.00000000000949905026E0, -0.00000000018310229805E0, &
         0.00000000239463074000E0, -0.00000002721444369609E0, &
         0.00000028045522331686E0, -0.00000261830022482897E0, &
         0.00002195455056768781E0, -0.00016358986921372656E0, &
         0.00107052153564110318E0, -0.00608284718113590151E0, &
         0.02986978465246258244E0, -0.13055593046562267625E0, &
         0.67493323603965504676E0, 							  &
         0.00000000000382722073E0, -0.00000000007421598602E0, &
         0.00000000097930574080E0, -0.00000001126008898854E0, &
         0.00000011775134830784E0, -0.00000111992758382650E0, &
         0.00000962023443095201E0, -0.00007404402135070773E0, &
         0.00050689993654144881E0, -0.00307553051439272889E0, &
         0.01668977892553165586E0, -0.08548534594781312114E0, &
         0.56909076642393639985E0,							  &
         0.00000000000155296588E0, -0.00000000003032205868E0, &
         0.00000000040424830707E0, -0.00000000471135111493E0, &
         0.00000005011915876293E0, -0.00000048722516178974E0, &
         0.00000430683284629395E0, -0.00003445026145385764E0, &
         0.00024879276133931664E0, -0.00162940941748079288E0, &
         0.00988786373932350462E0, -0.05962426839442303805E0, &
         0.49766113250947636708E0 /
      DATA (B(I), I = 0, 12) /                                  &
         -0.00000000029734388465E0,  0.00000000269776334046E0, 	&
         -0.00000000640788827665E0, -0.00000001667820132100E0,  &
         -0.00000021854388148686E0,  0.00000266246030457984E0, 	&
          0.00001612722157047886E0, -0.00025616361025506629E0, 	&
          0.00015380842432375365E0,  0.00815533022524927908E0, 	&
         -0.01402283663896319337E0, -0.19746892495383021487E0,  &
          0.71511720328842845913E0 /
      DATA (B(I), I = 13, 25) /                                 &
         -0.00000000001951073787E0, -0.00000000032302692214E0,  &
          0.00000000522461866919E0,  0.00000000342940918551E0, 	&
         -0.00000035772874310272E0,  0.00000019999935792654E0, 	&
          0.00002687044575042908E0, -0.00011843240273775776E0, 	&
         -0.00080991728956032271E0,  0.00661062970502241174E0, 	&
          0.00909530922354827295E0, -0.20160072778491013140E0, 	&
          0.51169696718727644908E0 /
      DATA (B(I), I = 26, 38) /                                 &
         0.00000000003147682272E0, -0.00000000048465972408E0,   &
         0.00000000063675740242E0,  0.00000003377623323271E0, 	&
        -0.00000015451139637086E0, -0.00000203340624738438E0, 	&
         0.00001947204525295057E0,  0.00002854147231653228E0, 	&
        -0.00101565063152200272E0,  0.00271187003520095655E0, 	&
         0.02328095035422810727E0, -0.16725021123116877197E0, 	&
         0.32490054966649436974E0 /
      DATA (B(I), I = 39, 51) /                                 &
         0.00000000002319363370E0, -0.00000000006303206648E0,   &
        -0.00000000264888267434E0,  0.00000002050708040581E0, 	&
         0.00000011371857327578E0, -0.00000211211337219663E0, 	&
         0.00000368797328322935E0,  0.00009823686253424796E0, 	&
        -0.00065860243990455368E0, -0.00075285814895230877E0, 	&
         0.02585434424202960464E0, -0.11637092784486193258E0, 	&
         0.18267336775296612024E0 /
      DATA (B(I), I = 52, 64) /                                 &
        -0.00000000000367789363E0,  0.00000000020876046746E0, 	&
        -0.00000000193319027226E0, -0.00000000435953392472E0, 	&
         0.00000018006992266137E0, -0.00000078441223763969E0, 	&
        -0.00000675407647949153E0,  0.00008428418334440096E0, 	&
        -0.00017604388937031815E0, -0.00239729611435071610E0, 	&
         0.02064129023876022970E0, -0.06905562880005864105E0,   &
         0.09084526782065478489E0 /
      W = ABS(X)
      IF (W .LT. 2.2D0) THEN
          T = W * W
          K = INT(T)
          T = T - K
          K = K * 13
          Y = ((((((((((((A(K) * T + A(K + 1)) * T +              &
              A(K + 2)) * T + A(K + 3)) * T + A(K + 4)) * T +     &
              A(K + 5)) * T + A(K + 6)) * T + A(K + 7)) * T +     &
              A(K + 8)) * T + A(K + 9)) * T + A(K + 10)) * T + 	  &
              A(K + 11)) * T + A(K + 12)) * W
      ELSE IF (W .LT. 6.9D0) THEN
          K = INT(W)
          T = W - K
          K = 13 * (K - 2)
          Y = (((((((((((B(K) * T + B(K + 1)) * T +               &
              B(K + 2)) * T + B(K + 3)) * T + B(K + 4)) * T + 	  &
              B(K + 5)) * T + B(K + 6)) * T + B(K + 7)) * T + 	  &
              B(K + 8)) * T + B(K + 9)) * T + B(K + 10)) * T + 	  &
              B(K + 11)) * T + B(K + 12)
          Y = Y * Y
          Y = Y * Y
          Y = Y * Y
          Y = 1 - Y * Y
      ELSE
          Y = 1
      END IF
      IF (X .LT. 0) Y = -Y
      DERF1 = Y
      END FUNCTION DERF1

!+---+-----------------------------------------------------------------+

      subroutine radar_init

      IMPLICIT NONE
      INTEGER:: n
      PI5 = PI*PI*PI*PI*PI
      lamda4 = lamda_radar*lamda_radar*lamda_radar*lamda_radar
      m_w_0 = m_complex_water_ray (lamda_radar, 0.0d0)
      m_i_0 = m_complex_ice_maetzler (lamda_radar, 0.0d0)
      K_w = (ABS( (m_w_0*m_w_0 - 1.0) /(m_w_0*m_w_0 + 2.0) ))**2

      do n = 1, nbins+1
         simpson(n) = 0.0d0
      enddo
      do n = 1, nbins-1, 2
         simpson(n) = simpson(n) + basis(1)
         simpson(n+1) = simpson(n+1) + basis(2)
         simpson(n+2) = simpson(n+2) + basis(3)
      enddo

      do n = 1, slen
         mixingrulestring_s(n:n) = char(0)
         matrixstring_s(n:n) = char(0)
         inclusionstring_s(n:n) = char(0)
         hoststring_s(n:n) = char(0)
         hostmatrixstring_s(n:n) = char(0)
         hostinclusionstring_s(n:n) = char(0)
         mixingrulestring_g(n:n) = char(0)
         matrixstring_g(n:n) = char(0)
         inclusionstring_g(n:n) = char(0)
         hoststring_g(n:n) = char(0)
         hostmatrixstring_g(n:n) = char(0)
         hostinclusionstring_g(n:n) = char(0)
      enddo

      mixingrulestring_s = 'maxwellgarnett'
      hoststring_s = 'air'
      matrixstring_s = 'water'
      inclusionstring_s = 'spheroidal'
      hostmatrixstring_s = 'icewater'
      hostinclusionstring_s = 'spheroidal'

      mixingrulestring_g = 'maxwellgarnett'
      hoststring_g = 'air'
      matrixstring_g = 'water'
      inclusionstring_g = 'spheroidal'
      hostmatrixstring_g = 'icewater'
      hostinclusionstring_g = 'spheroidal'

      end subroutine radar_init
!+---+-----------------------------------------------------------------+

      COMPLEX*16 FUNCTION m_complex_water_ray(lambda,T)

!      Complex refractive Index of Water as function of Temperature T
!      [deg C] and radar wavelength lambda [m]; valid for
!      lambda in [0.001,1.0] m; T in [-10.0,30.0] deg C
!      after Ray (1972)

      IMPLICIT NONE
      DOUBLE PRECISION, INTENT(IN):: T,lambda
      DOUBLE PRECISION:: epsinf,epss,epsr,epsi
      DOUBLE PRECISION:: alpha,lambdas,sigma,nenner
      COMPLEX*16, PARAMETER:: i = (0d0,1d0)

      epsinf  = 5.27137d0 + 0.02164740d0 * T - 0.00131198d0 * T*T
      epss    = 78.54d+0 * (1.0 - 4.579d-3 * (T - 25.0)                 &
              + 1.190d-5 * (T - 25.0)*(T - 25.0)                        &
              - 2.800d-8 * (T - 25.0)*(T - 25.0)*(T - 25.0))
      alpha   = -16.8129d0/(T+273.16) + 0.0609265d0
      lambdas = 0.00033836d0 * exp(2513.98d0/(T+273.16)) * 1e-2

      nenner = 1.d0+2.d0*(lambdas/lambda)**(1d0-alpha)*sin(alpha*PI*0.5) &
             + (lambdas/lambda)**(2d0-2d0*alpha)
      epsr = epsinf + ((epss-epsinf) * ((lambdas/lambda)**(1d0-alpha)   &
           * sin(alpha*PI*0.5)+1d0)) / nenner
      epsi = ((epss-epsinf) * ((lambdas/lambda)**(1d0-alpha)            &
           * cos(alpha*PI*0.5)+0d0)) / nenner                           &
           + lambda*1.25664/1.88496
      
      m_complex_water_ray = SQRT(CMPLX(epsr,-epsi))
      
      END FUNCTION m_complex_water_ray

!+---+-----------------------------------------------------------------+
      
      COMPLEX*16 FUNCTION m_complex_ice_maetzler(lambda,T)
      
!      complex refractive index of ice as function of Temperature T
!      [deg C] and radar wavelength lambda [m]; valid for
!      lambda in [0.0001,30] m; T in [-250.0,0.0] C
!      Original comment from the Matlab-routine of Prof. Maetzler:
!      Function for calculating the relative permittivity of pure ice in
!      the microwave region, according to C. Maetzler, "Microwave
!      properties of ice and snow", in B. Schmitt et al. (eds.) Solar
!      System Ices, Astrophys. and Space Sci. Library, Vol. 227, Kluwer
!      Academic Publishers, Dordrecht, pp. 241-257 (1998). Input:
!      TK = temperature (K), range 20 to 273.15
!      f = frequency in GHz, range 0.01 to 3000
         
      IMPLICIT NONE
      DOUBLE PRECISION, INTENT(IN):: T,lambda
      DOUBLE PRECISION:: f,c,TK,B1,B2,b,deltabeta,betam,beta,theta,alfa

      c = 2.99d8
      TK = T + 273.16
      f = c / lambda * 1d-9

      B1 = 0.0207
      B2 = 1.16d-11
      b = 335.0d0
      deltabeta = EXP(-10.02 + 0.0364*(TK-273.16))
      betam = (B1/TK) * ( EXP(b/TK) / ((EXP(b/TK)-1)**2) ) + B2*f*f
      beta = betam + deltabeta
      theta = 300. / TK - 1.
      alfa = (0.00504d0 + 0.0062d0*theta) * EXP(-22.1d0*theta)
      m_complex_ice_maetzler = 3.1884 + 9.1e-4*(TK-273.16)
      m_complex_ice_maetzler = m_complex_ice_maetzler                   &
                             + CMPLX(0.0d0, (alfa/f + beta*f)) 
      m_complex_ice_maetzler = SQRT(CONJG(m_complex_ice_maetzler))
      
      END FUNCTION m_complex_ice_maetzler
!+---+-----------------------------------------------------------------+

      subroutine rayleigh_soak_wetgraupel (x_g, a_geo, b_geo, fmelt,    &
                     meltratio_outside, m_w, m_i, lambda, C_back,       &
                     mixingrule,matrix,inclusion,                       &
                     host,hostmatrix,hostinclusion)

      IMPLICIT NONE

      DOUBLE PRECISION, INTENT(in):: x_g, a_geo, b_geo, fmelt, lambda,  &
                                     meltratio_outside
      DOUBLE PRECISION, INTENT(out):: C_back
      COMPLEX*16, INTENT(in):: m_w, m_i
      CHARACTER(len=*), INTENT(in):: mixingrule, matrix, inclusion,     &
                                     host, hostmatrix, hostinclusion

      COMPLEX*16:: m_core, m_air
      DOUBLE PRECISION:: D_large, D_g, rhog, x_w, xw_a, fm, fmgrenz,    &
                         volg, vg, volair, volice, volwater,            &
                         meltratio_outside_grenz, mra
      INTEGER:: error
      real :: rho_i, rho_w

      rho_i = 900.
      rho_w = 1000.


!     refractive index of air:
      m_air = (1.0d0,0.0d0)

!     Limiting the degree of melting --- for safety: 
      fm = DMAX1(DMIN1(fmelt, 1.0d0), 0.0d0)
!     Limiting the ratio of (melting on outside)/(melting on inside):
      mra = DMAX1(DMIN1(meltratio_outside, 1.0d0), 0.0d0)

!    ! The relative portion of meltwater melting at outside should increase
!    ! from the given input value (between 0 and 1)
!    ! to 1 as the degree of melting approaches 1,
!    ! so that the melting particle "converges" to a water drop.
!    ! Simplest assumption is linear:
      mra = mra + (1.0d0-mra)*fm

      x_w = x_g * fm

      D_g = a_geo * x_g**b_geo

      if (D_g .ge. 1d-12) then

       vg = PI/6. * D_g**3
       rhog = DMAX1(DMIN1(x_g / vg, DBLE(rho_i)), 10.0d0)
       vg = x_g / rhog
      
       meltratio_outside_grenz = 1.0d0 - rhog / rho_w

       if (mra .le. meltratio_outside_grenz) then
        !..In this case, it cannot happen that, during melting, all the
        !.. air inclusions within the ice particle get filled with
        !.. meltwater. This only happens at the end of all melting.
        volg = vg * (1.0d0 - mra * fm)
 
       else
        !..In this case, at some melting degree fm, all the air
        !.. inclusions get filled with meltwater.
        fmgrenz=(rho_i-rhog)/(mra*rho_i-rhog+rho_i*rhog/rho_w)

        if (fm .le. fmgrenz) then
         !.. not all air pockets are filled:
         volg = (1.0 - mra * fm) * vg
        else
         !..all air pockets are filled with meltwater, now the
         !.. entire ice sceleton melts homogeneously:
         volg = (x_g - x_w) / rho_i + x_w / rho_w
        endif

       endif

       D_large  = (6.0 / PI * volg) ** (1./3.)
       volice = (x_g - x_w) / (volg * rho_i)
       volwater = x_w / (rho_w * volg)
       volair = 1.0 - volice - volwater
      
       !..complex index of refraction for the ice-air-water mixture
       !.. of the particle:
       m_core = get_m_mix_nested (m_air, m_i, m_w, volair, volice,      &
                         volwater, mixingrule, host, matrix, inclusion, &
                         hostmatrix, hostinclusion, error)
       if (error .ne. 0) then
        C_back = 0.0d0
        return
       endif

       !..Rayleigh-backscattering coefficient of melting particle: 
       C_back = (ABS((m_core**2-1.0d0)/(m_core**2+2.0d0)))**2           &
                * PI5 * D_large**6 / lamda4

      else
       C_back = 0.0d0
      endif

      end subroutine rayleigh_soak_wetgraupel
!+---+-----------------------------------------------------------------+

      complex*16 function get_m_mix_nested (m_a, m_i, m_w, volair,      &
                     volice, volwater, mixingrule, host, matrix,        &
                     inclusion, hostmatrix, hostinclusion, cumulerror)

      IMPLICIT NONE

      DOUBLE PRECISION, INTENT(in):: volice, volair, volwater
      COMPLEX*16, INTENT(in):: m_a, m_i, m_w
      CHARACTER(len=*), INTENT(in):: mixingrule, host, matrix,          &
                     inclusion, hostmatrix, hostinclusion
      INTEGER, INTENT(out):: cumulerror

      DOUBLE PRECISION:: vol1, vol2
      COMPLEX*16:: mtmp
      INTEGER:: error

      !..Folded: ( (m1 + m2) + m3), where m1,m2,m3 could each be
      !.. air, ice, or water

      cumulerror = 0
      get_m_mix_nested = CMPLX(1.0d0,0.0d0)

      if (host .eq. 'air') then

       if (matrix .eq. 'air') then
        write(mp_debug,*) 'GET_M_MIX_NESTED: bad matrix: ', matrix
!!!        CALL wrf_debug(150, mp_debug)
        cumulerror = cumulerror + 1
       else
        vol1 = volice / MAX(volice+volwater,1d-10)
        vol2 = 1.0d0 - vol1
        mtmp = get_m_mix (m_a, m_i, m_w, 0.0d0, vol1, vol2,             &
                         mixingrule, matrix, inclusion, error)
        cumulerror = cumulerror + error
          
        if (hostmatrix .eq. 'air') then
         get_m_mix_nested = get_m_mix (m_a, mtmp, 2.0*m_a,              &
                         volair, (1.0d0-volair), 0.0d0, mixingrule,     &
                         hostmatrix, hostinclusion, error)
         cumulerror = cumulerror + error
        elseif (hostmatrix .eq. 'icewater') then
         get_m_mix_nested = get_m_mix (m_a, mtmp, 2.0*m_a,              &
                         volair, (1.0d0-volair), 0.0d0, mixingrule,     &
                         'ice', hostinclusion, error)
         cumulerror = cumulerror + error
        else
         write(mp_debug,*) 'GET_M_MIX_NESTED: bad hostmatrix: ',        &
                           hostmatrix
!!!         CALL wrf_debug(150, mp_debug)
         cumulerror = cumulerror + 1
        endif
       endif

      elseif (host .eq. 'ice') then

       if (matrix .eq. 'ice') then
        write(mp_debug,*) 'GET_M_MIX_NESTED: bad matrix: ', matrix
!!!        CALL wrf_debug(150, mp_debug)
        cumulerror = cumulerror + 1
       else
        vol1 = volair / MAX(volair+volwater,1d-10)
        vol2 = 1.0d0 - vol1
        mtmp = get_m_mix (m_a, m_i, m_w, vol1, 0.0d0, vol2,             &
                         mixingrule, matrix, inclusion, error)
        cumulerror = cumulerror + error

        if (hostmatrix .eq. 'ice') then
         get_m_mix_nested = get_m_mix (mtmp, m_i, 2.0*m_a,              &
                         (1.0d0-volice), volice, 0.0d0, mixingrule,     &
                         hostmatrix, hostinclusion, error)
         cumulerror = cumulerror + error
        elseif (hostmatrix .eq. 'airwater') then
         get_m_mix_nested = get_m_mix (mtmp, m_i, 2.0*m_a,              &
                         (1.0d0-volice), volice, 0.0d0, mixingrule,     &
                         'air', hostinclusion, error)
         cumulerror = cumulerror + error          
        else
         write(mp_debug,*) 'GET_M_MIX_NESTED: bad hostmatrix: ',        &
                           hostmatrix
!!!         CALL wrf_debug(150, mp_debug)
         cumulerror = cumulerror + 1
        endif
       endif

      elseif (host .eq. 'water') then

       if (matrix .eq. 'water') then
        write(mp_debug,*) 'GET_M_MIX_NESTED: bad matrix: ', matrix
!!!        CALL wrf_debug(150, mp_debug)
        cumulerror = cumulerror + 1
       else
        vol1 = volair / MAX(volice+volair,1d-10)
        vol2 = 1.0d0 - vol1
        mtmp = get_m_mix (m_a, m_i, m_w, vol1, vol2, 0.0d0,             &
                         mixingrule, matrix, inclusion, error)
        cumulerror = cumulerror + error

        if (hostmatrix .eq. 'water') then
         get_m_mix_nested = get_m_mix (2.0d0*m_a, mtmp, m_w,            &
                         0.0d0, (1.0d0-volwater), volwater, mixingrule, &
                         hostmatrix, hostinclusion, error)
         cumulerror = cumulerror + error
        elseif (hostmatrix .eq. 'airice') then
         get_m_mix_nested = get_m_mix (2.0d0*m_a, mtmp, m_w,            &
                         0.0d0, (1.0d0-volwater), volwater, mixingrule, &
                         'ice', hostinclusion, error)
         cumulerror = cumulerror + error          
        else
         write(mp_debug,*) 'GET_M_MIX_NESTED: bad hostmatrix: ',         &
                           hostmatrix
!!!         CALL wrf_debug(150, mp_debug)
         cumulerror = cumulerror + 1
        endif
       endif

      elseif (host .eq. 'none') then

       get_m_mix_nested = get_m_mix (m_a, m_i, m_w,                     &
                       volair, volice, volwater, mixingrule,            &
                       matrix, inclusion, error)
       cumulerror = cumulerror + error
        
      else
       write(mp_debug,*) 'GET_M_MIX_NESTED: unknown matrix: ', host
!!!       CALL wrf_debug(150, mp_debug)
       cumulerror = cumulerror + 1
      endif

      IF (cumulerror .ne. 0) THEN
       write(mp_debug,*) 'GET_M_MIX_NESTED: error encountered'
!!!       CALL wrf_debug(150, mp_debug)
       get_m_mix_nested = CMPLX(1.0d0,0.0d0)    
      endif

      end function get_m_mix_nested

!+---+-----------------------------------------------------------------+

      COMPLEX*16 FUNCTION get_m_mix (m_a, m_i, m_w, volair, volice,     &
                     volwater, mixingrule, matrix, inclusion, error)

      IMPLICIT NONE

      DOUBLE PRECISION, INTENT(in):: volice, volair, volwater
      COMPLEX*16, INTENT(in):: m_a, m_i, m_w
      CHARACTER(len=*), INTENT(in):: mixingrule, matrix, inclusion
      INTEGER, INTENT(out):: error

      error = 0
      get_m_mix = CMPLX(1.0d0,0.0d0)

      if (mixingrule .eq. 'maxwellgarnett') then
       if (matrix .eq. 'ice') then
        get_m_mix = m_complex_maxwellgarnett(volice, volair, volwater,  &
                           m_i, m_a, m_w, inclusion, error)
       elseif (matrix .eq. 'water') then
        get_m_mix = m_complex_maxwellgarnett(volwater, volair, volice,  &
                           m_w, m_a, m_i, inclusion, error)
       elseif (matrix .eq. 'air') then
        get_m_mix = m_complex_maxwellgarnett(volair, volwater, volice,  &
                           m_a, m_w, m_i, inclusion, error)
       else
        write(mp_debug,*) 'GET_M_MIX: unknown matrix: ', matrix
!!!        CALL wrf_debug(150, mp_debug)
        error = 1
       endif

      else
       write(mp_debug,*) 'GET_M_MIX: unknown mixingrule: ', mixingrule
!!!       CALL wrf_debug(150, mp_debug)
       error = 2
      endif

      if (error .ne. 0) then
       write(mp_debug,*) 'GET_M_MIX: error encountered'
!!!       CALL wrf_debug(150, mp_debug)
      endif

      END FUNCTION get_m_mix

!+---+-----------------------------------------------------------------+

      COMPLEX*16 FUNCTION m_complex_maxwellgarnett(vol1, vol2, vol3,    &
                     m1, m2, m3, inclusion, error)

      IMPLICIT NONE

      COMPLEX*16 :: m1, m2, m3
      DOUBLE PRECISION :: vol1, vol2, vol3
      CHARACTER(len=*) :: inclusion

      COMPLEX*16 :: beta2, beta3, m1t, m2t, m3t
      INTEGER, INTENT(out) :: error

      error = 0

      if (DABS(vol1+vol2+vol3-1.0d0) .gt. 1d-6) then
       write(mp_debug,*) 'M_COMPLEX_MAXWELLGARNETT: sum of the ',       &
              'partial volume fractions is not 1...ERROR'
!!!       CALL wrf_debug(150, mp_debug)
       m_complex_maxwellgarnett=CMPLX(-999.99d0,-999.99d0)
       error = 1
       return
      endif

      m1t = m1**2
      m2t = m2**2
      m3t = m3**2

      if (inclusion .eq. 'spherical') then
       beta2 = 3.0d0*m1t/(m2t+2.0d0*m1t)
       beta3 = 3.0d0*m1t/(m3t+2.0d0*m1t)
      elseif (inclusion .eq. 'spheroidal') then
       beta2 = 2.0d0*m1t/(m2t-m1t) * (m2t/(m2t-m1t)*LOG(m2t/m1t)-1.0d0)
       beta3 = 2.0d0*m1t/(m3t-m1t) * (m3t/(m3t-m1t)*LOG(m3t/m1t)-1.0d0)
      else
       write(mp_debug,*) 'M_COMPLEX_MAXWELLGARNETT: ',                  &
                         'unknown inclusion: ', inclusion
!!!       CALL wrf_debug(150, mp_debug)
       m_complex_maxwellgarnett=DCMPLX(-999.99d0,-999.99d0)
       error = 1
       return
      endif

      m_complex_maxwellgarnett = &
       SQRT(((1.0d0-vol2-vol3)*m1t + vol2*beta2*m2t + vol3*beta3*m3t) / &
       (1.0d0-vol2-vol3+vol2*beta2+vol3*beta3))

      END FUNCTION m_complex_maxwellgarnett

!+---+-----------------------------------------------------------------+
!..Compute radar reflectivity assuming 10 cm wavelength radar and using
!.. Rayleigh approximation.  Only complication is melted snow/graupel
!.. which we treat as water-coated ice spheres and use Uli Blahak's
!.. library of routines.  The meltwater fraction is simply the amount
!.. of frozen species remaining from what initially existed at the
!.. melting level interface.
!+---+-----------------------------------------------------------------+
      subroutine calc_refl10cm (qv1d, qr1d, qs1d, qg1d, t1d, p1d, dBZ,  &
                          kts, kte, ii, jj, nr1d, ns1d, ng1d)

      IMPLICIT NONE

!..Sub arguments
      INTEGER, INTENT(IN):: kts, kte, ii, jj
      REAL, DIMENSION(kts:kte), INTENT(IN)::                            &
                qv1d, qr1d, qs1d, qg1d, t1d, p1d, nr1d, ns1d, ng1d
      REAL, DIMENSION(kts:kte), INTENT(INOUT):: dBZ

!..Local variables
      REAL, DIMENSION(kts:kte):: temp, pres, qv, rho
      REAL, DIMENSION(kts:kte):: rr, rs, rg,rnr,rns,rng

      DOUBLE PRECISION, DIMENSION(kts:kte):: ilamr, ilamg, N0_r, N0_g,ilams,n0_s

      REAL, DIMENSION(kts:kte):: ze_rain, ze_snow, ze_graupel

      DOUBLE PRECISION:: lamg
      DOUBLE PRECISION:: fmelt_s, fmelt_g

      INTEGER:: i, k, k_0
      LOGICAL:: melti
      LOGICAL, DIMENSION(kts:kte):: L_qr, L_qs, L_qg

!..Single melting snow/graupel particle 70% meltwater on external sfc
      DOUBLE PRECISION, PARAMETER:: melt_outside_s = 0.7d0
      DOUBLE PRECISION, PARAMETER:: melt_outside_g = 0.7d0

      DOUBLE PRECISION:: cback, x, eta, f_d

! hm added parameter
      REAL R1,t_0,dumlams,dumlamr,dumlamg,dumn0s,dumn0r,dumn0g,ocms,obms,ocmg,obmg

      integer n

      R1 = 1.E-12
      t_0 = 273.15

!+---+

      do k = kts, kte
         dBZ(k) = -35.0
      enddo

!+---+-----------------------------------------------------------------+
!..Put column of data into local arrays.
!+---+-----------------------------------------------------------------+
      do k = kts, kte
         temp(k) = t1d(k)
         qv(k) = MAX(1.E-10, qv1d(k))
         pres(k) = p1d(k)
         rho(k) = 0.622*pres(k)/(R*temp(k)*(qv(k)+0.622))
         if (qr1d(k) .gt. R1) then
            rr(k) = qr1d(k)*rho(k)
            L_qr(k) = .true.
         else
            rr(k) = R1
            L_qr(k) = .false.
         endif
         if (qs1d(k) .gt. R1) then
            rs(k) = qs1d(k)*rho(k)
            L_qs(k) = .true.
         else
            rs(k) = R1
            L_qs(k) = .false.
         endif
         if (qg1d(k) .gt. R1) then
            rg(k) = qg1d(k)*rho(k)
            L_qg(k) = .true.
         else
            rg(k) = R1
            L_qg(k) = .false.
         endif

! hm add number concentration
         if (nr1d(k) .gt. R1) then
            rnr(k) = nr1d(k)*rho(k)
         else
            rnr(k) = R1
         endif
         if (ns1d(k) .gt. R1) then
            rns(k) = ns1d(k)*rho(k)
         else
            rns(k) = R1
         endif
         if (ng1d(k) .gt. R1) then
            rng(k) = ng1d(k)*rho(k)
         else
            rng(k) = R1
         endif

      enddo

!+---+-----------------------------------------------------------------+
!..Calculate y-intercept, slope, and useful moments for snow.
!+---+-----------------------------------------------------------------+
      do k = kts, kte

! compute moments for snow

! calculate slope and intercept parameter

      dumLAMS = (CONS1*rns(K)/rs(K))**(1./DS)
      dumN0S = rns(K)*dumLAMS/rho(k)

! CHECK FOR SLOPE to make sure min/max bounds are not exceeded

! ADJUST VARS

      IF (dumLAMS.LT.LAMMINS) THEN
      dumLAMS = LAMMINS
      dumN0S = dumLAMS**4*rs(K)/CONS1
      ELSE IF (dumLAMS.GT.LAMMAXS) THEN
      dumLAMS = LAMMAXS
      dumN0S = dumLAMS**4*rs(k)/CONS1
      end if

      ilams(k)=1./dumlams
      n0_s(k)=dumn0s

      enddo

!+---+-----------------------------------------------------------------+
!..Calculate y-intercept, slope values for graupel.
!+---+-----------------------------------------------------------------+

      do k = kte, kts, -1


! calculate slope and intercept parameter

      dumLAMg = (CONS2*rng(K)/rg(K))**(1./Dg)
      dumN0g = rng(K)*dumLAMg/rho(k)

! CHECK FOR SLOPE to make sure min/max bounds are not exceeded

! ADJUST VARS

      IF (dumLAMg.LT.LAMMINg) THEN
      dumLAMg = LAMMINg
      dumN0g = dumLAMg**4*rg(K)/CONS2
      ELSE IF (dumLAMg.GT.LAMMAXg) THEN
      dumLAMg = LAMMAXg
      dumN0g = dumLAMg**4*rg(k)/CONS2
      end if

      ilamg(k)=1./dumlamg
      n0_g(k)=dumn0g

      enddo

!+---+-----------------------------------------------------------------+
!..Calculate y-intercept & slope values for rain.
!+---+-----------------------------------------------------------------+

      do k = kte, kts, -1

! calculate slope and intercept parameter

      dumLAMr = (PI*RHOW*rnr(K)/rr(K))**(1./3.)
      dumN0r = rnr(K)*dumLAMr/rho(k)

! CHECK FOR SLOPE to make sure min/max bounds are not exceeded

! ADJUST VARS

      IF (dumLAMr.LT.LAMMINr) THEN
      dumLAMr = LAMMINr
      dumN0r = dumLAMr**4*rr(K)/(PI*RHOW)
      ELSE IF (dumLAMr.GT.LAMMAXr) THEN
      dumLAMr = LAMMAXr
      dumN0r = dumLAMr**4*rr(k)/(PI*RHOW)
      end if

      ilamr(k)=1./dumlamr
      n0_r(k)=dumn0r

      enddo

      melti = .false.
      k_0 = kts
      do k = kte-1, kts, -1
         if ( (temp(k).gt. T_0) .and. (rr(k).gt. 0.001e-3) &
                   .and. ((rs(k+1)+rg(k+1)).gt. 0.01e-3) ) then
            k_0 = MAX(k+1, k_0)
            melti=.true.
            goto 195
         endif
      enddo
 195  continue

!+---+-----------------------------------------------------------------+
!..Assume Rayleigh approximation at 10 cm wavelength. Rain (all temps)
!.. and non-water-coated snow and graupel when below freezing are
!.. simple. Integrations of m(D)*m(D)*N(D)*dD.
!+---+-----------------------------------------------------------------+

      do k = kts, kte
         ze_rain(k) = 1.e-22
         ze_snow(k) = 1.e-22
         ze_graupel(k) = 1.e-22
         if (L_qr(k)) ze_rain(k) = N0_r(k)*720.*ilamr(k)**7

         if (L_qs(k)) ze_snow(k) = (0.176/0.93) * (6.0/PI)*(6.0/PI)     &
                                 * (pi*rhosn/6./900.)*(pi*rhosn/6./900.) &
                                    * N0_s(k)*720.*ilams(k)**7
         if (L_qg(k)) ze_graupel(k) = (0.176/0.93) * (6.0/PI)*(6.0/PI)  &
                                    * (pi*rhog/6./900.)* (pi*rhog/6./900.)        &
                                    * N0_g(k)*720.*ilamg(k)**7
      enddo

!+---+-----------------------------------------------------------------+
!..Special case of melting ice (snow/graupel) particles.  Assume the
!.. ice is surrounded by the liquid water.  Fraction of meltwater is
!.. extremely simple based on amount found above the melting level.
!.. Uses code from Uli Blahak (rayleigh_soak_wetgraupel and supporting
!.. routines).
!+---+-----------------------------------------------------------------+

      if (melti .and. k_0.ge.2) then
       do k = k_0-1, 1, -1

!..Reflectivity contributed by melting snow
          fmelt_s = DMIN1(1.0d0-rs(k)/rs(k_0), 1.0d0)
          if (fmelt_s.gt.0.01d0 .and. fmelt_s.lt.0.99d0 .and.           &
                         rs(k).gt.R1) then
           eta = 0.d0
           obms = 1./ds
           ocms = (1./(pi*rhosn/6.))**obms
           do n = 1, nbs
              x = pi*rhosn/6. * Dds(n)**3
              call rayleigh_soak_wetgraupel (x, DBLE(ocms), DBLE(obms), &
                    fmelt_s, melt_outside_s, m_w_0, m_i_0, lamda_radar, &
                    CBACK, mixingrulestring_s, matrixstring_s,          &
                    inclusionstring_s, hoststring_s,                    &
                    hostmatrixstring_s, hostinclusionstring_s)
              f_d = N0_s(k)* DEXP(-Dds(n)/ilams(k))
              eta = eta + f_d * CBACK * simpson(n) * dts(n)

           enddo
           ze_snow(k) = SNGL(lamda4 / (pi5 * K_w) * eta)
          endif


!..Reflectivity contributed by melting graupel

          fmelt_g = DMIN1(1.0d0-rg(k)/rg(k_0), 1.0d0)
          if (fmelt_g.gt.0.01d0 .and. fmelt_g.lt.0.99d0 .and.           &
                         rg(k).gt.R1) then
           eta = 0.d0
           lamg = 1./ilamg(k)
           obmg = 1./dg
           ocmg = (1./(pi*rhog/6.))**obmg
           do n = 1, nbg
              x = pi*rhog/6. * Ddg(n)**3
              call rayleigh_soak_wetgraupel (x, DBLE(ocmg), DBLE(obmg), &
                    fmelt_g, melt_outside_g, m_w_0, m_i_0, lamda_radar, &
                    CBACK, mixingrulestring_g, matrixstring_g,          &
                    inclusionstring_g, hoststring_g,                    &
                    hostmatrixstring_g, hostinclusionstring_g)
              f_d = N0_g(k)* DEXP(-lamg*Ddg(n))
              eta = eta + f_d * CBACK * simpson(n) * dtg(n)
           enddo
           ze_graupel(k) = SNGL(lamda4 / (pi5 * K_w) * eta)
          endif

       enddo
      endif

      do k = kte, kts, -1
         dBZ(k) = 10.*log10((ze_rain(k)+ze_snow(k)+ze_graupel(k))*1.d18)
      enddo


      end subroutine calc_refl10cm

END MODULE module_mp_morr_two_moment
param.F/        1298670057  19071 8000  100644  145723    `


      subroutine param(dt,dtlast,stattim,taptim,rsttim,radtim,          &
                       cloudvar,rhovar,qname,budname,                   &
                       xh,rxh,uh,ruh,xf,rxf,uf,ruf,yh,vh,rvh,yf,vf,rvf, &
                       xfref,yfref,                                     &
                       sigma,sigmaf,tauh,taus,zh,mh,rmh,tauf,zf,mf,rmf, &
                       zs,gz,dzdx,dzdy,gx,gy)
      use module_mp_thompson
      use module_mp_morr_two_moment
      use orfiomod
      implicit none

      include 'input.incl'
      include 'constants.incl'
#ifdef MPI
      include 'mpif.h'
#endif


      real :: dt,dtlast
      real*8 :: stattim,taptim,rsttim,radtim
      logical, dimension(maxq) :: cloudvar,rhovar
      character*3, dimension(maxq) :: qname
      character*6, dimension(maxq) :: budname
      real, dimension(ib:ie) :: xh,rxh,uh,ruh
      real, dimension(ib:ie+1) :: xf,rxf,uf,ruf
      real, dimension(jb:je) :: yh,vh,rvh
      real, dimension(jb:je+1) :: yf,vf,rvf
      real, dimension(-2:nx+4) :: xfref
      real, dimension(-2:ny+4) :: yfref
      real, dimension(kb:ke) :: sigma
      real, dimension(kb:ke+1) :: sigmaf
      real, dimension(ib:ie,jb:je,kb:ke) :: tauh,taus,zh,mh,rmh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: tauf,zf,mf,rmf
      real, dimension(itb:ite,jtb:jte) :: zs,gz,dzdx,dzdy
      real, dimension(itb:ite+1,jtb:jte,ktb:kte) :: gx
      real, dimension(itb:ite,jtb:jte+1,ktb:kte) :: gy

!-----------------------------------------------------------------------

      integer i,j,k,n,kst,ni1,ni2,ni3,nj1,nj2,nj3,nk1,nk2,nk3
      integer ival,jval
      integer iterrain
      real :: var
#ifdef MPI
      character*50 fname
      integer nabor
#endif


! ORF 1/14/11
! Set up communicators for doing I/O on less than one file per core

! This is for blueprint, 16 cores per MCM
! Hardware mapping, that's done in load leveler script
! somehow. Assume that virtual mapping is same as hardware.
! cores_per_mcm MUST equal corex*corey
! mymcmid is not used by MPI, it's the equivalent to what myid would be
! if each MCM were a MPI process. It is used to name the hdf files though!
! mysubgrouprank (used in hdf I/O code) is the rank of the group mymcmgroup which goes from 0 to
! cores_per_mcm on each MCM
! So each core has two ranks, myid (MPI_COMM_WORLD) and mysubgrouprank (mysubgroupcomm)
! mysubgrouprank can be extracted with mpi_grouprank(mysubgroupcomm,mysubgrouprank,ierror)

      integer icount
      integer, dimension (:), allocatable :: mygroupranks,mcmxranks,mcmyranks,mcmrootranks
      integer, dimension (1) :: rootonlyranks
            integer, dimension (:), allocatable :: x1dranks,y1dranks
            integer ierror,orig_group
      !ORF -----end-----

            real c1,c2,nominal_dx,nominal_dy,nominal_dz,z1,z2,z3,mult
            real x1,x2,y1,y2

            namelist /param1/ dx,dy,dz,dtl,timax,tapfrq,rstfrq,statfrq,prclfrq
            namelist /param2/                                                 &
                adapt_dt,irst,rstnum,iconly,hadvorder,vadvorder,ifall,pdscheme, &
                advweno,idiff,vdiff,mdiff,difforder,imoist,iturb,             &
                tconfig,bcturbu,bcturbs,dns,                                  &
                irdamp,hrdamp,psolver,nsound,thsmall,ptype,ihail,iautoc,      &
                icor,pertcor,neweqts,idiss,efall,rterm,                       &
                wbc,ebc,sbc,nbc,irbc,roflux,isnd,iwnd,itern,iinit,irandp,     &
                ibalance,iorigin,axisymm,imove,iptra,npt,iprcl,nparcels
            namelist /param3/ kdiff2,kdiff6,fcor,kdiv,alph,rdalpha,zd,xhd,    &
                              umove,vmove,v_t,l_h,l_v
            namelist /param4/ stretch_x,dx_inner,dx_outer,nos_x_len,tot_x_len
            namelist /param5/ stretch_y,dy_inner,dy_outer,nos_y_len,tot_y_len
            namelist /param6/ stretch_z,ztop,str_bot,str_top,dz_bot,dz_top
            namelist /param7/ bc_wind,bc_temp,ptc_top,ptc_bot,viscosity,pr_num
            namelist /param8/ var1,var2,var3,var4,var5,var6,var7,var8,var9,var10
            namelist /param9/                                                       &
                    output_path,output_basename,output_format,output_filetype,      &
                    output_interp,output_rain,output_sws,output_coldpool,           &
                    output_sfcflx,output_sfcparams,output_sfcdiags,output_zs,       &
                    output_zh,output_basestate,                                     &
                    output_th,output_thpert,output_prs,output_prspert,              &
                    output_pi,output_pipert,output_rho,output_rhopert,output_tke,   &
                    output_km,output_kh,                                            &
                    output_qv,output_qvpert,output_q,output_dbz,                    &
                    output_u,output_upert,output_uinterp,                           &
                    output_v,output_vpert,output_vinterp,output_w,output_winterp,   &
                    output_vort,output_uh,output_pblten,output_dissten,             &
                    output_radten
            namelist /param10/                                                      &
                    stat_w,stat_u,stat_v,stat_rmw,stat_pipert,stat_prspert,         &
                    stat_thpert,stat_q,                                             &
                    stat_tke,stat_km,stat_kh,stat_div,stat_rh,stat_rhi,stat_the,    &
                    stat_cloud,stat_sfcprs,stat_wsp,stat_cfl,stat_vort,             &
                    stat_tmass,stat_tmois,stat_qmass,stat_tenerg,stat_mo,stat_tmf,  &
                    stat_pcn,stat_qsrc
            namelist /param11/                                                      &
                    radopt,dtrad,ctrlat,ctrlon,year,month,day,hour,minute,second
            namelist /param12/                                                      &
                    idrag,isfcflx,sfcmodel,oceanmodel,ipbl,initsfc,                 &
                    tsk0,tmn0,xland0,lu0,season,cecd,pertflx,cnstce,cnstcd,         &
                    isftcflx,iz0tlnd,oml_hml0,oml_gamma

      !--------------------------------------------------------------

#ifdef MPI
            if(myid.eq.0) then
                  fname='proc00000.print.out'
                  open(unit=10,file=fname,status='unknown')
            endif
#endif

      if(myid.eq.0)write(outfile,*) 'Inside PARAM'

#ifndef MPI
      !--------------------------------------------------------------

            if(nodex.ne.1 .or. nodey.ne.1)then
              print *
              print *,'  For non-MPI runs, nodex and nodey must be = 1 !'
              print *
              call stopcm1
            endif

#endif
      !--------------------------------------------------------------

#ifdef MPI
            if(myid.eq.0)then
#endif

            open(unit=20,file='namelist.input',form='formatted',status='old',    &
                 access='sequential')
            read(20,nml=param1)
            read(20,nml=param2)
            read(20,nml=param3)
            read(20,nml=param11)
            read(20,nml=param12)
            read(20,nml=param4)
            read(20,nml=param5)
            read(20,nml=param6)
            read(20,nml=param7)
            read(20,nml=param8)
            read(20,nml=param9)
            read(20,nml=param10)
      !!!      IF ( ptype .ge. 26 ) THEN
      !!!         read(20,nml=micro_params)
      !!!      ENDIF
            close(unit=20)

      !-----------------------------------------------------------------------
      !  Some dummy checks:

            if(imoist.ne.1) neweqts=0
            if(imoist.ne.1) efall=0

            if( (thsmall.eq.1).and.((psolver.le.1).or.(psolver.ge.4)) ) thsmall=0

            IF( psolver.eq.1 .and. adapt_dt.eq.1 )THEN
              print *
              print *,'  psolver  = ',psolver
              print *,'  adapt_dt = ',adapt_dt
              print *
              print *,'  Cannot use adapt_dt with psolver=1 '
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF(dns.gt.1.or.dns.lt.0)THEN
              print *
              print *,'  dns   = ',dns
              print *
              print *,'  dns must be either 0 or 1'
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF(iturb.gt.3.or.iturb.lt.0)THEN
              print *
              print *,'  iturb   = ',iturb
              print *
              print *,'  iturb must be either 0, 1, 2, or 3'
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF(iturb.ge.1 .and. dns.ge.1)THEN
              print *
              print *,'  iturb = ',iturb
              print *,'  dns   = ',dns
              print *
              print *,'  For dns = 1, iturb must be 0'
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF(bcturbu.lt.1.or.bcturbu.gt.3)THEN
              print *
              print *,'  bcturbu = ',bcturbu
              print *
              print *,'  bcturbu must be 1, 2, or 3'
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF(bcturbs.lt.1.or.bcturbs.gt.3)THEN
              print *
              print *,'  bcturbs = ',bcturbs
              print *
              print *,'  bcturbs must be 1, 2, or 3'
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF(dns.ge.1 .and. imoist.ge.1)THEN
              print *
              print *,'  imoist = ',imoist
              print *,'  dns    = ',dns
              print *
              print *,'  For dns = 1, imoist must be 0'
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF(imoist.eq.1 .and. (isnd.eq.1.or.isnd.eq.2   &
                              .or.isnd.eq.3.or.isnd.eq.8.) )THEN
              print *
              print *,'  imoist = ',imoist
              print *,'  isnd   = ',isnd
              print *
              print *,'  For this value of isnd, imoist must be 0'
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF(dns.eq.1 .and. (bc_wind.le.0 .or. bc_wind.ge.3))THEN
              print *
              print *,'  dns     = ',dns
              print *,'  bc_wind = ',bc_wind
              print *
              print *,'  for dns = 1, bc_wind must be either 1 or 2'
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF(dns.eq.1 .and. (bc_temp.le.0 .or. bc_temp.ge.3))THEN
              print *
              print *,'  dns     = ',dns
              print *,'  bc_temp = ',bc_temp
              print *
              print *,'  for dns = 1, bc_temp must be either 1 or 2'
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF(ihail.lt.0.or.ihail.gt.1)THEN
              print *
              print *,'  ihail   = ',ihail
              print *
              print *,'  ihail must be 0 or 1'
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF(imoist.eq.1.and.output_dbz.eq.1.and.ptype.ne.2.and.ptype.ne.3.and.ptype.ne.5)then
              print *
              print *,'  ptype      = ',ptype
              print *,'  output_dbz = ',output_dbz
              print *
              print *,'  output_dbz is only available for ptype=2,3,5'
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF(imoist.eq.1 .and. neweqts.ge.1 .and. ptype.eq.4)THEN
              print *
              print *,'  neweqts = ',neweqts
              print *,'  ptype   = ',ptype
              print *
              print *,'  neweqts >= 1 is not available for ptype = 4'
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF(imoist.eq.1 .and. efall.eq.1)THEN
            IF(ptype.ne.1.and.ptype.ne.2.and.ptype.ne.6)THEN
              print *
              print *,'  efall   = ',efall
              print *,'  ptype   = ',ptype
              print *
              print *,'  efall = 1 is only supported with ptype = 1,2,6'
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            ENDIF
            IF((imoist.eq.1).and.(ptype.eq.4).and.terrain_flag)THEN
              print *
              print *,'  ptype   = ',ptype
              print *,'  terrain_flag = ',terrain_flag
              print *
              print *,'  ptype = 4 does not work with terrain '
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF(terrain_flag .and. (psolver.eq.4.or.psolver.eq.5) )THEN
              print *
              print *,'  terrain_flag = ',terrain_flag
              print *,'  psolver      = ',psolver
              print *
              print *,'  for psolver = 4 or 5, terrain_flag must be .false.'
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF( (psolver.eq.4.or.psolver.eq.5) .and.    &
                (wbc.eq.2.or.ebc.eq.2.or.sbc.eq.2.or.nbc.eq.2) )THEN
              print *
              print *,'  psolver = ',psolver
              print *
              print *,'  cannot use open boundary conditions for psolver = 4 and 5 (at the moment)'
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF(terrain_flag .and. ibalance.eq.2)THEN
              print *
              print *,'  terrain_flag = ',terrain_flag
              print *,'  ibalance     = ',ibalance
              print *
              print *,'  for ibalance.eq.2, terrain_flag must be .false.'
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF(terrain_flag .and. psolver.eq.1)THEN
              print *
              print *,'  terrain_flag = ',terrain_flag
              print *,'  psolver      = ',psolver
              print *
              print *,'  for psolver.eq.1, terrain_flag must be .false.'
              print *,'  (dunno why.  ask George.)'
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF(iinit.eq.6)THEN
              print *
              print *,'  iinit        = ',iinit
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF( (output_format.le.0) .or. (output_format.ge.6) )THEN
              print *
              print *,'  output_format = ',output_format
              print *
              print *,'  only output_format = 1,2,3,4,5 are currently supported'
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF( (axisymm.eq.1) .and. (iorigin.ne.1) )THEN
              print *
              print *,'  iorigin = ',iorigin
              print *
              print *,'  axisymm=1 requires iorigin=1'
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF( (axisymm.eq.1) .and. (imove.ne.0) )THEN
              print *
              print *,'  imove = ',imove
              print *
              print *,'  axisymm=1 requires imove=0'
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF( (axisymm.eq.1) .and. terrain_flag )THEN
              print *
              print *,'  terrain_flag = ',terrain_flag
              print *
              print *,'  axisymm=1 cannot be used with terrain '
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF( (axisymm.eq.1).and.(icor.eq.0) ) fcor = 0.0
            IF( (axisymm.eq.1) .and. (wbc.ne.3) )THEN
              print *
              print *,'  wbc = ',wbc
              print *
              print *,'  axisymm=1 requires wbc=3 '
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF( (axisymm.eq.1) .and. ( (sbc.ne.1).or.(nbc.ne.1) ) )THEN
              print *
              print *,'  sbc = ',sbc
              print *,'  nbc = ',nbc
              print *
              print *,'  axisymm=1 requires sbc=nbc=1 '
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF( (axisymm.eq.1).and.(ny.gt.1) )THEN
              print *
              print *,'  ny = ',ny
              print *
              print *,'  axisymm=1 requires ny=1'
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF( (axisymm.eq.1.and.iturb.ge.1).and.iturb.ne.3 )THEN
              print *
              print *,'  iturb    = ',iturb
              print *
              print *,'  axisymm=1 is only available with iturb=3'
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF( axisymm.eq.1.and.(psolver.lt.2.or.psolver.gt.3) )THEN
              print *
              print *,'  psolver    = ',psolver
              print *
              print *,'  axisymm=1 is only available with psolver=2 or 3'
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF( (iturb.eq.3) .and. (tconfig.ne.2) )THEN
              print *
              print *,'  iturb    = ',iturb
              print *,'  tconfig  = ',tconfig
              print *
              print *,'  iturb=3 requires tconfig=2'
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF( (idrag.eq.1).and.(bcturbu.ne.3) )THEN
              print *
              print *,'  idrag    = ',idrag
              print *,'  bcturbu  = ',bcturbu
              print *
              print *,'  idrag=1 requires bcturbu=3'
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF( (idrag.eq.1).or.(isfcflx.eq.1) )THEN
            IF( iturb.eq.0 .and. ipbl.eq.0 )THEN
              print *
              print *,'  idrag    = ',idrag
              print *,'  isfcflx  = ',isfcflx
              print *
              print *,'  these options require the use of a subgrid turbulence scheme'
              print *
              print *,'  iturb    = ',iturb
              print *,'  ipbl     = ',ipbl
              print *
              print *,'  Use iturb = 1,2,3 or ipbl = 1'
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            ENDIF
            IF( ipbl.ge.1 .and. (iturb.eq.1.or.iturb.eq.2) )THEN
              print *
              print *,'  ipbl  = ',ipbl
              print *,'  iturb = ',iturb
              print *
              print *,'  cannot use PBL scheme and LES subgrid turbulence scheme at same time '
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF( ipbl.ge.1 .and. iturb.eq.3 .and. abs(l_v).gt.1.0e-6 )THEN
              print *
              print *,'  ipbl  = ',ipbl
              print *,'  iturb = ',iturb
              print *,'  l_v   = ',l_v
              print *
              print *,'  the PBL scheme requires l_v = 0 '
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
          IF( isfcflx.ne.0 )THEN
            IF( sfcmodel.lt.1 .or. sfcmodel.gt.2 )THEN
              print *
              print *,'  sfcmodel   = ',sfcmodel
              print *
              print *,'  sfcmodel must be 1,2 (for cm1r15) '
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
          ELSE
            IF( sfcmodel.ne.0 )THEN
              print *
              print *,'  isfcflx    = ',isfcflx
              print *,'  sfcmodel   = ',sfcmodel
              print *
              print *,'  sfcmodel must be 0 for isfcflx = 0 '
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
          ENDIF
            IF( sfcmodel.eq.2.and.imove.ne.0 )THEN
              print *
              print *,'  sfcmodel = ',sfcmodel
              print *,'  imove     = ',imove
              print *
              print *,'  domain translation is now allowed with sfcmodel = 2 '
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF( sfcmodel.eq.2.and.(season.le.0.or.season.ge.3) )THEN
              print *
              print *,'  sfcmodel = ',sfcmodel
              print *,'  season   = ',season
              print *
              print *,'  season must have a value of 1 or 2 '
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF( pertflx.eq.1 .and. sfcmodel.ge.2 )THEN
              print *
              print *,'  pertflx  = ',pertflx
              print *,'  sfcmodel = ',sfcmodel
              print *
              print *,'  pertflx can only be used with sfcmodel = 1  '
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF( sfcmodel.eq.1 .and. oceanmodel.ne.1 )THEN
              print *
              print *,'  sfcmodel   = ',sfcmodel
              print *,'  oceanmodel = ',oceanmodel
              print *
              print *,'  sfcmodel = 1 requires oceanmodel = 1 '
              print *,'  (oceanmodel = 2 requires sfcmodel = 2 ) '
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF( radopt.lt.0 .or. radopt.gt.1 )THEN
              print *
              print *,'  radopt   = ',radopt
              print *
              print *,'  radopt must be 0 or 1 '
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF( radopt.eq.1 .and. imoist.eq.0 )THEN
              print *
              print *,'  radopt   = ',radopt
              print *,'  imoist   = ',imoist
              print *
              print *,'  radopt=1 requires imoist=1 (for now) '
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF( ipbl.eq.1 .and. imoist.eq.0 )THEN
              print *
              print *,'  ipbl     = ',ipbl
              print *,'  imoist   = ',imoist
              print *
              print *,'  ipbl=1 requires imoist=1 (for now) '
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF( radopt.eq.1 .and. rterm.eq.1 )THEN
              print *
              print *,'  radopt   = ',radopt
              print *,'  rterm    = ',rterm
              print *
              print *,'  cannot use radopt and rterm at the same time '
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF( radopt.eq.1 .and. (ptype.eq.1.or.ptype.eq.6)  )THEN
              print *
              print *,'  radopt   = ',radopt
              print *,'  ptype    = ',ptype
              print *
              print *,'  radopt=1 requires an ice microphysics scheme (for now) '
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF( radopt.eq.1 .and. sfcmodel.eq.0 )THEN
              print *
              print *,'  radopt   = ',radopt
              print *,'  sfcmodel = ',sfcmodel
              print *
              print *,'  radopt=1 requires a surface model '
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF( sfcmodel.eq.2 .and. imoist.eq.0 )THEN
              print *
              print *,'  sfcmodel = ',sfcmodel
              print *,'  imoist   = ',imoist
              print *
              print *,'  sfcmodel=2 requires imoist=1 (for now) '
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
#ifndef NETCDF
            IF(output_format.eq.2)THEN
              print *
              print *,'  output_format = ',output_format
              print *
              print *,'  You have requested netcdf output, but you have not'
              print *,'  compiled the code with netcdf capability.  Modify the'
              print *,'  Makefile, clean, and recompile'
              print *
              call stopcm1
            ENDIF
#endif
#ifndef HDFOUT
            IF(output_format.eq.3.or.output_format.eq.4.or.output_format.eq.5)THEN
              print *
              print *,'  output_format = ',output_format
              print *
              print *,'  You have requested hdf output, but you have not'
              print *,'  compiled the code with hdf capability.  Modify the'
              print *,'  Makefile, clean, and recompile'
              print *
              call stopcm1
            ENDIF
#endif
#ifdef MPI
            IF(psolver.eq.4.or.psolver.eq.5)THEN
              print *
              print *,'  psolver = ',psolver
              print *
              print *,'  psolver = 4 and 5 are not supported in MPI mode'
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
            IF(axisymm.eq.1)THEN
              print *
              print *,'  axisymm = ',axisymm
              print *
              print *,'  axisymm is not supported in MPI mode'
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF
#endif

      !-----------------------------------------------------------------------

#ifdef MPI
            endif

            call MPI_BCAST(dx    ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(dy    ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(dz    ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(dtl   ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(timax ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(tapfrq,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(rstfrq,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(statfrq,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(prclfrq,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)

            call MPI_BCAST(adapt_dt ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(irst     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(rstnum   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(iconly   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(hadvorder,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(vadvorder,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(ifall    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(pdscheme ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(advweno  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(idiff    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(vdiff    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(mdiff    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(difforder,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(imoist   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(iturb    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(tconfig  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(bcturbu  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(bcturbs  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(dns      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(irdamp   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(hrdamp   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(psolver  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(nsound   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(thsmall  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(ptype    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(ihail    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(iautoc   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(icor     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(pertcor  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(neweqts  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(idiss    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(efall    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(rterm    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(wbc      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(ebc      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(sbc      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(nbc      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(irbc     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(roflux   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(isnd     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(iwnd     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(itern    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(iinit    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(irandp   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(ibalance ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(iorigin  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(axisymm  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(imove    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(iptra    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(npt      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(iprcl    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(nparcels ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)

            call MPI_BCAST(kdiff2 ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(kdiff6 ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(fcor   ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(kdiv   ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(alph   ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(rdalpha,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(zd     ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(xhd    ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(umove  ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(vmove  ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(v_t    ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(l_h    ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(l_v    ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)

            call MPI_BCAST(stretch_x,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(dx_inner ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(dx_outer ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(nos_x_len,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(tot_x_len,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)

            call MPI_BCAST(stretch_y,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(dy_inner ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(dy_outer ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(nos_y_len,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(tot_y_len,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)

            call MPI_BCAST(stretch_z,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(ztop     ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(str_bot  ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(str_top  ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(dz_bot   ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(dz_top   ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)

            call MPI_BCAST(bc_wind  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(bc_temp  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(ptc_top  ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(ptc_bot  ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(viscosity,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(pr_num   ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)

            call MPI_BCAST(var1     ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(var2     ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(var3     ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(var4     ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(var5     ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(var6     ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(var7     ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(var8     ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(var9     ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(var10    ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)

            call MPI_BCAST(output_path    ,70,MPI_CHARACTER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_basename,70,MPI_CHARACTER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_format  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_filetype,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_interp ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_rain   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_sws    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_coldpool,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_sfcflx ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_sfcparams,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_sfcdiags,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_zs     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_zh     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_basestate,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_th     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_thpert ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_prs    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_prspert,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_pi     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_pipert ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_rho    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_rhopert,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_tke    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_km     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_kh     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_qv     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_qvpert ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_q      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_dbz    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_u      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_upert  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_uinterp,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_v      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_vpert  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_vinterp,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_w      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_winterp,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_vort   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_uh     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_pblten ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_dissten,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(output_radten ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)

            call MPI_BCAST(stat_w      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(stat_u      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(stat_v      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(stat_rmw    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(stat_pipert ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(stat_prspert,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(stat_thpert ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(stat_q      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(stat_tke    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(stat_km     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(stat_kh     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(stat_div    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(stat_rh     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(stat_rhi    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(stat_the    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(stat_cloud  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(stat_sfcprs ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(stat_wsp    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(stat_cfl    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(stat_vort   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(stat_tmass  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(stat_tmois  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(stat_qmass  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(stat_tenerg ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(stat_mo     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(stat_tmf    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(stat_pcn    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(stat_qsrc   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)

            call MPI_BCAST(radopt   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(dtrad  ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(ctrlat ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(ctrlon ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(year   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(month  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(day    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(hour   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(minute ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(second ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)

            call MPI_BCAST(idrag     ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(isfcflx   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(sfcmodel  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(oceanmodel,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(ipbl      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(initsfc   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(tsk0      ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(tmn0      ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(xland0    ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(lu0       ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(season    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(cecd      ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(pertflx   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(cnstce    ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(cnstcd    ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(isftcflx  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(iz0tlnd   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(oml_hml0  ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
            call MPI_BCAST(oml_gamma ,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)

      !--------------------------------------------------------------
      !  Check domain size

            if(myid.eq.0)then

              if((nodex*nodey).ne.numprocs)then
                print *,'  WARNING!!! '
                print *,'  nodes does not equal numprocs!'
                print *,'  nodex,nodey,nodes=',nodex,nodey,nodex*nodey
                print *,'  numprocs=',numprocs
                call stopcm1
              endif

              if(mod(nx,nodex).ne.0)then
                print *,'  nx does not divide evenly by nodex! '
                print *,'  nx,nodex,mod(nx,nodex)=',nx,nodex,mod(nx,nodex)
                call stopcm1
              endif

              if(mod(ny,nodey).ne.0)then
                print *,'  ny does not divide evenly by nodey! '
                print *,'  ny,nodey,mod(ny,nodey)=',ny,nodey,mod(ny,nodey)
                call stopcm1
              endif

              print *
              print *,'  Everything is cool!'
              print *,'  ni,nj=',ni,nj
              print *

            endif

#endif
      !--------------------------------------------------------------

            if(ebc.eq.1 .and. wbc.ne.1)then
              print *,"Can not have periodic b.c.'s on one side only!"
              call stopcm1
            endif
            if(wbc.eq.1 .and. ebc.ne.1)then
              print *,"Can not have periodic b.c.'s on one side only!"
              call stopcm1
            endif
            if(nbc.eq.1 .and. sbc.ne.1)then
              print *,"Can not have periodic b.c.'s on one side only!"
              call stopcm1
            endif
            if(sbc.eq.1 .and. nbc.ne.1)then
              print *,"Can not have periodic b.c.'s on one side only!"
              call stopcm1
            endif

      !--------------------------------------------------------------
      !  Some basic checks:

            iptra    = max(0,min(1,iptra))
            if(iptra.eq.1)then
              npt      = max(1,npt)
            else
              npt      = 1
            endif
            nparcels = max(1,nparcels)

            if(iprcl.eq.1)then

              npvals = 3 + 14

              ifx = npvals - 2
              ify = npvals - 1
              ifz = npvals

            else

              npvals = 1
              nparcels = 1

            endif

            if(stretch_z.ne.1) ztop = dz*float(nk)

      !!!      IF ( ptype .ge. 26 ) THEN
      !!!      open(unit=20,file='namelist.input',form='formatted',status='old',    &
      !!!           access='sequential')
      !!!         read(20,nml=micro_params)
      !!!      close(unit=20)
      !!!      ENDIF

      !--------------------------------------------------------------


      if (myid.eq.0) then
            write(outfile,*)
            write(outfile,*) 'dx        =',dx
            write(outfile,*) 'dy        =',dy
            write(outfile,*) 'dz        =',dz
            write(outfile,*) 'dtl       =',dtl
            write(outfile,*) 'timax     =',timax
            write(outfile,*) 'tapfrq    =',tapfrq
            write(outfile,*) 'rstfrq    =',rstfrq
            write(outfile,*) 'statfrq   =',statfrq
            write(outfile,*) 'prclfrq   =',prclfrq
            write(outfile,*)
            write(outfile,*) 'adapt_dt  =',adapt_dt
            write(outfile,*) 'irst      =',irst
            write(outfile,*) 'rstnum    =',rstnum
            write(outfile,*) 'iconly    =',iconly
            write(outfile,*) 'hadvorder =',hadvorder
            write(outfile,*) 'vadvorder =',vadvorder
            write(outfile,*) 'ifall     =',ifall
            write(outfile,*) 'pdscheme  =',pdscheme
            write(outfile,*) 'advweno   =',advweno
            write(outfile,*) 'idiff     =',idiff
            write(outfile,*) 'vdiff     =',vdiff
            write(outfile,*) 'mdiff     =',mdiff
            write(outfile,*) 'difforder =',difforder
            write(outfile,*) 'imoist    =',imoist
            write(outfile,*) 'iturb     =',iturb
            write(outfile,*) 'tconfig   =',tconfig
            write(outfile,*) 'bcturbu   =',bcturbu
            write(outfile,*) 'bcturbs   =',bcturbs
            write(outfile,*) 'dns       =',dns
            write(outfile,*) 'irdamp    =',irdamp
            write(outfile,*) 'hrdamp    =',hrdamp
            write(outfile,*) 'psolver   =',psolver
            write(outfile,*) 'nsound    =',nsound
            write(outfile,*) 'thsmall   =',thsmall
            write(outfile,*) 'ptype     =',ptype
            write(outfile,*) 'ihail     =',ihail
            write(outfile,*) 'iautoc    =',iautoc
            write(outfile,*) 'icor      =',icor
            write(outfile,*) 'pertcor   =',pertcor
            write(outfile,*) 'neweqts   =',neweqts
            write(outfile,*) 'idiss     =',idiss
            write(outfile,*) 'efall     =',efall
            write(outfile,*) 'rterm     =',rterm
            write(outfile,*) 'wbc       =',wbc
            write(outfile,*) 'ebc       =',ebc
            write(outfile,*) 'sbc       =',sbc
            write(outfile,*) 'nbc       =',nbc
            write(outfile,*) 'irbc      =',irbc
            write(outfile,*) 'roflux    =',roflux
            write(outfile,*) 'isnd      =',isnd
            write(outfile,*) 'iwnd      =',iwnd
            write(outfile,*) 'itern     =',itern
            write(outfile,*) 'iinit     =',iinit
            write(outfile,*) 'irandp    =',irandp
            write(outfile,*) 'ibalance  =',ibalance
            write(outfile,*) 'iorigin   =',iorigin
            write(outfile,*) 'axisymm   =',axisymm
            write(outfile,*) 'imove     =',imove
            write(outfile,*) 'iptra     =',iptra
            write(outfile,*) 'npt       =',npt
            write(outfile,*) 'iprcl     =',iprcl
            write(outfile,*) 'nparcels  =',nparcels
            write(outfile,*)
            write(outfile,*) 'kdiff2    =',kdiff2
            write(outfile,*) 'kdiff6    =',kdiff6
            write(outfile,*) 'fcor      =',fcor
            write(outfile,*) 'kdiv      =',kdiv
            write(outfile,*) 'alph      =',alph
            write(outfile,*) 'rdalpha   =',rdalpha
            write(outfile,*) 'zd        =',zd
            write(outfile,*) 'xhd       =',xhd
            write(outfile,*) 'umove     =',umove
            write(outfile,*) 'vmove     =',vmove
            write(outfile,*) 'v_t       =',v_t
            write(outfile,*) 'l_h       =',l_h
            write(outfile,*) 'l_v       =',l_v
            write(outfile,*)
            write(outfile,*) 'radopt    =',radopt
            write(outfile,*) 'dtrad     =',dtrad
            write(outfile,*) 'ctrlat    =',ctrlat
            write(outfile,*) 'ctrlon    =',ctrlon
            write(outfile,*) 'year      =',year
            write(outfile,*) 'month     =',month
            write(outfile,*) 'day       =',day
            write(outfile,*) 'hour      =',hour
            write(outfile,*) 'minute    =',minute
            write(outfile,*) 'second    =',second
            write(outfile,*)
            write(outfile,*) 'idrag     =',idrag
            write(outfile,*) 'isfcflx   =',isfcflx
            write(outfile,*) 'sfcmodel  =',sfcmodel
            write(outfile,*) 'oceanmodel=',oceanmodel
            write(outfile,*) 'ipbl      =',ipbl
            write(outfile,*) 'initsfc   =',initsfc
            write(outfile,*) 'tsk0      =',tsk0
            write(outfile,*) 'tmn0      =',tmn0
            write(outfile,*) 'xland0    =',xland0
            write(outfile,*) 'lu0       =',lu0
            write(outfile,*) 'season    =',season
            write(outfile,*) 'cecd      =',cecd
            write(outfile,*) 'pertflx   =',pertflx
            write(outfile,*) 'cnstce    =',cnstce
            write(outfile,*) 'cnstcd    =',cnstcd
            write(outfile,*) 'isftcflx  =',isftcflx
            write(outfile,*) 'iz0tlnd   =',iz0tlnd
            write(outfile,*) 'oml_hml0  =',oml_hml0
            write(outfile,*) 'oml_gamma =',oml_gamma
            write(outfile,*)
            write(outfile,*) 'stretch_x =',stretch_x
            write(outfile,*) 'dx_inner  =',dx_inner
            write(outfile,*) 'dx_outer  =',dx_outer
            write(outfile,*) 'nos_x_len =',nos_x_len
            write(outfile,*) 'tot_x_len =',tot_x_len
            write(outfile,*)
            write(outfile,*) 'stretch_y =',stretch_y
            write(outfile,*) 'dy_inner  =',dy_inner
            write(outfile,*) 'dy_outer  =',dy_outer
            write(outfile,*) 'nos_y_len =',nos_y_len
            write(outfile,*) 'tot_y_len =',tot_y_len
            write(outfile,*)
            write(outfile,*) 'stretch_z =',stretch_z
            write(outfile,*) 'ztop      =',ztop
            write(outfile,*) 'str_bot   =',str_bot
            write(outfile,*) 'str_top   =',str_top
            write(outfile,*) 'dz_bot    =',dz_bot
            write(outfile,*) 'dz_top    =',dz_top
            write(outfile,*)
            write(outfile,*) 'bc_wind   =',bc_wind
            write(outfile,*) 'bc_temp   =',bc_temp
            write(outfile,*) 'ptc_top   =',ptc_top
            write(outfile,*) 'ptc_bot   =',ptc_bot
            write(outfile,*) 'viscosity =',viscosity
            write(outfile,*) 'pr_num    =',pr_num
            write(outfile,*)
            write(outfile,*) 'var1      =',var1
            write(outfile,*) 'var2      =',var2
            write(outfile,*) 'var3      =',var3
            write(outfile,*) 'var4      =',var4
            write(outfile,*) 'var5      =',var5
            write(outfile,*) 'var6      =',var6
            write(outfile,*) 'var7      =',var7
            write(outfile,*) 'var8      =',var8
            write(outfile,*) 'var9      =',var9
            write(outfile,*) 'var10     =',var10
            write(outfile,*)
      endif

      !--------------------------------------------------------------
      !  Configuration for simulations with moisture
      !

            !--- begin: define defaults (please do not change) ---------
            iice     = 0
            idm      = 0
            numq     = 1
            nqv      = 1
            nql1     = 1
            nql2     = 1
            nqs1     = 1
            nqs2     = 1
            nnc1     = 1
            nnc2     = 1
            nbudget  = 10
            budrain  = 1
            cloudvar = .false.
            rhovar   = .false.
            !--- end: define defaults ----------------------------------

            IF(imoist.eq.1)THEN

      !-----------------------------------------------------------------------
      !-------   BEGIN:  modify stuff below here -----------------------------
      !-----------------------------------------------------------------------

      !-----------------------------------------------------------------------
              IF(ptype.eq.1)THEN        ! Kessler scheme

                numq = 3    ! there are 3 q variables

                nqv  = 1    ! qv is the first array
                nql1 = 2    ! the first liquid variable is the second array
                nql2 = 3    ! the last liquid variable is the third array

                cloudvar(1) = .false.
                cloudvar(2) = .true.
                cloudvar(3) = .false.

                qname(1) = 'qv '
                qname(2) = 'qc '
                qname(3) = 'qr '

                !----- budget stuff below here -----

                nbudget = 10

                budname(1) = 'tcond '
                budname(2) = 'tevac '
                budname(3) = 'tauto '
                budname(4) = 'taccr '
                budname(5) = 'tevar '
                budname(6) = 'train '
                budname(7) = 'erain '
                budname(8) = 'qsfc  '
                budname(9) = 'esfc  '
                budname(10) = 'erad  '

                budrain = 6

      !-----------------------------------------------------------------------
              ELSEIF((ptype.eq.2).or.(ptype.eq.4))THEN    ! Goddard-LFO or 
                                                          ! GSR-LFO scheme

                iice = 1    ! this means that ptype=2,4 are ice schemes

                numq = 6    ! there are 6 q variables

                nqv  = 1    ! qv is the first array
                nql1 = 2    ! the first liquid variable is the second array
                nql2 = 3    ! the last liquid variable is the third array
                nqs1 = 4    ! the first solid variable is the fourth array
                nqs2 = 6    ! the last solid variable is the sixth array

                cloudvar(1) = .false.
                cloudvar(2) = .true.
                cloudvar(3) = .false.
                cloudvar(4) = .true.
                cloudvar(5) = .false.
                cloudvar(6) = .false.

                qname(1) = 'qv '
                qname(2) = 'qc '
                qname(3) = 'qr '
                qname(4) = 'qi '
                qname(5) = 'qs '
                qname(6) = 'qg '

                !----- budget stuff below here -----

                nbudget = 10

                budname(1) = 'tcond '
                budname(2) = 'tevac '
                budname(3) = 'tauto '
                budname(4) = 'taccr '
                budname(5) = 'tevar '
                budname(6) = 'train '
                budname(7) = 'erain '
                budname(8) = 'qsfc  '
                budname(9) = 'esfc  '
                budname(10) = 'erad  '

                budrain = 6

                !----- initialize the Goddard or GSR LFO scheme -----

                if(ptype.eq.2)THEN

                   if(myid.eq.0) then
                        write(outfile,*)
                        write(outfile,*) 'Calling CONSAT'
                        write(outfile,*)
                   endif

                  call consat
                  call consat2(dtl)

                endif

                if(ptype.eq.4)then

                   if(myid.eq.0) then
                       write(outfile,*)
                       write(outfile,*) 'Calling lfoice_init'
                       write(outfile,*)
                   endif

                  call lfoice_init(dtl)

                endif

      !-----------------------------------------------------------------------
              ELSEIF(ptype.eq.3)THEN    ! Thompson scheme

                iice = 1    ! this means that ptype=3 is an ice scheme
                idm  = 1    ! this means that ptype=3 has at least one double moment

                numq = 8    ! there are 8 q variables

                nqv  = 1    ! qv is the first array
                nql1 = 2    ! the first liquid variable is the second array
                nql2 = 3    ! the last liquid variable is the third array
                nqs1 = 4    ! the first solid variable is the fourth array
                nqs2 = 6    ! the last solid variable is the sixth array
                nnc1 = 7    ! the first number concentration var is the seventh array
                nnc2 = 8    ! the last number concentration var is the eighth array

                cloudvar(1) = .false.
                cloudvar(2) = .true.
                cloudvar(3) = .false.
                cloudvar(4) = .true.
                cloudvar(5) = .false.
                cloudvar(6) = .false.
                cloudvar(7) = .false.
                cloudvar(8) = .false.

                qname(1) = 'qv '
                qname(2) = 'qc '
                qname(3) = 'qr '
                qname(4) = 'qi '
                qname(5) = 'qs '
                qname(6) = 'qg '
                qname(7) = 'nci'
                qname(8) = 'ncr'

                !----- budget stuff below here -----

                nbudget = 10

                budname(1) = 'tcond '
                budname(2) = 'tevac '
                budname(3) = 'tauto '
                budname(4) = 'taccr '
                budname(5) = 'tevar '
                budname(6) = 'train '
                budname(7) = 'erain '
                budname(8) = 'qsfc  '
                budname(9) = 'esfc  '
                budname(10) = 'erad  '

                budrain = 6

                !----- initialize the Thompson scheme -----

                if (myid.eq.0)then
                      write(outfile,*)
                      write(outfile,*) 'Calling thompson_init'
                      write(outfile,*) '(this can take several minutes ... please be patient)'
                endif

                call thompson_init

                if (myid.eq.0)then
                      write(outfile,*) 'Done with thompson_init'
                      write(outfile,*)
                endif

      !-----------------------------------------------------------------------

              ELSEIF(ptype.eq.5)THEN    ! Morrison scheme

                iice = 1    ! this means that ptype=5 is an ice scheme
                idm  = 1    ! this means that ptype=5 has at least one double moment

                numq = 10   ! there are 10 q variables

                nqv  = 1    ! qv is the first array
                nql1 = 2    ! the first liquid variable is the second array
                nql2 = 3    ! the last liquid variable is the third array
                nqs1 = 4    ! the first solid variable is the fourth array
                nqs2 = 6    ! the last solid variable is the sixth array
                nnc1 = 7    ! the first number concentration var is the seventh array
                nnc2 = 10   ! the last number concentration var is the tenth array

                cloudvar( 1) = .false.
                cloudvar( 2) = .true.
                cloudvar( 3) = .false.
                cloudvar( 4) = .true.
                cloudvar( 5) = .false.
                cloudvar( 6) = .false.
                cloudvar( 7) = .false.
                cloudvar( 8) = .false.
                cloudvar( 9) = .false.
                cloudvar(10) = .false.

                qname( 1) = 'qv '
                qname( 2) = 'qc '
                qname( 3) = 'qr '
                qname( 4) = 'qi '
                qname( 5) = 'qs '
                qname( 6) = 'qg '
                qname( 7) = 'nci'
                qname( 8) = 'ncs'
                qname( 9) = 'ncr'
                qname(10) = 'ncg'

                !----- budget stuff below here -----

                nbudget = 10

                budname(1) = 'tcond '
                budname(2) = 'tevac '
                budname(3) = 'tauto '
                budname(4) = 'taccr '
                budname(5) = 'tevar '
                budname(6) = 'train '
                budname(7) = 'erain '
                budname(8) = 'qsfc  '
                budname(9) = 'esfc  '
                budname(10) = 'erad  '

                budrain = 6

                !----- initialize the Morrison scheme -----

                if(myid.eq.0) then
                      write(outfile,*)
                      write(outfile,*) 'Calling MORR_TWO_MOMENT_INIT'
                      write(outfile,*)
                endif

                call MORR_TWO_MOMENT_INIT(ihail)

                if(myid.eq.0) then
                      write(outfile,*)
                      write(outfile,*) 'Returned from MORR_TWO_MOMENT_INIT'
                      write(outfile,*)
                endif

      !-----------------------------------------------------------------------

              ELSEIF(ptype.eq.6)THEN        ! Rotunno-Emanuel scheme

                numq = 2    ! there are 2 q variables

                nqv  = 1    ! qv is the first array
                nql1 = 2    ! the first liquid variable is the second array
                nql2 = 2    ! the last liquid variable is the second array

                cloudvar(1) = .false.
                cloudvar(2) = .true.

                qname(1) = 'qv '
                qname(2) = 'ql '

                !----- budget stuff below here -----

                nbudget = 10

                budname(1) = 'tcond '
                budname(2) = 'tevac '
                budname(3) = 'tauto '
                budname(4) = 'taccr '
                budname(5) = 'tevar '
                budname(6) = 'train '
                budname(7) = 'erain '
                budname(8) = 'qsfc  '
                budname(9) = 'esfc  '
                budname(10) = 'erad  '

                budrain = 6

      !-----------------------------------------------------------------------

      !!!        ELSEIF(ptype.eq.7)THEN    ! Milbrandt & Yao double-moment scheme

      !-----------------------------------------------------------------------

              ELSEIF ( ptype .eq. 26 ) THEN    ! ZVD scheme (without hail)

                iice = 1    ! this means that ptype=26 is an ice scheme
                idm  = 1    ! this means that ptype=26 has at least one double moment

                numq = 14   ! number of variables

                nqv  = 1    ! qv is the first array
                nql1 = 2    ! the first liquid variable is the second array
                nql2 = 3    ! the last liquid variable is the third array
                nqs1 = 4    ! the first solid variable is the fourth array
                nqs2 = 6    ! the last solid variable is the sixth array
                nnc1 = 7    ! the first number concentration var is the seventh array
                nnc2 = 12   ! the last number concentration var is the eleventh array

                cloudvar( 1) = .false.
                cloudvar( 2) = .true.
                cloudvar( 3) = .false.
                cloudvar( 4) = .true.
                cloudvar( 5) = .false.
                cloudvar( 6) = .false.
                cloudvar( 7) = .false.
                cloudvar( 8) = .false.
                cloudvar( 9) = .false.
                cloudvar(10) = .false.
                cloudvar(11) = .false.
                cloudvar(12) = .false.
                cloudvar(13) = .false.
                cloudvar(14) = .false.

                qname( 1) = 'qv '
                qname( 2) = 'qc '
                qname( 3) = 'qr '
                qname( 4) = 'qi '
                qname( 5) = 'qs '
                qname( 6) = 'qg '
                qname( 7) = 'ccn' ! CCN concentration
                qname( 8) = 'ccw' ! droplet conc
                qname( 9) = 'crw' ! rain conc
                qname(10) = 'cci' ! ice crystal conc
                qname(11) = 'csw' ! snow conc
                qname(12) = 'chw' ! graupel conc
                qname(13) = 'ss ' ! max supersaturation
                qname(14) = 'vhw' ! graupel volume

                rhovar( 1) = .false.
                rhovar( 2) = .false.
                rhovar( 3) = .false.
                rhovar( 4) = .false.
                rhovar( 5) = .false.
                rhovar( 6) = .false.
                rhovar( 7) = .true.
                rhovar( 8) = .true.
                rhovar( 9) = .true.
                rhovar(10) = .true.
                rhovar(11) = .true.
                rhovar(12) = .true.
                rhovar(13) = .false.
                rhovar(14) = .true.

      !          ipconc = 5
      !          lr = 4
      !          li = 5
      !          ls = 6
      !          lh = 7
      !          lg = lh
      !          lhab = lh
      !          lhl = 0
      !          lqe  = lhab
      !
      !          lccn = 8
      !          lnc  = 9
      !          lnr  = 10
      !          lni  = 11
      !          lns  = 12
      !          lnh  = 13
      !          lnhl = 0
      !          lss  = 14
      !          lvh  = 15
      !
      !          lsch = 0
      !          lschab = 0
      !          lscw = 0
      !          lscb = lscw
      !          lscni = 0
      !          lscpi = 0
      !          lsce = lscni
      !          lsceq= lschab
      !
      !          lsw  = 0
      !          lhw  = 0
      !          lhlw = 0

                !----- budget stuff below here -----

                nbudget = 10

                budname(1) = 'tcond '
                budname(2) = 'tevac '
                budname(3) = 'tauto '
                budname(4) = 'taccr '
                budname(5) = 'tevar '
                budname(6) = 'train '
                budname(7) = 'erain '
                budname(8) = 'qsfc  '
                budname(9) = 'esfc  '
                budname(10) = 'erad  '

                budrain = 6

                !----- initialize the ZVD scheme -----

                if(myid.eq.0)then
                      write(outfile,*)
                      write(outfile,*) 'Calling index_module_init'
                      write(outfile,*)
                endif

      !          call INDEX_MODULE_INIT(ptype)

                if(myid.eq.0)then
                      write(outfile,*)
                      write(outfile,*) 'Returned from index_module_init'
                      write(outfile,*)
                endif

              ELSEIF ( ptype .eq. 27 ) THEN    ! ZVDHV scheme (with hail)

                iice = 1    ! this means that ptype=27 is an ice scheme
                idm  = 1    ! this means that ptype=27 has at least one double moment

                numq = 17   ! number of variables

                nqv  = 1    ! qv is the first array
                nql1 = 2    ! the first liquid variable is the second array
                nql2 = 3    ! the last liquid variable is the third array
                nqs1 = 4    ! the first solid variable is the fourth array
                nqs2 = 7    ! the last solid variable is the sixth array
                nnc1 = 8    ! the first number concentration var is the seventh array
                nnc2 = 14   ! the last number concentration var is the eleventh array

                cloudvar( 1) = .false.
                cloudvar( 2) = .true.
                cloudvar( 3) = .false.
                cloudvar( 4) = .true.
                cloudvar( 5) = .false.
                cloudvar( 6) = .false.
                cloudvar( 7) = .false.
                cloudvar( 8) = .false.
                cloudvar( 9) = .false.
                cloudvar(10) = .false.
                cloudvar(11) = .false.
                cloudvar(12) = .false.
                cloudvar(13) = .false.
                cloudvar(14) = .false.

                qname( 1) = 'qv '
                qname( 2) = 'qc '
                qname( 3) = 'qr '
                qname( 4) = 'qi '
                qname( 5) = 'qs '
                qname( 6) = 'qg '
                qname( 7) = 'qhl'
                qname( 8) = 'ccn' ! CCN concentration
                qname( 9) = 'ccw' ! droplet conc
                qname(10) = 'crw' ! rain conc
                qname(11) = 'cci' ! ice crystal conc
                qname(12) = 'csw' ! snow conc
                qname(13) = 'chw' ! graupel conc
                qname(14) = 'chl' ! hail conc
                qname(15) = 'ss ' ! max supersaturation
                qname(16) = 'vhw' ! graupel volume
                qname(17) = 'vhl' ! hail volume

                rhovar( 1) = .false.
                rhovar( 2) = .false.
                rhovar( 3) = .false.
                rhovar( 4) = .false.
                rhovar( 5) = .false.
                rhovar( 6) = .false.
                rhovar( 7) = .false.
                rhovar( 8) = .true.
                rhovar( 9) = .true.
                rhovar(10) = .true.
                rhovar(11) = .true.
                rhovar(12) = .true.
                rhovar(13) = .true.
                rhovar(14) = .true.
                rhovar(15) = .false.
                rhovar(16) = .true.
                rhovar(17) = .true.

      !          ipconc = 5
      !          lr = 4
      !          li = 5
      !          ls = 6
      !          lh = 7
      !          lhl = 8
      !          lg = lh
      !          lhab = lhl
      !          lqe  = lhab
      !
      !          lccn = 9
      !          lnc  = 10
      !          lnr  = 11
      !          lni  = 12
      !          lns  = 13
      !          lnh  = 14
      !          lnhl = 15
      !          lss  = 16
      !          lvh  = 17
      !          lvhl = 18
      !
      !          lsch = 0
      !          lschab = 0
      !          lscw = 0
      !          lscb = lscw
      !          lscni = 0
      !          lscpi = 0
      !          lsce = lscni
      !          lsceq= lschab
      !
      !          lsw  = 0
      !          lhw  = 0
      !          lhlw = 0

                !----- budget stuff below here -----

                nbudget = 10

                budname(1) = 'tcond '
                budname(2) = 'tevac '
                budname(3) = 'tauto '
                budname(4) = 'taccr '
                budname(5) = 'tevar '
                budname(6) = 'train '
                budname(7) = 'erain '
                budname(8) = 'qsfc  '
                budname(9) = 'esfc  '
                budname(10) = 'erad  '

                budrain = 6

                !----- initialize the ZVD scheme -----

      !          write(outfile,*)
      !          write(outfile,*) 'Calling graupel_init'
      !          write(outfile,*)

      !          call INDEX_MODULE_INIT(ptype)

      !          write(outfile,*)
      !          write(outfile,*) 'Returned from graupel_init'
      !          write(outfile,*)

              ELSEIF ( ptype .eq. 28 ) THEN    ! single moment ZIEG scheme (without hail)

                iice = 1    ! this means that ptype=28 is an ice scheme
                idm  = 0    ! this means that ptype=28 has at least one double moment

                numq = 6   ! number of variables

                nqv  = 1    ! qv is the first array
                nql1 = 2    ! the first liquid variable is the second array
                nql2 = 3    ! the last liquid variable is the third array
                nqs1 = 4    ! the first solid variable is the fourth array
                nqs2 = 6    ! the last solid variable is the sixth array

                cloudvar( 1) = .false.
                cloudvar( 2) = .true.
                cloudvar( 3) = .false.
                cloudvar( 4) = .true.
                cloudvar( 5) = .false.
                cloudvar( 6) = .false.

                qname( 1) = 'qv '
                qname( 2) = 'qc '
                qname( 3) = 'qr '
                qname( 4) = 'qi '
                qname( 5) = 'qs '
                qname( 6) = 'qg '

                rhovar( 1) = .false.
                rhovar( 2) = .false.
                rhovar( 3) = .false.
                rhovar( 4) = .false.
                rhovar( 5) = .false.
                rhovar( 6) = .false.

      !          ipconc = 0
      !          lr = 4
      !          li = 5
      !          ls = 6
      !          lh = 7
      !          lg = lh
      !          lhab = lh
      !          lhl = 0
      !          lqe  = lhab
      !
      !          lccn = 0
      !          lnc  = 0
      !          lnr  = 0
      !          lni  = 0
      !          lns  = 0
      !          lnh  = 0
      !          lnhl = 0
      !          lss  = 0
      !          lvh  = 0
      !
      !          lsch = 0
      !          lschab = 0
      !          lscw = 0
      !          lscb = lscw
      !          lscni = 0
      !          lscpi = 0
      !          lsce = lscni
      !          lsceq= lschab
      !
      !          lsw  = 0
      !          lhw  = 0
      !          lhlw = 0

                !----- budget stuff below here -----

                nbudget = 10

                budname(1) = 'tcond '
                budname(2) = 'tevac '
                budname(3) = 'tauto '
                budname(4) = 'taccr '
                budname(5) = 'tevar '
                budname(6) = 'train '
                budname(7) = 'erain '
                budname(8) = 'qsfc  '
                budname(9) = 'esfc  '
                budname(10) = 'erad  '

                budrain = 6

                !----- initialize the ZVD scheme -----

      !          write(outfile,*)
      !          write(outfile,*) 'Calling graupel_init'
      !          write(outfile,*)

      !          call INDEX_MODULE_INIT(ptype)

      !          write(outfile,*)
      !          write(outfile,*) 'Returned from graupel_init'
      !          write(outfile,*)

      !-----------------------------------------------------------------------
      !  insert new ptype here

      !!!        ELSEIF(ptype.eq.8)THEN    ! new microphysics scheme

      !-----------------------------------------------------------------------

              ELSE

                IF(myid.eq.0)THEN
                  print *
                  print *,'  ptype = ',ptype
                  print *
                  print *,'  Unrecognized value for ptype '
                  print *
                  print *,'  ... stopping cm1 ... '
                  print *
                ENDIF

                call stopcm1

              ENDIF    ! endif for ptype

            ENDIF    ! endif for imoist=1

      !-----------------------------------------------------------------------
      !-------   END:  modify stuff above here -------------------------------
      !-----------------------------------------------------------------------

            IF( radopt.eq.1 .and. iice.ne.1 )THEN
              print *
              print *,'  radopt   = ',radopt
              print *,'  iice     = ',iice
              print *
              print *,'  radopt=1 requires an ice microphysics scheme '
              print *
              print *,'   stopping model .... '
              print *
              call stopcm1
            ENDIF

      !-----------------------------------------------------------------------

            nqc = 0
            nqr = 0
            nqi = 0
            nqs = 0
            nqg = 0

            do n=1,numq
              if( qname(n).eq.'qc ' .or. qname(n).eq.'ql ' ) nqc = n
              if( qname(n).eq.'qr ' ) nqr = n
              if( qname(n).eq.'qi ' ) nqi = n
              if( qname(n).eq.'qs ' ) nqs = n
              if( qname(n).eq.'qg ' ) nqg = n
            enddo

            if(numq .gt. maxq)then
                if(myid.eq.0)then
                    write(outfile,*)
                    write(outfile,*) '  WARNING!   numq > maxq'
                    write(outfile,*) '  You need to increase maxq in input.incl and recompile'
                    write(outfile,*)
                    write(outfile,*) '  Stopping model ....'
                    write(outfile,*)
                endif
              call stopcm1
            endif

            if(myid.eq.0)then
                  write(outfile,*) 'iice      =',iice
                  write(outfile,*) 'idm       =',idm
                  write(outfile,*) 'numq      =',numq
                  write(outfile,*) 'nqv       =',nqv
                  write(outfile,*) 'nqc       =',nqc
                  write(outfile,*) 'nqr       =',nqr
                  write(outfile,*) 'nqi       =',nqi
                  write(outfile,*) 'nqs       =',nqs
                  write(outfile,*) 'nqg       =',nqg
                  write(outfile,*) 'nql1      =',nql1
                  write(outfile,*) 'nql2      =',nql2
                  write(outfile,*) 'nqs1      =',nqs1
                  write(outfile,*) 'nqs2      =',nqs2
                  write(outfile,*) 'nnc1      =',nnc1
                  write(outfile,*) 'nnc2      =',nnc2
                  write(outfile,*)
            endif

      !--------------------------------------------------------------

            iterrain = 0
            if(terrain_flag) iterrain = 1

            output_interp  = max(0,min(1,output_interp))*iterrain
            output_rain    = max(0,min(1,output_rain))
            output_sws     = max(0,min(1,output_sws))
            output_coldpool= max(0,min(1,output_coldpool))
            output_sfcflx  = max(0,min(1,output_sfcflx))
            output_sfcparams = max(0,min(1,output_sfcparams))
            output_sfcdiags = max(0,min(1,output_sfcdiags))
            output_zs      = max(0,min(1,output_zs))*iterrain
            output_zh      = max(0,min(1,output_zh))
            output_basestate = max(0,min(1,output_basestate))
            output_th      = max(0,min(1,output_th))
            output_thpert  = max(0,min(1,output_thpert))
            output_prs     = max(0,min(1,output_prs))
            output_prspert = max(0,min(1,output_prspert))
            output_pi      = max(0,min(1,output_pi))
            output_pipert  = max(0,min(1,output_pipert))
            output_rho     = max(0,min(1,output_rho))
            output_rhopert = max(0,min(1,output_rhopert))
            output_tke     = max(0,min(1,output_tke))
            output_km      = max(0,min(1,output_km))
            output_kh      = max(0,min(1,output_kh))
            output_qv      = max(0,min(1,output_qv))
            output_qvpert  = max(0,min(1,output_qvpert))
            output_q       = max(0,min(1,output_q))
            output_dbz     = max(0,min(1,output_dbz))
            output_u       = max(0,min(1,output_u))
            output_upert   = max(0,min(1,output_upert))
            output_uinterp = max(0,min(1,output_uinterp))
            output_v       = max(0,min(1,output_v))
            output_vpert   = max(0,min(1,output_vpert))
            output_vinterp = max(0,min(1,output_vinterp))
            output_w       = max(0,min(1,output_w))
            output_winterp = max(0,min(1,output_winterp))
            output_vort    = max(0,min(1,output_vort))
            output_uh      = max(0,min(1,output_uh))
            output_pblten  = max(0,min(1,output_pblten))
            output_dissten = max(0,min(1,output_dissten))
            output_radten  = max(0,min(1,output_radten))


            nrain = 1
      !!!      if(imove.eq.1.and.imoist.eq.1) nrain = 2
            if(imove.eq.1)                 nrain = 2

            if(myid.eq.0)then
                  write(outfile,*) 'nrain     =',nrain
                  write(outfile,*)
            endif

            if(imoist.eq.0)then
              output_rain=0
              output_qv=0
              output_qvpert=0
              output_q=0
              output_dbz=0
            endif
            if( (iturb.eq.0.or.dns.eq.1) )then
              output_tke=0
            endif
            if( (iturb.eq.0.or.dns.eq.1).and.(ipbl.eq.0) )then
              output_km=0
              output_kh=0
            endif
            if(iturb.eq.2.or.iturb.eq.3)then
              output_tke=0
            endif
            if(idiss.ne.1)then
              output_dissten=0
            endif
            if(ipbl.ne.1)then
              output_pblten=0
            endif
            if(radopt.eq.0)then
              output_radten=0
            endif
            if(terrain_flag)then
              output_vort=0
            endif
            if( isfcflx.eq.0 )then
              output_sfcflx = 0
            endif
            if( idrag.eq.0 .and. isfcflx.eq.0 )then
              output_sfcparams = 0
              output_sfcdiags = 0
            endif

            if(myid.eq.0) then
                  write(outfile,*)
                  write(outfile,*) 'output_path      = ',output_path
                  write(outfile,*) 'output_basename  = ',output_basename
                  write(outfile,*) 'output_format    =',output_format
                  write(outfile,*) 'output_filetype  =',output_filetype
                  write(outfile,*) 'output_interp    =',output_interp
                  write(outfile,*) 'output_rain      =',output_rain
                  write(outfile,*) 'output_sws       =',output_sws
                  write(outfile,*) 'output_coldpool  =',output_coldpool
                  write(outfile,*) 'output_sfcflx    =',output_sfcflx
                  write(outfile,*) 'output_sfcparams =',output_sfcparams
                  write(outfile,*) 'output_sfcdiags  =',output_sfcdiags
                  write(outfile,*) 'output_zs        =',output_zs
                  write(outfile,*) 'output_zh        =',output_zh
                  write(outfile,*) 'output_basestate =',output_basestate
                  write(outfile,*) 'output_th        =',output_th
                  write(outfile,*) 'output_thpert    =',output_thpert
                  write(outfile,*) 'output_prs       =',output_prs
                  write(outfile,*) 'output_prspert   =',output_prspert
                  write(outfile,*) 'output_pi        =',output_pi
                  write(outfile,*) 'output_pipert    =',output_pipert
                  write(outfile,*) 'output_rho       =',output_rho
                  write(outfile,*) 'output_rhopert   =',output_rhopert
                  write(outfile,*) 'output_tke       =',output_tke
                  write(outfile,*) 'output_km        =',output_km
                  write(outfile,*) 'output_kh        =',output_kh
                  write(outfile,*) 'output_qv        =',output_qv
                  write(outfile,*) 'output_qvpert    =',output_qvpert
                  write(outfile,*) 'output_q         =',output_q
                  write(outfile,*) 'output_dbz       =',output_dbz
                  write(outfile,*) 'output_u         =',output_u
                  write(outfile,*) 'output_upert     =',output_upert
                  write(outfile,*) 'output_uinterp   =',output_uinterp
                  write(outfile,*) 'output_v         =',output_v
                  write(outfile,*) 'output_vpert     =',output_vpert
                  write(outfile,*) 'output_vinterp   =',output_vinterp
                  write(outfile,*) 'output_w         =',output_w
                  write(outfile,*) 'output_winterp   =',output_winterp
                  write(outfile,*) 'output_vort      =',output_vort
                  write(outfile,*) 'output_uh        =',output_uh
                  write(outfile,*) 'output_pblten    =',output_pblten
                  write(outfile,*) 'output_dissten   =',output_dissten
                  write(outfile,*) 'output_radten    =',output_radten
                  write(outfile,*)
            endif

      !--------------------------------------------------------------


            stat_w       = max(0,min(1,stat_w))
            stat_u       = max(0,min(1,stat_u))
            stat_v       = max(0,min(1,stat_v))
            stat_rmw     = max(0,min(1,stat_rmw))
            IF(axisymm.ne.1) stat_rmw = 0
            stat_pipert  = max(0,min(1,stat_pipert))
            stat_prspert = max(0,min(1,stat_prspert))
            stat_thpert  = max(0,min(1,stat_thpert))
            stat_q       = max(0,min(1,stat_q))
            stat_tke     = max(0,min(1,stat_tke))
            stat_km      = max(0,min(1,stat_km))
            stat_kh      = max(0,min(1,stat_kh))
            stat_div     = max(0,min(1,stat_div))
            stat_rh      = max(0,min(1,stat_rh))
            stat_rhi     = max(0,min(1,stat_rhi))
            stat_the     = max(0,min(1,stat_the))
            stat_cloud   = max(0,min(1,stat_cloud))
            stat_sfcprs  = max(0,min(1,stat_sfcprs))
            stat_wsp     = max(0,min(1,stat_wsp))
            stat_cfl     = max(0,min(1,stat_cfl))
            stat_vort    = max(0,min(1,stat_vort))
            stat_tmass   = max(0,min(1,stat_tmass))
            stat_tmois   = max(0,min(1,stat_tmois))
            stat_qmass   = max(0,min(1,stat_qmass))
            stat_tenerg  = max(0,min(1,stat_tenerg))
            stat_mo      = max(0,min(1,stat_mo))
            stat_tmf     = max(0,min(1,stat_tmf))
            stat_pcn     = max(0,min(1,stat_pcn))
            stat_qsrc    = max(0,min(1,stat_qsrc))


            if(imoist.eq.0)then
              stat_q=0
              stat_rh=0
              stat_rhi=0
              stat_the=0
              stat_cloud=0
              stat_tmois=0
              stat_qmass=0
              stat_pcn=0
              stat_qsrc=0
            endif
            if(iice.eq.0)then
              stat_rhi=0
            endif
            if(iturb.eq.0.or.dns.eq.1)then
              stat_tke=0
              stat_km=0
              stat_kh=0
            endif 
            if(iturb.eq.2.or.iturb.eq.3)then
              stat_tke=0
            endif


            if(myid.eq.0)then
                  write(outfile,*)
                  write(outfile,*) 'stat_w       = ',stat_w
                  write(outfile,*) 'stat_u       = ',stat_u
                  write(outfile,*) 'stat_v       = ',stat_v
                  write(outfile,*) 'stat_rmw     = ',stat_rmw
                  write(outfile,*) 'stat_pipert  = ',stat_pipert
                  write(outfile,*) 'stat_prspert = ',stat_prspert
                  write(outfile,*) 'stat_thpert  = ',stat_thpert
                  write(outfile,*) 'stat_q       = ',stat_q
                  write(outfile,*) 'stat_tke     = ',stat_tke
                  write(outfile,*) 'stat_km      = ',stat_km
                  write(outfile,*) 'stat_kh      = ',stat_kh
                  write(outfile,*) 'stat_div     = ',stat_div
                  write(outfile,*) 'stat_rh      = ',stat_rh
                  write(outfile,*) 'stat_rhi     = ',stat_rhi
                  write(outfile,*) 'stat_the     = ',stat_the
                  write(outfile,*) 'stat_cloud   = ',stat_cloud
                  write(outfile,*) 'stat_sfcprs  = ',stat_sfcprs
                  write(outfile,*) 'stat_wsp     = ',stat_wsp
                  write(outfile,*) 'stat_cfl     = ',stat_cfl
                  write(outfile,*) 'stat_vort    = ',stat_vort
                  write(outfile,*) 'stat_tmass   = ',stat_tmass
                  write(outfile,*) 'stat_tmois   = ',stat_tmois
                  write(outfile,*) 'stat_qmass   = ',stat_qmass
                  write(outfile,*) 'stat_tenerg  = ',stat_tenerg
                  write(outfile,*) 'stat_mo      = ',stat_mo
                  write(outfile,*) 'stat_tmf     = ',stat_tmf
                  write(outfile,*) 'stat_pcn     = ',stat_pcn
                  write(outfile,*) 'stat_qsrc    = ',stat_qsrc
                  write(outfile,*)
            endif

            stat_out=2*(stat_w+stat_pipert+stat_prspert+numq*stat_q+              &
                    stat_tke+2*stat_km+2*stat_kh+stat_div+stat_rh+stat_rhi+       &
                    stat_cloud+stat_sfcprs+2*stat_wsp)  +                         &
                    4*(stat_thpert+stat_u+stat_v)  + 1*stat_rmw +                 &
                    3*stat_cfl  +  6*stat_vort  +  stat_tmass  +  stat_tmois  +   &
                    (1+(1+nql2-nql1)+iice*(1+nqs2-nqs1))*stat_qmass +             &
                    5*stat_tenerg  +  3*stat_mo  +                                &
                    nbudget*stat_pcn  + numq*2*stat_qsrc +                        &
                    4*stat_the  +  2*stat_tmf + 2*iptra*npt
            IF( adapt_dt.eq.1 ) stat_out = stat_out + 1
            IF( stat_wsp.eq.1 .and. idrag.eq.1 ) stat_out = stat_out + 2
            stat_out = max(1,stat_out)

            if(myid.eq.0)then
                  write(outfile,*) 'stat_out = ',stat_out
                  write(outfile,*)
            endif

      !--------------------------------------------------------------
      !  Define dimensions for allocatable arrays

      if(imoist.eq.1)then
        ibm=ib
        iem=ie
        jbm=jb
        jem=je
        kbm=kb
        kem=ke
        if(ptype.ge.26)then
          ibzvd=ib
          iezvd=ie
          jbzvd=jb
          jezvd=je
          kbzvd=kb
          kezvd=ke
          nqzvd = numq + 1
        else
          ibzvd=1
          iezvd=1
          jbzvd=1
          jezvd=1
          kbzvd=1
          kezvd=1
          nqzvd=1
        endif
      else
        ibm=1
        iem=1
        jbm=1
        jem=1
        kbm=1
        kem=1
        ibzvd=1
        iezvd=1
        jbzvd=1
        jezvd=1
        kbzvd=1
        kezvd=1
        nqzvd=1
      endif

      if(iice.eq.1)then
        ibi=ib
        iei=ie
        jbi=jb
        jei=je
        kbi=kb
        kei=ke
      else
        ibi=1
        iei=1
        jbi=1
        jei=1
        kbi=1
        kei=1
      endif

      if(radopt.eq.1)then
        ibr=ib
        ier=ie
        jbr=jb
        jer=je
        kbr=kb
        ker=ke
      else
        ibr=1
        ier=1
        jbr=1
        jer=1
        kbr=1
        ker=1
      endif

      if(ipbl.eq.1)then
        ibb=ib
        ieb=ie
        jbb=jb
        jeb=je
        kbb=kb
        keb=ke
      else
        ibb=1
        ieb=1
        jbb=1
        jeb=1
        kbb=1
        keb=1
      endif

      if( (sfcmodel.ge.1) .or. (oceanmodel.eq.2) .or. (ipbl.eq.1) .or. (radopt.eq.1) )then
        ibl=ib
        iel=ie
        jbl=jb
        jel=je
      else
        ibl=1
        iel=1
        jbl=1
        jel=1
      endif

      if((iturb.ge.1).or.(ipbl.eq.1))then
        ibc=ib
        iec=ie
        jbc=jb
        jec=je
        kbc=kb
        kec=ke+1
        nkt=nk+1
      else
        ibc=1
        iec=1
        jbc=1
        jec=1
        kbc=1
        kec=1
      endif

      if(iturb.eq.1)then
        ibt=ib
        iet=ie
        jbt=jb
        jet=je
        kbt=kb
        ket=ke+1
        nkt=nk+1
      else
        ibt=1
        iet=1
        jbt=1
        jet=1
        kbt=1
        ket=1
      endif

      if(iptra.eq.1)then
        ibp=ib
        iep=ie
        jbp=jb
        jep=je
        kbp=kb
        kep=ke
      else
        ibp=1
        iep=1
        jbp=1
        jep=1
        kbp=1
        kep=1
      endif

      if(psolver.eq.4.or.psolver.eq.5.or.ibalance.eq.2)then

        imirror = 0
        jmirror = 0

        ipb=1
        ipe=ni

        jpb=1
        jpe=nj

        if( (wbc.eq.2.or.wbc.eq.3).or.(ebc.eq.2.or.ebc.eq.3) )then

          imirror = 1
          ipe = ni*2

        endif

        if( (sbc.eq.2.or.sbc.eq.3).or.(nbc.eq.2.or.nbc.eq.3) )then

          jmirror = 1
          jpe = nj*2

        endif

        kpb=0
        kpe=nk+1

      else

        ipb=1
        ipe=1
        jpb=1
        jpe=1
        kpb=1
        kpe=1

      endif

!--------------------------------------------------------------

      rdx=1.0/dx
      rdy=1.0/dy
      rdz=1.0/dz
      rdx2=1.0/(2.0*dx)
      rdy2=1.0/(2.0*dy)
      rdz2=1.0/(2.0*dz)
      rdx4=1.0/(4.0*dx)
      rdy4=1.0/(4.0*dy)
      rdz4=1.0/(4.0*dz)

      thec_mb=0.0
      qt_mb=0.0

      stattim=statfrq
      taptim=tapfrq
      rsttim=rstfrq
      radtim=0.0
      prcltim=0.0   ! writeout at first time

!--------------------------------------------------------------
!  Get identity

      ibw=0
      ibe=0
      ibs=0
      ibn=0

      patchsws = .false.
      patchsww = .false.
      patchses = .false.
      patchsee = .false.
      patchnwn = .false.
      patchnww = .false.
      patchnen = .false.
      patchnee = .false.

      p2tchsws = .false.
      p2tchsww = .false.
      p2tchses = .false.
      p2tchsee = .false.
      p2tchnwn = .false.
      p2tchnww = .false.
      p2tchnen = .false.
      p2tchnee = .false.

      myi=1
      myj=1

#ifdef MPI
      myj = myid / nodex + 1
      myi = myid - (myj-1)*nodex  + 1

      if(myid.eq.0)then
            write(outfile,*) '  myi,myj=',myi,myj
            write(outfile,*)
      endif

      mynorth = nabor(myi,   myj+1, nodex, nodey)
      mysouth = nabor(myi,   myj-1, nodex, nodey)
      myeast  = nabor(myi+1, myj,   nodex, nodey)
      mywest  = nabor(myi-1, myj,   nodex, nodey)

      if(myid.eq.0)then
            write(outfile,*) '  mywest  =',mywest
            write(outfile,*) '  myeast  =',myeast
            write(outfile,*) '  mysouth =',mysouth
            write(outfile,*) '  mynorth =',mynorth
            write(outfile,*)
      endif

      mysw = nabor(myi-1, myj-1,   nodex, nodey)
      mynw = nabor(myi-1, myj+1,   nodex, nodey)
      myne = nabor(myi+1, myj+1,   nodex, nodey)
      myse = nabor(myi+1, myj-1,   nodex, nodey)

      if(myid.eq.0)then
            write(outfile,*) '  mysw    =',mysw
            write(outfile,*) '  mynw    =',mynw
            write(outfile,*) '  myne    =',myne
            write(outfile,*) '  myse    =',myse
      endif

      cs1we = (nj)*(nk)
      cs1sn = (ni)*(nk)
      ct1we = (nj)*(nk+1)
      ct1sn = (ni)*(nk+1)
      cv1we = (nj+1)*(nk)
      cu1sn = (ni+1)*(nk)
      cw1we = (nj)*(nk-1)
      cw1sn = (ni)*(nk-1)
      cs2we = 2*(nj)*(nk)
      cs2sn = (ni)*2*(nk)
      cs3we = 3*(nj)*(nk)
      cs3sn = (ni)*3*(nk)
      ct3we = 3*(nj)*(nk+1)
      ct3sn = (ni)*3*(nk+1)
      cv3we = 3*(nj+1)*(nk)
      cu3sn = 3*(ni+1)*(nk)
      cw3we = 3*(nj)*(nk-1)
      cw3sn = (ni)*3*(nk-1)

      if(myid.eq.0)then
            write(outfile,*)
            write(outfile,*) '  cs1we   =',cs1we
            write(outfile,*) '  cs1sn   =',cs1sn
            write(outfile,*) '  ct1we   =',ct1we
            write(outfile,*) '  ct1sn   =',ct1sn
            write(outfile,*) '  cv1we   =',cv1we
            write(outfile,*) '  cu1sn   =',cu1sn
            write(outfile,*) '  cw1we   =',cw1we
            write(outfile,*) '  cw1sn   =',cw1sn
            write(outfile,*) '  cs2we   =',cs2we
            write(outfile,*) '  cs2sn   =',cs2sn
            write(outfile,*) '  cs3we   =',cs3we
            write(outfile,*) '  cs3sn   =',cs3sn
            write(outfile,*) '  ct3we   =',ct3we
            write(outfile,*) '  ct3sn   =',ct3sn
            write(outfile,*) '  cv3we   =',cv3we
            write(outfile,*) '  cu3sn   =',cu3sn
            write(outfile,*) '  cw3we   =',cw3we
            write(outfile,*) '  cw3sn   =',cw3sn
            write(outfile,*)
      endif
#endif




!-------------------- ORF 12/8/10 Begin MPI communicator code --------------------------------

! Here is where we figure out what "virtual MCM" we are on and set
! up groups We have already checked that nprocs=nodex*nodey etc. above.
! Just be damned sure corex, corey and cores_per_mcm are correct

! mymcmi and mymcmj both start at 0 unlike myi and myj which start at 1

! Like myid, myi, myj etc, these variables are all global (in orfiomod module ) 

      cores_per_mcm = 16
      corex = 4
      corey = 4
      if (myid.eq.0) then
            if ( mod(numprocs,cores_per_mcm).ne.0 )   then
                  print *, "Exiting, numprocs/cores_per_mcm not evenly divisible"
                  write(*,1917) numprocs,cores_per_mcm
                  call FFLUSH(6)
                  call stopcm1
            endif
      endif
1917  format("numprocs = ",i5,"  cores_per_mcm = ",i5)
      nmcm = numprocs/cores_per_mcm
      mymcmi = (myi-1)/corex
      mymcmj = (myj-1)/corey
      mymcmid = mymcmi + mymcmj*(nodex/corex)
!     myrootx = mymcmi*corex
!     myrooty = mymcmj*corey
!     myroot=myrootx+myrooty*nodey
      myroot=mymcmi*corex+mymcmj*corey*nodex

      if (myid.eq.0) then
            if ( mod(nodex,corex).ne.0 .or. mod(nodey,corey).ne.0 )   then
                  print *, "Exiting, nodex/corex or nodey/corey not evenly divisible"
                  write(*,1918) nodex,corex,nodey,corey
                  call FFLUSH(6)
                  call stopcm1
            endif
      endif

1918  format("nodex = ",i5,"  corex = ",i5,"  nodey = ",i5,"  corey = ",i5)
      call MPI_BARRIER(MPI_COMM_WORLD,ierror)
      if (iodebug) then; if (myid.eq.0) print *,'-------------------------------------';call FFLUSH(6);endif

      if (iodebug) then
            write (*,1497)myid,mymcmi,mymcmj,mymcmid,myroot
            call FFLUSH(6)
      endif

1497  format("myid = ",i4,"   mymcmi = ",i4,"   mymcmj = ",i4,"   mymcmid = ",i4,"   myroot = ",i4)
      call MPI_BARRIER(MPI_COMM_WORLD,ierror)
      if (iodebug) then; if (myid.eq.0) print *,'-------------------------------------';call FFLUSH(6);endif

      allocate (mygroupranks(cores_per_mcm))
   
      allocate (mcmyranks(corey))
      allocate (mcmxranks(corex))
      allocate (mcmrootranks(numprocs/cores_per_mcm))
      allocate (x1dranks(nodex))
      allocate (y1dranks(nodey))

! Create groups for each MCM, enabling intra-mcm communiation 
! mygroupranks contain the original MPI ranks

      icount=1
      do j=0,corey-1
         do i = 0,corex-1
            mygroupranks(icount) = (myroot+i)+j*nodex
            if (iodebug) then
                  write(*,1919) myid,icount,mygroupranks(icount)
                  call FFLUSH(6)
            endif
            icount = icount+1
         enddo
      enddo

1919  format("myid = ",i3, "  mygroupranks(",i3,") = ",i5)
      call MPI_BARRIER(MPI_COMM_WORLD,ierror)
      if (iodebug) then; if (myid.eq.0) print *,'-------------------------------------';call FFLUSH(6);endif

! Create group which has only the ranks of the root cores on each MCM
! This is so we can write z-dependent 1d arrays which are the same on all ranks
! but which need to go in each of the 3d hdf5 files

      icount=1
      do j=1,nodey/corey
          do i=1,nodex/corex
              mcmrootranks(icount) = (i-1)*corex + (j-1)*corey*nodex
              if (iodebug) then
                    if(myid.eq.0)write(*,1920) myid,icount,mcmrootranks(icount)
                    call FFLUSH(6)
              endif
              icount = icount + 1
          enddo
      enddo


1920  format("myid = ",i3, "  mcmrootranks(",i3,") = ",i5)
      call MPI_BARRIER(MPI_COMM_WORLD,ierror)
      if (iodebug) then; if (myid.eq.0) print *,'-------------------------------------';call FFLUSH(6);endif

! Create communicator for each MCM, enabling intra-mcm communiation, and for
! ORF_PHDF5

! orig_group contains all MPI ranks, you need to start with this

      call MPI_COMM_GROUP(MPI_COMM_WORLD,orig_group,ierror); if (ierror.ne.0) print *,myid,ierror,'Error at mpi_comm_group 1'
      call MPI_GROUP_INCL(orig_group,cores_per_mcm,mygroupranks,mygroup,ierror); if (ierror.ne.0) print *,myid,ierror,'Error at mpi_group_incl 1'
      call MPI_COMM_CREATE(MPI_COMM_WORLD,mygroup,mysubgroupcomm,ierror); if (ierror.ne.0) print *,myid,ierror,'Error at mpi_comm_create 1'

! Create communicator which just contains cores that will do I/O (the root node of each MCM) for ORF_MCM

      call MPI_GROUP_INCL(orig_group,nmcm,mcmrootranks,mcmrootgroup,ierror); if (ierror.ne.0) print *,myid,ierror,'Error at mpi_group_incl 2'
      call MPI_COMM_CREATE(MPI_COMM_WORLD,mcmrootgroup,mcmrootcomm,ierror); if (ierror.ne.0) print *,myid,ierror,'Error at comm_create 2'

!     if (iodebug)            print *, myid, 'mcmrootgroup =', mcmrootgroup
!     if (iodebug)            print *, myid, 'mcmrootranks =', mcmrootranks
!     if (iodebug)            print *, myid, 'mcmrootcomm =', mcmrootcomm

      call FFLUSH(6)

! Create subgroup of mcm which just contains a row or column so we can
! collectively communicate the 1d mesh arrays. This simplifies things,
! we can just MPI_GATHER to root. These are all with respect to the
! new ranks of mygroup, not orig_group

! ORF 1/15/11
! Also make two new subgoups which are the easternmost column and the northernmost row
! This way we can also use for writing last (easternmost/northernmost) point of staggered U and V
! to each hdf5 file in writeout_hdf5.F for ORF_MCM_GATHER

      do i=1,corex
            mcmxranks(i)=i-1 
      end do
      do j=1,corey
            mcmyranks(j)=(j-1)*corex
      end do

      call MPI_GROUP_INCL(mygroup,corex,mcmxranks,mybxgroup,ierror); if (ierror.ne.0) print *,myid,ierror,'Error at mpi_group_incl 3'
      call MPI_COMM_CREATE(mysubgroupcomm,mybxgroup,mybxgroupcomm,ierror); if (ierror.ne.0) print *,myid,ierror,'Error at mpi_comm_create 3'

      call MPI_GROUP_INCL(mygroup,corey,mcmyranks,mylygroup,ierror); if (ierror.ne.0) print *,myid,ierror,'Error at mpi_group_incl 4'
      call MPI_COMM_CREATE(mysubgroupcomm,mylygroup,mylygroupcomm,ierror); if (ierror.ne.0) print *,myid,ierror,'Error at mpi_comm_create 4'

      do i=1,corex
            mcmxranks(i)=i-1 + (corey-1)*corex
      end do
      do j=1,corey
            mcmyranks(j)=(j-1)*corex + (corex-1)
      end do

      call MPI_GROUP_INCL(mygroup,corex,mcmxranks,mytxgroup,ierror); if (ierror.ne.0) print *,myid,ierror,'Error at mpi_group_incl 3'
      call MPI_COMM_CREATE(mysubgroupcomm,mytxgroup,mytxgroupcomm,ierror); if (ierror.ne.0) print *,myid,ierror,'Error at mpi_comm_create 3'
      call MPI_GROUP_INCL(mygroup,corey,mcmyranks,myrygroup,ierror); if (ierror.ne.0) print *,myid,ierror,'Error at mpi_group_incl 4'
      call MPI_COMM_CREATE(mysubgroupcomm,myrygroup,myrygroupcomm,ierror); if (ierror.ne.0) print *,myid,ierror,'Error at mpi_comm_create 4'

! ORF 1/31/11
! Create groups for 1d variables which only require a column or row of the
! entire horizontal extent of the model domain
! We choose southernmost row and westernmost column because they share root rank
! 0 which we can collect to for writing

! Also, for simplicity, create a group that is only root, this simplifies logic
! in write_1d_float which has been giving me fits

      do i=1,nodex
            x1dranks(i) = i-1
      enddo

      icount=1

      do j=0,numprocs-1,nodex
            y1dranks(icount) = j
            icount = icount + 1
      enddo

! Just root
      rootonlyranks(1) = 0
      call MPI_GROUP_INCL(orig_group,1,rootonlyranks,rootonlygroup,ierror); if (ierror.ne.0) print *,myid,ierror,'Error at mpi_group_incl 5'

      call MPI_GROUP_INCL(orig_group,nodex,x1dranks,x1dgroup,ierror); if (ierror.ne.0) print *,myid,ierror,'Error at mpi_group_incl 5'
      call MPI_BARRIER(MPI_COMM_WORLD,ierror)
      call MPI_COMM_CREATE(MPI_COMM_WORLD,x1dgroup,x1dcomm,ierror); if (ierror.ne.0) print *,myid,ierror,'Error at comm_create 5'
      call MPI_GROUP_INCL(orig_group,nodey,y1dranks,y1dgroup,ierror); if (ierror.ne.0) print *,myid,ierror,'Error at mpi_group_incl 6'
      call MPI_COMM_CREATE(MPI_COMM_WORLD,y1dgroup,y1dcomm,ierror); if (ierror.ne.0) print *,myid,ierror,'Error at comm_create 6'

      call FFLUSH(6)

! Create derived types for all gathers, apparently this can be faster

      call MPI_TYPE_CONTIGUOUS(ni,MPI_REAL,corextype,ierror); call MPI_TYPE_COMMIT    (corextype,ierror)
      call MPI_TYPE_CONTIGUOUS(nj,MPI_REAL,coreytype,ierror); call MPI_TYPE_COMMIT    (coreytype,ierror)
      call MPI_TYPE_CONTIGUOUS(nx,MPI_REAL,x1dtype,ierror); call MPI_TYPE_COMMIT    (x1dtype,ierror)
      call MPI_TYPE_CONTIGUOUS(ny,MPI_REAL,y1dtype,ierror); call MPI_TYPE_COMMIT    (y1dtype,ierror)
      call MPI_TYPE_CONTIGUOUS(ni*nk,MPI_REAL,corexztype,ierror); call MPI_TYPE_COMMIT    (corexztype,ierror)
      call MPI_TYPE_CONTIGUOUS(nj*nk,MPI_REAL,coreyztype,ierror); call MPI_TYPE_COMMIT    (coreyztype,ierror)
      call MPI_TYPE_CONTIGUOUS(ni*nj,MPI_REAL,corexytype,ierror); call MPI_TYPE_COMMIT    (corexytype,ierror)
      call MPI_TYPE_CONTIGUOUS(ni*nj*nk,MPI_REAL,corexyztype,ierror); call MPI_TYPE_COMMIT    (corexyztype,ierror)
      call MPI_TYPE_CONTIGUOUS((ni+1)*nj*nk,MPI_REAL,corexyzutype,ierror); call MPI_TYPE_COMMIT    (corexyzutype,ierror)
      call MPI_TYPE_CONTIGUOUS(ni*(nj+1)*nk,MPI_REAL,corexyzvtype,ierror); call MPI_TYPE_COMMIT    (corexyzvtype,ierror)
      call MPI_TYPE_CONTIGUOUS(ni*nj*(nk+1),MPI_REAL,corexyzwtype,ierror); call MPI_TYPE_COMMIT    (corexyzwtype,ierror)

      call MPI_GROUP_RANK(rootonlygroup,rootonlyrank,ierror)
      call MPI_GROUP_RANK(mylygroup,mylygrouprank,ierror)
      call MPI_GROUP_RANK(myrygroup,myrygrouprank,ierror)
      call MPI_GROUP_RANK(mybxgroup,mybxgrouprank,ierror)
      call MPI_GROUP_RANK(mytxgroup,mytxgrouprank,ierror)
      call MPI_GROUP_RANK(mygroup,mysubgrouprank,ierror)
      call MPI_GROUP_RANK(x1dgroup,x1drank,ierror)
      call MPI_GROUP_RANK(y1dgroup,y1drank,ierror)
      call MPI_GROUP_RANK(mcmrootgroup,mcmrootrank,ierror)

!print *, 'Param: myid = ',myid,' myygrouprank = ',myygrouprank
!print *, 'Param: myid = ',myid,' myxgrouprank = ',myxgrouprank
!     if (iodebug) print *, 'Param: myid = ',myid,' mcmrootcomm = ',mcmrootcomm
!     if (iodebug) print *, 'Param: myid = ',myid,' MPI_COMM_WORLD = ',MPI_COMM_WORLD

! Set up hdf file geometry, used mostly in writeout_hdf5.F

      ioid = mymcmid
      iocomm = mcmrootcomm
      iox0 = mymcmi*ni*corex
      iox1 = (mymcmi+1)*ni*corex-1
      ioy0 = mymcmj*nj*corey
      ioy1 = (mymcmj+1)*nj*corey-1
      iomyi = mymcmi+1
      iomyj = mymcmj+1
      ionumi = ni*corex
      ionumj = nj*corey
      ionodex = nodex/corex
      ionodey = nodey/corey
      iorank = mysubgrouprank
      mygroupi = mod(mysubgrouprank,corex)
      mygroupj = mysubgrouprank/corex
      mygroupoffseti = mygroupi * ni
      mygroupoffsetj = mygroupj * nj
      myfulloffseti = (myi-1)*ni
      myfulloffsetj = (myj-1)*nj

      call MPI_BARRIER(MPI_COMM_WORLD,ierror)
      if (iodebug) then; if (myid.eq.0) print *,'-------------------------------------';call FFLUSH(6);endif

      write(*,1921)myid,ioid,iorank,mygroupi,mygroupj,ionumi,ionumj,myi,myj,ni,nj
      call FFLUSH(6)
1921 format("myid = ",i5, "  ioid = ",i3,"  iorank = ",i3,"  mygroupi = ",i3,"  mygroupj = ",i3," ionumi = ",i3,"  ionumj = ",i3,"  myi = ",i3,"  myj = ",i3,"  ni = ",i3,"  nj = ",i3)
      call MPI_BARRIER(MPI_COMM_WORLD,ierror)
      if (iodebug) then; if (myid.eq.0) print *,'-------------------------------------';call FFLUSH(6);endif

! mygrouprak.eq.0 used when writing out data with PHDF5 where data is same across
! file (stuff like scalars - time, dx, dy, etc.)

! Allocate 2D and 3D I/O arrays if we are on I/O nodes
! Do we need to allocate anything on non-io nodes? Just in case...
! ORF 1/19/11: For PHDF5 we probably don't need to allocate these - maybe just
! one row/column for U,V?

!-------------------- ORF 12/8/10 End MPI communicator code --------------------------------

    IF(iorigin.eq.1)THEN

      do i=ib,ie
        xh(i)=dx*(i+(myi-1)*nx/nodex)-0.5*dx
        if(i+(myi-1)*nx/nodex.lt.1 .and. wbc.ne.1) ibw=1
        if(i+(myi-1)*nx/nodex.gt.nx .and. ebc.ne.1) ibe=1
      enddo

      do i=ib,ie+1
        xf(i)=dx*(i+(myi-1)*nx/nodex-1)
      enddo
      do i=-2,nx+4
        xfref(i)=dx*(i-1)
      enddo

      do j=jb,je
        yh(j)=dy*(j+(myj-1)*ny/nodey)-0.5*dy
        if(j+(myj-1)*ny/nodey.lt.1 .and. sbc.ne.1) ibs=1
        if(j+(myj-1)*ny/nodey.gt.ny .and. nbc.ne.1) ibn=1
      enddo

      do j=jb,je+1
        yf(j)=dy*(j+(myj-1)*ny/nodey-1)
      enddo
      do j=-2,ny+4
        yfref(j)=dy*(j-1)
      enddo

    ELSEIF(iorigin.eq.2)THEN

      do i=ib,ie
        xh(i)=dx*(i+(myi-1)*nx/nodex)-0.5*dx-0.5*dx*nx
        if(i+(myi-1)*nx/nodex.lt.1 .and. wbc.ne.1) ibw=1
        if(i+(myi-1)*nx/nodex.gt.nx .and. ebc.ne.1) ibe=1
      enddo

      do i=ib,ie+1
        xf(i)=dx*(i+(myi-1)*nx/nodex-1)-0.5*dx*nx
      enddo
      do i=-2,nx+4
        xfref(i)=dx*(i-1)-0.5*dx*nx
      enddo

      do j=jb,je
        yh(j)=dy*(j+(myj-1)*ny/nodey)-0.5*dy-0.5*dy*ny
        if(j+(myj-1)*ny/nodey.lt.1 .and. sbc.ne.1) ibs=1
        if(j+(myj-1)*ny/nodey.gt.ny .and. nbc.ne.1) ibn=1
      enddo

      do j=jb,je+1
        yf(j)=dy*(j+(myj-1)*ny/nodey-1)-0.5*dy*ny
      enddo
      do j=-2,ny+4
        yfref(j)=dy*(j-1)-0.5*dy*ny
      enddo

    ELSE

      print *,'  invalid option for iorigin'
      call stopcm1

    ENDIF

#ifndef MPI
      if(wbc.eq.2)then
        ibw=1
      endif

      if(ebc.eq.2)then
        ibe=1
      endif

      if(sbc.eq.2)then
        ibs=1
      endif

      if(nbc.eq.2)then
        ibn=1
      endif
#endif

!--------------------------------------------------------------

      if(myid.eq.0)then
            write(outfile,*)

            write(outfile,*) 'g     =',g
            write(outfile,*) 'to    =',to
            write(outfile,*) 'rd    =',rd
            write(outfile,*) 'rv    =',rv
            write(outfile,*) 'cp    =',cp
            write(outfile,*) 'cv    =',cv
            write(outfile,*) 'cpv   =',cpv
            write(outfile,*) 'cvv   =',cvv
            write(outfile,*) 'p00   =',p00
            write(outfile,*) 'rp00  =',rp00
            write(outfile,*) 'rcp   =',rcp
            write(outfile,*) 'pi    =',pi

            write(outfile,*)

            write(outfile,*) 'cpdcv =',cpdcv
            write(outfile,*) 'rovcp =',rovcp
            write(outfile,*) 'rddcv =',rddcv
            write(outfile,*) 'cvdrd =',cvdrd
            write(outfile,*) 'cpdrd =',cpdrd
            write(outfile,*) 'eps   =',eps
            write(outfile,*) 'reps  =',reps
            write(outfile,*) 'repsm1=',repsm1
            write(outfile,*) 'cpt   =',cpt
            write(outfile,*) 'cvt   =',cvt
            write(outfile,*) 'pnum  =',pnum
            write(outfile,*) 'xlv   =',xlv
            write(outfile,*) 'xls   =',xls
            write(outfile,*) 'lvdcp =',lvdcp
            write(outfile,*) 'condc =',condc
            write(outfile,*) 'cpl   =',cpl
            write(outfile,*) 'cpi   =',cpi
            write(outfile,*) 'lv1   =',lv1
            write(outfile,*) 'lv2   =',lv2
            write(outfile,*) 'ls1   =',ls1
            write(outfile,*) 'ls2   =',ls2

            write(outfile,*)
            write(outfile,*) 'timeformat   =',timeformat
            write(outfile,*) 'timestats    =',timestats
            write(outfile,*) 'terrain_flag =',terrain_flag


            write(outfile,*)
            write(outfile,*) 'nx    =',nx
            write(outfile,*) 'ny    =',ny
            write(outfile,*) 'nz    =',nz

#ifdef MPI
            write(outfile,*)

            write(outfile,*) 'nodex =',nodex
            write(outfile,*) 'nodey =',nodey
#endif

            write(outfile,*)
       
            write(outfile,*) 'ni    =',ni
            write(outfile,*) 'nj    =',nj
            write(outfile,*) 'nk    =',nk
            write(outfile,*) 'nkp1  =',nkp1

            write(outfile,*)
       
            write(outfile,130) 'ib,ibm,ibi,ibc,ibt=',ib,ibm,ibi,ibc,ibt
            write(outfile,130) 'ie,iem,iei,iec,iet=',ie,iem,iei,iec,iet
            write(outfile,130) 'jb,jbm,jbi,jbc,jbt=',jb,jbm,jbi,jbc,jbt
            write(outfile,130) 'je,jem,jei,jec,jet=',je,jem,jei,jec,jet
            write(outfile,130) 'kb,kbm,kbi,kbc,kbt=',kb,kbm,kbi,kbc,kbt
            write(outfile,130) 'ke,kem,kei,kec,ket=',ke,kem,kei,kec,ket

130   format(1x,a19,5(4x,i5))

            write(outfile,*)
            write(outfile,*) 'imirror,jmirror,nkt = ',imirror,jmirror,nkt
            write(outfile,*)

            write(outfile,131) 'ibp,itb,ipb,ibr,ibb=',ibp,itb,ipb,ibr,ibb
            write(outfile,131) 'iep,ite,ipe,ier,ieb=',iep,ite,ipe,ier,ieb
            write(outfile,131) 'jbp,jtb,jpb,jbr,jbb=',jbp,jtb,jpb,jbr,jbb
            write(outfile,131) 'jep,jte,jpe,jer,jeb=',jep,jte,jpe,jer,jeb
            write(outfile,131) 'kbp,ktb,kpb,kbr,kbb=',kbp,ktb,kpb,kbr,kbb
            write(outfile,131) 'kep,kte,kpe,ker,keb=',kep,kte,kpe,ker,keb

131   format(1x,a20,5(4x,i5))

            write(outfile,*)
            write(outfile,132) 'ibl               =',ibl
            write(outfile,132) 'iel               =',iel
            write(outfile,132) 'jbl               =',jbl
            write(outfile,132) 'jel               =',jel

132   format(1x,a19,1(4x,i5))

!----------

            write(outfile,*)

            write(outfile,*) 'rdx    =',rdx
            write(outfile,*) 'rdy    =',rdy
            write(outfile,*) 'rdz    =',rdz
            write(outfile,*) 'rdx2   =',rdx2
            write(outfile,*) 'rdy2   =',rdy2
            write(outfile,*) 'rdz2   =',rdz2
            write(outfile,*) 'rdx4   =',rdx4
            write(outfile,*) 'rdy4   =',rdy4
            write(outfile,*) 'rdz4   =',rdz4
            write(outfile,*) 'govtwo =',govtwo
            write(outfile,*) 'clwsat =',clwsat
            write(outfile,*) 'tsmall =',tsmall

            write(outfile,*)

      endif
!--------------------------------------------------------------

      do i=ib,ie
        uh(i)=1.0
      enddo

      do i=ib,ie+1
        uf(i)=1.0
      enddo

      IF(stretch_x.ge.1)THEN

!!!        ibw=0
!!!        ibe=0

!-----------------------------------------------------------------------
!  Begin hard-wired analytic stretching function

        nominal_dx = 0.5*( dx_inner + dx_outer )

      IF(stretch_x.eq.1)THEN
           if(myid.eq.0)then
              write(outfile,*)
              write(outfile,*) ' stretch_x = 1 ... stretching on both west and east sides of domain:'
              write(outfile,*)
           endif
        ni1=(tot_x_len-nos_x_len)*0.5/nominal_dx
        ni2=nos_x_len/dx_inner
        ni3=ni1
        if(myid.eq.0)then
              write(outfile,*) '  ni1,ni2,ni3 = ',(tot_x_len-nos_x_len)*0.5/nominal_dx,   &
                               nos_x_len/dx_inner,(tot_x_len-nos_x_len)*0.5/nominal_dx
              write(outfile,*) '    (note:  ni1,ni2,ni3 need to be exact integers for this to work correctly)'
        endif
      ELSEIF(stretch_x.eq.2)THEN
            if(myid.eq.0)then
                  write(outfile,*)
                  write(outfile,*) ' stretch_x = 2 ... stretching on east side of domain only:'
                  write(outfile,*)
            endif
        ni1=0
        ni2=nos_x_len/dx_inner
        ni3=(tot_x_len-nos_x_len)/nominal_dx
        if(myid.eq.0)then
              write(outfile,*) '  ni1,ni2,ni3 = ',0.0,nos_x_len/dx_inner,(tot_x_len-nos_x_len)/nominal_dx
              write(outfile,*) '    (note:  ni1,ni2,ni3 need to be exact integers for this to work correctly)'
        endif
      ELSE
        if(myid.eq.0)then
              write(outfile,*)
              write(outfile,*) ' stretch_x must be either 1 or 2'
              write(outfile,*)
        endif
        call stopcm1
      ENDIF

        c2=(nominal_dx-dx_inner)/(nominal_dx*nominal_dx*float(ni3-1))
        c1=(dx_inner/nominal_dx)-c2*nominal_dx

        if(myid.eq.0)then
              write(outfile,*) '  nominal_dx  = ',nominal_dx
              write(outfile,*) '  c1,c2       = ',c1,c2
              write(outfile,*)
        endif

        ! Test to see if nx is kosher.
      IF(stretch_x.eq.1)THEN
        if(nx.ne.ni1+ni2+ni3)then
        if(myid.eq.0)then
          write(outfile,*)
          write(outfile,*) '  There is a problem with the settings for horizontal grid stretching'
          write(outfile,*)
          write(outfile,*) '  User value of nx = ',nx
          write(outfile,*)
          write(outfile,*) '  Value needed for these settings ...'
          write(outfile,*) '       dx_inner  = ',dx_inner
          write(outfile,*) '       dx_outer  = ',dx_outer
          write(outfile,*) '       nos_x_len = ',nos_x_len
          write(outfile,*) '       tot_x_len = ',tot_x_len
          write(outfile,*)
          write(outfile,*) '  ... would be nx = ',(nos_x_len/dx_inner)+(tot_x_len-nos_x_len)/(0.5*(dx_inner+dx_outer))
          write(outfile,*) '  (if this number is an integer) '
          write(outfile,*) '  (and if ni1,ni2,ni3 are all integers) '
          write(outfile,*)
          write(outfile,*) '  ... stopping ...  '
          write(outfile,*)
        endif
          call stopcm1
        endif
      ELSEIF(stretch_x.eq.2)THEN
        if(nx.ne.ni1+ni2+ni3)then
        if(myid.eq.0)then
          write(outfile,*)
          write(outfile,*) '  There is a problem with the settings for horizontal grid stretching'
          write(outfile,*)
          write(outfile,*) '  User value of nx = ',nx
          write(outfile,*)
          write(outfile,*) '  Value for these settings ...'
          write(outfile,*) '       dx_inner  = ',dx_inner
          write(outfile,*) '       dx_outer  = ',dx_outer
          write(outfile,*) '       nos_x_len = ',nos_x_len
          write(outfile,*) '       tot_x_len = ',tot_x_len
          write(outfile,*)
          write(outfile,*) '  ... would be nx = ',(nos_x_len/dx_inner)+(tot_x_len-nos_x_len)/(0.5*(dx_inner+dx_outer))
          write(outfile,*) '  (if this number is an integer) '
          write(outfile,*) '  (and if ni1,ni2,ni3 are all integers) '
          write(outfile,*)
          write(outfile,*) '  ... stopping ...  '
          write(outfile,*)
        endif
          call stopcm1
        endif
      ENDIF

        mult = 0.0
        if(iorigin.eq.2) mult = 0.5

      IF(stretch_x.eq.1)THEN

        do i=ni1+1,ni1+ni2+1
            xfref(i)=ni1*nominal_dx+(i-ni1-1)*dx_inner - mult*tot_x_len
        enddo
        do i=ni1+ni2+2,ni1+ni2+ni3+4
            xfref(i)=ni1*nominal_dx+(ni1+ni2+1-ni1-1)*dble(dx_inner)   &
                 +(c1+c2*dble(i-1-ni1-ni2)*nominal_dx)   &
                 *dble(i-1-ni1-ni2)*nominal_dx - mult*tot_x_len
        enddo
        do i=-2,ni1
            xfref(i)=ni1*nominal_dx+(ni1+1-ni1-1)*dble(dx_inner)    &
                 -(c1+c2*dble(ni1+1-i)*nominal_dx)   &
                 *dble(ni1+1-i)*nominal_dx - mult*tot_x_len
        enddo

      ELSEIF(stretch_x.eq.2)THEN

        do i=ni1+1,ni1+ni2+1
            xfref(i)=ni1*nominal_dx+(i-ni1-1)*dx_inner - mult*tot_x_len
        enddo
        do i=ni1+ni2+2,ni1+ni2+ni3+3
            xfref(i)=ni1*nominal_dx+(ni1+ni2+1-ni1-1)*dble(dx_inner)   &
                 +(c1+c2*dble(i-1-ni1-ni2)*nominal_dx)   &
                 *dble(i-1-ni1-ni2)*nominal_dx - mult*tot_x_len
        enddo
        do i=-2,ni1
            xfref(i)=ni1*nominal_dx+(ni1+1-ni1-1)*dble(dx_inner)    &
                 -(c1+c2*dble(ni1+1-i)*nominal_dx)   &
                 *dble(ni1+1-i)*nominal_dx - mult*tot_x_len
        enddo

      ENDIF

!!!        if( xf(ib).lt.0.0  .and. wbc.ne.1 ) ibw=1
!!!        if( xf(ie).gt.maxx .and. ebc.ne.1 ) ibe=1

        IF(stretch_x.eq.1)THEN
          xfref( 0)=xfref(1)-1*dx_outer
          xfref(-1)=xfref(1)-2*dx_outer
          xfref(-2)=xfref(1)-3*dx_outer
        ELSEIF(stretch_x.eq.2)THEN
          xfref( 0)=xfref(1)-1*dx_inner
          xfref(-1)=xfref(1)-2*dx_inner
          xfref(-2)=xfref(1)-3*dx_inner
        ENDIF

          xfref(nx+2)=xfref(nx+1)+1*dx_outer
          xfref(nx+3)=xfref(nx+1)+2*dx_outer
          xfref(nx+4)=xfref(nx+1)+3*dx_outer

!  End hard-wired analytic stretching function
!-----------------------------------------------------------------------
!
!  Optional:  to use a different stretching function, or to use 
!  arbitrarily located grid points, simply comment out the 
!  "hard-wired" section above, and then specify values for xfref
!  here.  Do not change anything below here!
!
!  Note:  xfref stores the location of the staggered u points for
!  the entire domain (from x=-2 to x=nx+4) (note: this includes
!  the boundary points that extend 3 gridpoints beyond the
!  computational domain.
!
!-----------------------------------------------------------------------

        do i=ib,ie+1
          xf(i)=xfref(i+(myi-1)*ni)
        enddo

        do i=ib,ie
          xh(i)=0.5*(xf(i+1)+xf(i))
          uh(i)=dx/(xf(i+1)-xf(i))
        enddo

        do i=ib+1,ie
          uf(i)=dx/(xh(i)-xh(i-1))
        enddo

        if(ibw.eq.1)then
          uf( 0)=uf(1)
          uf(-1)=uf(1)
          uf(-2)=uf(1)
        endif

        if(ibe.eq.1)then
          uf(ni+2)=uf(ni+1)
          uf(ni+3)=uf(ni+1)
          uf(ni+4)=uf(ni+1)
        endif

      ENDIF

      do i=ib,ie
        rxh(i)=1.0/(smeps+xh(i))
        ruh(i)=1.0/uh(i)
      enddo

      do i=ib,ie+1
        rxf(i)=1.0/(smeps+xf(i))
        ruf(i)=1.0/uf(i)
      enddo

      minx = xfref(1)
      maxx = xfref(nx+1)

      if(myid.eq.0)then
            write(outfile,*)
            write(outfile,*) 'x:'
            write(outfile,124)
124         format('      i         xf           xh         dx         uf         uh')
            write(outfile,125)
125         format(' ---------------------------------------------------------------')
            do i=ib,ib+2
              write(outfile,122) i,xf(i),xh(i),xf(i+1)-xf(i),uf(i),uh(i),'   x'
            enddo
            do i=ib+3,ie-3
              write(outfile,122) i,xf(i),xh(i),xf(i+1)-xf(i),uf(i),uh(i),'    '
            enddo
            do i=ie-2,ie
              write(outfile,122) i,xf(i),xh(i),xf(i+1)-xf(i),uf(i),uh(i),'   x'
            enddo
122         format(3x,i5,3x,f11.2,3x,f11.2,3x,f9.2,3x,f8.4,3x,f8.4,a4)
            write(outfile,123) ie+1,xf(ie+1),uf(ie+1)
123         format(3x,i5,3x,f11.2,29x,f8.4)
            write(outfile,*)
      endif

!--------------------------------------------------------------

      do j=jb,je
        vh(j)=1.0
      enddo

      do j=jb,je+1
        vf(j)=1.0
      enddo

      IF(stretch_y.ge.1)THEN

!!!        ibs=0
!!!        ibn=0

!-----------------------------------------------------------------------
!  Begin hard-wired analytic stretching function

        nominal_dy = 0.5*( dy_inner + dy_outer )

      IF(stretch_y.eq.1)THEN
      if(myid.eq.0)then
              write(outfile,*)
              write(outfile,*) ' stretch_y = 1 ... stretching on both south and north sides of domain:'
              write(outfile,*)
       endif
        nj1=(tot_y_len-nos_y_len)*0.5/nominal_dy
        nj2=nos_y_len/dy_inner
        nj3=nj1
        if(myid.eq.0)then
              write(outfile,*) '  nj1,nj2,nj3 = ',(tot_y_len-nos_y_len)*0.5/nominal_dy,   &
                               nos_y_len/dy_inner,(tot_y_len-nos_y_len)*0.5/nominal_dy
              write(outfile,*) '    (note:  nj1,nj2,nj3 need to be exact integers for this to work correctly)'
        endif
      ELSEIF(stretch_y.eq.2)THEN
        if(myid.eq.0)then
              write(outfile,*)
              write(outfile,*) ' stretch_y = 2 ... stretching on north side of domain only:'
              write(outfile,*)
        endif
        nj1=0
        nj2=nos_y_len/dy_inner
        nj3=(tot_y_len-nos_y_len)/nominal_dy
        if(myid.eq.0)then
              write(outfile,*) '  nj1,nj2,nj3 = ',0.0,nos_y_len/dy_inner,(tot_y_len-nos_y_len)/nominal_dy
              write(outfile,*) '    (note:  nj1,nj2,nj3 need to be exact integers for this to work correctly)'
        endif
      ELSE
        if(myid.eq.0)then
              write(outfile,*)
              write(outfile,*) ' stretch_y must be either 1 or 2'
              write(outfile,*)
        endif
        call stopcm1
      ENDIF

        c2=(nominal_dy-dy_inner)/(nominal_dy*nominal_dy*float(nj3-1))
        c1=(dy_inner/nominal_dy)-c2*nominal_dy

        if(myid.eq.0)then
              write(outfile,*) '  nominal_dy  = ',nominal_dy
              write(outfile,*) '  c1,c2       = ',c1,c2
              write(outfile,*)
        endif

        ! Test to see if ny is kosher.
      IF(stretch_y.eq.1)THEN
        if(ny.ne.nj1+nj2+nj3)then
        if(myid.eq.0)then
          write(outfile,*)
          write(outfile,*) '  There is a problem with the settings for horizontal grid stretching'
          write(outfile,*)
          write(outfile,*) '  User value of ny = ',ny
          write(outfile,*)
          write(outfile,*) '  Value needed for these settings ...'
          write(outfile,*) '       dy_inner  = ',dy_inner
          write(outfile,*) '       dy_outer  = ',dy_outer
          write(outfile,*) '       nos_y_len = ',nos_y_len
          write(outfile,*) '       tot_y_len = ',tot_y_len
          write(outfile,*)
          write(outfile,*) '  ... would be ny = ',(nos_y_len/dy_inner)+(tot_y_len-nos_y_len)/(0.5*(dy_inner+dy_outer))
          write(outfile,*) '  (if this number is an integer) '
          write(outfile,*) '  (and if nj1,nj2,nj3 are all integers) '
          write(outfile,*)
          write(outfile,*) '  ... stopping ...  '
          write(outfile,*)
         endif
          call stopcm1
        endif
      ELSEIF(stretch_y.eq.2)THEN
        if(ny.ne.nj1+nj2+nj3)then
        if(myid.eq.0)then
          write(outfile,*)
          write(outfile,*) '  There is a problem with the settings for horizontal grid stretching'
          write(outfile,*)
          write(outfile,*) '  User value of ny = ',ny
          write(outfile,*)
          write(outfile,*) '  Value for these settings ...'
          write(outfile,*) '       dy_inner  = ',dy_inner
          write(outfile,*) '       dy_outer  = ',dy_outer
          write(outfile,*) '       nos_y_len = ',nos_y_len
          write(outfile,*) '       tot_y_len = ',tot_y_len
          write(outfile,*)
          write(outfile,*) '  ... would be ny = ',(nos_y_len/dy_inner)+(tot_y_len-nos_y_len)/(0.5*(dy_inner+dy_outer))
          write(outfile,*) '  (if this number is an integer) '
          write(outfile,*) '  (and if nj1,nj2,nj3 are all integers) '
          write(outfile,*)
          write(outfile,*) '  ... stopping ...  '
          write(outfile,*)
         endif
          call stopcm1
        endif
      ENDIF

        mult = 0.0
        if(iorigin.eq.2) mult = 0.5

      IF(stretch_y.eq.1)THEN

        do j=nj1+1,nj1+nj2+1
            yfref(j)=nj1*nominal_dy+(j-nj1-1)*dy_inner - mult*tot_y_len
        enddo
        do j=nj1+nj2+2,nj1+nj2+nj3+4
            yfref(j)=nj1*nominal_dy+(nj1+nj2+1-nj1-1)*dble(dy_inner)   &
                 +(c1+c2*dble(j-1-nj1-nj2)*nominal_dy)   &
                 *dble(j-1-nj1-nj2)*nominal_dy - mult*tot_y_len
        enddo
        do j=-2,nj1
            yfref(j)=nj1*nominal_dy+(nj1+1-nj1-1)*dble(dy_inner)    &
                 -(c1+c2*dble(nj1+1-j)*nominal_dy)   &
                 *dble(nj1+1-j)*nominal_dy - mult*tot_y_len
        enddo

      ELSEIF(stretch_y.eq.2)THEN

        do j=nj1+1,nj1+nj2+1
            yfref(j)=nj1*nominal_dy+(j-nj1-1)*dy_inner - mult*tot_y_len
        enddo
        do j=nj1+nj2+2,nj1+nj2+nj3+3
            yfref(j)=nj1*nominal_dy+(nj1+nj2+1-nj1-1)*dble(dy_inner)   &
                 +(c1+c2*dble(j-1-nj1-nj2)*nominal_dy)   &
                 *dble(j-1-nj1-nj2)*nominal_dy - mult*tot_y_len
        enddo
        do j=-2,nj1
            yfref(j)=nj1*nominal_dy+(nj1+1-nj1-1)*dble(dy_inner)    &
                 -(c1+c2*dble(nj1+1-j)*nominal_dy)   &
                 *dble(nj1+1-j)*nominal_dy - mult*tot_y_len
        enddo

      ENDIF

!!!        if( yf(jb).lt.0.0  .and. sbc.ne.1 ) ibs=1
!!!        if( yf(je).gt.maxy .and. nbc.ne.1 ) ibn=1

        IF(stretch_y.eq.1)THEN
          yfref( 0)=yfref(1)-1*dy_outer
          yfref(-1)=yfref(1)-2*dy_outer
          yfref(-2)=yfref(1)-3*dy_outer
        ELSEIF(stretch_y.eq.2)THEN
          yfref( 0)=yfref(1)-1*dy_inner
          yfref(-1)=yfref(1)-2*dy_inner
          yfref(-2)=yfref(1)-3*dy_inner
        ENDIF

          yfref(ny+2)=yfref(ny+1)+1*dy_outer
          yfref(ny+3)=yfref(ny+1)+2*dy_outer
          yfref(ny+4)=yfref(ny+1)+3*dy_outer

!  End hard-wired analytic stretching function
!-----------------------------------------------------------------------
!
!  Optional:  to use a different stretching function, or to use 
!  arbitrarily located grid points, simply comment out the 
!  "hard-wired" section above, and then specify values for yfref
!  here.  Do not change anything below here!
!
!  Note:  yfref stores the location of the staggered v points for
!  the entire domain (from y=-2 to y=ny+4) (note: this includes
!  the boundary points that extend 3 gridpoints beyond the
!  computational domain.
!
!-----------------------------------------------------------------------

        do j=jb,je+1
          yf(j)=yfref(j+(myj-1)*nj)
        enddo

        do j=jb,je
          yh(j)=0.5*(yf(j+1)+yf(j))
          vh(j)=dy/(yf(j+1)-yf(j))
        enddo

        do j=jb+1,je
          vf(j)=dy/(yh(j)-yh(j-1))
        enddo

        if(ibs.eq.1)then
          vf( 0)=vf(1)
          vf(-1)=vf(1)
          vf(-2)=vf(1)
        endif

        if(ibn.eq.1)then
          vf(nj+2)=vf(nj+1)
          vf(nj+3)=vf(nj+1)
          vf(nj+4)=vf(nj+1)
        endif

      ENDIF

      do j=jb,je
        rvh(j)=1.0/vh(j)
      enddo

      do j=jb,je+1
        rvf(j)=1.0/vf(j)
      enddo

      miny = yfref(1)
      maxy = yfref(ny+1)

      if(myid.eq.0)then
            write(outfile,*)
            write(outfile,*) 'y:'
            write(outfile,134)
134         format('      j         yf           yh         dy         vf         vh')
            write(outfile,125)
            do j=jb,jb+2
              write(outfile,122) j,yf(j),yh(j),yf(j+1)-yf(j),vf(j),vh(j),'   x'
            enddo
            do j=jb+3,je-3
              write(outfile,122) j,yf(j),yh(j),yf(j+1)-yf(j),vf(j),vh(j),'    '
            enddo
            do j=je-2,je
              write(outfile,122) j,yf(j),yh(j),yf(j+1)-yf(j),vf(j),vh(j),'   x'
            enddo
            write(outfile,123) je+1,yf(je+1),vf(je+1)
            write(outfile,*)
       endif

!--------------------------------------------------------------

      do k=kb,ke+1
      do j=jb,je
      do i=ib,ie
        zf(i,j,k)=dz*(k-1)
        mf(i,j,k)=1.0
      enddo
      enddo
      enddo

      do k=kb,ke
      do j=jb,je
      do i=ib,ie
        zh(i,j,k)=0.5*(zf(i,j,k)+zf(i,j,k+1))
        mh(i,j,k)=1.0
      enddo
      enddo
      enddo

      do k=kb,ke+1
        sigmaf(k)=1.0
      enddo


      maxz = nz*dz

    IF(stretch_z.eq.1)THEN

!-----------------------------------------------------------------------
!  Begin hard-wired analytic stretching function

        maxz = ztop

        nk1=str_bot/dz_bot
        nk3=(ztop-str_top)/dz_top
        nk2=nk-(nk1+nk3)

        nominal_dz=(str_top-str_bot)/nk2

        c2=(nominal_dz-dz_bot)/(nominal_dz*nominal_dz*float(nk2-1))
        c1=(dz_bot/nominal_dz)-c2*nominal_dz

        ! Test to see if nk is kosher.
        if(nk.ne.nk1+nk3+(str_top-str_bot)/(0.5*(dz_bot+dz_top)))then
            if(myid.eq.0)then
                write(outfile,*)
                write(outfile,*) '  User value of nz = ',nz
                write(outfile,*)
                write(outfile,*) '  Value needed for these settings:'
                write(outfile,*) '       ztop      = ',ztop
                write(outfile,*) '       str_bot   = ',str_bot
                write(outfile,*) '       str_top   = ',str_top
                write(outfile,*) '       dz_bot    = ',dz_bot
                write(outfile,*) '       dz_top    = ',dz_top
                write(outfile,*) '  would be nz = ',nk1+nk3+(str_top-str_bot)/(0.5*(dz_bot+dz_top))
                write(outfile,*)
                write(outfile,*) '  ... stopping ...  '
                write(outfile,*)
             endif
          call stopcm1
        endif

        if(myid.eq.0)then
              write(outfile,*)
              write(outfile,*) '  nk1,nk2,nk3,ntot=',nk1,nk2,nk3,(nk1+nk2+nk3)
              write(outfile,*) '  nominal_dz =',nominal_dz
              write(outfile,*) '  c1,c2 = ',c1,c2
              write(outfile,*)
        endif

      do j=jb,je
      do i=ib,ie

        do k=1,nk1+1
          zf(i,j,k)=(k-1)*dz_bot
        enddo
        do k=(nk1+1),(nk1+nk2+1)
          zf(i,j,k)=zf(i,j,nk1+1)+(c1+c2*float(k-1-nk1)*nominal_dz)   &
                         *float(k-1-nk1)*nominal_dz
        enddo
        do k=(nk1+nk2+2),(nk1+nk2+nk3+1)
          zf(i,j,k)=zf(i,j,k-1)+dz_top
        enddo

      enddo
      enddo

      if(terrain_flag)then

        do k=1,nk1+1
          sigmaf(k)=(k-1)*dz_bot
        enddo
        do k=(nk1+1),(nk1+nk2+1)
          sigmaf(k)=sigmaf(nk1+1)+(c1+c2*float(k-1-nk1)*nominal_dz)   &
                         *float(k-1-nk1)*nominal_dz
        enddo
        do k=(nk1+nk2+2),(nk1+nk2+nk3+1)
          sigmaf(k)=sigmaf(k-1)+dz_top
        enddo

        sigmaf(0)=-sigmaf(2)
        sigmaf(nk+2)=sigmaf(nk+1)+(sigmaf(nk+1)-sigmaf(nk))

      endif

!  End hard-wired analytic stretching function
!-----------------------------------------------------------------------
!
!  Optional:  to use a different stretching function, or to use 
!  arbitrarily located grid points, simply comment out the 
!  "hard-wired" section above, and then specify values for zf
!  here.  Do not change anything below here!
!
!  Note:  zf stores the location of the staggered w points. 
!
!  Note:  if you are using terrain, you need to also specify the nominal 
!  locations of the zf points in the sigmaf array.
!
!-----------------------------------------------------------------------

      do j=jb,je
      do i=ib,ie

        zf(i,j,0)=-zf(i,j,2)
        zf(i,j,nk+2)=zf(i,j,nk+1)+(zf(i,j,nk+1)-zf(i,j,nk))

        do k=0,nk+1
          zh(i,j,k)=0.5*(zf(i,j,k+1)+zf(i,j,k))
          mh(i,j,k)=dz/(zf(i,j,k+1)-zf(i,j,k))
        enddo
        zh(i,j,0)=-zh(i,j,1)
        zh(i,j,nk+1)=zh(i,j,nk)+2.0*(zf(i,j,nk+1)-zh(i,j,nk))

        do k=1,nk+1
          mf(i,j,k)=dz/(zh(i,j,k)-zh(i,j,k-1))
        enddo
        mf(i,j,0)=mf(i,j,1)
        mf(i,j,nk+2)=mf(i,j,nk+1)

      enddo
      enddo

    ENDIF

! end vertical stretching section
!-----------------------------------------------------------------------

      do k=kb,ke
      do j=jb,je
      do i=ib,ie
        rmh(i,j,k)=1.0/mh(i,j,k)
      enddo
      enddo
      enddo

      do k=kb,ke+1
      do j=jb,je
      do i=ib,ie
        rmf(i,j,k)=1.0/mf(i,j,k)
      enddo
      enddo
      enddo

      if(myid.eq.0)then
            write(outfile,*)
            write(outfile,*) 'model heights:'
            write(outfile,104)
104         format('     k       zf         zh         dz         mf         mh')
            write(outfile,105)
105         format(' ---------------------------------------------------------------')
            do k=1,nk
              write(outfile,102) k,zf(1,1,k),zh(1,1,k),zf(1,1,k+1)-zf(1,1,k),mf(1,1,k),mh(1,1,k)
102           format(3x,i4,3x,f8.2,3x,f8.2,3x,f8.2,3x,f8.4,3x,f8.4)
            enddo
            write(outfile,103) nk+1,zf(1,1,nk+1),mf(1,1,nk+1)
103         format(3x,i4,3x,f8.2,25x,f8.4)
            write(outfile,*)
      endif

!-----------------------------------------------------------------------

#ifdef MPI
      if( ibw.eq.1 .and. yh(jb).gt.miny ) patchsww = .true.
      if( ibw.eq.1 .and. yh(je).lt.maxy ) patchnww = .true.
      if( ibe.eq.1 .and. yh(jb).gt.miny ) patchsee = .true.
      if( ibe.eq.1 .and. yh(je).lt.maxy ) patchnee = .true.
      if( ibs.eq.1 .and. xh(ib).gt.minx ) patchsws = .true.
      if( ibs.eq.1 .and. xh(ie).lt.maxx ) patchses = .true.
      if( ibn.eq.1 .and. xh(ib).gt.minx ) patchnwn = .true.
      if( ibn.eq.1 .and. xh(ie).lt.maxx ) patchnen = .true.

      if(myid.eq.0)then
            write(outfile,*) '  patchsww =',patchsww
            write(outfile,*) '  patchnww =',patchnww
            write(outfile,*) '  patchsee =',patchsee
            write(outfile,*) '  patchnee =',patchnee
            write(outfile,*) '  patchsws =',patchsws
            write(outfile,*) '  patchses =',patchses
            write(outfile,*) '  patchnwn =',patchnwn
            write(outfile,*) '  patchnen =',patchnen
            write(outfile,*)
      endif

      if( ibw.eq.1 .and. yh(jb).lt.miny ) p2tchsww = .true.
      if( ibw.eq.1 .and. yh(je).gt.maxy ) p2tchnww = .true.
      if( ibe.eq.1 .and. yh(jb).lt.miny ) p2tchsee = .true.
      if( ibe.eq.1 .and. yh(je).gt.maxy ) p2tchnee = .true.
      if( ibs.eq.1 .and. xh(ib).lt.minx ) p2tchsws = .true.
      if( ibs.eq.1 .and. xh(ie).gt.maxx ) p2tchses = .true.
      if( ibn.eq.1 .and. xh(ib).lt.minx ) p2tchnwn = .true.
      if( ibn.eq.1 .and. xh(ie).gt.maxx ) p2tchnen = .true.

      if(myid.eq.0)then
            write(outfile,*) '  p2tchsww =',p2tchsww
            write(outfile,*) '  p2tchnww =',p2tchnww
            write(outfile,*) '  p2tchsee =',p2tchsee
            write(outfile,*) '  p2tchnee =',p2tchnee
            write(outfile,*) '  p2tchsws =',p2tchsws
            write(outfile,*) '  p2tchses =',p2tchses
            write(outfile,*) '  p2tchnwn =',p2tchnwn
            write(outfile,*) '  p2tchnen =',p2tchnen
            write(outfile,*)
      endif
#endif

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!                  BEGIN TERRAIN !
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      do k=kb,ke
        sigma(k)=1.0
      enddo

      do j=jtb,jte
      do i=itb,ite
        zs(i,j)=0.0
        gz(i,j)=1.0
        dzdx(i,j)=0.0
        dzdy(i,j)=0.0
      enddo
      enddo

      do k=ktb,kte
      do j=jtb,jte
      do i=itb,ite+1
        gx(i,j,k)=0.0
      enddo
      enddo
      enddo

      do k=ktb,kte
      do j=jtb,jte+1
      do i=itb,ite
        gy(i,j,k)=0.0
      enddo
      enddo
      enddo


      IF(terrain_flag)THEN

            if(myid.eq.0)then
              write(outfile,*)
              write(outfile,*) '  Terrain included!'
              write(outfile,*)
            endif

        zs = 0.0

        ! moved this section of code to init_terrain in cm1r15:
        call init_terrain(xh,xf,yh,yf,sigma,sigmaf,   &
                          zh,mh,rmh,zf,mf,rmf,zs,gz,dzdx,dzdy,gx,gy)

      ENDIF

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!                  END   TERRAIN !
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

!-----------------------------------------------------------------------

      if(myid.eq.0)then
            write(outfile,*) '  minx = ',minx
            write(outfile,*) '  maxx = ',maxx
            write(outfile,*) '  miny = ',miny
            write(outfile,*) '  maxy = ',maxy
            write(outfile,*) '  maxz = ',maxz
            write(outfile,*)

            write(outfile,*) '  ibw =',ibw
            write(outfile,*) '  ibe =',ibe
            write(outfile,*) '  ibs =',ibs
            write(outfile,*) '  ibn =',ibn
            write(outfile,*)
      endif

!-----------------------------------------------------------------------
!  Get min/max dx,dy,dz on grid
!  (needed for adapt_dt ... but interesting to report, nontheless)

      min_dx = 1.0e20
      min_dy = 1.0e20
      min_dz = 1.0e20

      max_dx = 0.0
      max_dy = 0.0
      max_dz = 0.0

      do i=1,ni
        min_dx = min( min_dx , xf(i+1)-xf(i) )
        max_dx = max( max_dx , xf(i+1)-xf(i) )
      enddo

      do j=1,nj
        min_dy = min( min_dy , yf(j+1)-yf(j) )
        max_dy = max( max_dy , yf(j+1)-yf(j) )
      enddo

      do k=1,nk
      do j=1,nj
      do i=1,ni
        min_dz = min( min_dz , zf(i,j,k+1)-zf(i,j,k) )
        max_dz = max( max_dz , zf(i,j,k+1)-zf(i,j,k) )
      enddo
      enddo
      enddo

#ifdef MPI
      var=0.0
      call MPI_ALLREDUCE(min_dx,var,1,MPI_REAL,MPI_MIN,MPI_COMM_WORLD,ierr)
      min_dx=var
      var=0.0
      call MPI_ALLREDUCE(min_dy,var,1,MPI_REAL,MPI_MIN,MPI_COMM_WORLD,ierr)
      min_dy=var
      var=0.0
      call MPI_ALLREDUCE(min_dz,var,1,MPI_REAL,MPI_MIN,MPI_COMM_WORLD,ierr)
      min_dz=var
      var=0.0
      call MPI_ALLREDUCE(max_dx,var,1,MPI_REAL,MPI_MAX,MPI_COMM_WORLD,ierr)
      max_dx=var
      var=0.0
      call MPI_ALLREDUCE(max_dy,var,1,MPI_REAL,MPI_MAX,MPI_COMM_WORLD,ierr)
      max_dy=var
      var=0.0
      call MPI_ALLREDUCE(max_dz,var,1,MPI_REAL,MPI_MAX,MPI_COMM_WORLD,ierr)
      max_dz=var
#endif

      if(myid.eq.0)then
            write(outfile,*) '  min_dx = ',min_dx
            write(outfile,*) '  max_dx = ',max_dx
            write(outfile,*) '  min_dy = ',min_dy
            write(outfile,*) '  max_dy = ',max_dy
            write(outfile,*) '  min_dz = ',min_dz
            write(outfile,*) '  max_dz = ',max_dz
            write(outfile,*)
      endif

!--------------------------------------------------------------
!  Specify coefficient for Rayleigh damper in vertical

      do k=kb,ke
      do j=jb,je
      do i=ib,ie
        tauh(i,j,k)=0.0
        taus(i,j,k)=0.0
      enddo
      enddo
      enddo

      do k=kb,ke+1
      do j=jb,je
      do i=ib,ie
        tauf(i,j,k)=0.0
      enddo
      enddo
      enddo

      if( (irdamp.eq.1).and.(zd.lt.maxz) )then

        do j=jb,je
        do i=ib,ie
          do k=1,nk
            if(zh(i,j,k).gt.zd)then
            tauh(i,j,k)=0.5*(1.0-cos(pi*(zh(i,j,k)-zd)/(zf(i,j,nk+1)-zd)))
            taus(i,j,k)=tauh(i,j,k)
            endif
          enddo
          enddo
        enddo
 
        do j=jb,je
        do i=ib,ie
          do k=1,nk+1
            if(zf(i,j,k).gt.zd)then
            tauf(i,j,k)=0.5*(1.0-cos(pi*(zf(i,j,k)-zd)/(zf(i,j,nk+1)-zd)))
            endif
          enddo
          enddo
        enddo

      endif

      if(myid.eq.0)then
            write(outfile,*)
            write(outfile,*) '  ------ tauf, tauh -----'
            do k=1,nk
              write(outfile,*) k,tauf(1,1,k),tauh(1,1,k)
            enddo
            write(outfile,*) nk+1,tauf(1,1,nk+1)
            write(outfile,*)
      endif

!--------------------------------------------------------------
!  Rayleigh damping near lateral boundaries:

      IF(hrdamp.eq.1)THEN

        do k=1,nk
        do j=jb,je
        do i=ib,ie
          ! skip this section of code for 2d simulations:
          IF(nx.gt.1)THEN
            ! west boundary:
            IF( axisymm.ne.1 )THEN
              x1 = xhd+minx-xh(i)
              if( x1.gt.0.0 )then
                tauh(i,j,k) = max( tauh(i,j,k) , 0.5*(1.0-cos(pi*x1/xhd)) )
                tauf(i,j,k) = max( tauf(i,j,k) , 0.5*(1.0-cos(pi*x1/xhd)) )
              endif
            ENDIF
            ! east boundary:
            x2 = xh(i)-(maxx-xhd)
            if( x2.gt.0.0 )then
              tauh(i,j,k) = max( tauh(i,j,k) , 0.5*(1.0-cos(pi*x2/xhd)) )
              tauf(i,j,k) = max( tauf(i,j,k) , 0.5*(1.0-cos(pi*x2/xhd)) )
            endif
          ENDIF
          ! skip this section of code for 2d simulations:
          IF(ny.gt.1)THEN
            ! south boundary:
            y1 = xhd+miny-yh(j)
            if( y1.gt.0.0 )then
              tauh(i,j,k) = max( tauh(i,j,k) , 0.5*(1.0-cos(pi*y1/xhd)) )
              tauf(i,j,k) = max( tauf(i,j,k) , 0.5*(1.0-cos(pi*y1/xhd)) )
            endif
            ! north boundary:
            y2 = yh(j)-(maxy-xhd)
            if( y2.gt.0.0 )then
              tauh(i,j,k) = max( tauh(i,j,k) , 0.5*(1.0-cos(pi*y2/xhd)) )
              tauf(i,j,k) = max( tauf(i,j,k) , 0.5*(1.0-cos(pi*y2/xhd)) )
            endif
          ENDIF
        enddo
        enddo
        enddo

      ENDIF

!--------------------------------------------------------------
!  vertically implicit turbulent diffusion:

      ! Set vialpha:
      !      0.0 = forward-in-time (unstable if K dt / (dz^2) > 0.5)
      !      0.5 = centered-in-time (Crank-Nicholson) (stable but oscillatory)
      !      1.0 = backward-in-time (stable)
!      vialpha = 1.0

      ! Do not change this:
!      vibeta  = 1.0 - vialpha

!      NOTE:  these are now set in constants.incl files

      if(myid.eq.0)then
        write(outfile,*)
        write(outfile,*) '  vialpha,vibeta = ',vialpha,vibeta
        write(outfile,*)
      endif

!--------------------------------------------------------------

      dt = dtl
      dtlast = dt

!--------------------------------------------------------------

      if(myid.eq.0) write(outfile,*) 'Leaving PARAM'

      return
      end



parcel.F/       1298670057  19071 8000  100644  15705     `


      subroutine parcel_driver(prec,dt,xh,uh,ruh,yh,vh,rvh,zh,mh,rmh,mf,   &
                               pi0,thv0,th0,the,b,dpdz,thv,qt,prs,      &
                               ua,va,wa,ppi,nm,tha,qa,kh,pdata,rtime,   &
                               ploc,packet,reqs_s,                      &
                               sw1,sw2,se1,se2,ss1,ss2,sn1,sn2)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      integer :: prec
      real :: dt
      real, dimension(ib:ie) :: xh,uh,ruh
      real, dimension(jb:je) :: yh,vh,rvh
      real, dimension(ib:ie,jb:je,kb:ke) :: zh,mh,rmh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, dimension(ib:ie,jb:je,kb:ke) :: pi0,thv0,th0
      real, dimension(ib:ie,jb:je,kb:ke) :: the,b,dpdz,thv,qt,prs
      real, dimension(ib:ie+1,jb:je,kb:ke) :: ua
      real, dimension(ib:ie,jb:je+1,kb:ke) :: va
      real, dimension(ib:ie,jb:je,kb:ke+1) :: wa
      real, dimension(ib:ie,jb:je,kb:ke) :: ppi,nm,tha
      real, dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: qa
      real, dimension(ibc:iec,jbc:jec,kbc:kec) :: kh
      real, dimension(npvals,nparcels) :: pdata
      real :: rtime
      real, dimension(3,nparcels) :: ploc
      real, dimension(npvals+1,nparcels) :: packet
      integer, dimension(rmp) :: reqs_s
      real, dimension(jmp,kmp) :: sw1,sw2,se1,se2
      real, dimension(imp,kmp) :: ss1,ss2,sn1,sn2

      integer :: n,np,i,j,k,iflag,jflag,kflag
      real :: tx,cpm,qvs,tem
      real :: uval,vval,wval,rx,ry,rz,w1,w2,w3,w4,w5,w6,w7,w8
      real :: rslf

#ifdef MPI
      include 'mpif.h'
      integer status(MPI_STATUS_SIZE)
      integer :: proc,ihave
#endif

!----------------------------------------------------------------------
!  Calculate derived variables
!
!  Note:  n-squared should be on w-points

    call bcs(prs)
#ifdef MPI
    call comm_1s_start(prs,sw1,sw2,se1,se2,   &
                           ss1,ss2,sn1,sn2,reqs_s)
#endif
    call bcs(nm)
#ifdef MPI
    call comm_1s_end(prs,sw1,sw2,se1,se2,   &
                         ss1,ss2,sn1,sn2,reqs_s)
    call comm_1s_start(nm,sw1,sw2,se1,se2,   &
                          ss1,ss2,sn1,sn2,reqs_s)
#endif

    IF(imoist.eq.1)THEN

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=0,nk+1
      do j=0,nj+1
      do i=0,ni+1
        qt(i,j,k)=0.0
      enddo
      enddo
      enddo

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=0,nk+1
      do j=0,nj+1
      do i=0,ni+1
        qt(i,j,k)=qt(i,j,k)+qa(i,j,k,nqv)
      enddo
      enddo
      enddo

      do n=nql1,nql2
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=0,nk+1
        do j=0,nj+1
        do i=0,ni+1
          qt(i,j,k)=qt(i,j,k)+qa(i,j,k,n)
        enddo
        enddo
        enddo
      enddo

      do n=nqs1,nqs2
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=0,nk+1
        do j=0,nj+1
        do i=0,ni+1
          qt(i,j,k)=qt(i,j,k)+qa(i,j,k,n)
        enddo
        enddo
        enddo
      enddo

!$omp parallel do default(shared)  &
!$omp private(i,j,k,n,tx,cpm,qvs)
      do k=0,nk+1
      do j=0,nj+1
      do i=0,ni+1
        tx=(th0(i,j,k)+tha(i,j,k))*(pi0(i,j,k)+ppi(i,j,k))
        cpm=cp+cpl*qa(i,j,k,nqv)
        do n=nql1,nql2
          cpm=cpm+cpl*qa(i,j,k,n)
        enddo
        qvs=rslf( prs(i,j,k) , tx )
        the(i,j,k)=tx*((p00*(1.0+qa(i,j,k,nqv)*reps)      &
                        /prs(i,j,k))**(rd/cpm))       &
           *((qa(i,j,k,nqv)/qvs)**(-qa(i,j,k,nqv)*rv/cpm))    &
           *exp((lv1-lv2*tx)*qa(i,j,k,nqv)/(cpm*tx))
        thv(i,j,k)=(th0(i,j,k)+tha(i,j,k))*(1.0+reps*qa(i,j,k,nqv))/(1.0+qt(i,j,k))
        b(i,j,k)=g*( thv(i,j,k)/thv0(i,j,k) - 1.0 )
      enddo
      enddo
      enddo

    ELSE

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=0,nk+1
      do j=0,nj+1
      do i=0,ni+1
        the(i,j,k)=th0(i,j,k)+tha(i,j,k)
        thv(i,j,k)=th0(i,j,k)+tha(i,j,k)
        b(i,j,k)=g*( thv(i,j,k)/thv0(i,j,k) - 1.0 )
      enddo
      enddo
      enddo

    ENDIF

    tem=rdz*cp*0.5
!$omp parallel do default(shared)  &
!$omp private(i,j,k,tem)
    do k=2,nk
      do j=0,nj+1
      do i=0,ni+1
        dpdz(i,j,k)=-( tem*(ppi(i,j,k)-ppi(i,j,k-1))*mf(i,j,k)       &
                          *(thv(i,j,k)+thv(i,j,k-1)) )
      enddo
      enddo
    enddo

!$omp parallel do default(shared)  &
!$omp private(i,j)
    do j=0,nj+1
    do i=0,ni+1
      dpdz(i,j,1   )=0.0
      dpdz(i,j,nk+1)=0.0
    enddo
    enddo

    if(timestats.ge.1) time_parcels=time_parcels+mytime()
#ifdef MPI
    call comm_1s_end(nm,sw1,sw2,se1,se2,   &
                        ss1,ss2,sn1,sn2,reqs_s)
      ihave = 0
#endif

!----------------------------------------------------------------------
!  get corner info for MPI runs
!  (may not parallelize correctly if this is not done)

#ifdef MPI
      call getcorneru(ua)
      call bcu2(ua)
      call getcornerv(va)
      call bcv2(va)
      call getcornerw(wa)
      call bcw2(wa)
#endif

      do j=0,nj+1
      do i=0,ni+2
        ua(i,j,0)    = ua(i,j,1)
        ua(i,j,nk+1) = ua(i,j,nk)
      enddo
      enddo

      do j=0,nj+2
      do i=0,ni+1
        va(i,j,0)    = va(i,j,1)
        va(i,j,nk+1) = va(i,j,nk)
      enddo
      enddo

      do j=0,nj+1
      do i=0,ni+1
        wa(i,j,0)    = -wa(i,j,2)
        wa(i,j,nk+2) = -wa(i,j,nk)
      enddo
      enddo

      if(timestats.ge.1) time_parcels=time_parcels+mytime()
      call prepcorners(nm)
      call prepcorners(dpdz)
      if(imoist.eq.1)then
        if(nqv.ne.0) call prepcorners(qa(ib,jb,kb,nqv))
        if(nqc.ne.0) call prepcorners(qa(ib,jb,kb,nqc))
        if(nqr.ne.0) call prepcorners(qa(ib,jb,kb,nqr))
      endif
      call prepcorners(the)
      call prepcorners(b)

!----------------------------------------------------------------------
!
!  Currently, pdata( 1) = x
!                  ( 2) = y
!                  ( 3) = z
!                  ( 4) = qv
!                  ( 5) = qc  ( = qa(2) for kessler and goddard)
!                  ( 6) = qr  ( = qa(3) for kessler and goddard)
!                       (may have to be changed for other microphysics schemes)
!                  ( 7) = n-squared
!                  ( 8) = u
!                  ( 9) = v
!                  (10) = w
!                  (11) = kh
!                  (12) = theta-e
!                  (13) = b
!                  (14) = dpdz
!
!    npvals should be 17 (14 + 3) in param.F
!
!----------------------------------------------------------------------

    DO np=1,nparcels

      pdata(1,np)=pdata(ifx,np)
      pdata(2,np)=pdata(ify,np)
      pdata(3,np)=pdata(ifz,np)

      iflag=0
      jflag=0

      do i=1,ni
        if( abs(xh(i)-pdata(1,np)).le.0.5*dx*ruh(i) ) iflag=i
      enddo

    IF(axisymm.eq.1)THEN
      jflag = 1
    ELSE
      do j=1,nj
        if( abs(yh(j)-pdata(2,np)).le.0.5*dy*rvh(j) ) jflag=j
      enddo
    ENDIF

      IF( (iflag.ge.1.and.iflag.le.ni) .and.   &
          (jflag.ge.1.and.jflag.le.nj) )THEN

        i=iflag
        j=jflag

        do k=1,nk
          if( abs(zh(i,j,k)-pdata(3,np)).le.0.5*dz*rmh(i,j,k) ) kflag=k
        enddo

!----------------------------------------------------------------------
!  Data on u points

        i=iflag
        j=jflag
        k=kflag

        if( pdata(2,np).lt.yh(j) )then
          j=j-1
        endif
        if( pdata(3,np).lt.zh(i,j,k) )then
          k=k-1
        endif

        rx = ( pdata(1,np)-xh(i)+0.5*dx*ruh(i) )*rdx*uh(i)
        ry = ( pdata(2,np)-yh(j) )*rdy*vh(j)
        rz = ( pdata(3,np)-zh(iflag,jflag,k) )*rdz*mh(i,j,k)

        w1=(1.0-rx)*(1.0-ry)*(1.0-rz)
        w2=rx*(1.0-ry)*(1.0-rz)
        w3=(1.0-rx)*ry*(1.0-rz)
        w4=(1.0-rx)*(1.0-ry)*rz
        w5=rx*(1.0-ry)*rz
        w6=(1.0-rx)*ry*rz
        w7=rx*ry*(1.0-rz)
        w8=rx*ry*rz

        call tri_interp(ni+1,nj,nk,i,j,k,w1,w2,w3,w4,w5,w6,w7,w8,ua,uval)

!----------------------------------------------------------------------
!  Data on v points

        i=iflag
        j=jflag
        k=kflag

        if( pdata(1,np).lt.xh(i) )then
          i=i-1
        endif
        if( pdata(3,np).lt.zh(i,j,k) )then
          k=k-1
        endif

        rx = ( pdata(1,np)-xh(i) )*rdx*uh(i)
        ry = ( pdata(2,np)-yh(j)+0.5*dy*rvh(j) )*rdy*vh(j)
        rz = ( pdata(3,np)-zh(iflag,jflag,k) )*rdz*mh(i,j,k)

        w1=(1.0-rx)*(1.0-ry)*(1.0-rz)
        w2=rx*(1.0-ry)*(1.0-rz)
        w3=(1.0-rx)*ry*(1.0-rz)
        w4=(1.0-rx)*(1.0-ry)*rz
        w5=rx*(1.0-ry)*rz
        w6=(1.0-rx)*ry*rz
        w7=rx*ry*(1.0-rz)
        w8=rx*ry*rz

        call tri_interp(ni,nj+1,nk,i,j,k,w1,w2,w3,w4,w5,w6,w7,w8,va,vval)

!----------------------------------------------------------------------
!  Data on w points


        i=iflag
        j=jflag
        k=kflag

        if( pdata(1,np).lt.xh(i) )then
          i=i-1
        endif
        if( pdata(2,np).lt.yh(j) )then
          j=j-1
        endif

        rx = ( pdata(1,np)-xh(i) )*rdx*uh(i)
        ry = ( pdata(2,np)-yh(j) )*rdy*vh(j)
        rz = ( pdata(3,np)-(zh(iflag,jflag,k)-0.5*dz*rmh(i,j,k)) )*rdz*mh(i,j,k)

        w1=(1.0-rx)*(1.0-ry)*(1.0-rz)
        w2=rx*(1.0-ry)*(1.0-rz)
        w3=(1.0-rx)*ry*(1.0-rz)
        w4=(1.0-rx)*(1.0-ry)*rz
        w5=rx*(1.0-ry)*rz
        w6=(1.0-rx)*ry*rz
        w7=rx*ry*(1.0-rz)
        w8=rx*ry*rz

        call tri_interp(ni,nj,nk+1,i,j,k,w1,w2,w3,w4,w5,w6,w7,w8,wa  ,wval)
        call tri_interp(ni,nj,nk  ,i,j,k,w1,w2,w3,w4,w5,w6,w7,w8,nm  ,pdata( 7,np))
        call tri_interp(ni,nj,nk  ,i,j,k,w1,w2,w3,w4,w5,w6,w7,w8,dpdz,pdata(14,np))

!----------------------------------------------------------------------
!  Data on scalar points

        i=iflag
        j=jflag
        k=kflag

        if( pdata(1,np).lt.xh(i) )then
          i=i-1
        endif
        if( pdata(2,np).lt.yh(j) )then
          j=j-1
        endif
        if( pdata(3,np).lt.zh(i,j,k) )then
          k=k-1
        endif

        rx = ( pdata(1,np)-xh(i) )*rdx*uh(i)
        ry = ( pdata(2,np)-yh(j) )*rdy*vh(j)
        rz = ( pdata(3,np)-zh(iflag,jflag,k) )*rdz*mh(i,j,k)

        w1=(1.0-rx)*(1.0-ry)*(1.0-rz)
        w2=rx*(1.0-ry)*(1.0-rz)
        w3=(1.0-rx)*ry*(1.0-rz)
        w4=(1.0-rx)*(1.0-ry)*rz
        w5=rx*(1.0-ry)*rz
        w6=(1.0-rx)*ry*rz
        w7=rx*ry*(1.0-rz)
        w8=rx*ry*rz

      if(imoist.eq.1)then
        call tri_interp(ni,nj,nk,i,j,k,w1,w2,w3,w4,w5,w6,w7,w8,qa(ib,jb,kb,nqv),pdata( 4,np))
        call tri_interp(ni,nj,nk,i,j,k,w1,w2,w3,w4,w5,w6,w7,w8,qa(ib,jb,kb,nqc),pdata( 5,np))
        if(ptype.ne.6)then
          call tri_interp(ni,nj,nk,i,j,k,w1,w2,w3,w4,w5,w6,w7,w8,qa(ib,jb,kb,nqr),pdata( 6,np))
        endif
      endif
        call tri_interp(ni,nj,nk,i,j,k,w1,w2,w3,w4,w5,w6,w7,w8,the,pdata(12,np))
        call tri_interp(ni,nj,nk,i,j,k,w1,w2,w3,w4,w5,w6,w7,w8,b  ,pdata(13,np))

!----------------------------------------------------------------------

        pdata( 8,np)=uval
        pdata( 9,np)=vval
        pdata(10,np)=wval

        pdata(ifx,np)=pdata(1,np)+dt*uval
      IF(axisymm.eq.1)THEN
        pdata(ify,np)=0.0
      ELSE
        pdata(ify,np)=pdata(2,np)+dt*vval
      ENDIF
        pdata(ifz,np)=pdata(3,np)+dt*wval

        if(pdata(ifx,np).lt. 0.0)then
          if(wbc.eq.1)then
            pdata(ifx,np)=pdata(ifx,np)+(maxx-minx)
          else
            pdata(ifx,np)=minx
          endif
        endif
        if(pdata(ifx,np).ge.maxx)then
           if(ebc.eq.1)then
             pdata(ifx,np)=pdata(ifx,np)-(maxx-minx)
           else
             pdata(ifx,np)=maxx
           endif
        endif

        if((pdata(ify,np).ge.maxy).and.(axisymm.ne.1))then
          if(nbc.eq.1)then
            pdata(ify,np)=pdata(ify,np)-(maxy-miny)
          else
            pdata(ify,np)=maxy
          endif
        endif
        if((pdata(ify,np).lt. 0.0).and.(axisymm.ne.1))then
          if(sbc.eq.1)then
            pdata(ify,np)=pdata(ify,np)+(maxy-miny)
          else
            pdata(ify,np)=miny
          endif
        endif

        pdata(ifz,np)=max(pdata(ifz,np),0.0)
        pdata(ifz,np)=min(pdata(ifz,np),maxz)

#ifdef MPI
        ihave = ihave + 1
        do n=1,npvals
          packet(n,ihave) = pdata(n,np)
        enddo
        packet(npvals+1,ihave) = np
#endif

      ENDIF

    ENDDO

!----------------------------------------------------------------------
!  communicate data

#ifdef MPI
      IF(myid.eq.0)THEN

        do i=1,ihave
          np=nint(packet(npvals+1,i))
          do n=1,npvals
            pdata(n,np)=packet(n,i)
          enddo
        enddo

        DO proc=1,(numprocs-1)
          call MPI_RECV(ihave,1,MPI_INTEGER,proc,proc,MPI_COMM_WORLD,status,ierr)
          if(ihave.gt.0) call MPI_RECV(packet,(npvals+1)*ihave,MPI_REAL,proc,1000+proc,MPI_COMM_WORLD,status,ierr)
          do i=1,ihave
            np=nint(packet(npvals+1,i))
            do n=1,npvals
              pdata(n,np)=packet(n,i)
            enddo
          enddo
        ENDDO

      ELSE

        call MPI_SEND(ihave,1,MPI_INTEGER,0,myid,MPI_COMM_WORLD,ierr)
        if(ihave.gt.0) call MPI_SEND(packet,(npvals+1)*ihave,MPI_REAL,0,1000+myid,MPI_COMM_WORLD,ierr)

      ENDIF

      IF(myid.eq.0)THEN
        DO np=1,nparcels
          ploc(1,np)=pdata(ifx,np)
          ploc(2,np)=pdata(ify,np)
          ploc(3,np)=pdata(ifz,np)
        ENDDO
      ENDIF

      call MPI_BARRIER (MPI_COMM_WORLD,ierr)
      call MPI_BCAST(ploc,3*nparcels,MPI_REAL,0,MPI_COMM_WORLD,ierr)

      IF(myid.ne.0)THEN
        DO np=1,nparcels
          pdata(ifx,np)=ploc(1,np)
          pdata(ify,np)=ploc(2,np)
          pdata(ifz,np)=ploc(3,np)
        ENDDO
      ENDIF
#endif

!----------------------------------------------------------------------
!  write out data

    IF( rtime.ge.prcltim .or. prclfrq.lt.0.0 )THEN

      IF(myid.eq.0)THEN

      IF(output_format.eq.1)THEN
        ! GrADS format:

        string(totlen+1:totlen+1+12) = '_pdata.dat  '
        if(myid.eq.0)then
              write(outfile,*)
              write(outfile,*) string
              write(outfile,*)
        endif
        open(unit=61,file=string,form='unformatted',access='direct',   &
             recl=4,status='unknown')

          do n=1,npvals-3
          do np=1,nparcels
            write(61,rec=prec) pdata(n,np)
            prec=prec+1
          enddo
          enddo

        close(unit=61)

#ifdef NETCDF
      ELSEIF(output_format.eq.2)THEN

        call writepdata_nc(prec,rtime,pdata)

#endif
#ifdef HDFOUT
      ELSEIF(output_format.ge.3)THEN

        call writepdata_hdf5(prec,rtime,pdata)

#endif
      ENDIF

      ENDIF

      prcltim = prcltim + prclfrq

    ENDIF

!----------------------------------------------------------------------

      if(timestats.ge.1) time_parcels=time_parcels+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine tri_interp(iz,jz,kz,i,j,k,w1,w2,w3,w4,w5,w6,w7,w8,s,pdata)
      implicit none

      include 'input.incl'

      integer :: iz,jz,kz,i,j,k
      real :: w1,w2,w3,w4,w5,w6,w7,w8
      real, dimension(1-ngxy:iz+ngxy,1-ngxy:jz+ngxy,1-ngz:kz+ngz) :: s
      real :: pdata

      pdata=s(i  ,j  ,k  )*w1    &
           +s(i+1,j  ,k  )*w2    &
           +s(i  ,j+1,k  )*w3    &
           +s(i  ,j  ,k+1)*w4    &
           +s(i+1,j  ,k+1)*w5    &
           +s(i  ,j+1,k+1)*w6    &
           +s(i+1,j+1,k  )*w7    &
           +s(i+1,j+1,k+1)*w8

      return
      end



poiss.F/        1298670057  19071 8000  100644  4838      `


      subroutine poiss(uh,vh,mh,rmh,mf,rmf,pi0,thv0,rho0,rf0,   &
                       def,divx,ppi,uten,vten,wten,             &
                       cfb,cfa,cfc,d1,d2,pdt,deft,rhs,trans,dttmp)

      use singleton
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real, dimension(ib:ie) :: uh
      real, dimension(jb:je) :: vh
      real, dimension(ib:ie,jb:je,kb:ke) :: mh,rmh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf,rmf
      real, dimension(ib:ie,jb:je,kb:ke) :: pi0,thv0,rho0,rf0
      real, dimension(ib:ie,jb:je,kb:ke) :: def,divx,ppi
      real, dimension(ib:ie+1,jb:je,kb:ke) :: uten
      real, dimension(ib:ie,jb:je+1,kb:ke) :: vten
      real, dimension(ib:ie,jb:je,kb:ke+1) :: wten
      real, dimension(ipb:ipe,jpb:jpe,kpb:kpe) :: cfb
      real, dimension(kpb:kpe) :: cfa,cfc,d1,d2
      complex, dimension(ipb:ipe,jpb:jpe,kpb:kpe) :: pdt,deft
      complex, dimension(ipb:ipe,jpb:jpe) :: rhs,trans
      real dttmp

      integer i,j,k
      real :: tem
      real, dimension(0:nk+1) :: r1
      complex, dimension(nk) :: lgbth,lgbph

!!!
!!!  Get the forcing from the exact numerical representation
!!!  of the right-hand side of the momentum equation
!!!
!!!  The divx term reduces accumulation of numerical errors over time
!!!

      IF(axisymm.eq.1)THEN
        if(myid.eq.0)then
          print *
          print *,'  The anelastic/incompressible solver cannot be '
          print *,'  used with the axisymmetric model(yet)'
          print *
          print *,'  Stopping model ...'
          print *
        endif
        call stopcm1
      ENDIF

      tem = 1.0/dttmp

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        def(i,j,k)=rho0(1,1,k)*(                                  &
                   (uten(i+1,j,k)-uten(i,j,k))*rdx*uh(i)          &
                  +(vten(i,j+1,k)-vten(i,j,k))*rdy*vh(j) )        &
                  +( rf0(i,j,k+1)*wten(i,j,k+1)                   &
                    -rf0(i,j,k  )*wten(i,j,k  ) )*rdz*mh(i,j,k)   &
                  +divx(i,j,k)*tem
      enddo
      enddo
      enddo

!-----------------------------------------------------------------------
!!!
!!! fourier transform the total forcing
!!!

      DO k=1,nk

!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          rhs(i,j)=cmplx(def(i,j,k)*d1(k),0.0)
        enddo
        enddo

        if(imirror.eq.1)then

!$omp parallel do default(shared)  &
!$omp private(i,j)
          do j=1,nj
          do i=1,ni
            rhs(ipe+1-i,j)=rhs(i,j)
          enddo
          enddo

        endif

        if(jmirror.eq.1)then

!$omp parallel do default(shared)  &
!$omp private(i,j)
          do j=1,nj
          do i=1,ni
            rhs(i,jpe+1-j)=rhs(i,j)
          enddo
          enddo

        endif

        trans=fft(rhs)

!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=jpb,jpe
        do i=ipb,ipe
          deft(i,j,k)=trans(i,j)
        enddo
        enddo

      ENDDO

!-----------------------------------------------------------------------

!!!
!!! solve the tri-diagonal matrix
!!!

!$omp parallel do default(shared)  &
!$omp private(i,j,k,r1,lgbth,lgbph)
      DO j=jpb,jpe
      DO i=ipb,ipe

        if(i.eq.1.and.j.eq.1)then
          r1(nk+1)=0.0
          r1(nk)=0.0
          do k=nk,2,-1
            r1(k-1)=(deft(i,j,k)-cfc(k)*r1(k+1)-cfb(i,j,k)*r1(k))/cfa(k)
          enddo
          do k=1,nk
            pdt(i,j,k)=cmplx( r1(k) , 0.0 )
          enddo
        else
          lgbth(1)=-cfc(1)/cfb(i,j,1)
          lgbph(1)= deft(i,j,1)/cfb(i,j,1)
          do k=2,nk
            lgbth(k)=-cfc(k)/(cfa(k)*lgbth(k-1)+cfb(i,j,k))
            lgbph(k)=(deft(i,j,k)-cfa(k)*lgbph(k-1))/(cfa(k)*lgbth(k-1)+cfb(i,j,k))
          enddo
          pdt(i,j,nk)=lgbph(nk)
          do k=nk-1,1,-1
            pdt(i,j,k)=lgbth(k)*pdt(i,j,k+1)+lgbph(k)
          enddo
        endif

      ENDDO
      ENDDO

!---------------------------------------------

!!!
!!! reverse fourier transform and we're done, not so bad after all!
!!!

      DO k=1,nk

!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=jpb,jpe
        do i=ipb,ipe
          rhs(i,j)=pdt(i,j,k)
        enddo
        enddo

        trans=fft(rhs,inv=.true.)

!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          ppi(i,j,k)=real(trans(i,j))*d2(k)
        enddo
        enddo

      ENDDO

      if(timestats.ge.1) time_poiss=time_poiss+mytime()

!-----------------------------------------------------------------------

      call bcp(ppi)

!-----------------------------------------------------------------------
!  All done.

      return
      end


sfcphys.F/      1298670057  19071 8000  100644  16715     `
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine getcecd(cdu,cdv,ce,u0,v0,rf0,u1,v1,w1,u,v)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(inout), dimension(ib:ie,jb:je) :: cdu,cdv,ce
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: rf0
      real, intent(inout), dimension(ib:ie,jb:je) :: u1,v1,w1
      real, intent(in), dimension(ib:ie+1,jb:je,kb:ke) :: u0,u
      real, intent(in), dimension(ib:ie,jb:je+1,kb:ke) :: v0,v

      integer i,j
      real usfc,vsfc,wsp

      real, parameter :: dcd1  =  0.5e-3
      real, parameter :: dcd2  =  2.4e-3
      real, parameter :: dwsp1 =  5.0
      real, parameter :: dwsp2 = 35.0

!-----------------------------------------------------------------------
! for pertflx=1, the base-state is not included in calculation of wind speed

      IF(pertflx.eq.1)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=0,nj+1
        do i=0,ni+1
          u1(i,j) = u(i,j,1)-u0(i,j,1)
          v1(i,j) = v(i,j,1)-v0(i,j,1)
        enddo
        enddo

      ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=0,nj+1
        do i=0,ni+1
          u1(i,j) = u(i,j,1)
          v1(i,j) = v(i,j,1)
        enddo
        enddo

      ENDIF

!$omp parallel do default(shared)   &
!$omp private(i,j,usfc,vsfc)
      do j=1,nj
      do i=1,ni
        usfc=0.5*( u1(i,j)+u1(i+1,j) )
        vsfc=0.5*( v1(i,j)+v1(i,j+1) )
        w1(i,j)=sqrt(usfc**2+vsfc**2)
      enddo
      enddo

!-----------------------------------------------------------------------
!  Get Cd on u pts:

  IF(idrag.eq.1)THEN

    IF(cecd.eq.1)THEN
      ! constant value:

!$omp parallel do default(shared)   &
!$omp private(i,j)
      do j=1,nj
      do i=1,ni+1
        cdu(i,j) = cnstcd
      enddo
      enddo

    ELSEIF(cecd.eq.2)THEN
      ! Deacon's formula:  see Rotunno and Emanuel (1987, JAS, p. 547)

!$omp parallel do default(shared)   &
!$omp private(i,j,usfc,vsfc,wsp)
      do j=1,nj
      do i=1,ni+1
        usfc=u1(i,j)
        vsfc=0.25*( ( v1(i  ,j)+v1(i  ,j+1) )   &
                   +( v1(i-1,j)+v1(i-1,j+1) ) )
        wsp=sqrt(usfc**2+vsfc**2)
        cdu(i,j) = 1.1e-3+(4.0e-5*wsp)
      enddo
      enddo

    ELSEIF(cecd.eq.3)THEN
      ! Based on Donelan (2004, GRL)

!$omp parallel do default(shared)   &
!$omp private(i,j,usfc,vsfc,wsp)
      do j=1,nj
      do i=1,ni+1
        usfc=u1(i,j)
        vsfc=0.25*( ( v1(i  ,j)+v1(i  ,j+1) )   &
                   +( v1(i-1,j)+v1(i-1,j+1) ) )
        wsp=sqrt(usfc**2+vsfc**2)
        cdu(i,j) = dcd1+( wsp - dwsp1 )*( dcd2 - dcd1 )/( dwsp2 - dwsp1 )
        cdu(i,j) = min(cdu(i,j),dcd2)
        cdu(i,j) = max(cdu(i,j),dcd1)
      enddo
      enddo

    ELSE

      if(myid.eq.0)then
            write(outfile,*)
            write(outfile,*) '  Undefined value for cecd '
            write(outfile,*)
      endif
      call stopcm1

    ENDIF

!-----------------------------------------------------------------------
!  Get Cd on v pts:

    IF(cecd.eq.1)THEN
      ! constant value:

!$omp parallel do default(shared)   &
!$omp private(i,j)
      do j=1,nj+1
      do i=1,ni
        cdv(i,j) = cnstcd
      enddo
      enddo

    ELSEIF(cecd.eq.2)THEN
      ! Deacon's formula:  see Rotunno and Emanuel (1987, JAS, p. 547)

!$omp parallel do default(shared)   &
!$omp private(i,j,usfc,vsfc,wsp)
      do j=1,nj+1
      do i=1,ni
        usfc=0.25*( ( u1(i,j  )+u1(i+1,j  ) )   &
                   +( u1(i,j-1)+u1(i+1,j-1) ) )
        vsfc=v1(i,j)
        wsp=sqrt(usfc**2+vsfc**2)
        cdv(i,j) = 1.1e-3+(4.0e-5*wsp)
      enddo
      enddo

    ELSEIF(cecd.eq.3)THEN
      ! Based on Donelan (2004, GRL)

!$omp parallel do default(shared)   &
!$omp private(i,j,usfc,vsfc,wsp)
      do j=1,nj+1
      do i=1,ni
        usfc=0.25*( ( u1(i,j  )+u1(i+1,j  ) )   &
                   +( u1(i,j-1)+u1(i+1,j-1) ) )
        vsfc=v1(i,j)
        wsp=sqrt(usfc**2+vsfc**2)
        cdv(i,j) = dcd1+( wsp - dwsp1 )*( dcd2 - dcd1 )/( dwsp2 - dwsp1 )
        cdv(i,j) = min(cdv(i,j),dcd2)
        cdv(i,j) = max(cdv(i,j),dcd1)
      enddo
      enddo

    ELSE

          if(myid.eq.0)then
            write(outfile,*)
            write(outfile,*) '  Undefined value for cecd '
            write(outfile,*)
          endif
      call stopcm1

    ENDIF

  ENDIF   ! endif for idrag=1 check

!-----------------------------------------------------------------------
!  Get Ce:

  IF(isfcflx.eq.1)THEN

    IF(cecd.eq.1)THEN
      ! constant value:

!$omp parallel do default(shared)   &
!$omp private(i,j)
      do j=1,nj
      do i=1,ni
        ce(i,j) = cnstce
      enddo
      enddo

    ELSEIF(cecd.eq.2)THEN
      ! Deacon's formula:  see Rotunno and Emanuel (1987, JAS, p. 547)

!$omp parallel do default(shared)   &
!$omp private(i,j)
      do j=1,nj
      do i=1,ni
        ce(i,j) = 1.1e-3+(4.0e-5*w1(i,j))
      enddo
      enddo

    ELSEIF(cecd.eq.3)THEN
      ! Constant, based on Drennan et al. (2007, JAS, p. 1103)

!$omp parallel do default(shared)   &
!$omp private(i,j)
      do j=1,nj
      do i=1,ni
        ce(i,j) = 1.18e-3
      enddo
      enddo

    ELSE

          if(myid.eq.0)then
            write(outfile,*)
            write(outfile,*) '  Undefined value for cecd '
            write(outfile,*)
          endif
      call stopcm1

    ENDIF

  ENDIF

!-----------------------------------------------------------------------

      if(timestats.ge.1) time_sfcphys=time_sfcphys+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine sfcdrag(cdu,cdv,u0,v0,rf0,u1,v1,t13,t23,u,v)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(in), dimension(ib:ie,jb:je) :: cdu,cdv
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: rf0
      real, intent(in), dimension(ib:ie,jb:je) :: u1,v1
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: t13,t23
      real, intent(in), dimension(ib:ie+1,jb:je,kb:ke) :: u0,u
      real, intent(in), dimension(ib:ie,jb:je+1,kb:ke) :: v0,v

      integer i,j
      real usfc,vsfc,wspd

!-----------------------------------------------------------------------
!  x component:

!$omp parallel do default(shared)   &
!$omp private(i,j,usfc,vsfc,wspd)
      do j=1,nj
      do i=1,ni+1
        usfc=u1(i,j)
        vsfc=0.25*( ( v1(i  ,j)+v1(i  ,j+1) )   &
                   +( v1(i-1,j)+v1(i-1,j+1) ) )
        wspd=sqrt(usfc**2+vsfc**2)
        t13(i,j,1) = cdu(i,j)*usfc*wspd
      enddo
      enddo

!-----------------------------------------------------------------------
!  y component:

!$omp parallel do default(shared)   &
!$omp private(i,j,usfc,vsfc,wspd)
      do j=1,nj+1
      do i=1,ni
        usfc=0.25*( ( u1(i,j  )+u1(i+1,j  ) )   &
                   +( u1(i,j-1)+u1(i+1,j-1) ) )
        vsfc=v1(i,j)
        wspd=sqrt(usfc**2+vsfc**2)
        t23(i,j,1) = cdv(i,j)*vsfc*wspd
      enddo
      enddo

!-----------------------------------------------------------------------

      if(timestats.ge.1) time_sfcphys=time_sfcphys+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine sfcflux(dt,ruh,xf,rvh,pi0s,ce,zh,pi0,thv0,th0,u0,v0,tsk,thflux,qvflux,mavail,   &
                         rho,u1,v1,w1,u,v,ppi,tha,qva,qsfc)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(in) :: dt
      real, intent(in), dimension(ib:ie) :: ruh
      real, intent(in), dimension(ib:ie+1) :: xf
      real, intent(in), dimension(jb:je) :: rvh
      real, intent(in), dimension(ib:ie,jb:je) :: pi0s,ce
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: zh,pi0,thv0,th0
      real, intent(in), dimension(ib:ie,jb:je) :: tsk
      real, intent(inout), dimension(ib:ie,jb:je) :: thflux,qvflux
      real, intent(in), dimension(ibl:iel,jbl:jel) :: mavail
      real, intent(in), dimension(ib:ie,jb:je) :: u1,v1,w1
      real, intent(in), dimension(ib:ie+1,jb:je,kb:ke) :: u0,u
      real, intent(in), dimension(ib:ie,jb:je+1,kb:ke) :: v0,v
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: rho,ppi,tha
      real, intent(in), dimension(ibm:iem,jbm:jem,kbm:kem) :: qva
      real*8, intent(inout) :: qsfc

      integer i,j
      real pisfc,usfc,vsfc,qvsat

      real :: rhosfc,tem
      real rslf
      real*8, dimension(nj) :: bud1

!-----------------------------------------------------------------------
!  sensible heat flux:

!$omp parallel do default(shared)   &
!$omp private(i,j,pisfc)
      do j=1,nj
      do i=1,ni
        pisfc = pi0s(i,j) + ppi(i,j,1)
        thflux(i,j)=ce(i,j)*w1(i,j)*(tsk(i,j)/pisfc-th0(i,j,1)-tha(i,j,1))
      enddo
      enddo

!-----------------------------------------------------------------------
!  latent heat flux:

    IF(imoist.eq.1)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,pisfc,qvsat)
      do j=1,nj
      do i=1,ni
        pisfc = pi0s(i,j) + ppi(i,j,1)
        qvsat=rslf(p00*(pisfc**cpdrd),tsk(i,j))
        qvflux(i,j)=ce(i,j)*w1(i,j)*(qvsat-qva(i,j,1))*mavail(i,j)
      enddo
      enddo

!-----------------------------------------------------------------------
!  some budget calculations (only calculated if imoist=1):

!$omp parallel do default(shared)  &
!$omp private(j)
      do j=1,nj
        bud1(j)=0.0d0
      enddo

!$omp parallel do default(shared)  &
!$omp private(i,j,rhosfc)
      do j=1,nj
      do i=1,ni
        rhosfc=rho(i,j,1)-zh(i,j,1)*(rho(i,j,2)-rho(i,j,1))   &
                                   /( zh(i,j,2)- zh(i,j,1))
        if(axisymm.eq.1) rhosfc=rhosfc*pi*(xf(i+1)**2-xf(i)**2)/(dx*dy)
        bud1(j)=bud1(j)+qvflux(i,j)*ruh(i)*rvh(j)*rhosfc
      enddo
      enddo

      tem = dt*dx*dy

      do j=1,nj
        qsfc=qsfc+bud1(j)*tem
      enddo

    ENDIF

!-----------------------------------------------------------------------

      if(timestats.ge.1) time_sfcphys=time_sfcphys+mytime()

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine sfcdiags(tsk,thflux,qvflux,cdu,cdv,ce,u1,v1,w1,   &
                          xland,psfc,qsfc,u10,v10,hfx,qfx,cda,znt,ust,gz1oz0,   &
                          psim,psih,br,zol,mol,hpbl,wspd,dsxy,th2,t2,q2, &
                          zs,zh,pi0s,pi0,th0,ppi,tha,rho,qa,ua,va)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(in), dimension(ib:ie,jb:je) :: tsk,thflux,qvflux,   &
                                                  cdu,cdv,ce,u1,v1,w1
      real, intent(in), dimension(ibl:iel,jbl:jel) :: xland
      real, intent(inout), dimension(ibl:iel,jbl:jel) :: psfc,qsfc,u10,v10,hfx,qfx, &
                                    cda,znt,ust,gz1oz0,psim,psih,br,zol,mol,hpbl,wspd,dsxy,th2,t2,q2
      real, intent(in), dimension(itb:ite,jtb:jte) :: zs
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: zh
      real, intent(in), dimension(ib:ie,jb:je) :: pi0s
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: pi0,th0,ppi,tha,rho
      real, intent(in), dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: qa
      real, intent(in), dimension(ib:ie+1,jb:je,kb:ke) :: ua
      real, intent(in), dimension(ib:ie,jb:je+1,kb:ke) :: va

      integer :: i,j
      real :: pisfc,thgb,thx,thvx,tskv,za,govrth,dthvdz,vconv,vsgd,dthvm,   &
              rhosfc,val,fluxc
      real :: rslf

      REAL    , PARAMETER ::  VCONVC=1.
      REAL    , PARAMETER ::  CZO=0.0185
      REAL    , PARAMETER ::  OZO=1.59E-5
      REAL    , PARAMETER ::  KARMAN = 0.4
      REAL    , PARAMETER ::  EP1 = rv/rd - 1.0
      REAL,     PARAMETER ::  PRT=1.

      ! surface layer diagnostics:

!$omp parallel do default(shared)   &
!$omp private(i,j,pisfc,thgb,thx,thvx,tskv,za,govrth,dthvdz,vconv,vsgd,   &
!$omp dthvm,rhosfc,val,fluxc)
      do j=1,nj
      do i=1,ni
        pisfc = pi0s(i,j) + ppi(i,j,1)
        psfc(i,j) = p00*(pisfc**cpdrd)
        thgb = tsk(i,j)/pisfc
        thx = th0(i,j,1)+tha(i,j,1)
        thvx = thx*(1.+EP1*qa(i,j,1,nqv))
        qsfc(i,j) = rslf(psfc(i,j),tsk(i,j))
        tskv = thgb*(1.0+ep1*qsfc(i,j))
        za = zh(i,j,1)
        if( terrain_flag ) za = za - zs(i,j)
        govrth = g/thx
        ! use old znt (as in sfclay):
        gz1oz0(i,j) = alog(za/znt(i,j))
        DTHVDZ = THVX-TSKV
        if (xland(i,j).lt.1.5) then
          ! land:
          fluxc = max(thflux(i,j) + ep1*tskv*qvflux(i,j),0.)
          VCONV = vconvc*(g/tsk(i,j)*hpbl(i,j)*fluxc)**.33
        else
          ! ocean:
          IF(-DTHVDZ.GE.0)THEN
            DTHVM=-DTHVDZ
          ELSE
            DTHVM=0.
          ENDIF
          VCONV = 2.*SQRT(DTHVM)
        endif
! Mahrt and Sun low-res correction
        VSGD = 0.32 * (max(dsxy(i,j)/5000.-1.,0.))**.33
        wspd(i,j) = sqrt( w1(i,j)*w1(i,j) + vconv*vconv + vsgd*vsgd )
        wspd(i,j) = max(0.1,wspd(i,j))
        br(i,j) = govrth*za*DTHVDZ/(wspd(i,j)**2)
        rhosfc=rho(i,j,1)-zh(i,j,1)*(rho(i,j,2)-rho(i,j,1))   &
                                   /( zh(i,j,2)- zh(i,j,1))
        hfx(i,j) = thflux(i,j)*cp*rhosfc
        qfx(i,j) = qvflux(i,j)*rhosfc
        cda(i,j) = 0.25*( (cdu(i,j)+cdu(i+1,j))+(cdv(i,j)+cdv(i,j+1)) )
        ! new ust/znt:
        ! TO PREVENT OSCILLATIONS AVERAGE WITH OLD VALUE
        ust(i,j) = 0.5*( ust(i,j) + sqrt(cda(i,j)*wspd(i,j)*wspd(i,j)) )
        if( (xland(i,j)-1.5).ge.0.0 )then
          znt(i,j) = CZO*ust(i,j)*ust(i,j)/G+OZO
        endif
        ! impose neutral sfc layer:
        psim(i,j) = 0.0
        psih(i,j) = 0.0
        zol(i,j) = 0.0
        mol(i,j) = 0.0
        val = alog(10.0/znt(i,j))/alog(za/znt(i,j))
        u10(i,j) = 0.5*(ua(i,j,1)+ua(i+1,j,1))*val
        v10(i,j) = 0.5*(va(i,j,1)+va(i,j+1,1))*val
        val = alog(2.0/znt(i,j))/alog(za/znt(i,j))
        th2(i,j) = thgb+(thx-thgb)*val
        q2(i,j) = qsfc(i,j)+(qa(i,j,1,nqv)-qsfc(i,j))*val
        t2(i,j) = th2(i,j)*pisfc
      enddo
      enddo

      if(timestats.ge.1) time_sfcphys=time_sfcphys+mytime()
      end subroutine sfcdiags


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine gethpbl(zh,th0,tha,qa,hpbl)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: zh,th0,tha
      real, intent(in), dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: qa
      real, intent(inout), dimension(ibl:iel,jbl:jel) :: hpbl

      integer :: i,j,kk
      real :: thx,thvx,thv,thvlast,thcrit

      REAL    , PARAMETER ::  EP1 = rv/rd - 1.0

      ! (NEEDED BY SFCLAY ... THIS IS A ROUGH ESTIMATE ONLY)
      ! (ONLY NEEDED WHEN IPBL=0)
      ! (USE WITH CAUTION)
      ! extraordinarily simple calculation:  define pbl depth as 
      ! level where thv is first greater than thv at lowest model level
      ! 110104:  add 0.5 K, for the sake of slightly stable PBLs

!$omp parallel do default(shared)   &
!$omp private(i,j,kk,thx,thvx,thv,thvlast,thcrit)
      do j=1,nj
      do i=1,ni
        hpbl(i,j) = 0.0
        kk = 1
        thx = th0(i,j,1)+tha(i,j,1)
        thvx = thx*(1.+EP1*qa(i,j,1,nqv))
        thvlast = thvx
        thcrit = thvx+0.5
        do while( hpbl(i,j).lt.1.0e-12 .and. kk.lt.nk )
          kk = kk + 1
          thv = (th0(i,j,kk)+tha(i,j,kk))*(1.0+EP1*qa(i,j,kk,nqv))
          if( thv.ge.thcrit )then
            hpbl(i,j) = zh(i,j,kk-1)+(zh(i,j,kk)-zh(i,j,kk-1))   &
                                    *(thcrit-thvlast)/(thv-thvlast)
          endif
          thvlast = thv
        enddo
        if( kk.gt.(nk-1) .or. hpbl(i,j).lt.1.0e-12 ) hpbl(i,j) = 0.0
      enddo
      enddo

      if(timestats.ge.1) time_sfcphys=time_sfcphys+mytime()
      end subroutine gethpbl



singleton.F/    1298670057  19071 8000  100644  38594     `
MODULE singleton
  !-----------------------------------------------------------------------------
  ! Multivariate Fast Fourier Transform
  !
  ! Fortran 90 (ELF90) Implementation of Singleton's mixed-radix algorithm,
  ! RC Singleton, Stanford Research Institute, Sept. 1968.
  !
  ! Adapted from fftn.c, translated from Fortran 66 to C by Mark Olesen and
  ! John Beale.
  !
  ! Fourier transforms can be computed either in place, using assumed size
  ! arguments, or by generic function, using assumed shape arguments.
  !
  !
  ! Public:
  !
  !   fftkind                              kind parameter of complex arguments
  !                                        and function results.
  !
  !   fft(array, dim, inv)                 generic transform function
  !    COMPLEX(fftkind), DIMENSION(:,...,:), INTENT(IN)           :: array
  !    INTEGER,          DIMENSION(:),       INTENT(IN),  OPTIONAL:: dim
  !    LOGICAL,                              INTENT(IN),  OPTIONAL:: inv
  !
  !   fftn(array, shape, dim, inv, stat)   in place transform subroutine
  !    COMPLEX(fftkind), DIMENSION(*), INTENT(INOUT)        :: array
  !    INTEGER,          DIMENSION(:), INTENT(IN)           :: shape
  !    INTEGER,          DIMENSION(:), INTENT(IN),  OPTIONAL:: dim
  !    LOGICAL,                        INTENT(IN),  OPTIONAL:: inv
  !    INTEGER,                        INTENT(OUT), OPTIONAL:: stat
  !
  !
  ! Formal Parameters:
  !
  !   array    The complex array to be transformed. array can be of arbitrary
  !            rank (i.e. up to seven).
  !
  !   shape    With subroutine fftn, the shape of the array to be transformed
  !            has to be passed separately, since fftradix - the internal trans-
  !            formation routine - will treat array always as one dimensional.
  !            The product of elements in shape must be the number of
  !            elements in array.
  !            Although passing array with assumed shape would have been nicer,
  !            I prefered assumed size in order to prevent the compiler from
  !            using a copy-in-copy-out mechanism. That would generally be
  !            necessary with fftn passing array to fftradix and with fftn
  !            being prepared for accepting non consecutive array sections.
  !            Using assumed size, it's up to the user to pass an array argu-
  !            ment, that can be addressed as continous one dimensional array
  !            without copying. Otherwise, transformation will not really be
  !            performed in place.
  !            On the other hand, since the rank of array and the size of
  !            shape needn't match, fftn is appropriate for handling more than
  !            seven dimensions.
  !            As far as function fft is concerned all this doesn't matter,
  !            because the argument will be copied anyway. Thus no extra
  !            shape argument is needed for fft.
  !
  ! Optional Parameters:
  !
  !   dim      One dimensional integer array, containing the dimensions to be
  !            transformed. Default is (/1,...,N/) with N being the rank of
  !            array, i.e. complete transform. dim can restrict transformation
  !            to a subset of available dimensions. Its size must not exceed the
  !            rank of array or the size of shape respectivly.
  !
  !   inv      If .true., inverse transformation will be performed. Default is
  !            .false., i.e. forward transformation.
  !
  !   stat     If present, a system dependent nonzero status value will be
  !            returned in stat, if allocation of temporary storage failed.
  !            For functions, the integer variable status is used.
  !
  ! Scaling:
  !
  !   Transformation results will always be scaled by the square root of the
  !   product of sizes of each dimension in dim. (See examples below)
  !
  !
  ! Examples:
  !
  !   Let A be a L*M*N three dimensional complex array. Then
  !
  !     result = fft(A)
  !
  !   will produce a three dimensional transform, scaled by sqrt(L*M*N), while
  !
  !     call fftn(A, SHAPE(A))
  !
  !   will do the same in place.
  !
  !     result = fft(A, dim=(/1,3/))
  !
  !   will transform with respect to the first and the third dimension, scaled
  !   by sqrt(L*N).
  !
  !     result = fft(fft(A), inv=.true.)
  !
  !   should (approximately) reproduce A.
  !   With B having the same shape as A
  !
  !     result = fft(fft(A) * CONJG(fft(B)), inv=.true.)
  !
  !   will correlate A and B.
  !
  !
  ! Remarks:
  !
  !   Following changes have been introduced with respect to fftn.c:
  !   - complex arguments and results are of type complex, rather than
  !     real an imaginary part separately.
  !   - increment parameter (magnitude of isign) has been dropped,
  !     inc is always one, direction of transform is given by inv.     
  !   - maxf and maxp have been dropped. The amount of temporary storage
  !     needed is determined by the fftradix routine. Both fftn and fft
  !     can handle any size of array. (Maybe they take a lot of time and
  !     memory, but they will do it)
  !
  !   Redesigning fftradix in a way, that it handles assumed shape arrays
  !   would have been desirable. However, I found it rather hard to do this
  !   in an efficient way. Problems were:
  !   - to prevent stride multiplications when indexing arrays. At least our
  !     compiler was not clever enough to discover that in fact additions
  !     would do the job as well. On the other hand, I haven't been clever
  !     enough to find an implementation using array operations.
  !   - fftradix is rather large and different versions would be necessaray
  !     for each possible rank of array.
  !   Consequently, in place transformation still needs the argument stored
  !   in a consecutive bunch of memory and can't be performed on array
  !   sections like A(100:199:-3, 50:1020). Calling fftn with such sections
  !   will most probably imply copy-in-copy-out. However, the function fft
  !   works with everything it gets and should be convenient to use.
  !
  !   To enable this module to be used with ELF90 it appears to be necessary
  !   to allocate a 1-D work array into which the multi-dimensional array is
  !   copied, and then to copy the results back from the 1-D array to the
  !   multi-dimensional array ft.
  !
  !   Unfortunately, ELF90 will not allow a function to return more than one
  !   output variable.   The variable `stat' has been dropped from the function
  !   arguments.   Users should examine the value of the variable `status'
  !   instead.   This is a PUBLIC variable declared in this module.
  !
  ! Michael Steffens, 09.12.96, <Michael.Steffens@mbox.muk.uni-hannover.de>
  ! ELF90-compatible version by Alan Miller, 29 April 1997 & 6 June 1997
  ! amiller @ bigpond.net.au
  ! Restructured fftradix for better optimization by M. Steffens, 4 June 1997
  !-----------------------------------------------------------------------------
  IMPLICIT NONE

  PRIVATE
  PUBLIC:: fft, fftn, fftkind, status

  INTEGER, PARAMETER:: fftkind = KIND(0.0) !--- adjust here for other precisions
  INTEGER, SAVE     :: status = 0 !--- shifted to here as ELF90 does not allow
                                  !    arguments to be INTENT(OUT)

  REAL(fftkind), PARAMETER:: sin60 = 0.86602540378443865_fftkind
  REAL(fftkind), PARAMETER:: cos72 = 0.30901699437494742_fftkind
  REAL(fftkind), PARAMETER:: sin72 = 0.95105651629515357_fftkind
  REAL(fftkind), PARAMETER:: pi    = 3.14159265358979323_fftkind

  INTERFACE fft
     MODULE PROCEDURE fft1d
     MODULE PROCEDURE fft2d
     MODULE PROCEDURE fft3d
     MODULE PROCEDURE fft4d
     MODULE PROCEDURE fft5d
     MODULE PROCEDURE fft6d
     MODULE PROCEDURE fft7d
  END INTERFACE


CONTAINS


  FUNCTION fft1d(array, dim, inv) RESULT(ft)
    !--- formal parameters
    COMPLEX(fftkind), DIMENSION(:), INTENT(IN)           :: array
    INTEGER,          DIMENSION(:), INTENT(IN),  OPTIONAL:: dim
    LOGICAL,                        INTENT(IN),  OPTIONAL:: inv
    !--- function result
    COMPLEX(fftkind), DIMENSION(SIZE(array, 1)):: ft

    ft = array
    CALL fftn(ft, SHAPE(array), dim, inv = inv, stat = status)

    RETURN
  END FUNCTION fft1d


  FUNCTION fft2d(array, dim, inv) RESULT(ft)
    !--- formal parameters
    COMPLEX(fftkind), DIMENSION(:,:), INTENT(IN)           :: array
    INTEGER,          DIMENSION(:),   INTENT(IN),  OPTIONAL:: dim
    LOGICAL,                          INTENT(IN),  OPTIONAL:: inv
    !--- function result
    COMPLEX(fftkind), DIMENSION(SIZE(array, 1), SIZE(array, 2)):: ft

    !--- Allocate 1-D array to be used by routine fftn
    COMPLEX(fftkind), DIMENSION(:), ALLOCATABLE :: work

    ALLOCATE( work(SIZE(array)) )
    work = RESHAPE(array, (/ SIZE(array) /))
    CALL fftn(work, SHAPE(array), dim, inv, stat = status)
    ft = RESHAPE(work, (/ SIZE(array, 1), SIZE(array, 2) /))
    DEALLOCATE( work )

    RETURN
  END FUNCTION fft2d


  FUNCTION fft3d(array, dim, inv) RESULT(ft)
    !--- formal parameters
    COMPLEX(fftkind), DIMENSION(:,:,:), INTENT(IN)           :: array
    INTEGER,          DIMENSION(:),     INTENT(IN),  OPTIONAL:: dim
    LOGICAL,                            INTENT(IN),  OPTIONAL:: inv
    !--- function result
    COMPLEX(fftkind), &
         DIMENSION(SIZE(array, 1), SIZE(array, 2), SIZE(array, 3)):: ft

    !--- Allocate 1-D array to be used by routine fftn
    COMPLEX(fftkind), DIMENSION(:), ALLOCATABLE :: work

    ALLOCATE( work(SIZE(array)) )
    work = RESHAPE(array, (/ SIZE(array) /))
    CALL fftn(work, SHAPE(array), dim, inv, stat = status)
    ft = RESHAPE(work, (/ SIZE(array, 1), SIZE(array, 2), SIZE(array, 3) /))
    DEALLOCATE( work )

    RETURN
  END FUNCTION fft3d


  FUNCTION fft4d(array, dim, inv) RESULT(ft)
    !--- formal parameters
    COMPLEX(fftkind), DIMENSION(:,:,:,:), INTENT(IN)           :: array
    INTEGER,          DIMENSION(:),       INTENT(IN),  OPTIONAL:: dim
    LOGICAL,                              INTENT(IN),  OPTIONAL:: inv
    !--- function result
    COMPLEX(fftkind), DIMENSION( &
         SIZE(array, 1), SIZE(array, 2), SIZE(array, 3), SIZE(array, 4)):: ft

    !--- Allocate 1-D array to be used by routine fftn
    COMPLEX(fftkind), DIMENSION(:), ALLOCATABLE :: work

    ALLOCATE( work(SIZE(array)) )
    work = RESHAPE(array, (/ SIZE(array) /))
    CALL fftn(work, SHAPE(array), dim, inv, stat = status)
    ft = RESHAPE(work, (/ SIZE(array, 1), SIZE(array, 2), SIZE(array, 3), &
                          SIZE(array, 4) /))
    DEALLOCATE( work )

    RETURN
  END FUNCTION fft4d


  FUNCTION fft5d(array, dim, inv) RESULT(ft)
    !--- formal parameters
    COMPLEX(fftkind), DIMENSION(:,:,:,:,:), INTENT(IN)           :: array
    INTEGER,          DIMENSION(:),         INTENT(IN),  OPTIONAL:: dim
    LOGICAL,                                INTENT(IN),  OPTIONAL:: inv
    !--- function result
    COMPLEX(fftkind), DIMENSION( &
         SIZE(array, 1), SIZE(array, 2), SIZE(array, 3), SIZE(array, 4), &
         SIZE(array, 5)):: ft

    !--- Allocate 1-D array to be used by routine fftn
    COMPLEX(fftkind), DIMENSION(:), ALLOCATABLE :: work

    ALLOCATE( work(SIZE(array)) )
    work = RESHAPE(array, (/ SIZE(array) /))
    CALL fftn(work, SHAPE(array), dim, inv, stat = status)
    ft = RESHAPE(work, (/ SIZE(array, 1), SIZE(array, 2), SIZE(array, 3), &
                          SIZE(array, 4), SIZE(array, 5) /))
    DEALLOCATE( work )

    RETURN
  END FUNCTION fft5d


  FUNCTION fft6d(array, dim, inv) RESULT(ft)
    !--- formal parameters
    COMPLEX(fftkind), DIMENSION(:,:,:,:,:,:), INTENT(IN)           :: array
    INTEGER,          DIMENSION(:),           INTENT(IN),  OPTIONAL:: dim
    LOGICAL,                                  INTENT(IN),  OPTIONAL:: inv
    !--- function result
    COMPLEX(fftkind), DIMENSION( &
         SIZE(array, 1), SIZE(array, 2), SIZE(array, 3), SIZE(array, 4), &
         SIZE(array, 5), SIZE(array, 6)):: ft

    !--- Allocate 1-D array to be used by routine fftn
    COMPLEX(fftkind), DIMENSION(:), ALLOCATABLE :: work

    ALLOCATE( work(SIZE(array)) )
    work = RESHAPE(array, (/ SIZE(array) /))
    CALL fftn(work, SHAPE(array), dim, inv, stat = status)
    ft = RESHAPE(work, (/ SIZE(array, 1), SIZE(array, 2), SIZE(array, 3), &
                          SIZE(array, 4), SIZE(array, 5), SIZE(array, 6) /))
    DEALLOCATE( work )

    RETURN
  END FUNCTION fft6d


  FUNCTION fft7d(array, dim, inv) RESULT(ft)
    !--- formal parameters
    COMPLEX(fftkind), DIMENSION(:,:,:,:,:,:,:), INTENT(IN)           :: array
    INTEGER,          DIMENSION(:),             INTENT(IN),  OPTIONAL:: dim
    LOGICAL,                                    INTENT(IN),  OPTIONAL:: inv
    !--- function result
    COMPLEX(fftkind), DIMENSION( &
         SIZE(array, 1), SIZE(array, 2), SIZE(array, 3), SIZE(array, 4), &
         SIZE(array, 5), SIZE(array, 6), SIZE(array, 7)):: ft

    !--- Allocate 1-D array to be used by routine fftn
    COMPLEX(fftkind), DIMENSION(:), ALLOCATABLE :: work

    ALLOCATE( work(SIZE(array)) )
    work = RESHAPE(array, (/ SIZE(array) /))
    CALL fftn(work, SHAPE(array), dim, inv, stat = status)
    ft = RESHAPE(work, (/ SIZE(array, 1), SIZE(array, 2), SIZE(array, 3), &
                          SIZE(array, 4), SIZE(array, 5), SIZE(array, 6), &
                          SIZE(array, 7) /))
    DEALLOCATE( work )

    RETURN
  END FUNCTION fft7d


  SUBROUTINE fftn(array, shape, dim, inv, stat)
    !--- formal parameters
    COMPLEX(fftkind), DIMENSION(:), INTENT(IN OUT)       :: array
    INTEGER,          DIMENSION(:), INTENT(IN)           :: shape
    INTEGER,          DIMENSION(:), INTENT(IN),  OPTIONAL:: dim
    LOGICAL,                        INTENT(IN),  OPTIONAL:: inv
    INTEGER,                        INTENT(OUT), OPTIONAL:: stat
    !--- local arrays
    INTEGER, DIMENSION(SIZE(shape)):: d
    !--- local scalars
    LOGICAL      :: inverse
    INTEGER      :: i, ndim, ntotal
    REAL(fftkind):: scale

    !--- optional parameter settings
    IF (PRESENT(inv)) THEN
       inverse = inv
    ELSE
       inverse = .FALSE.
    END IF
    IF (PRESENT(dim)) THEN
       ndim = MIN(SIZE(dim), SIZE(d))
       d(1:ndim) = dim(1:ndim)
    ELSE
       ndim = SIZE(d)
       d = (/(i, i = 1, SIZE(d))/)
    END IF

    ntotal = PRODUCT(shape)
    scale = SQRT(1.0_fftkind / PRODUCT(shape(d(1:ndim))))
    DO i = 1, ntotal
       array(i) = CMPLX(REAL(array(i)) * scale, AIMAG(array(i)) * scale, &
            KIND=fftkind)
    END DO

    DO i = 1, ndim
       CALL fftradix(array, ntotal, shape(d(i)), PRODUCT(shape(1:d(i))), &
            inverse)
    END DO

    IF (PRESENT(stat)) stat = status
    RETURN
  END SUBROUTINE fftn


  SUBROUTINE fftradix(array, ntotal, npass, nspan, inv)
    !--- formal parameters
    COMPLEX(fftkind), DIMENSION(:), INTENT(IN OUT)       :: array
    INTEGER,                        INTENT(IN)           :: ntotal, npass, nspan
    LOGICAL,                        INTENT(IN)           :: inv
    !--- local arrays
    INTEGER,          DIMENSION(BIT_SIZE(0))     :: factor
    !--- local scalars
    INTEGER         :: maxfactor, nfactor, nsquare
    !--- intrinsics used

    IF (npass <= 1) RETURN

    CALL factorize(npass, factor, nfactor, nsquare)

    maxfactor = MAXVAL(factor(:nfactor))

    CALL transform(array, ntotal, npass, nspan, factor, nfactor, inv)
    CALL permute(array, ntotal, npass, nspan, &
            factor, nfactor, nsquare, maxfactor)

    RETURN


  CONTAINS


    SUBROUTINE factorize(npass, factor, nfactor, nsquare)
      !--- formal parameters
      INTEGER,               INTENT(IN) :: npass
      INTEGER, DIMENSION(:), INTENT(OUT):: factor
      INTEGER,               INTENT(OUT):: nfactor, nsquare
      !--- local scalars
      INTEGER:: j, jj, k

      nfactor = 0
      k = npass
      DO WHILE (MOD(k, 16) == 0) 
         nfactor = nfactor + 1
         factor(nfactor) = 4
         k = k / 16
      END DO
      j = 3
      jj = 9
      DO
         DO WHILE (MOD(k, jj) == 0)
            nfactor = nfactor + 1
            factor(nfactor) = j
            k = k / jj
         END DO
         j = j + 2
         jj = j * j
         IF (jj > k) EXIT
      END DO
      IF (k <= 4) THEN
         nsquare = nfactor
         factor(nfactor + 1) = k
         IF (k /= 1) nfactor = nfactor + 1
      ELSE 
         IF (k - ISHFT(k / 4, 2) == 0) THEN
            nfactor = nfactor + 1
            factor(nfactor) = 2
            k = k / 4
         END IF
         nsquare = nfactor
         j = 2
         DO
            IF (MOD(k, j) == 0) THEN
               nfactor = nfactor + 1
               factor(nfactor) = j
               k = k / j
            END IF
            j = ISHFT((j + 1) / 2, 1) + 1
            IF (j > k) EXIT
         END DO
      END IF
      IF (nsquare > 0) THEN
         j = nsquare
         DO
            nfactor = nfactor + 1
            factor(nfactor) = factor(j)
            j = j - 1
            IF (j==0) EXIT
         END DO
      END IF

      RETURN
    END SUBROUTINE factorize


    SUBROUTINE transform(array, ntotal, npass, nspan, &
         factor, nfactor, inv) !-- compute fourier transform
      !--- formal parameters
      COMPLEX(fftkind), DIMENSION(:), INTENT(IN OUT):: array
      INTEGER,                        INTENT(IN)    :: ntotal, npass, nspan
      INTEGER,          DIMENSION(:), INTENT(IN)    :: factor
      INTEGER,                        INTENT(IN)    :: nfactor
      LOGICAL,                        INTENT(IN)    :: inv
      !--- local scalars
      INTEGER         :: ii, ispan
      INTEGER         :: j, jc, jf, jj
      INTEGER         :: k, kk, kspan, k1, k2, k3, k4
      INTEGER         :: nn, nt
      REAL(fftkind)   :: s60, c72, s72, pi2, radf
      REAL(fftkind)   :: c1, s1, c2, s2, c3, s3, cd, sd, ak
      COMPLEX(fftkind):: cc, cj, ck, cjp, cjm, ckp, ckm
      !--- local arrays
      COMPLEX(fftkind), DIMENSION(:), ALLOCATABLE  :: ctmp
      REAL(fftkind),    DIMENSION(:), ALLOCATABLE  :: sine, cosine

      maxfactor = MAXVAL(factor(:nfactor))
      ALLOCATE(ctmp(maxfactor), sine(maxfactor), cosine(maxfactor), STAT=status)
      IF (status /= 0) RETURN

      c72 = cos72
      IF (inv) THEN
         s72 = sin72
         s60 = sin60
         pi2 = pi
      ELSE
         s72 = -sin72
         s60 = -sin60
         pi2 = -pi
      END IF

      nt = ntotal
      nn = nt - 1
      kspan = nspan
      jc = nspan / npass
      radf = pi2 * jc
      pi2 = pi2 * 2.0_fftkind !-- use 2 PI from here on

      ii = 0
      jf = 0
      DO
         sd = radf / kspan
         cd = SIN(sd)
         cd = 2.0_fftkind * cd * cd
         sd = SIN(sd + sd)
         kk = 1
         ii = ii + 1

         SELECT CASE (factor(ii))
         CASE (2)
            !-- transform for factor of 2 (including rotation factor)
            kspan = kspan / 2
            k1 = kspan + 2
            DO
               DO
                  k2 = kk + kspan
                  ck = array(k2)
                  array(k2) = array(kk)-ck
                  array(kk) = array(kk) + ck
                  kk = k2 + kspan
                  IF (kk > nn) EXIT
               END DO
               kk = kk - nn
               IF (kk > jc) EXIT
            END DO
            IF (kk > kspan) THEN
               DEALLOCATE(ctmp, sine, cosine, STAT=status)
               RETURN
            END IF
            DO
               c1 = 1.0_fftkind - cd
               s1 = sd
               DO
                  DO
                     DO
                        k2 = kk + kspan
                        ck = array(kk) - array(k2)
                        array(kk) = array(kk) + array(k2)
                        array(k2) = ck * CMPLX(c1, s1, KIND=fftkind)
                        kk = k2 + kspan
                        IF (kk >= nt) EXIT
                     END DO
                     k2 = kk - nt
                     c1 = -c1
                     kk = k1 - k2
                     IF (kk <= k2) EXIT
                  END DO
                  ak = c1 - (cd * c1 + sd * s1)
                  s1 = sd * c1 - cd * s1 + s1
                  c1 = 2.0_fftkind - (ak * ak + s1 * s1)
                  s1 = s1 * c1
                  c1 = c1 * ak
                  kk = kk + jc
                  IF (kk >= k2) EXIT
               END DO
               k1 = k1 + 1 + 1
               kk = (k1 - kspan) / 2 + jc
               IF (kk > jc + jc) EXIT
            END DO

         CASE (4) !-- transform for factor of 4
            ispan = kspan
            kspan = kspan / 4

            DO
               c1 = 1.0_fftkind
               s1 = 0.0_fftkind
               DO
                  DO
                     k1 = kk + kspan
                     k2 = k1 + kspan
                     k3 = k2 + kspan
                     ckp = array(kk) + array(k2)
                     ckm = array(kk) - array(k2)
                     cjp = array(k1) + array(k3)
                     cjm = array(k1) - array(k3)
                     array(kk) = ckp + cjp
                     cjp = ckp - cjp
                     IF (inv) THEN
                        ckp = ckm + CMPLX(-AIMAG(cjm), REAL(cjm), KIND=fftkind)
                        ckm = ckm + CMPLX(AIMAG(cjm), -REAL(cjm), KIND=fftkind)
                     ELSE
                        ckp = ckm + CMPLX(AIMAG(cjm), -REAL(cjm), KIND=fftkind)
                        ckm = ckm + CMPLX(-AIMAG(cjm), REAL(cjm), KIND=fftkind)
                     END IF
                     !-- avoid useless multiplies
                     IF (s1 == 0.0_fftkind) THEN
                        array(k1) = ckp
                        array(k2) = cjp
                        array(k3) = ckm
                     ELSE
                        array(k1) = ckp * CMPLX(c1, s1, KIND=fftkind)
                        array(k2) = cjp * CMPLX(c2, s2, KIND=fftkind)
                        array(k3) = ckm * CMPLX(c3, s3, KIND=fftkind)
                     END IF
                     kk = k3 + kspan
                     IF (kk > nt) EXIT
                  END DO

                  c2 = c1 - (cd * c1 + sd * s1)
                  s1 = sd * c1 - cd * s1 + s1
                  c1 = 2.0_fftkind - (c2 * c2 + s1 * s1)
                  s1 = s1 * c1
                  c1 = c1 * c2
                  !-- values of c2, c3, s2, s3 that will get used next time
                  c2 = c1 * c1 - s1 * s1
                  s2 = 2.0_fftkind * c1 * s1
                  c3 = c2 * c1 - s2 * s1
                  s3 = c2 * s1 + s2 * c1
                  kk = kk - nt + jc
                  IF (kk > kspan) EXIT
               END DO
               kk = kk - kspan + 1
               IF (kk > jc) EXIT
            END DO
            IF (kspan == jc) THEN
               DEALLOCATE(ctmp, sine, cosine, STAT=status)
               RETURN
            END IF

         CASE default
            !-- transform for odd factors
            k = factor(ii)
            ispan = kspan
            kspan = kspan / k

            SELECT CASE (k)
            CASE (3) !-- transform for factor of 3 (optional code)
               DO
                  DO
                     k1 = kk + kspan
                     k2 = k1 + kspan
                     ck = array(kk)
                     cj = array(k1) + array(k2)
                     array(kk) = ck + cj
                     ck = ck - CMPLX( &
                          0.5_fftkind * REAL (cj), &
                          0.5_fftkind * AIMAG(cj), &
                          KIND=fftkind)
                     cj = CMPLX( &
                          (REAL (array(k1)) - REAL (array(k2))) * s60, &
                          (AIMAG(array(k1)) - AIMAG(array(k2))) * s60, &
                          KIND=fftkind)
                     array(k1) = ck + CMPLX(-AIMAG(cj), REAL(cj), KIND=fftkind)
                     array(k2) = ck + CMPLX(AIMAG(cj), -REAL(cj), KIND=fftkind)
                     kk = k2 + kspan
                     IF (kk >= nn) EXIT
                  END DO
                  kk = kk - nn
                  IF (kk > kspan) EXIT
               END DO

            CASE (5) !-- transform for factor of 5 (optional code)
               c2 = c72 * c72 - s72 * s72
               s2 = 2.0_fftkind * c72 * s72
               DO
                  DO
                     k1 = kk + kspan
                     k2 = k1 + kspan
                     k3 = k2 + kspan
                     k4 = k3 + kspan
                     ckp = array(k1) + array(k4)
                     ckm = array(k1) - array(k4)
                     cjp = array(k2) + array(k3)
                     cjm = array(k2) - array(k3)
                     cc = array(kk)
                     array(kk) = cc + ckp + cjp
                     ck = CMPLX(REAL(ckp) * c72, AIMAG(ckp) * c72, &
                          KIND=fftkind) + &
                          CMPLX(REAL(cjp) * c2,  AIMAG(cjp) * c2,  &
                          KIND=fftkind) + cc
                     cj = CMPLX(REAL(ckm) * s72, AIMAG(ckm) * s72, &
                          KIND=fftkind) + &
                          CMPLX(REAL(cjm) * s2,  AIMAG(cjm) * s2,  &
                          KIND=fftkind)
                     array(k1) = ck + CMPLX(-AIMAG(cj), REAL(cj), KIND=fftkind)
                     array(k4) = ck + CMPLX(AIMAG(cj), -REAL(cj), KIND=fftkind)
                     ck = CMPLX(REAL(ckp) * c2,  AIMAG(ckp) * c2,  &
                          KIND=fftkind) + &
                          CMPLX(REAL(cjp) * c72, AIMAG(cjp) * c72, &
                          KIND=fftkind) + cc
                     cj = CMPLX(REAL(ckm) * s2,  AIMAG(ckm) * s2,  &
                          KIND=fftkind) - &
                          CMPLX(REAL(cjm) * s72, AIMAG(cjm) * s72, &
                          KIND=fftkind)
                     array(k2) = ck + CMPLX(-AIMAG(cj), REAL(cj), KIND=fftkind)
                     array(k3) = ck + CMPLX(AIMAG(cj), -REAL(cj), KIND=fftkind)
                     kk = k4 + kspan
                     IF (kk >= nn) EXIT
                  END DO
                  kk = kk - nn
                  IF (kk > kspan) EXIT
               END DO

            CASE default
               IF (k /= jf) THEN
                  jf = k
                  s1 = pi2 / k
                  c1 = COS(s1)
                  s1 = SIN(s1)
                  cosine (jf) = 1.0_fftkind
                  sine (jf) = 0.0_fftkind
                  j = 1
                  DO
                     cosine (j) = cosine (k) * c1 + sine (k) * s1
                     sine (j) = cosine (k) * s1 - sine (k) * c1
                     k = k-1
                     cosine (k) = cosine (j)
                     sine (k) = -sine (j)
                     j = j + 1
                     IF (j >= k) EXIT
                  END DO
               END IF
               DO
                  DO
                     k1 = kk
                     k2 = kk + ispan
                     cc = array(kk)
                     ck = cc
                     j = 1
                     k1 = k1 + kspan
                     DO
                        k2 = k2 - kspan
                        j = j + 1
                        ctmp(j) = array(k1) + array(k2)
                        ck = ck + ctmp(j)
                        j = j + 1
                        ctmp(j) = array(k1) - array(k2)
                        k1 = k1 + kspan
                        IF (k1 >= k2) EXIT
                     END DO
                     array(kk) = ck
                     k1 = kk
                     k2 = kk + ispan
                     j = 1
                     DO
                        k1 = k1 + kspan
                        k2 = k2 - kspan
                        jj = j
                        ck = cc
                        cj = (0.0_fftkind, 0.0_fftkind)
                        k = 1
                        DO
                           k = k + 1
                           ck = ck + CMPLX( &
                                REAL (ctmp(k)) * cosine(jj), &
                                AIMAG(ctmp(k)) * cosine(jj), KIND=fftkind)
                           k = k + 1
                           cj = cj + CMPLX( &
                                REAL (ctmp(k)) * sine(jj), &
                                AIMAG(ctmp(k)) * sine(jj), KIND=fftkind)
                           jj = jj + j
                           IF (jj > jf) jj = jj - jf
                           IF (k >= jf) EXIT
                        END DO
                        k = jf - j
                        array(k1) = ck + CMPLX(-AIMAG(cj), REAL(cj), &
                             KIND=fftkind)
                        array(k2) = ck + CMPLX(AIMAG(cj), -REAL(cj), &
                             KIND=fftkind)
                        j = j + 1
                        IF (j >= k) EXIT
                     END DO
                     kk = kk + ispan
                     IF (kk > nn) EXIT
                  END DO
                  kk = kk - nn
                  IF (kk > kspan) EXIT
               END DO

            END SELECT
            !--  multiply by rotation factor (except for factors of 2 and 4)
            IF (ii == nfactor) THEN
               DEALLOCATE(ctmp, sine, cosine, STAT=status)
               RETURN
            END IF

            kk = jc + 1
            DO
               c2 = 1.0_fftkind - cd
               s1 = sd
               DO
                  c1 = c2
                  s2 = s1
                  kk = kk + kspan
                  DO
                     DO
                        array(kk) = CMPLX(c2, s2, KIND=fftkind) * array(kk)
                        kk = kk + ispan
                        IF (kk > nt) EXIT
                     END DO
                     ak = s1 * s2
                     s2 = s1 * c2 + c1 * s2
                     c2 = c1 * c2 - ak
                     kk = kk - nt + kspan
                     IF (kk > ispan) EXIT
                  END DO
                  c2 = c1 - (cd * c1 + sd * s1)
                  s1 = s1 + sd * c1 - cd * s1
                  c1 = 2.0_fftkind - (c2 * c2 + s1 * s1)
                  s1 = s1 * c1
                  c2 = c2 * c1
                  kk = kk - ispan + jc
                  IF (kk > kspan) EXIT
               END DO
               kk = kk - kspan + jc + 1
               IF (kk > jc + jc) EXIT
            END DO

         END SELECT
      END DO

      DEALLOCATE(ctmp, sine, cosine, STAT=status)
      RETURN
    END SUBROUTINE transform


    SUBROUTINE permute(array, ntotal, npass, nspan, &
         factor, nfactor, nsquare, maxfactor)
      !--- formal parameters
      COMPLEX(fftkind), DIMENSION(:), INTENT(IN OUT):: array
      INTEGER,                        INTENT(IN)    :: ntotal, npass, nspan
      INTEGER,          DIMENSION(:), INTENT(IN OUT):: factor
      INTEGER,                        INTENT(IN)    :: nfactor, nsquare
      INTEGER,                        INTENT(IN)    :: maxfactor
      !--- local scalars
      INTEGER         :: ii, ispan
      INTEGER         :: j, jc, jj
      INTEGER         :: k, kk, kspan, kt, k1, k2, k3
      INTEGER         :: nn, nperm, nt
      COMPLEX(fftkind):: ck
      !--- local arrays
      COMPLEX(fftkind), DIMENSION(:), ALLOCATABLE  :: ctmp
      INTEGER         , DIMENSION(:), ALLOCATABLE  :: perm

      ALLOCATE(ctmp(maxfactor), STAT=status)
      IF (status /= 0) RETURN

      IF (nfactor - ISHFT(nsquare, 1) > 0) THEN
         nperm = MAX(nfactor + 1, PRODUCT(factor(nsquare+1: nfactor-nsquare)) - 1)
      ELSE
         nperm = nfactor + 1
      END IF
      ALLOCATE(perm(nperm), STAT=status)
      IF (status /= 0) RETURN

      !--  permute the results to normal order---done in two stages
      !--  permutation for square factors of n

      nt = ntotal
      nn = nt - 1
      kt = nsquare
      kspan = nspan
      jc = nspan / npass

      perm (1) = nspan
      IF (kt > 0) THEN
         k = kt + kt + 1
         IF (nfactor < k) k = k - 1
         j = 1
         perm (k + 1) = jc
         DO
            perm (j + 1) = perm (j) / factor(j)
            perm (k) = perm (k + 1) * factor(j)
            j = j + 1
            k = k - 1
            IF (j >= k) EXIT
         END DO
         k3 = perm (k + 1)
         kspan = perm (2)
         kk = jc + 1
         k2 = kspan + 1
         j = 1

         IF (npass /= ntotal) THEN
            permute_multi: DO
               DO
                  DO
                     k = kk + jc
                     DO
                        !-- swap array(kk) <> array(k2)
                        ck = array(kk)
                        array(kk) = array(k2)
                        array(k2) = ck
                        kk = kk + 1
                        k2 = k2 + 1
                        IF (kk >= k) EXIT
                     END DO
                     kk = kk + nspan - jc
                     k2 = k2 + nspan - jc
                     IF (kk >= nt) EXIT
                  END DO
                  kk = kk - nt + jc
                  k2 = k2 - nt + kspan
                  IF (k2 >= nspan) EXIT
               END DO
               DO
                  DO
                     k2 = k2 - perm (j)
                     j = j + 1
                     k2 = perm (j + 1) + k2
                     IF (k2 <= perm (j)) EXIT
                  END DO
                  j = 1
                  DO
                     IF (kk < k2) CYCLE permute_multi
                     kk = kk + jc
                     k2 = k2 + kspan
                     IF (k2 >= nspan) EXIT
                  END DO
                  IF (kk >= nspan) EXIT
               END DO
               EXIT
            END DO permute_multi
         ELSE
            permute_single: DO
               DO
                  !-- swap array(kk) <> array(k2)
                  ck = array(kk)
                  array(kk) = array(k2)
                  array(k2) = ck
                  kk = kk + 1
                  k2 = k2 + kspan
                  IF (k2 >= nspan) EXIT
               END DO
               DO
                  DO
                     k2 = k2 - perm (j)
                     j = j + 1
                     k2 = perm (j + 1) + k2
                     IF (k2 <= perm (j)) EXIT
                  END DO
                  j = 1
                  DO
                     IF (kk < k2) CYCLE permute_single
                     kk = kk + 1
                     k2 = k2 + kspan
                     IF (k2 >= nspan) EXIT
                  END DO
                  IF (kk >= nspan) EXIT
               END DO
               EXIT
            END DO permute_single
         END IF
         jc = k3
      END IF

      IF (ISHFT(kt, 1) + 1 >= nfactor) THEN
         DEALLOCATE(perm, ctmp)
         RETURN
      END IF

      ispan = perm (kt + 1)
      !-- permutation for square-free factors of n
      j = nfactor - kt
      factor(j + 1) = 1
      DO
         factor(j) = factor(j) * factor(j+1)
         j = j - 1
         IF (j == kt) EXIT
      END DO
      kt = kt + 1
      nn = factor(kt) - 1
      j = 0
      jj = 0
      DO
         k = kt + 1
         k2 = factor(kt)
         kk = factor(k)
         j = j + 1
         IF (j > nn) EXIT !-- exit infinite loop
         jj = jj + kk
         DO WHILE (jj >= k2)
            jj = jj - k2
            k2 = kk
            k = k + 1
            kk = factor(k)
            jj = jj + kk
         END DO
         perm (j) = jj
      END DO
      !--  determine the permutation cycles of length greater than 1
      j = 0
      DO
         DO
            j = j + 1
            kk = perm(j)
            IF (kk >= 0) EXIT
         END DO
         IF (kk /= j) THEN
            DO
               k = kk
               kk = perm (k)
               perm (k) = -kk
               IF (kk == j) EXIT
            END DO
            k3 = kk
         ELSE
            perm (j) = -j
            IF (j == nn) EXIT !-- exit infinite loop
         END IF
      END DO
      !--  reorder a and b, following the permutation cycles
      DO
         j = k3 + 1
         nt = nt - ispan
         ii = nt - 1 + 1
         IF (nt < 0) EXIT !-- exit infinite loop
         DO
            DO
               j = j-1
               IF (perm(j) >= 0) EXIT
            END DO
            jj = jc
            DO
               kspan = jj
               IF (jj > maxfactor) kspan = maxfactor
               jj = jj - kspan
               k = perm(j)
               kk = jc * k + ii + jj
               k1 = kk + kspan
               k2 = 0
               DO
                  k2 = k2 + 1
                  ctmp(k2) = array(k1)
                  k1 = k1 - 1
                  IF (k1 == kk) EXIT
               END DO
               DO
                  k1 = kk + kspan
                  k2 = k1 - jc * (k + perm(k))
                  k = -perm(k)
                  DO
                     array(k1) = array(k2)
                     k1 = k1 - 1
                     k2 = k2 - 1
                     IF (k1 == kk) EXIT
                  END DO
                  kk = k2
                  IF (k == j) EXIT
               END DO
               k1 = kk + kspan
               k2 = 0
               DO
                  k2 = k2 + 1
                  array(k1) = ctmp(k2)
                  k1 = k1 - 1
                  IF (k1 == kk) EXIT
               END DO
               IF (jj == 0) EXIT
            END DO
            IF (j == 1) EXIT
         END DO
      END DO

      DEALLOCATE(perm, ctmp)
      RETURN
    END SUBROUTINE permute

  END SUBROUTINE fftradix

END MODULE singleton
solve.F/        1298670206  19071 8000  100644  143434    `

!-----------------------------------------------------------------------
!  CM1 Numerical Model, Release 15  (cm1r15)
!  13 January 2011
!  http://www.mmm.ucar.edu/people/bryan/cm1/
!-----------------------------------------------------------------------
!  Quick Index:
!    ua/u3d     = velocity in x-direction (m/s)
!    va/v3d     = velocity in y-direction (m/s)
!    wa/w3d     = velocity in z-direction (m/s)
!    tha/th3d   = perturbation potential temperature (K)
!    ppi/pp3d   = perturbation nondimensional pressure ("Exner function")
!    qa/q3d     = mixing ratios of moisture (kg/kg)
!    tkea/tke3d = SUBGRID turbulence kinetic energy (m^2/s^2)
!    kmh/kmv    = turbulent diffusion coefficients for momentum (m^2/s)
!    khh/khv    = turbulent diffusion coefficients for scalars (m^2/s)
!                 (h = horizontal, v = vertical)
!    prs        = pressure (Pa)
!    rho        = density (kg/m^3)
!
!    th0,pi0,prs0,etc = base-state arrays
!
!    xh         = x (m) at scalar points
!    xf         = x (m) at u points
!    yh         = y (m) at scalar points
!    yf         = y (m) at v points
!    zh         = z (m above sea level) of scalar points (aka, "half levels")
!    zf         = z (m above sea level) of w points (aka, "full levels")
!
!    For the axisymmetric model (axisymm=1), xh and xf are radius (m).
!
!  See "The governing equations for CM1" for more details:
!        http://www.mmm.ucar.edu/people/bryan/cm1/cm1_equations.pdf
!-----------------------------------------------------------------------
!  Some notes:
!
!  - Upon entering solve, the arrays ending in "a" (eg, ua,wa,tha,qa,etc)
!    are equivalent to the arrays ending in "3d" (eg, u3d,w3d,th3d,q3d,etc).
!  - The purpose of solve is to update the variables from time "t" to time
!    "t+dt".  Values at time "t+dt" are stored in the "3d" arrays.
!  - The "ghost zones" (boundaries beyond the computational subdomain) are
!    filled out completely (3 rows/columns) for the "3d" arrays.  To save 
!    unnecessary computations, starting with cm1r15 the "ghost zones" of 
!    the "a" arrays are only filled out to 1 row/column.  Hence, if you 
!    need to do calculations that use a large stencil, you must use the 
!    "3d" arrays (not the "a") arrays.
!  - Arrays named "ten" store tendencies.  Those ending "ten1" store
!    pre-RK tendencies that are calculated once and then held fixed during
!    the RK (Runge-Kutta) sub-steps. 
!  - CM1 uses a low-storage three-step Runge-Kutta scheme.  See Wicker
!    and Skamarock (2002, MWR, p 2088) for more information.
!  - CM1 uses a staggered C grid.  Hence, u arrays have one more grid point
!    in the i direction, v arrays have one more grid point in the j 
!    direction, and w arrays have one more grid point in the k direction
!    (compared to scalar arrays).
!  - CM1 assumes the subgrid turbulence parameters (tke,km,kh) are located
!    at the w points. 
!-----------------------------------------------------------------------

      subroutine solve(nstep,nrec,prec,nwrite,nrst,rbufsz,num_soil_layers,ndt, &
                   dt,dtlast,mtime,stattim,taptim,rsttim,radtim,adt,acfl, &
                   dodrag,dosfcflx,cloudvar,rhovar,qname,budname,bud,bud2,qbudget,asq,bsq, &
                   xh,rxh,uh,ruh,xf,rxf,uf,ruf,yh,vh,rvh,yf,vf,rvf,  &
                   sigma,sigmaf,tauh,taus,zh,mh,rmh,tauf,zf,mf,rmf,  &
                   rstat,rho0s,pi0s,prs0s,rth0s,pi0,rho0,prs0,thv0,th0,qv0,qc0, &
                   ql0,rr0,rf0,rrf0,rru0,rrv0,                       &
                   zs,gz,dzdx,dzdy,rain,sws,svs,sps,srs,sgs,sus,shs, &
                   doimpl,tsk,thflux,qvflux,cdu,cdv,ce,u1,v1,w1,     &
                   radbcw,radbce,radbcs,radbcn,                      &
                   dum1,dum2,dum3,dum4,divx,rho,prs,                 &
                   t11,t12,t13,t22,t23,t33,                          &
                   gx,u0,rru,ua,u3d,uten,uten1,                      &
                   gy,v0,rrv,va,v3d,vten,vten1,                      &
                   rrw,wa,w3d,wten,wten1,ppi,pp3d,ppten,sten,        &
                   tha,th3d,thten,thten1,thterm,tk,qa,q3d,qten,zvdarray, &
                   kmh,kmv,khh,khv,tkea,tke3d,tketen,                &
                   dissten,thpten,qvpten,qcpten,qipten,upten,vpten,  &
                   swten,lwten,o30,radsw,rnflx,radswnet,radlwin,rad2d,   &
                   x,y,z,za,zp,                                      &
                   lu_index,kpbl2d,psfc,u10,v10,hfx,qfx,xland,znt,ust,  &
                   hpbl,wspd,psim,psih,gz1oz0,br,                    &
                   CHS,CHS2,CQS2,CPMM,ZOL,MAVAIL,                    &
                   MOL,RMOL,REGIME,LH,FLHC,FLQC,QGH,                 &
                   CK,CKA,CD,CDA,USTM,QSFC,T2,Q2,TH2,EMISS,THC,ALBD, &
                   f2d,gsw,glw,chklowq,capg,snowc,dsxy,              &
                   slab_zs,slab_dzs,tslb,tmn,tml,t0ml,hml,h0ml,huml,hvml,tmoml,       &
                   pta,pt3d,ptten,                                   &
#ifdef MICROBURST
                   q1mb,q2mb, &
#endif
                   pdata,cfb,cfa,cfc,ad1,ad2,pdt,deft,rhs,trans,     &
                   reqs_u,reqs_v,reqs_w,reqs_s,reqs_p,reqs_tk,reqs_q,reqs_t, &
                   ww1,ww2,we1,we2,ws1,ws2,wn1,wn2,                  &
                   pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2,                  &
                   vw1,vw2,ve1,ve2,vs1,vs2,vn1,vn2,                  &
                   uw31,uw32,ue31,ue32,us31,us32,un31,un32,          &
                   vw31,vw32,ve31,ve32,vs31,vs32,vn31,vn32,          &
                   ww31,ww32,we31,we32,ws31,ws32,wn31,wn32,          &
                   sw31,sw32,se31,se32,ss31,ss32,sn31,sn32,          &
                   pw31,pw32,pe31,pe32,ps31,ps32,pn31,pn32,          &
                   tkw1,tkw2,tke1,tke2,tks1,tks2,tkn1,tkn2,          &
                   qw1,qw2,qe1,qe2,qs1,qs2,qn1,qn2,                  &
                   tw1,tw2,te1,te2,ts1,ts2,tn1,tn2,ploc,packet)
      use module_mp_thompson
      use module_mp_morr_two_moment
      use module_sf_sfclay
      use module_bl_ysu
      use module_sf_slab
      use module_sf_oml
      use orfiomod
#ifdef ORFSWATHS
      use orfswathsmod
#endif
! ORF kludge for wr3d
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'radcst.incl'
      include 'timestat.incl'
#ifdef MPI
      include 'mpif.h'
#endif

!-----------------------------------------------------------------------
! Arrays and variables passed into solve

      integer, intent(in) :: nstep
      integer, intent(inout) :: nrec,prec,nwrite,nrst
      integer, intent(in) :: rbufsz,num_soil_layers
      integer, intent(inout) :: ndt
      real, intent(inout) :: dt,dtlast
      real*8, intent(inout) :: mtime
      real*8, intent(inout) :: stattim,taptim,rsttim,radtim,adt,acfl
      logical, intent(in) :: dodrag,dosfcflx
      logical, intent(in), dimension(maxq) :: cloudvar,rhovar
      character*3, intent(in), dimension(maxq) :: qname
      character*6, intent(in), dimension(maxq) :: budname
      real*8, intent(inout), dimension(nk) :: bud
      real*8, intent(inout), dimension(nj) :: bud2
      real*8, intent(inout), dimension(nbudget) :: qbudget
      real*8, intent(inout), dimension(numq) :: asq,bsq
      real, intent(in), dimension(ib:ie) :: xh,rxh,uh,ruh
      real, intent(in), dimension(ib:ie+1) :: xf,rxf,uf,ruf
      real, intent(in), dimension(jb:je) :: yh,vh,rvh
      real, intent(in), dimension(jb:je+1) :: yf,vf,rvf
      real, intent(in), dimension(kb:ke) :: sigma
      real, intent(in), dimension(kb:ke+1) :: sigmaf
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: tauh,taus,zh,mh,rmh
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: tauf,zf,mf,rmf
      real, intent(inout), dimension(stat_out) :: rstat
      real, intent(in), dimension(ib:ie,jb:je) :: rho0s,pi0s,prs0s,rth0s
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: pi0,rho0,prs0,thv0,th0,qv0,qc0
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: ql0,rr0,rf0,rrf0,rru0,rrv0
      real, intent(in), dimension(itb:ite,jtb:jte) :: zs,gz,dzdx,dzdy
      real, intent(in), dimension(itb:ite+1,jtb:jte,ktb:kte) :: gx
      real, intent(in), dimension(itb:ite,jtb:jte+1,ktb:kte) :: gy
      real, intent(inout), dimension(ib:ie,jb:je,nrain) :: rain,sws,svs,sps,srs,sgs,sus,shs
      logical, intent(inout), dimension(ib:ie,jb:je) :: doimpl
      real, intent(inout), dimension(ib:ie,jb:je) :: tsk,thflux,qvflux,cdu,cdv,ce,u1,v1,w1
      real, intent(inout), dimension(jb:je,kb:ke) :: radbcw,radbce
      real, intent(inout), dimension(ib:ie,kb:ke) :: radbcs,radbcn
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: dum1,dum2,dum3,dum4,divx,rho,prs
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: t11,t12,t13,t22,t23,t33
      real, intent(in), dimension(ib:ie+1,jb:je,kb:ke) :: u0
      real, intent(inout), dimension(ib:ie+1,jb:je,kb:ke) :: rru,ua,u3d,uten,uten1
      real, intent(in), dimension(ib:ie,jb:je+1,kb:ke) :: v0
      real, intent(inout), dimension(ib:ie,jb:je+1,kb:ke) :: rrv,va,v3d,vten,vten1
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke+1) :: rrw,wa,w3d,wten,wten1
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: ppi,pp3d,ppten,sten
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: tha,th3d,thten,thten1,thterm
#ifdef MICROBURST
      real, dimension(ib:ie,jb:je,kb:ke) :: q1mb,q2mb
      real q1forc,q2forc,ot
#endif
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: tk
      real, intent(inout), dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: qa,q3d,qten
      real, intent(inout), dimension(ibzvd:iezvd,jbzvd:jezvd,kbzvd:kezvd,nqzvd) :: zvdarray
      real, intent(inout), dimension(ibc:iec,jbc:jec,kbc:kec) :: kmh,kmv,khh,khv
      real, intent(inout), dimension(ibt:iet,jbt:jet,kbt:ket) :: tkea,tke3d,tketen
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: dissten
      real, intent(inout), dimension(ibb:ieb,jbb:jeb,kbb:keb) :: thpten,qvpten,qcpten,qipten,upten,vpten
      real, intent(inout), dimension(ibr:ier,jbr:jer,kbr:ker) :: swten,lwten
      real, intent(in), dimension(ibr:ier,jbr:jer,kbr:ker) :: o30
      real, intent(inout), dimension(ni,nj) :: radsw,rnflx,radswnet,radlwin
      real, intent(inout), dimension(ni,nj,nrad2d) :: rad2d
      real, intent(inout), dimension(ni+1) :: x
      real, intent(inout), dimension(nj+1) :: y
      real, intent(inout), dimension(nk+3) :: z,za
      real, intent(inout), dimension(ni,nj,nk+3) :: zp
      integer, intent(in), dimension(ibl:iel,jbl:jel) :: lu_index
      integer, intent(inout), dimension(ibl:iel,jbl:jel) :: kpbl2d
      real, intent(inout), dimension(ibl:iel,jbl:jel) :: psfc,u10,v10,hfx,qfx,xland,znt,ust, &
                                      hpbl,wspd,psim,psih,gz1oz0,br,          &
                                      CHS,CHS2,CQS2,CPMM,ZOL,MAVAIL,          &
                                      MOL,RMOL,REGIME,LH,FLHC,FLQC,QGH,       &
                                      CK,CKA,CD,CDA,USTM,QSFC,T2,Q2,TH2,EMISS,THC,ALBD,   &
                                      f2d,gsw,glw,chklowq,capg,snowc,dsxy
      real, intent(in), dimension(num_soil_layers) :: slab_zs,slab_dzs
      real, intent(inout), dimension(ibl:iel,jbl:jel,num_soil_layers) :: tslb
      real, intent(inout), dimension(ibl:iel,jbl:jel) :: tmn,tml,t0ml,hml,h0ml,huml,hvml,tmoml
      real, intent(inout), dimension(ibp:iep,jbp:jep,kbp:kep,npt) :: pta,pt3d,ptten
      real, intent(inout), dimension(npvals,nparcels) :: pdata
      real, intent(in), dimension(ipb:ipe,jpb:jpe,kpb:kpe) :: cfb
      real, intent(in), dimension(kpb:kpe) :: cfa,cfc,ad1,ad2
      complex, intent(inout), dimension(ipb:ipe,jpb:jpe,kpb:kpe) :: pdt,deft
      complex, intent(inout), dimension(ipb:ipe,jpb:jpe) :: rhs,trans
      integer, intent(inout), dimension(rmp) :: reqs_u,reqs_v,reqs_w,reqs_s,reqs_p,reqs_tk
      integer, intent(inout), dimension(rmp,numq) :: reqs_q
      integer, intent(inout), dimension(rmp,npt) :: reqs_t
      real, intent(inout), dimension(jmp,kmp-1) :: ww1,ww2,we1,we2
      real, intent(inout), dimension(imp,kmp-1) :: ws1,ws2,wn1,wn2
      real, intent(inout), dimension(jmp,kmp) :: pw1,pw2,pe1,pe2
      real, intent(inout), dimension(imp,kmp) :: ps1,ps2,pn1,pn2
      real, intent(inout), dimension(jmp,kmp) :: vw1,vw2,ve1,ve2
      real, intent(inout), dimension(imp,kmp) :: vs1,vs2,vn1,vn2
      real, intent(inout), dimension(cmp,jmp,kmp)   :: uw31,uw32,ue31,ue32
      real, intent(inout), dimension(imp+1,cmp,kmp) :: us31,us32,un31,un32
      real, intent(inout), dimension(cmp,jmp+1,kmp) :: vw31,vw32,ve31,ve32
      real, intent(inout), dimension(imp,cmp,kmp)   :: vs31,vs32,vn31,vn32
      real, intent(inout), dimension(cmp,jmp,kmp-1) :: ww31,ww32,we31,we32
      real, intent(inout), dimension(imp,cmp,kmp-1) :: ws31,ws32,wn31,wn32
      real, intent(inout), dimension(cmp,jmp,kmp)   :: sw31,sw32,se31,se32
      real, intent(inout), dimension(imp,cmp,kmp)   :: ss31,ss32,sn31,sn32
      real, intent(inout), dimension(cmp,jmp,kmp)   :: pw31,pw32,pe31,pe32
      real, intent(inout), dimension(imp,cmp,kmp)   :: ps31,ps32,pn31,pn32
      real, intent(inout), dimension(cmp,jmp,kmt)   :: tkw1,tkw2,tke1,tke2
      real, intent(inout), dimension(imp,cmp,kmt)   :: tks1,tks2,tkn1,tkn2
      real, intent(inout), dimension(cmp,jmp,kmp,numq) :: qw1,qw2,qe1,qe2
      real, intent(inout), dimension(imp,cmp,kmp,numq) :: qs1,qs2,qn1,qn2
      real, intent(inout), dimension(cmp,jmp,kmp,npt) :: tw1,tw2,te1,te2
      real, intent(inout), dimension(imp,cmp,kmp,npt) :: ts1,ts2,tn1,tn2
      real, intent(inout), dimension(3,nparcels) :: ploc
      real, intent(inout), dimension(npvals+1,nparcels) :: packet

!-----------------------------------------------------------------------
! Arrays and variables defined inside solve

      integer i,j,k,n,nrk,bflag,pdef,nn,fnum,onekmindex
      real :: delqv,delpi,delth,delt,fac
      real :: foo1,foo2

      logical :: simple_comm,qcom,tcom,dorad

      real :: tout,cfl_limit,max_change,dtsm

      real dttmp,rtime,rdt,tem,thrad,prad,ql
      real :: cpm,cvm
      real*8 afoo,bfoo
      logical :: getdbz

      logical :: doirrad,dosorad
      real :: saltitude,sazimuth,zen
      real, dimension(2) :: x1
      real, dimension(2) :: y1
      real, dimension(rbufsz) :: radbuf
      real, dimension(nkr) :: swtmp,lwtmp
      real, dimension(nkr) :: tem1,tem2,tem3,tem4,tem5,   &
                              tem6,tem7,tem8,tem9,tem10,   &
                              tem11,tem12,tem13,tem14,tem15,   &
                              tem16,tem17
      real, dimension(nkr) :: ptprt,pprt,qv,qc,qr,qi,qs,qh,   &
                              ptbar,pbar,appi,rhostr,zpp,o31

      real :: rad2deg,albedo,albedoz,tema,temb,frac_snowcover
      real :: dtsfc0,dtsfc

      logical :: flag_qi
      integer :: isfflx
      real :: ep1,ep2,karman,rovg
      real :: SVP1,SVP2,SVP3,SVPT0,p1000mb,eomeg,stbolt
      integer :: ifsnow
      real :: dtmin

#ifdef MPI
      ! for mpi comm of cda:
      integer, dimension(8) :: reqs
      real, dimension(3,nj) :: west,newwest,east,neweast
      real, dimension(ni,3) :: south,newsouth,north,newnorth
#endif
! ORF
      integer ihist
      character(len=109) dircmd
      character(len=4) cid
      character(len=5) ctime


!--------------------------------------------------------------------


#ifdef MPI
      nf=0
      nu=0
      nv=0
      nw=0
#endif

      afoo=0.0d0
      bfoo=0.0d0

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
! Adaptive timestepping:
!   (assumes cflmax has already been calculated)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      IF( (adapt_dt.eq.1) .and. (myid.eq.0) )THEN
        ! only processor 0 does this:

        cfl_limit  = 1.00    ! maximum CFL allowed  (actually a "target" value)
        max_change = 0.25    ! maximum (percentage) change in timestep

        IF( cflmax.gt.cfl_limit )THEN
          ! decrease timestep timestep:
          dttmp = max( 1.0-max_change , cfl_limit/cflmax )*dt
        ELSE
          ! increase timestep:
          dttmp = min( 1.0+max_change , cfl_limit/cflmax )*dt
        ENDIF

        ! don't allow dt to exceed twice initial timestep
        dttmp = min( dttmp , 2.0*dtl )

        ! ramp-down timestep when approaching output time
      IF( taptim.gt.0.0 )THEN
        tout = sngl( taptim - mtime )
        if( tout.gt.(2.0*dttmp) .and. tout.le.(3.0*dttmp)  )then
          dttmp = 0.33333333*tout
        elseif( tout.gt.dttmp .and. tout.le.(2.0*dttmp)  )then
          dttmp = 0.5*tout
        elseif( tout.le.dttmp )then
          dttmp = tout
        endif
      ENDIF

      IF( rsttim.gt.0.0 )THEN
        ! ramp-down timestep when approaching restart time
        tout = sngl( rsttim - mtime )
        if( tout.gt.(2.0*dttmp) .and. tout.le.(3.0*dttmp)  )then
          dttmp = 0.33333333*tout
        elseif( tout.gt.dttmp .and. tout.le.(2.0*dttmp)  )then
          dttmp = 0.5*tout
        elseif( tout.le.dttmp )then
          dttmp = tout
        endif
      ENDIF

      IF( stattim.gt.0.0 )THEN
        ! ramp-down timestep when approaching stat time
        tout = sngl( stattim - mtime )
        if( tout.gt.(2.0*dttmp) .and. tout.le.(3.0*dttmp)  )then
          dttmp = 0.33333333*tout
        elseif( tout.gt.dttmp .and. tout.le.(2.0*dttmp)  )then
          dttmp = 0.5*tout
        elseif( tout.le.dttmp )then
          dttmp = tout
        endif
      ENDIF

        dt = dttmp

        ! Algorithm to determine number of small steps:
        IF( psolver.eq.2 )THEN
          ! check dx,dy,dz:
          IF( ny.eq.1 )THEN
            ! 2D sims (x-z):
            dtsm = 0.50*min( min_dx , min_dz )/350.0
          ELSEIF( nx.eq.1 )THEN
            ! 2D sims (y-z):
            dtsm = 0.50*min( min_dy , min_dz )/350.0
          ELSE
            ! 3D sims:
            dtsm = 0.50*min( min_dx , min_dy , min_dz )/350.0
          ENDIF
        ELSEIF( psolver.eq.3 )THEN
          ! check dx,dy:
          IF( ny.eq.1 )THEN
            ! 2D sims (x-z):
            dtsm = 0.60*min_dx/350.0
          ELSEIF( nx.eq.1 )THEN
            ! 2D sims (y-z):
            dtsm = 0.60*min_dy/350.0
          ELSE
            ! 3D sims:
            dtsm = 0.60*min( min_dx , min_dy )/350.0
          ENDIF
        ENDIF
        nsound = max( nint( dt/dtsm ) , 4 )
        if( mod(nsound,2).ne.0 ) nsound = nsound + 1
        if( dt/float(nsound).gt.dtsm ) nsound = nsound + 2

        if( nsound.gt.24 )then
          nsound = 24
          dt = 24*dtsm
        endif

        print *,'cflmax,dt,nsound:',cflmax,dt,nsound

        ! end of processor 0 stuff
      ENDIF

      IF( adapt_dt.eq.1 )THEN
        ! all processors:
#ifdef MPI
        call MPI_BCAST(dt    ,1,MPI_REAL   ,0,MPI_COMM_WORLD,ierr)
        call MPI_BCAST(nsound,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
#endif
        ndt = ndt + 1
        adt = adt + dt
        acfl = acfl + cflmax
        if(timestats.ge.1) time_misc=time_misc+mytime()
        IF( dt.ne.dtlast )THEN
          IF( (imoist.eq.1).and.(ptype.eq.2) )then
            call consat2(dt)
            if(timestats.ge.1) time_microphy=time_microphy+mytime()
          ENDIF
          IF( (imoist.eq.1).and.(ptype.eq.4) )then
            call lfoice_init(dt)
            if(timestats.ge.1) time_microphy=time_microphy+mytime()
          ENDIF
          dtlast = dt
        ENDIF
      ENDIF

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cc   radiation  ccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      IF( radopt.eq.1 )THEN

        ! time at end of timestep:
        rtime=sngl(mtime+dt)
        dorad = .false.
        IF( rtime.ge.sngl(radtim) ) dorad = .true.
        dtrad = max( dtrad , dt )

        IF( dorad )THEN
!$omp parallel do default(shared)  &
!$omp private(i)
          do i=1,ni+1
            x(i)=xf(i)
          enddo
!$omp parallel do default(shared)  &
!$omp private(j)
          do j=1,nj+1
            y(j)=yf(j)
          enddo
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk+3
          do j=1,nj
          do i=1,ni
            zp(i,j,k) =   zf(i,j,k-1)
          enddo
          enddo
          enddo
          i = 1
          j = 1
!$omp parallel do default(shared)  &
!$omp private(k)
          do k=1,nk+3
            z(k)=zf(1,1,k-1)
            za(k)=zh(1,1,min(k-1,ke))
          enddo
          rtime=sngl(mtime+dt)
          if(myid.eq.0)write(outfile,*) '  Calculating radiation tendency:'
          if(timestats.ge.1) time_rad=time_rad+mytime()
          call bcs(prs)
          CALL zenangl( ni,nj, x,y, zp(1,1,2),    &
                rad2d(1,1,ncosz), rad2d(1,1,ncosss), radsw,              &
                dum1(1,1,1),dum1(1,1,2),dum1(1,1,3),dum1(1,1,4),        &
                dum2(1,1,1),dum2(1,1,2),dum2(1,1,3),dum2(1,1,4),        &
                saltitude,sazimuth,dx,dy,dt,rtime,                     &
                ctrlat,ctrlon,year,month,day,hour,minute,second,jday )
          if(myid.eq.0)then
            print *,'    solar zenith angle  (degrees) = ',   &
                                   acos(rad2d(ni,nj,ncosz))*degdpi
            print *,'    solar azimuth angle (degrees) = ',sazimuth*degdpi
          endif
!-----------------------------------------------------------------------
!
!  Calculate surface albedo which is dependent on solar zenith angle
!  and soil moisture. Set the albedo for different types of solar
!  flux to be same.
!
!    rsirbm   Solar IR surface albedo for beam radiation
!    rsirdf   Solar IR surface albedo for diffuse radiation
!    rsuvbm   Solar UV surface albedo for beam radiation
!    rsuvdf   Solar UV surface albedo for diffuse radiation
!
!-----------------------------------------------------------------------
!
  rad2deg = 180.0/3.141592654

!$omp parallel do default(shared)  &
!$omp private(i,j,albedo,albedoz,frac_snowcover,tema)
  DO j=1,nj
    DO i=1,ni

      ! let's just use MM5/WRF value, instead:
      albedo = albd(i,j)

      ! arps code for albedo:
      ! (not sure I trust this.....)

!      albedoz = 0.01 * ( EXP( 0.003286         & ! zenith dependent albedo
!          * SQRT( ( ACOS(rad2d(i,j,ncosz))*rad2deg ) ** 3 ) ) - 1.0 )
!
!      IF ( soilmodel == 0 ) THEN             ! soil type not defined
!!!!        stop 12321
!        tema = 0
!      ELSE
!        tema = qsoil(i,j,1)/wsat(soiltyp(i,j))
!      END IF
!
!      frac_snowcover = MIN(snowdpth(i,j)/snowdepth_crit, 1.0)
!
!      IF ( tema > 0.5 ) THEN
!        albedo = albedoz + (1.-frac_snowcover)*0.14                     &
!                         + frac_snowcover*snow_albedo
!      ELSE
!        albedo = albedoz + (1.-frac_snowcover)*(0.31 - 0.34 * tema)     &
!                         + frac_snowcover*snow_albedo
!      END IF
!        albedo = albedoz

      rad2d(i,j,nrsirbm) = albedo
      rad2d(i,j,nrsirdf) = albedo
      rad2d(i,j,nrsuvbm) = albedo
      rad2d(i,j,nrsuvdf) = albedo

    END DO
  END DO
          ! big OpenMP parallelization loop:
!$omp parallel do default(shared)  &
!$omp private(i,j,k,ptprt,pprt,qv,qc,qr,qi,qs,qh,appi,o31,                 &
!$omp tem1,tem2,tem3,tem4,tem5,tem6,tem7,tem8,tem9,tem10,        &
!$omp tem11,tem12,tem13,tem14,tem15,tem16,tem17,radbuf,swtmp,lwtmp,   &
!$omp doirrad,dosorad,z,za,zpp,ptbar,pbar,rhostr,x1,y1)
        do j=1,nj
        do i=1,ni
          swtmp = 0.0
          lwtmp = 0.0
          do k=1,nk+2
            ptprt(k) =  tha(i,j,k-1)
             pprt(k) =  prs(i,j,k-1) - prs0(i,j,k-1)
               qv(k) =   qa(i,j,k-1,nqv)
               qc(k) =   qa(i,j,k-1,nqc)
               qr(k) =   qa(i,j,k-1,nqr)
               qi(k) =   qa(i,j,k-1,nqi)
               qs(k) =   qa(i,j,k-1,nqs)
               qh(k) =   qa(i,j,k-1,nqg)
             appi(k) =  pi0(i,j,k-1) + ppi(i,j,k-1)
              o31(k) =  o30(i,j,k-1)
          enddo
          ptprt(1) = ptprt(2)
           pprt(1) =  pprt(2)
          ptprt(nk+2) = ptprt(nk+1)
           pprt(nk+2) =  pprt(nk+1)
          x1(1) = xf(i)
          x1(2) = xf(i+1)
          y1(1) = yf(j)
          y1(2) = yf(j+1)
          do k=1,nk+3
            z(k)=zf(i,j,k-1)
            za(k)=zh(i,j,min(k-1,ke))
            zpp(k) =   zp(i,j,k)
          enddo
          do k=2,nk+2
            ptbar(k) =  th0(i,j,k-1)
             pbar(k) = prs0(i,j,k-1)
           rhostr(k) = rho0(i,j,k-1)
          enddo
            ptbar(1) = rth0s(i,j)**(-1)
             pbar(1) = prs0s(i,j)
           rhostr(1) = rho0s(i,j)
            doirrad = .true.
            dosorad = .true.
          CALL radtrns(nir,njr,nkr, rbufsz, 0,myid,dx,dy,            &
                 ib,ie,jb,je,kb,ke,xh,yh,prs0s(i,j),                  &
                 ptprt,pprt,qv,qc,qr,qi,qs,qh,                          &
                 ptbar,pbar,appi,o31,rhostr, tsk(i,j), zpp ,                                 &
                 radsw(i,j),rnflx(i,j),radswnet(i,j),radlwin(i,j), rad2d(i,j,ncosss),            &
                 rad2d(i,j,nrsirbm),rad2d(i,j,nrsirdf),rad2d(i,j,nrsuvbm),                       &
                 rad2d(i,j,nrsuvdf), rad2d(i,j,ncosz),sazimuth,                                  &
                 rad2d(i,j,nfdirir),rad2d(i,j,nfdifir),rad2d(i,j,nfdirpar),rad2d(i,j,nfdifpar),  &
                 tem1, tem2, tem3, tem4, tem5,                &
                 tem6, tem7, tem8, tem9, tem10,               &
                 tem11,tem12,tem13,tem14,tem15,tem16,  &
                 radbuf(1), tem17,swtmp,lwtmp,doirrad,dosorad)
          do k=1,nk
            swten(i,j,k) = swtmp(k+1)
            lwten(i,j,k) = lwtmp(k+1)
          enddo
        enddo
        enddo
          radtim=radtim+dtrad
        ENDIF
        if(timestats.ge.1) time_rad=time_rad+mytime()

      ENDIF


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cc   surface  ccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

!-------------------------------------------------------------------
!  prepare some arrays for WRF surface/pbl physics:

      ! between here and call to ysu:
      ! DO NOT CHANGE:  dum1,dum2,dum3,dum4,sten,t11,t23

      IF((oceanmodel.eq.2).or.(ipbl.eq.1).or.(sfcmodel.eq.2))THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          dum1(i,j,k)=0.5*(ua(i,j,k)+ua(i+1,j,k))
          dum2(i,j,k)=0.5*(va(i,j,k)+va(i,j+1,k))
          dum3(i,j,k)=th0(i,j,k)+tha(i,j,k)
          sten(i,j,k)=pi0(i,j,k)+ppi(i,j,k)
          dum4(i,j,k)=dum3(i,j,k)*sten(i,j,k)
        enddo
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk+1
        do j=1,nj
        do i=1,ni
          t11(i,j,k) = dz*rmf(i,j,k)
          t23(i,j,k) = prs(i,j,k-1)+(prs(i,j,k)-prs(i,j,k-1))   &
                                   *( zf(i,j,k)- zh(i,j,k-1))   &
                                   /( zh(i,j,k)- zh(i,j,k-1))
        enddo
        enddo
        enddo

        ! values at surface, top of model:
!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          t23(i,j,1) =  prs(i,j,1)-zh(i,j,1)*( prs(i,j,2)- prs(i,j,1))   &
                                            /(  zh(i,j,2)-  zh(i,j,1))
          t23(i,j,nk+1)= prs(i,j,nk)+(zf(i,j,nk+1)-zh(i,j,nk))       &
                                    *( prs(i,j,nk)- prs(i,j,nk-1))   &
                                    /(  zh(i,j,nk)-  zh(i,j,nk-1))
          psfc(i,j) = t23(i,j,1)
        enddo
        enddo

        ep1 = rv/rd - 1.0
        ep2 = rd/rv
        karman = 0.4
        rovg = rd/g

        ! dum1 = u at scalars
        ! dum2 = v at scalars
        ! dum3 = th
        ! dum4 = t
        ! sten = pi
        ! t11 = dz8w
        ! t12 = qvten
        ! t13 = qcten
        ! t22 = qiten
        ! t23 = p3di
        ! t33 = exch_h
        ! divx = uten
        ! thterm = vten

        isfflx = 1
        SVP1=0.6112
        SVP2=17.67
        SVP3=29.65
        SVPT0=273.15
        p1000mb      = 100000.
        EOMEG=7.2921E-5
        STBOLT=5.67051E-8

        IF(radopt.eq.1)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j)
          do j=1,nj
          do i=1,ni
            gsw(i,j)=radsw(i,j)
            glw(i,j)=radlwin(i,j)
          enddo
          enddo
        ELSE
!$omp parallel do default(shared)   &
!$omp private(i,j)
          do j=1,nj
          do i=1,ni
            gsw(i,j)=0.0
            glw(i,j)=0.0
          enddo
          enddo
        ENDIF

        if(timestats.ge.1) time_sfcphys=time_sfcphys+mytime()
      ENDIF

      IF( sfcmodel.ge.1 .and. ipbl.eq.0 )THEN

        call gethpbl(zh,th0,tha,qa,hpbl)

      ENDIF

!-------------------------------------------------------------------
! surface schemes:

!---------------------------------------------------------------------------
! original CM1 formulation:


      if(isfcflx.eq.1.or.idrag.eq.1)then
        call getcecd(cdu,cdv,ce,u0,v0,rf0,u1,v1,w1,ua,va)
      endif

    IF(sfcmodel.eq.1)THEN !ORF See George email from 2/7/11

      ! get surface flux
      if(isfcflx.eq.1)then
        call sfcflux(dt,ruh,xf,rvh,pi0s,ce,zh,pi0,thv0,th0,u0,v0,tsk,thflux,qvflux,mavail, &
                     rho,u1,v1,w1,ua,va,ppi,tha,qa(ibm,jbm,kbm,nqv), &
                     qbudget(8))
      endif

      call sfcdiags(tsk,thflux,qvflux,cdu,cdv,ce,u1,v1,w1,   &
                    xland,psfc,qsfc,u10,v10,hfx,qfx,cda,znt,ust,gz1oz0,   &
                    psim,psih,br,zol,mol,hpbl,wspd,dsxy,th2,t2,q2,      &
                    zs,zh,pi0s,pi0,th0,ppi,tha,rho,qa,ua,va)

!-------------------------------------------------------------------

    ELSEIF(sfcmodel.eq.2)THEN

      ! surface layer:
      ! (needed by sfcmodel=2 and ipbl=1)
      call SFCLAY(dum1,dum2,dum4,qa(ib,jb,kb,nqv),prs,t11,       &
                   CP,G,ROVCP,RD,XLV,PSFC,CHS,CHS2,CQS2,CPMM,    &
                   ZNT,UST,hpbl,MAVAIL,ZOL,MOL,REGIME,PSIM,PSIH, &
                   XLAND,HFX,QFX,LH,TSK,FLHC,FLQC,QGH,QSFC,RMOL, &
                   U10,V10,TH2,T2,Q2,                            &
                   GZ1OZ0,WSPD,BR,ISFFLX,dsxy,                   &
                   SVP1,SVP2,SVP3,SVPT0,EP1,EP2,                 &
                   KARMAN,EOMEG,STBOLT,                          &
                   P1000mb,                                      &
                   1  ,ni+1 , 1  ,nj+1 , 1  ,nk+1 ,                    &
                   ib ,ie , jb ,je , kb ,ke ,                    &
                   1  ,ni , 1  ,nj , 1  ,nk ,                    &
                   ustm,ck,cka,cd,cda,isftcflx,iz0tlnd           )

      ifsnow = 0
      dtmin = dt/60.0

      ! slab scheme (MM5/WRF):
      call SLAB(dum4,qa(ib,jb,kb,nqv),prs,FLHC,FLQC,                      &
                   PSFC,XLAND,TMN,HFX,QFX,LH,TSK,QSFC,CHKLOWQ,  &
                   GSW,GLW,CAPG,THC,SNOWC,EMISS,MAVAIL,         &
                   DT,ROVCP,XLV,DTMIN,IFSNOW,               &
                   SVP1,SVP2,SVP3,SVPT0,EP2,                    &
                   KARMAN,EOMEG,STBOLT,                         &
                   TSLB,slab_ZS,slab_DZS,num_soil_layers, .true. ,       &
                   P1000mb,                                     &
                     1, ni+1,   1, nj+1,   1, nk+1,             &
                    ib, ie,  jb, je,  kb, ke,                   &
                     1, ni,   1, nj,   1, nk                    )

      if(timestats.ge.1) time_sfcphys=time_sfcphys+mytime()
    ENDIF

!-------------------------------------------------------------------
! simple ocean mixed layer model based Pollard, Rhines and Thompson (1973)
!   (from WRF)

    IF(oceanmodel.eq.2)THEN

        CALL oceanml(tml,t0ml,hml,h0ml,huml,hvml,ust,dum1,dum2, &
                     tmoml,f2d,g,oml_gamma,                     &
                     xland,hfx,lh,tsk,gsw,glw,emiss,            &
                     dt,STBOLT,                                 &
                       1, ni+1,   1, nj+1,   1, nk+1,           &
                      ib, ie,  jb, je,  kb, ke,                 &
                       1, ni,   1, nj,   1, nk                  )

      if(timestats.ge.1) time_sfcphys=time_sfcphys+mytime()
    ENDIF

!-------------------------------------------------------------------
!  PBL scheme:

      IF(ipbl.eq.1)THEN

        divx = 0.0
        thterm = 0.0
        thten = 0.0
        t12 = 0.0
        t13 = 0.0
        t22 = 0.0

        if( iice.eq.1 )then
          flag_qi = .true.
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            qten(i,j,k,nqv) = qa(i,j,k,nqi)
          enddo
          enddo
          enddo
        else
          flag_qi = .false.
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            qten(i,j,k,nqv) = 0.0
          enddo
          enddo
          enddo
        endif

        IF(output_km.eq.1.or.output_kh.eq.1)THEN
          ! ppten = exch_m
          t33=0.0
          ppten=0.0
        ENDIF

        ! PBL:
        call ysu(dum1,dum2,dum3,dum4,qa(ib,jb,kb,nqv),         &
                  qa(ib,jb,kb,nqc),qten(ib,jb,kb,nqv),prs,t23,sten,  &
                  divx,thterm,thten,                           &
                  t12,t13,t22,flag_qi,                         &
                  cp,g,rovcp,rd,rovg,ep1,ep2,karman,xlv,rv,    &
                  t11 ,psfc,                                   &
!!!                  znu,znw,mut,p_top,                        &
                  znt,ust,hpbl,psim,psih,                      &
                  xland,hfx,qfx,gz1oz0,wspd,br,                &
                  dt,kpbl2d,                                   &
                  t33,ppten,                                   &
                  u10,v10,                                     &
                  1  ,ni+1 , 1  ,nj+1 , 1  ,nk+1 ,             &
                  ib ,ie , jb ,je , kb ,ke ,                   &
                  1  ,ni , 1  ,nj , 1  ,nk ,                   &
                  regime                                       )
        if(timestats.ge.1) time_pbl=time_pbl+mytime()

        call bcs(divx)
#ifdef MPI
        call comm_1s_start(divx,pw1,pw2,pe1,pe2,   &
                                ps1,ps2,pn1,pn2,reqs_s)
#endif
        call bcs(thterm)
#ifdef MPI
        call comm_1s_start(thterm,vw1,vw2,ve1,ve2,   &
                                  vs1,vs2,vn1,vn2,reqs_p)
#endif
        IF(output_km.eq.1.or.output_kh.eq.1)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=1,nk+1
          do j=1,nj
          do i=1,ni
            khv(i,j,k) = t33(i,j,k)
            kmv(i,j,k) = ppten(i,j,k)
          enddo
          enddo
          enddo
        ENDIF
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          thpten(i,j,k) = thten(i,j,k)
          qvpten(i,j,k) =   t12(i,j,k)
          qcpten(i,j,k) =   t13(i,j,k)
          qipten(i,j,k) =   t22(i,j,k)
        enddo
        enddo
        enddo
        if(timestats.ge.1) time_pbl=time_pbl+mytime()
#ifdef MPI
        call comm_1s_end(divx,pw1,pw2,pe1,pe2,   &
                              ps1,ps2,pn1,pn2,reqs_s)
#endif
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=0,ni+1
           upten(i,j,k) =  divx(i,j,k)
        enddo
        enddo
        enddo
        if(timestats.ge.1) time_pbl=time_pbl+mytime()
#ifdef MPI
        call comm_1s_end(thterm,vw1,vw2,ve1,ve2,   &
                                vs1,vs2,vn1,vn2,reqs_p)
#endif
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=0,nj+1
        do i=1,ni
           vpten(i,j,k) =thterm(i,j,k)
        enddo
        enddo
        enddo
        if(timestats.ge.1) time_pbl=time_pbl+mytime()

      ENDIF

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cc   subgrid turbulence schemes  cccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!  Misc prep:
!  Also, set surface stresses:

      IF( sfcmodel.ge.2 )THEN
        ! put WRF parameters into CM1 arrays:

        IF( dosfcflx )THEN
!$omp parallel do default(shared)   &
!$omp private(i,j)
          do j=1,nj
          do i=1,ni
            thflux(i,j) = hfx(i,j)/(cp*rho(i,j,1))
            qvflux(i,j) = qfx(i,j)/rho(i,j,1)
          enddo
          enddo
        ENDIF
        IF( dodrag )THEN
!$omp parallel do default(shared)   &
!$omp private(i,j)
          do j=0,nj+1
          do i=0,ni+1
            u1(i,j) = 0.5*(ua(i,j,1)+ua(i+1,j,1))
            v1(i,j) = 0.5*(va(i,j,1)+va(i,j+1,1))
            w1(i,j) = sqrt( u1(i,j)**2 + v1(i,j)**2 )
            ce(i,j) = cka(i,j)
          enddo
          enddo
          call bc2d(cda)
          call bc2d(ust)
#ifdef MPI
          call comm_2d_start(cda,west,newwest,east,neweast,   &
                                 south,newsouth,north,newnorth,reqs)
          call comm_2dew_end(cda,west,newwest,east,neweast,reqs)
          call comm_2dns_end(cda,south,newsouth,north,newnorth,reqs)
          call comm_2d_start(ust,west,newwest,east,neweast,   &
                                 south,newsouth,north,newnorth,reqs)
          call comm_2dew_end(ust,west,newwest,east,neweast,reqs)
          call comm_2dns_end(ust,south,newsouth,north,newnorth,reqs)
#endif
!$omp parallel do default(shared)   &
!$omp private(i,j)
          do j=1,nj+1
          do i=1,ni+1
            cdu(i,j) = 0.5*(cda(i-1,j)+cda(i,j))
            cdv(i,j) = 0.5*(cda(i,j-1)+cda(i,j))
            t13(i,j,1) = ((0.5*(ust(i-1,j)+ust(i,j)))**2)*ua(i,j,1)/max(0.5*(w1(i-1,j)+w1(i,j)),0.1)
            t23(i,j,1) = ((0.5*(ust(i,j-1)+ust(i,j)))**2)*va(i,j,1)/max(0.5*(w1(i,j-1)+w1(i,j)),0.1)
          enddo
          enddo
        ENDIF

      ENDIF

      IF(sfcmodel.eq.0.or.sfcmodel.eq.1)THEN !ORF CHANGED THIS
        ! get surface drag
        if(idrag.eq.1)then
          call sfcdrag(cdu,cdv,u0,v0,rf0,u1,v1,t13,t23,ua,va)
        endif
      ENDIF

!--------------------------------------------------------------------
!                 For turbulence section only:
!  dum1 = squared Brunt-Vaisala frequency (N_m^2) (nm)
!  dum2 = Vertical deformation terms (S_v^2) (defsq)
!  dum3 = Horizontal deformation terms (S_h^2) (defh)
!
!  Arrays available for temporary storage:
!  dum4,divx,ppten,sten,thterm

      IF(iturb.ge.1)THEN

        ! squared Brunt-Vaisala frequency:
        call calcnm(mf,pi0,thv0,th0,cloudvar,dum1,dum2,dum3,dum4,divx,   &
                    prs,ppi,tha,qa)

        ! deformation:
        call calcdef(dodrag,xh,rxh,uh,xf,rxf,uf,vh,vf,mh,mf,dum2,dum3,   &
                     divx,ppten,ua,va,wa,t11,t12,t13,t22,t23,t33,gx,gy)

      ENDIF

!--------------------------------------------------------------------
!  iturb=1:  tke scheme  (for large eddy simulation)
!    Reference:  Deardorff, 1980, Bound Layer Meteor, p. 495
!                see also Stevens, Moeng, Sullivan, 1999, JAS, p. 3963

      IF(iturb.eq.1)THEN
 
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nkt
        do j=1,nj
        do i=1,ni
          tketen(i,j,k)=0.0
        enddo
        enddo
        enddo
        if(timestats.ge.1) time_misc=time_misc+mytime()

        call turbtke(dt,dodrag,dosfcflx,ruh,rvh,rmh,mf,rmf,th0,thflux,qvflux,rth0s,   &
                     dum1,dum2,dum3,dum4,divx,ppten,sten,thterm,   &
                     kmh,kmv,khh,khv,tkea,tketen,t13,t23,ua,va)

!-------------------------------------------------
!  iturb=2:  Smagorinsky scheme  (for large eddy simulation)
!    Reference:  see, e.g., Stevens, Moeng, Sullivan, 1999, JAS, p. 3963

      ELSEIF(iturb.eq.2)THEN

        call turbsmag(dt,dodrag,dosfcflx,ruh,rvh,rmh,mf,rmf,th0,thflux,qvflux,rth0s,  &
                      dum1,dum2,dum3,dum4,divx,sten,               &
                      kmh,kmv,khh,khv,t13,t23,ua,va)

!-------------------------------------------------
!  iturb=3:  parameterized turbulence  (no explicit turbulence)
!    Reference:  Rotunno and Emanuel, 1987, JAS, p. 542
!                Bryan and Rotunno, 2009, MWR, p. 1770

      ELSEIF(iturb.eq.3)THEN

        IF( l_v.le.tsmall .and. ipbl.eq.1 )THEN
          ! save kmv,khv:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk+1
          do j=1,nj
          do i=1,ni
            sten(i,j,k)=kmv(i,j,k)
            ppten(i,j,k)=khv(i,j,k)
          enddo
          enddo
          enddo
        ENDIF

        call turbparam(nstep,zf,dt,dodrag,dosfcflx,ruh,rvh,rmh,mf,rmf,th0,thflux,qvflux,rth0s,  &
                         dum1,dum2,dum3,kmh,kmv,khh,khv,t13,t23,ua,va)

        IF( l_v.le.tsmall .and. ipbl.eq.1 )THEN
          ! restore kmv,khv:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk+1
          do j=1,nj
          do i=1,ni
            kmv(i,j,k)=sten(i,j,k)
            khv(i,j,k)=ppten(i,j,k)
          enddo
          enddo
          enddo
!!!          ! diagnostic:  effective khv
!!!          !   dum1 is theta flux:
!!!          do j=1,nj
!!!          do i=1,ni
!!!            dum1(i,j,nk+1) = 0.0
!!!            do k=nk,1,-1
!!!              dum1(i,j,k) = dum1(i,j,k+1)+thpten(i,j,k)*rho0(i,j,k)*dz*rmh(i,j,k)
!!!            enddo
!!!            do k=1,nk+1
!!!              khv(i,j,k) = -dum1(i,j,k)/((th0(i,j,k)+tha(i,j,k))-(th0(i,j,k-1)+tha(i,j,k-1)))*rdz*mf(i,j,k)*rf0(i,j,k)
!!!            enddo
!!!          enddo
!!!          enddo
        ENDIF

!-------------------------------------------------

      ELSEIF(iturb.ne.0)THEN

        print *,'  unknown turbulence setting ... '
        call stopcm1

      ENDIF

!-------------------------------------------------
!  check for columns that need vertically implicit diffusion:

      IF(iturb.ge.1)THEN

        tem = 0.125*dz*dz/dt

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do j=0,nj+1
        do i=0,ni+1
          doimpl(i,j) = .false.
          k = 2
          do while( ( .not. doimpl(i,j) ) .and. (k.le.nk) )
            if( khv(i,j,k) .gt. tem*rmf(i,j,k)*rmf(i,j,k) )then
              doimpl(i,j) = .true.
            endif
            k = k + 1
          enddo
        enddo
        enddo
        if(timestats.ge.1) time_turb=time_turb+mytime()

      ENDIF

!-------------------------------------------------
!  some more calculations for TKE scheme:

      IF(iturb.eq.1)THEN

        call turbt(dt,xh,rxh,uh,xf,uf,vh,vf,mh,mf,rho0,rr0,rf0,rrf0,   &
                   dum1,dum2,dum3,dum4,divx,tkea,tketen,kmh,kmv,gx,gy,doimpl)

        if(idiff.eq.1)then
          if(difforder.eq.2)then
            call diff2w(1,0,rxh,uh,xf,uf,vh,vf,mh,mf,dum1,dum2,dum3,dum4,thterm,tkea,tketen)
          elseif(difforder.eq.6)then
            ! for diff6, use '3d' array
            call diff6w(dt,dum1,dum2,dum3,tke3d,tketen)
          endif
        endif

      ENDIF

!-------------------------------------------------
!  Get turbulent stresses:

      IF(iturb.ge.1)THEN

        call gettau(dodrag,xf,rxf,rho0,rf0,kmh,kmv,t11,t12,t13,t22,t23,t33,ua)

      ENDIF

!--------------------------------------------------------------------
!  Dissipative heating term:

      IF(idiss.eq.1)THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          dissten(i,j,k) = 0.0
        enddo
        enddo
        enddo
        if(timestats.ge.1) time_turb=time_turb+mytime()
      ENDIF

      IF(iturb.ge.1.and.idiss.eq.1)THEN

        call getepsilon(rxh,uh,xf,rxf,uf,yh,vh,yf,vf,mh,mf,rr0,rrf0,   &
                        dum1,dum2,dum3,dum4,divx,ppten,sten,dissten,    &
                        t11,t12,t13,t22,t23,t33,ua,va,wa,gx,gy)

      ENDIF

      IF(ipbl.eq.1.and.idiss.eq.1)THEN
        ! Dissipative heating from ysu scheme:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do j=1,nj
        do i=1,ni
          ! assume t13,t23 are zero at top of domain:
          t13(i,j,nk+1) = 0.0
          t23(i,j,nk+1) = 0.0
          do k=nk,1,-1
            t13(i,j,k) = t13(i,j,k+1)-upten(i,j,k)*rho0(i,j,k)*dz*rmh(i,j,k)
            t23(i,j,k) = t23(i,j,k+1)-vpten(i,j,k)*rho0(i,j,k)*dz*rmh(i,j,k)
          enddo
          do k=2,nk
            dum2(i,j,k)=0.5*((ua(i,j,k  )+ua(i+1,j,k  ))  &
                            -(ua(i,j,k-1)+ua(i+1,j,k-1)))*rdz*mf(i,j,k)
            dum3(i,j,k)=0.5*((va(i,j,k  )+va(i,j+1,k  ))  &
                            -(va(i,j,k-1)+va(i,j+1,k-1)))*rdz*mf(i,j,k)
          enddo
          dum2(i,j,1)=2.0*0.5*(ua(i,j,1)+ua(i+1,j,1))*rdz*mf(i,j,1)
          dum3(i,j,1)=2.0*0.5*(va(i,j,1)+va(i,j+1,1))*rdz*mf(i,j,1)
          dum2(i,j,nk+1)=0.0
          dum3(i,j,nk+1)=0.0
          do k=1,nk
            dissten(i,j,k)=dissten(i,j,k)+rr0(i,j,k)*0.5*(  &
                             ( t13(i,j,k  )*dum2(i,j,k  )   &
                              +t13(i,j,k+1)*dum2(i,j,k+1) ) &
                            +( t23(i,j,k  )*dum3(i,j,k  )   &
                              +t23(i,j,k+1)*dum3(i,j,k+1) ) )
          enddo
        enddo
        enddo
        t13 = 0.0
        t23 = 0.0

      ENDIF

!--------------------------------------------------------------------


!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CC   Pre-RK calculations   CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

 
!-------------------------------------------------------------------
!  Parcel update

      if(iprcl.eq.1)then
        ! rtime valid at beginning of time step
        rtime=sngl(mtime)
        call parcel_driver(prec,dt,xh,uh,ruh,yh,vh,rvh,zh,mh,rmh,mf,        &
                           pi0,thv0,th0,dum1,dum2,dum3,dum4,divx,prs,    &
                           ua,va,wa,ppi,thten,tha,qa,khv,pdata,rtime,    &
                           ploc,packet,reqs_p,                           &
                           pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2)
      endif

!--------------------------------------------------------------------
!  radbc
 
      if(irbc.eq.1)then

        if(ibw.eq.1 .or. ibe.eq.1) call radbcew(radbcw,radbce,ua)
 
        if(ibs.eq.1 .or. ibn.eq.1) call radbcns(radbcs,radbcn,va)

      endif

!--------------------------------------------------------------------
!  U-equation
 
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni+1
!!!        uten1(i,j,k)=0.
        uten1(i,j,k)=-rdalpha*0.5*(tauh(i-1,j,k)+tauh(i,j,k))*(ua(i,j,k)-u0(i,j,k))
      enddo
      enddo
      enddo
      if(timestats.ge.1) time_rdamp=time_rdamp+mytime()

      if(idiff.ge.1)then
        if(difforder.eq.2)then
          call diff2u(1,rxh,uh,xf,uf,vh,vf,mh,mf,dum1,dum2,dum3,dum4,dissten,ua,uten1)
        elseif(difforder.eq.6)then
          ! for diff6, use '3d' array
          call diff6u(dt,u0,dum1,dum2,dum3,u3d,uten1)
        endif
      endif

      if(dns.eq.1)then
        call diff2u(2,rxh,uh,xf,uf,vh,vf,mh,mf,dum1,dum2,dum3,dum4,dissten,ua,uten1)
      endif
 
      if(iturb.ge.1)then
        call turbu(dt,dodrag,xh,ruh,xf,rxf,uf,vh,mh,mf,rmf,rho0,rf0,rru0,   &
           dum1,dum2,dum3,dum4,ua,uten1,wa,t11,t12,t13,t22,kmv,gx,gy,doimpl)
      endif

      if(ipbl.eq.1)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni+1
          uten1(i,j,k) = uten1(i,j,k) + 0.5*( upten(i-1,j,k)+ upten(i,j,k))
        enddo
        enddo
        enddo
        if(timestats.ge.1) time_pbl=time_pbl+mytime()
      endif

!--------------------------------------------------------------------
!  V-equation
 
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj+1
      do i=1,ni
!!!        vten1(i,j,k)=0.
        vten1(i,j,k)=-rdalpha*0.5*(tauh(i,j-1,k)+tauh(i,j,k))*(va(i,j,k)-v0(i,j,k))
      enddo
      enddo
      enddo
      if(timestats.ge.1) time_rdamp=time_rdamp+mytime()

      if(idiff.ge.1)then
        if(difforder.eq.2)then
          call diff2v(1,xh,uh,rxf,uf,vh,vf,mh,mf,dum1,dum2,dum3,dum4,dissten,va,vten1)
        elseif(difforder.eq.6)then
          ! for diff6, use '3d' array
          call diff6v(dt,v0,dum1,dum2,dum3,v3d,vten1)
        endif
      endif

      if(dns.eq.1)then
        call diff2v(2,xh,uh,rxf,uf,vh,vf,mh,mf,dum1,dum2,dum3,dum4,dissten,va,vten1)
      endif
 
      if(iturb.ge.1)then
        call turbv(dt,dodrag,xh,rxh,uh,xf,rvh,vf,mh,mf,rho0,rf0,rrv0,   &
            dum1,dum2,dum3,dum4,va,vten1,wa,t12,t22,t23,kmv,gx,gy,doimpl)
      endif

      if(ipbl.eq.1)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj+1
        do i=1,ni
          vten1(i,j,k) = vten1(i,j,k) + 0.5*( vpten(i,j-1,k)+ vpten(i,j,k))
        enddo
        enddo
        enddo
        if(timestats.ge.1) time_pbl=time_pbl+mytime()
      endif
 
!--------------------------------------------------------------------
!  W-equation
 
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk+1
      do j=1,nj
      do i=1,ni
!!!        wten1(i,j,k)=0.0
        wten1(i,j,k)=-rdalpha*tauf(i,j,k)*wa(i,j,k)
      enddo
      enddo
      enddo
      if(timestats.ge.1) time_rdamp=time_rdamp+mytime()

      if(idiff.ge.1)then
        if(difforder.eq.2)then
          call diff2w(1,1,rxh,uh,xf,uf,vh,vf,mh,mf,dum1,dum2,dum3,dum4,dissten,wa,wten1)
        elseif(difforder.eq.6)then
          ! for diff6, use '3d' array
          call diff6w(dt,dum1,dum2,dum3,w3d,wten1)
        endif
      endif

      if(dns.eq.1)then
        call diff2w(2,1,rxh,uh,xf,uf,vh,vf,mh,mf,dum1,dum2,dum3,dum4,dissten,wa,wten1)
      endif
 
      if(iturb.ge.1)then
        call turbw(dt,xh,rxh,uh,xf,vh,mh,mf,rho0,rf0,rrf0,   &
               dum1,dum2,dum3,dum4,wa,wten1,t13,t23,t33,kmv,gx,gy,doimpl)
      endif

!--------------------------------------------------------------------
!  THETA-equation

! ORF colliding microburst bits 
#ifdef MICROBURST
      rtime=sngl(mtime)

      q1forc = 0.0;
      q2forc = 0.0;

! cm2.2
! first mb
      if (rtime > 0.0) q1forc = 0.5 * (1.0 - cos (3.14159 * rtime / 120.0));
      if (rtime > 120.0) q1forc = 1.0;
      if (rtime > 720.0) q1forc = 0.5 * (1.0 + cos (3.14159 * (rtime - 720.0) / 120.0));
      if (rtime > 840.0) q1forc = 0.0;

! second mb
! 2 minutes after first (120 seconds):
      ot = 120.0
      if (rtime > 0.0+ot) q2forc = 0.5 * (1.0 - cos (3.14159 * (rtime-ot) / 120.0));
      if (rtime > 120.0+ot) q2forc = 1.0;
      if (rtime > 720.0+ot) q2forc = 0.5 * (1.0 + cos (3.14159 * ((rtime-ot) - 720.0) / 120.0));
      if (rtime > 840.0+ot) q2forc = 0.0;

#endif

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
!!!        thten1(i,j,k)=0.0
        thten1(i,j,k)=-rdalpha*taus(i,j,k)*tha(i,j,k)
      enddo
      enddo
      enddo
      if(timestats.ge.1) time_rdamp=time_rdamp+mytime()

      if(idiff.eq.1)then
        if(difforder.eq.2)then
          call diff2s(1,rxh,uh,xf,uf,vh,vf,mh,mf,dum1,dum2,dum3,tha,thten1)
        elseif(difforder.eq.6)then
          ! for diff6, use '3d' array
          call diff6s(dt,ql0,dum1,dum2,dum3,th3d,thten1)
        endif
      endif

!----- cvm (if needed) -----!

      IF( neweqts.ge.1 .and. (idiss.eq.1.or.rterm.eq.1) )THEN
        ! store cvm in dum1:
        ! store ql  in dum2:
        ! store qi  in dum3:
        call getqli(0,qa,dum2,dum3)
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          dum1(i,j,k)=cv+cvv*qa(i,j,k,nqv)+cpl*dum2(i,j,k)+cpi*dum3(i,j,k)
        enddo
        enddo
        enddo
      ENDIF

!----- store appropriate rho for budget calculations in dum2 -----!

      IF(axisymm.eq.1)THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          dum2(i,j,k) = rho(i,j,k)*pi*(xf(i+1)**2-xf(i)**2)/(dx*dy)
        enddo
        enddo
        enddo
      ELSE
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          dum2(i,j,k) = rho(i,j,k)
        enddo
        enddo
        enddo
      ENDIF

!---- Dissipative heating term:

      IF(idiss.eq.1)THEN
        ! use dissten array to store epsilon
        if(imoist.eq.1.and.neweqts.ge.1)then
          ! moist, new equations:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            thten1(i,j,k)=thten1(i,j,k)   &
                        +dissten(i,j,k)/( cpdcv*dum1(i,j,k)*(pi0(i,j,k)+ppi(i,j,k)) )
          enddo
          enddo
          enddo
        else
          ! traditional equations:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            thten1(i,j,k)=thten1(i,j,k)   &
                        +dissten(i,j,k)/( cp*(pi0(i,j,k)+ppi(i,j,k)) )
          enddo
          enddo
          enddo
        endif
      ENDIF

#ifdef MICROBURST
      do k=1,nk
      do j=1,nj
      do i=1,ni
        thten1(i,j,k)=thten1(i,j,k) + q1forc * q1mb(i,j,k) + q2forc * q2mb(i,j,k)
      enddo
      enddo
      enddo
#endif

!---- Rotunno-Emanuel "radiation" term
!---- (currently capped at 2 K/day ... see RE87 p 546)

      IF(rterm.eq.1)THEN
!$omp parallel do default(shared)  &
!$omp private(k)
        do k=1,nk
          bud(k)=0.0d0
        enddo
!$omp parallel do default(shared)  &
!$omp private(i,j,k,thrad,prad)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ! NOTE:  thrad is a POTENTIAL TEMPERATURE tendency
          thrad = -tha(i,j,k)/(12.0*3600.0)
          if( tha(i,j,k).gt. 1.0 ) thrad = -1.0/(12.0*3600.0)
          if( tha(i,j,k).lt.-1.0 ) thrad =  1.0/(12.0*3600.0)
          thten1(i,j,k)=thten1(i,j,k)+thrad
          ! associated pressure tendency:
          prad = (pi0(i,j,k)+ppi(i,j,k))*rddcv*thrad/(th0(i,j,k)+tha(i,j,k))
          ! budget:
          bud(k) = bud(k) + dum1(i,j,k)*dum2(i,j,k)*ruh(i)*rvh(j)*rmh(i,j,k)*( &
                            thrad*(pi0(i,j,k)+ppi(i,j,k))    &
                           + prad*(th0(i,j,k)+tha(i,j,k)) )
        enddo
        enddo
        enddo
        tem = dt*dx*dy*dz
        do k=1,nk
          qbudget(10) = qbudget(10) + tem*bud(k)
        enddo
      ENDIF
      if(timestats.ge.1) time_misc=time_misc+mytime()

      if( (iturb.ge.1).or.(dns.eq.1) )then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=0,nk+1
        do j=0,nj+1
        do i=0,ni+1
          sten(i,j,k)=th0(i,j,k)+tha(i,j,k)
        enddo
        enddo
        enddo
      endif

      if(dns.eq.1)then
        call diff2s(2,rxh,uh,xf,uf,vh,vf,mh,mf,dum1,dum2,dum3,sten,thten1)
      endif

      IF( radopt.eq.1 )THEN
        ! tendency from radiation scheme:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          thten1(i,j,k)=thten1(i,j,k)+(swten(i,j,k)+lwten(i,j,k))
        enddo
        enddo
        enddo
        if(timestats.ge.1) time_rad=time_rad+mytime()
      ENDIF

      IF( ipbl.eq.1 )THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          thten1(i,j,k) = thten1(i,j,k) + thpten(i,j,k)
        enddo
        enddo
        enddo
        if(timestats.ge.1) time_pbl=time_pbl+mytime()
      ENDIF

      if(iturb.ge.1)then
        call turbs(1,dt,dosfcflx,xh,rxh,uh,xf,uf,vh,vf,mh,mf,rho0,rr0,rf0,thflux,   &
                   dum1,dum2,dum3,dum4,divx,sten,thten1,khh,khv,gx,gy,doimpl)
      endif

!-------------------------------------------------------------------
!  contribution to pressure tendency from potential temperature:

      IF(neweqts.ge.1.or.imoist.eq.0)THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ppten(i,j,k) = thten1(i,j,k)*rddcv   &
                        *(pi0(i,j,k)+ppi(i,j,k))/(th0(i,j,k)+tha(i,j,k))
        enddo
        enddo
        enddo
      ELSE
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ppten(i,j,k) = 0.0
        enddo
        enddo
        enddo
      ENDIF
      if(timestats.ge.1) time_misc=time_misc+mytime()

!-------------------------------------------------------------------
!  budget calculations:

      if(dosfcflx.and.imoist.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(j)
        do j=1,nj
          bud2(j) = 0.0d0
        enddo
!$omp parallel do default(shared)  &
!$omp private(i,j,k,delpi,delth,delqv,delt,n)
        do j=1,nj
        do i=1,ni
          k = 1
          delth = rf0(i,j,1)*rr0(i,j,1)*rdz*mh(i,j,1)*thflux(i,j)
          delqv = rf0(i,j,1)*rr0(i,j,1)*rdz*mh(i,j,1)*qvflux(i,j)
          delpi = rddcv*(pi0(i,j,1)+ppi(i,j,1))*(           &
                                delqv/(eps+qa(i,j,1,nqv))   &
                               +delth/(th0(i,j,1)+tha(i,j,1))  )
          delt = (pi0(i,j,k)+ppi(i,j,k))*delth   &
                +(th0(i,j,k)+tha(i,j,k))*delpi
          bud2(j) = bud2(j) + dum2(i,j,k)*ruh(i)*rvh(j)*rmh(i,j,k)*(        &
                  cv*delt                                                   &
                + cvv*qa(i,j,k,nqv)*delt                                    &
                + cvv*(pi0(i,j,k)+ppi(i,j,k))*(th0(i,j,k)+tha(i,j,k))*delqv &
                + g*zh(i,j,k)*delqv   )
          do n=nql1,nql2
            bud2(j) = bud2(j) + dum2(i,j,k)*ruh(i)*rvh(j)*rmh(i,j,k)*cpl*qa(i,j,k,n)*delt
          enddo
          if(iice.eq.1)then
            do n=nqs1,nqs2
              bud2(j) = bud2(j) + dum2(i,j,k)*ruh(i)*rvh(j)*rmh(i,j,k)*cpi*qa(i,j,k,n)*delt
            enddo
          endif
        enddo
        enddo
        tem = dt*dx*dy*dz
        do j=1,nj
          qbudget(9) = qbudget(9) + tem*bud2(j)
        enddo
        if(timestats.ge.1) time_misc=time_misc+mytime()
      endif

!-------------------------------------------------------------------
!  Passive Tracers

      if(iptra.eq.1)then
        do n=1,npt
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ptten(i,j,k,n)=0.0
          enddo
          enddo
          enddo
          if(timestats.ge.1) time_misc=time_misc+mytime()
          if(idiff.eq.1)then
            if(difforder.eq.2)then
              call diff2s(1,rxh,uh,xf,uf,vh,vf,mh,mf,dum1,dum2,dum3,pta(ib,jb,kb,n),ptten(ib,jb,kb,n))
            elseif(difforder.eq.6)then
              ! for diff6, use '3d' array
              call diff6s(dt,ql0,dum1,dum2,dum3,pt3d(ib,jb,kb,n),ptten(ib,jb,kb,n))
            endif
          endif
          if(iturb.ge.1)then
            call turbs(0,dt,dosfcflx,xh,rxh,uh,xf,uf,vh,vf,mh,mf,rho0,rr0,rf0,qvflux,   &
                       dum1,dum2,dum3,dum4,divx,pta(ib,jb,kb,n),ptten(ib,jb,kb,n),khh,khv,gx,gy,doimpl)
          endif
        enddo
      endif

!-------------------------------------------------------------------
!  Moisture

      if(imoist.eq.1)then
        DO n=1,numq
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            qten(i,j,k,n)=0.0
          enddo
          enddo
          enddo
          if(timestats.ge.1) time_misc=time_misc+mytime()
!---------------------------
          ! qv:
          if(n.eq.nqv)then
            if(idiff.eq.1)then
              if(difforder.eq.2)then
                call diff2s(1,rxh,uh,xf,uf,vh,vf,mh,mf,dum1,dum2,dum3,qa(ib,jb,kb,n),qten(ib,jb,kb,n))
              elseif(difforder.eq.6)then
                ! for diff6, use '3d' array
                call diff6s(dt,qv0,dum1,dum2,dum3,q3d(ib,jb,kb,n),qten(ib,jb,kb,n))
              endif
            endif
            if(iturb.ge.1)then
              call turbs(1,dt,dosfcflx,xh,rxh,uh,xf,uf,vh,vf,mh,mf,rho0,rr0,rf0,qvflux,   &
                         dum1,dum2,dum3,dum4,divx,qa(ib,jb,kb,n),qten(ib,jb,kb,n),khh,khv,gx,gy,doimpl)
            endif
            if(ipbl.eq.1)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
              do k=1,nk
              do j=1,nj
              do i=1,ni
                qten(i,j,k,nqv) = qten(i,j,k,nqv) + qvpten(i,j,k)
              enddo
              enddo
              enddo
              if(timestats.ge.1) time_pbl=time_pbl+mytime()
            endif
            IF(neweqts.ge.1)THEN
              ! contribution to pressure tendency from water vapor:
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
              do k=1,nk
              do j=1,nj
              do i=1,ni
                ppten(i,j,k)=ppten(i,j,k)+qten(i,j,k,n)   &
                            *rddcv*(pi0(i,j,k)+ppi(i,j,k))/(eps+qa(i,j,k,n))
              enddo
              enddo
              enddo
              if(timestats.ge.1) time_misc=time_misc+mytime()
            ENDIF
!---------------------------
          ! not qv:
          else
            if(idiff.eq.1)then
              if(difforder.eq.2)then
                call diff2s(1,rxh,uh,xf,uf,vh,vf,mh,mf,dum1,dum2,dum3,qa(ib,jb,kb,n),qten(ib,jb,kb,n))
              elseif(difforder.eq.6)then
                ! for diff6, use '3d' array
                call diff6s(dt,ql0,dum1,dum2,dum3,q3d(ib,jb,kb,n),qten(ib,jb,kb,n))
              endif
            endif
            if(iturb.ge.1)then
              call turbs(0,dt,dosfcflx,xh,rxh,uh,xf,uf,vh,vf,mh,mf,rho0,rr0,rf0,qvflux,   &
                         dum1,dum2,dum3,dum4,divx,qa(ib,jb,kb,n),qten(ib,jb,kb,n),khh,khv,gx,gy,doimpl)
            endif
          endif
!---------------------------
        ENDDO
        IF(ipbl.eq.1)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            if(nqc.ne.0)   &
            qten(i,j,k,nqc) = qten(i,j,k,nqc) + qcpten(i,j,k)
            if(nqi.ne.0)   &
            qten(i,j,k,nqi) = qten(i,j,k,nqi) + qipten(i,j,k)
          enddo
          enddo
          enddo
          if(timestats.ge.1) time_pbl=time_pbl+mytime()
        ENDIF
      endif

!-------------------------------------------------------------------


!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CC   Begin RK section   CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      ! time at end of full timestep:
      rtime=sngl(mtime+dt)

!--------------------------------------------------------------------
! RK3 begin

      DO NRK=1,3

        dttmp=dt/float(4-nrk)

!--------------------------------------------------------------------

      ! terms in theta and pi equations for proper mass/energy conservation
      ! Reference:  Bryan and Fritsch (2002, MWR)
      IF(neweqts.ge.1 .and. imoist.eq.1)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          dum4(i,j,k)=cpl*q3d(i,j,k,nql1)
        enddo
        enddo
        enddo

        IF(nql2.ge.2)THEN
        DO n=(nql1+1),nql2
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            dum4(i,j,k)=dum4(i,j,k)+cpl*q3d(i,j,k,n)
          enddo
          enddo
          enddo
        ENDDO
        ENDIF

        if(iice.eq.1)then
          DO n=nqs1,nqs2
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
            do k=1,nk
            do j=1,nj
            do i=1,ni
              dum4(i,j,k)=dum4(i,j,k)+cpi*q3d(i,j,k,n)
            enddo
            enddo
            enddo
          ENDDO
        endif

!$omp parallel do default(shared)   &
!$omp private(i,j,k,cpm,cvm)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          cpm=cp+cpv*q3d(i,j,k,nqv)+dum4(i,j,k)
          cvm=cv+cvv*q3d(i,j,k,nqv)+dum4(i,j,k)
          thterm(i,j,k)=( rd+rv*q3d(i,j,k,nqv)-rovcp*cpm )/cvm
          t22(i,j,k)=rovcp*cpm/cvm
        enddo
        enddo
        enddo

      ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          t22(i,j,k)=rddcv
        enddo
        enddo
        enddo

      ENDIF   ! for neweqts=1
      if(timestats.ge.1) time_misc=time_misc+mytime()

!--------------------------------------------------------------------
        IF(nrk.ge.2)THEN
#ifdef MPI
          call comm_3u_end(u3d,uw31,uw32,ue31,ue32,   &
                               us31,us32,un31,un32,reqs_u)
          call comm_3v_end(v3d,vw31,vw32,ve31,ve32,   &
                               vs31,vs32,vn31,vn32,reqs_v)
          call comm_3w_end(w3d,ww31,ww32,we31,we32,   &
                               ws31,ws32,wn31,wn32,reqs_w)
#endif
          if(terrain_flag)then
            call bcwsfc(dzdx,dzdy,u3d,v3d,w3d)
            call bc2d(w3d(ib,jb,1))
          endif
        ENDIF
!--------------------------------------------------------------------

        IF(.not.terrain_flag)THEN

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=2,nk
          do j=0,nj+1
          do i=0,ni+1
            rrw(i,j,k)=rf0(i,j,k)*w3d(i,j,k)
          enddo
          enddo
          enddo
          if(timestats.ge.1) time_advs=time_advs+mytime()

        ELSE

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=2,nk
          do j=1,nj
          do i=1,ni
            rrw(i,j,k)=rf0(i,j,k)*( w3d(i,j,k)*gz(i,j)                 &
                 +0.25*(sigma(k)-zt)/(zt-zs(i,j))*(                    &
                       ( (u3d(i+1,j,k-1)+u3d(i  ,j,k-1))               &
                        +(u3d(i+1,j,k  )+u3d(i  ,j,k  )) )*dzdx(i,j)   &
                      +( (v3d(i,j+1,k-1)+v3d(i,j  ,k-1))               &
                        +(v3d(i,j+1,k  )+v3d(i,j  ,k  )) )*dzdy(i,j) ) )
          enddo
          enddo
          enddo
          if(timestats.ge.1) time_advs=time_advs+mytime()

          call bcw(rrw,0)
#ifdef MPI
          call comm_1w_start(rrw,ww1,ww2,we1,we2,   &
                                 ws1,ws2,wn1,wn2,reqs_w)
#endif

        ENDIF

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=0,nj+1
        do i=0,ni+2
          rru(i,j,k)=0.5*(rho0(i-1,j,k)+rho0(i,j,k))*u3d(i,j,k)
        enddo
        enddo
        enddo

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=0,nj+2
        do i=0,ni+1
          rrv(i,j,k)=0.5*(rho0(i,j-1,k)+rho0(i,j,k))*v3d(i,j,k)
        enddo
        enddo
        enddo
        if(timestats.ge.1) time_advs=time_advs+mytime()

#ifdef MPI
        if(terrain_flag)then
          call comm_1w_end(rrw,ww1,ww2,we1,we2,   &
                               ws1,ws2,wn1,wn2,reqs_w)
        endif
#endif

        IF(.not.terrain_flag)THEN

!------------
        IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=0,nj+1
          do i=0,ni+1
            divx(i,j,k)=(rru(i+1,j,k)-rru(i,j,k))*rdx*uh(i)        &
                       +(rrv(i,j+1,k)-rrv(i,j,k))*rdy*vh(j)        &
                       +(rrw(i,j,k+1)-rrw(i,j,k))*rdz*mh(i,j,k)
          enddo
          enddo
          enddo

        ELSE

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=0,nj+1
          do i=0,ni+1
            divx(i,j,k)=(xf(i+1)*rru(i+1,j,k)-xf(i)*rru(i,j,k))*rdx*uh(i)*rxh(i)   &
                       +(rrw(i,j,k+1)-rrw(i,j,k))*rdz*mh(i,j,k)
          enddo
          enddo
          enddo

        ENDIF
!------------

        ELSE

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=0,nj+1
          do i=0,ni+1
            divx(i,j,k)=(rru(i+1,j,k)-rru(i,j,k))*rdx*uh(i)        &
                       +(rrv(i,j+1,k)-rrv(i,j,k))*rdy*vh(j)        &
                       +(rrw(i,j,k+1)-rrw(i,j,k))*rdz*mh(i,j,k)/gz(i,j)
          enddo
          enddo
          enddo

        ENDIF
        if(timestats.ge.1) time_divx=time_divx+mytime()


!--------------------------------------------------------------------
!  TKE advection
 
        IF(iturb.eq.1)THEN

          ! use wten for tke tendency, step tke forward:

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=1,nkt
          do j=1,nj
          do i=1,ni
            wten(i,j,k)=tketen(i,j,k)
          enddo
          enddo
          enddo
          if(timestats.ge.1) time_misc=time_misc+mytime()

#ifdef MPI
        IF(nrk.ge.2)THEN
          call comm_3t_end(tke3d,tkw1,tkw2,tke1,tke2,   &
                                 tks1,tks2,tkn1,tkn2,reqs_tk)
        ENDIF
#endif

          if(hadvorder.eq.5)then
            call adv5w(xh,rxh,uh,xf,vh,gz,mf,rho0,rr0,rf0,rrf0,dum1,dum2,dum3,dum4,divx,  &
                       rru,rrv,rrw,tke3d,wten)
          elseif(hadvorder.eq.6)then
            call adv6w(xh,rxh,uh,xf,vh,gz,mf,rho0,rr0,rf0,rrf0,dum1,dum2,dum3,dum4,divx,  &
                       rru,rrv,rrw,tke3d,wten)
          endif

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=1,nkt
          do j=1,nj
          do i=1,ni
            tke3d(i,j,k)=tkea(i,j,k)+dttmp*wten(i,j,k)
          enddo
          enddo
          enddo
          if(timestats.ge.1) time_misc=time_misc+mytime()

          if(nrk.eq.3)then
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
            do k=1,nkt
            do j=1,nj
            do i=1,ni
              if(tke3d(i,j,k).lt.1.0e-6) tke3d(i,j,k)=0.0
            enddo
            enddo
            enddo
          endif
          if(timestats.ge.1) time_integ=time_integ+mytime()


          call bct(tke3d)
#ifdef MPI
          call comm_3t_start(tke3d,tkw1,tkw2,tke1,tke2,   &
                                   tks1,tks2,tkn1,tkn2,reqs_tk)
#endif

        ENDIF

!--------------------------------------------------------------------
!  Passive Tracers

        if(iptra.eq.1)then
          DO n=1,npt

      ! t33 = dummy

      bflag=0
      if(stat_qsrc.eq.1 .and. nrk.eq.3) bflag=1

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        sten(i,j,k)=ptten(i,j,k,n)
      enddo
      enddo
      enddo
      if(timestats.ge.1) time_misc=time_misc+mytime()


      if(nrk.eq.3)then
        pdef = 1
      else
        pdef = 0
      endif

#ifdef MPI
          IF(nrk.ge.2)THEN
            call comm_3s_end(pt3d(ib,jb,kb,n),                           &
                  tw1(1,1,1,n),tw2(1,1,1,n),te1(1,1,1,n),te2(1,1,1,n),   &
                  ts1(1,1,1,n),ts2(1,1,1,n),tn1(1,1,1,n),tn2(1,1,1,n),   &
                  reqs_t(1,n))
          ENDIF
#endif


    IF( (advweno.eq.1) .or. (advweno.eq.2.and.nrk.eq.3) )THEN
        call wenos(bflag,bfoo,xh,rxh,uh,ruh,xf,vh,rvh,gz,mh,rmh,       &
                   rho0,rr0,rf0,rrf0,dum1,dum2,dum3,dum4,   &
                   divx,rru,rrv,rrw,pt3d(ib,jb,kb,n),sten,dt)
    ELSE
      if(hadvorder.eq.5.or.advweno.ge.1)then
        call adv5s(bflag,bfoo,xh,rxh,uh,ruh,xf,vh,rvh,gz,mh,rmh,       &
                   rho0,rr0,rf0,rrf0,dum1,dum2,dum3,dum4,divx,t33,   &
                   rru,rrv,rrw,pta(ib,jb,kb,n),pt3d(ib,jb,kb,n),sten,pdef,dttmp)
      elseif(hadvorder.eq.6)then
        call adv6s(bflag,bfoo,xh,rxh,uh,ruh,xf,vh,rvh,gz,mh,rmh,       &
                   rho0,rr0,rf0,rrf0,dum1,dum2,dum3,dum4,divx,t33,   &
                   rru,rrv,rrw,pta(ib,jb,kb,n),pt3d(ib,jb,kb,n),sten,pdef,dttmp)
      endif
    ENDIF

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        pt3d(i,j,k,n)=pta(i,j,k,n)+dttmp*sten(i,j,k)
      enddo
      enddo
      enddo
      if(timestats.ge.1) time_integ=time_integ+mytime()

        if(nrk.eq.3) call pdefq(0.0,afoo,ruh,rvh,rmh,rho,pt3d(ib,jb,kb,n))

        call bcs(pt3d(ib,jb,kb,n))
#ifdef MPI
        call comm_3s_start(pt3d(ib,jb,kb,n)   &
                     ,tw1(1,1,1,n),tw2(1,1,1,n),te1(1,1,1,n),te2(1,1,1,n)     &
                     ,ts1(1,1,1,n),ts2(1,1,1,n),tn1(1,1,1,n),tn2(1,1,1,n)     &
                     ,reqs_t(1,n) )
#endif

          ENDDO
        endif

!--------------------------------------------------------------------
!  finish comms for q/theta:
#ifdef MPI
        IF(nrk.ge.2)THEN
        if(imoist.eq.1)then
          DO n=numq,1,-1
            call comm_3s_end(q3d(ib,jb,kb,n),                            &
                  qw1(1,1,1,n),qw2(1,1,1,n),qe1(1,1,1,n),qe2(1,1,1,n),   &
                  qs1(1,1,1,n),qs2(1,1,1,n),qn1(1,1,1,n),qn2(1,1,1,n),   &
                  reqs_q(1,n))
          ENDDO
        endif
          call comm_3s_end(th3d,sw31,sw32,se31,se32,   &
                                ss31,ss32,sn31,sn32,reqs_s)
        ENDIF
#endif
!--------------------------------------------------------------------
!  Calculate misc. variables
!
!    These arrays store variables that are used later in the
!    SOUND subroutine.  Do not modify t11 or t22 until after sound!
!    dum1 = vapor
!    dum2 = all liquid
!    dum3 = all solid

        IF(imoist.eq.1)THEN

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=0,nj+1
          do i=0,ni+1
            dum1(i,j,k)=max(q3d(i,j,k,nqv),0.0)
          enddo
          enddo
          enddo

          call getqli(1,q3d,dum2,dum3)

        ELSE

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=0,nj+1
          do i=0,ni+1
            dum1(i,j,k)=0.0
            dum2(i,j,k)=0.0
            dum3(i,j,k)=0.0
          enddo
          enddo
          enddo

        ENDIF

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=0,nj+1
        do i=0,ni+1
          t11(i,j,k)=(th0(i,j,k)+th3d(i,j,k))*(1.0+reps*dum1(i,j,k))     &
                     /(1.0+dum1(i,j,k)+max(0.0,dum2(i,j,k))+max(0.0,dum3(i,j,k)))
        enddo
        enddo
        enddo

        IF(thsmall.eq.1.and.imoist.eq.1)THEN
          ! save qv,ql,qi for buoyancy calculation:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            t12(i,j,k)=dum1(i,j,k)
            t13(i,j,k)=max(0.0,dum2(i,j,k))+max(0.0,dum3(i,j,k))
          enddo
          enddo
          enddo
        ENDIF

        if(timestats.ge.1) time_buoyan=time_buoyan+mytime()


!--------------------------------------------------------------------
! Moisture

        if(imoist.eq.1)then
          DO n=numq,1,-1

      ! t33 = dummy

      bflag=0
      if(stat_qsrc.eq.1 .and. nrk.eq.3) bflag=1

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        sten(i,j,k)=qten(i,j,k,n)
      enddo
      enddo
      enddo
      if(timestats.ge.1) time_misc=time_misc+mytime()


      if(nrk.eq.3)then
        pdef = 1
      else
        pdef = 0
      endif


    IF( (advweno.eq.1) .or. (advweno.eq.2.and.nrk.eq.3) )THEN
        call wenos(bflag,bsq(n),xh,rxh,uh,ruh,xf,vh,rvh,gz,mh,rmh,       &
                   rho0,rr0,rf0,rrf0,dum1,dum2,dum3,dum4,   &
                   divx,rru,rrv,rrw,q3d(ib,jb,kb,n),sten,dt)
    ELSE
      if(hadvorder.eq.5.or.advweno.ge.1)then
        call adv5s(bflag,bsq(n),xh,rxh,uh,ruh,xf,vh,rvh,gz,mh,rmh,       &
                   rho0,rr0,rf0,rrf0,dum1,dum2,dum3,dum4,divx,t33,   &
                   rru,rrv,rrw,qa(ib,jb,kb,n),q3d(ib,jb,kb,n),sten,pdef,dttmp)
      elseif(hadvorder.eq.6)then
        call adv6s(bflag,bsq(n),xh,rxh,uh,ruh,xf,vh,rvh,gz,mh,rmh,       &
                   rho0,rr0,rf0,rrf0,dum1,dum2,dum3,dum4,divx,t33,   &
                   rru,rrv,rrw,qa(ib,jb,kb,n),q3d(ib,jb,kb,n),sten,pdef,dttmp)
      endif
    ENDIF

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        q3d(i,j,k,n)=qa(i,j,k,n)+dttmp*sten(i,j,k)
      enddo
      enddo
      enddo
      if(timestats.ge.1) time_integ=time_integ+mytime()

      IF(nrk.lt.3)THEN
        qcom = .true.
        if(neweqts.eq.2.and.(n.eq.nqv.or.n.eq.2.or.n.eq.4)) qcom = .false.
        if( qcom )then
        call bcs(q3d(ib,jb,kb,n))
#ifdef MPI
        call comm_3s_start(q3d(ib,jb,kb,n)   &
                     ,qw1(1,1,1,n),qw2(1,1,1,n),qe1(1,1,1,n),qe2(1,1,1,n)     &
                     ,qs1(1,1,1,n),qs2(1,1,1,n),qn1(1,1,1,n),qn2(1,1,1,n)     &
                     ,reqs_q(1,n) )
#endif
        endif
      ENDIF

          ENDDO
        endif

!--------------------------------------------------------------------
!  THETA-equation

      ! t23  = theta used for advection  (full theta if thsmall=0)
      ! t33  = dummy

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        thten(i,j,k)=thten1(i,j,k)
      enddo
      enddo
      enddo

    IF(thsmall.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=kb,ke
      do j=jb,je
      do i=ib,ie
        t23(i,j,k)=th0(i,j,k)+th3d(i,j,k)
      enddo
      enddo
      enddo

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=kb,ke
      do j=jb,je
      do i=ib,ie
        if(abs(th3d(i,j,k)).lt.smeps)then
          t23(i,j,k)=0.0
        else
          t23(i,j,k)=th3d(i,j,k)
        endif
      enddo
      enddo
      enddo

    ENDIF
      if(timestats.ge.1) time_misc=time_misc+mytime()


    IF( (advweno.eq.1) .or. (advweno.eq.2.and.nrk.eq.3) )THEN
        call wenos(0,bfoo,xh,rxh,uh,ruh,xf,vh,rvh,gz,mh,rmh,          &
                   rho0,rr0,rf0,rrf0,dum1,dum2,dum3,dum4,   &
                   divx,rru,rrv,rrw,t23,thten,dt)
    ELSE
      if(hadvorder.eq.5.or.advweno.ge.1)then
        call adv5s(0,bfoo,xh,rxh,uh,ruh,xf,vh,rvh,gz,mh,rmh,          &
                   rho0,rr0,rf0,rrf0,dum1,dum2,dum3,dum4,divx,t33,   &
                   rru,rrv,rrw,tha,t23,thten,0,dttmp)
      elseif(hadvorder.eq.6)then
        call adv6s(0,bfoo,xh,rxh,uh,ruh,xf,vh,rvh,gz,mh,rmh,          &
                   rho0,rr0,rf0,rrf0,dum1,dum2,dum3,dum4,divx,t33,   &
                   rru,rrv,rrw,tha,t23,thten,0,dttmp)
      endif
    ENDIF


    IF(thsmall.eq.0.and.neweqts.ge.1.and.imoist.eq.1)THEN

      ! this section of code only accessed if thsmall=0
      ! (for which t23 = full theta)

      IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          thten(i,j,k)=thten(i,j,k)-t23(i,j,k)*(              &
                      (u3d(i+1,j,k)-u3d(i,j,k))*rdx*uh(i)      &
                     +(v3d(i,j+1,k)-v3d(i,j,k))*rdy*vh(j)      &
                     +(w3d(i,j,k+1)-w3d(i,j,k))*rdz*mh(i,j,k) )    &
                    *thterm(i,j,k)
        enddo
        enddo
        enddo

      ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          thten(i,j,k)=thten(i,j,k)-t23(i,j,k)*(              &
                      (xf(i+1)*u3d(i+1,j,k)-xf(i)*u3d(i,j,k))*rdx*uh(i)*rxh(i)      &
                     +(w3d(i,j,k+1)-w3d(i,j,k))*rdz*mh(i,j,k) )    &
                    *thterm(i,j,k)
        enddo
        enddo
        enddo

      ENDIF

        IF(terrain_flag)THEN

          ! dum1 = dudz
          ! dum4 = dvdz

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=2,nk-1
          do j=1,nj
          do i=1,ni+1
            dum1(i,j,k)=gx(i,j,k)*(u3d(i,j,k+1)-u3d(i,j,k-1))*rdz2
          enddo
          enddo
          enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
          do j=1,nj
          do i=1,ni+1
            dum1(i,j,1 )=gx(i,j,1 )*(u3d(i,j,2 )-u3d(i,j,1   ))*rdz
            dum1(i,j,nk)=gx(i,j,nk)*(u3d(i,j,nk)-u3d(i,j,nk-1))*rdz
          enddo
          enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=2,nk-1
          do j=1,nj+1
          do i=1,ni
            dum4(i,j,k)=gy(i,j,k)*(v3d(i,j,k+1)-v3d(i,j,k-1))*rdz2
          enddo
          enddo
          enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
          do j=1,nj+1
          do i=1,ni
            dum4(i,j,1 )=gy(i,j,1 )*(v3d(i,j,2 )-v3d(i,j,1   ))*rdz
            dum4(i,j,nk)=gy(i,j,nk)*(v3d(i,j,nk)-v3d(i,j,nk-1))*rdz
          enddo
          enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            thten(i,j,k)=thten(i,j,k)-t23(i,j,k)*0.5*(      &
                           (dum1(i,j,k)+dum1(i+1,j,k))       &
                          +(dum4(i,j,k)+dum4(i,j+1,k))  )    &
                      *thterm(i,j,k)
          enddo
          enddo
          enddo

        ENDIF   ! for terrain

    ENDIF
    if(timestats.ge.1) time_misc=time_misc+mytime()

    IF(thsmall.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        th3d(i,j,k)=tha(i,j,k)+dttmp*thten(i,j,k)
      enddo
      enddo
      enddo
      if(timestats.ge.1) time_integ=time_integ+mytime()

      tcom = .true.
      if(imoist.eq.1.and.neweqts.eq.2) tcom = .false. ! dont start comm for neweqts=2
      if(imoist.eq.1.and.nrk.eq.3) tcom = .false.     ! dont start comm if moist & nrk=3
      if(thsmall.eq.1) tcom = .false.                 ! dont start comm if thsmall=1

      IF( tcom )THEN
        call bcs(th3d)
#ifdef MPI
        call comm_3s_start(th3d,sw31,sw32,se31,se32,   &
                                ss31,ss32,sn31,sn32,reqs_s)
#endif
      ENDIF

    ENDIF

!--------------------------------------------------------------------
!  Pressure equation

      ! t22  = ppterm
      ! t33  = dummy

      IF(psolver.le.3)THEN

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          sten(i,j,k)=ppten(i,j,k)
        enddo
        enddo
        enddo
        if(timestats.ge.1) time_misc=time_misc+mytime()

#ifdef MPI
        IF(nrk.ge.2)THEN
          call comm_3s_end(pp3d,pw31,pw32,pe31,pe32,   &
                                ps31,ps32,pn31,pn32,reqs_p)
        ENDIF
#endif

        if(hadvorder.eq.5)then
          call adv5s(0,bfoo,xh,rxh,uh,ruh,xf,vh,rvh,gz,mh,rmh,         &
                     rho0,rr0,rf0,rrf0,dum1,dum2,dum3,dum4,divx,t33,   &
                     rru,rrv,rrw,ppi,pp3d,sten,0,dttmp)
        elseif(hadvorder.eq.6)then
          call adv6s(0,bfoo,xh,rxh,uh,ruh,xf,vh,rvh,gz,mh,rmh,         &
                     rho0,rr0,rf0,rrf0,dum1,dum2,dum3,dum4,divx,t33,   &
                     rru,rrv,rrw,ppi,pp3d,sten,0,dttmp)
        endif

        IF(imoist.eq.1.and.neweqts.eq.2)THEN

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            t33(i,j,k)=ppi(i,j,k)+dttmp*sten(i,j,k)
            t23(i,j,k)=t33(i,j,k)
          enddo
          enddo
          enddo

          IF(thsmall.eq.1)THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
            do k=1,nk
            do j=1,nj
            do i=1,ni
              th3d(i,j,k)=tha(i,j,k)+dttmp*thten(i,j,k)
            enddo
            enddo
            enddo
          ENDIF
          if(timestats.ge.1) time_satadj=time_satadj+mytime()

          call calcprs(pi0,prs,t33)
          call calcrho(pi0,th0,rho,prs,t33,th3d,q3d)
          IF(nrk.ge.3)THEN
            IF(axisymm.eq.0)THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
              do k=1,nk
              do j=1,nj
              do i=1,ni
                dum3(i,j,k)=rho(i,j,k)
              enddo
              enddo
              enddo
            ELSE
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
              do k=1,nk
              do j=1,nj
              do i=1,ni
                dum3(i,j,k) = rho(i,j,k)*pi*(xf(i+1)**2-xf(i)**2)/(dx*dy)
              enddo
              enddo
              enddo
            ENDIF
          ENDIF
          if(ptype.eq.1.or.ptype.eq.3.or.ptype.eq.5.or.ptype.eq.6)then
            call satadj(nrk,qbudget(1),qbudget(2),ruh,rvh,rmh,pi0,th0,   &
                        rho,dum3,t33,prs,th3d,q3d)
          elseif(ptype.eq.2)then
            call satadj_ice(nrk,qbudget(1),qbudget(2),ruh,rvh,rmh,pi0,th0,   &
                            rho,dum3,t33,prs,th3d,                      &
                q3d(ib,jb,kb,1),q3d(ib,jb,kb,2),q3d(ib,jb,kb,3),   &
                q3d(ib,jb,kb,4),q3d(ib,jb,kb,5),q3d(ib,jb,kb,6))
          endif

          IF(thsmall.eq.1)THEN
            rdt=1.0/dttmp
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
            do k=1,nk
            do j=1,nj
            do i=1,ni
              thten(i,j,k)=(th3d(i,j,k)-tha(i,j,k))*rdt
            enddo
            enddo
            enddo
            if(timestats.ge.1) time_satadj=time_satadj+mytime()
          ENDIF

          if(nrk.lt.3)then
            call bcs(q3d(ib,jb,kb,nqv))
#ifdef MPI
            call comm_3s_start(q3d(ib,jb,kb,nqv),                            &
              qw1(1,1,1,nqv),qw2(1,1,1,nqv),qe1(1,1,1,nqv),qe2(1,1,1,nqv),   &
              qs1(1,1,1,nqv),qs2(1,1,1,nqv),qn1(1,1,1,nqv),qn2(1,1,1,nqv),   &
              reqs_q(1,nqv))
#endif
            call bcs(q3d(ib,jb,kb,2))
#ifdef MPI
            call comm_3s_start(q3d(ib,jb,kb,2),                            &
              qw1(1,1,1,2),qw2(1,1,1,2),qe1(1,1,1,2),qe2(1,1,1,2),   &
              qs1(1,1,1,2),qs2(1,1,1,2),qn1(1,1,1,2),qn2(1,1,1,2),   &
              reqs_q(1,2))
#endif
            if(iice.eq.1)then
              call bcs(q3d(ib,jb,kb,4))
#ifdef MPI
              call comm_3s_start(q3d(ib,jb,kb,4),                            &
                qw1(1,1,1,4),qw2(1,1,1,4),qe1(1,1,1,4),qe2(1,1,1,4),   &
                qs1(1,1,1,4),qs2(1,1,1,4),qn1(1,1,1,4),qn2(1,1,1,4),   &
                reqs_q(1,4))
#endif
            endif
            if(thsmall.eq.0)then
              call bcs(th3d)
#ifdef MPI
              call comm_3s_start(th3d,sw31,sw32,se31,se32,   &
                                      ss31,ss32,sn31,sn32,reqs_s)
#endif
            endif
          endif

          rdt=1.0/dttmp

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            sten(i,j,k)=sten(i,j,k)+(t33(i,j,k)-t23(i,j,k))*rdt
          enddo
          enddo
          enddo
          if(timestats.ge.1) time_satadj=time_satadj+mytime()

        ENDIF

      ENDIF

!--------------------------------------------------------------------
!  U-equation

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni+1
          uten(i,j,k)=uten1(i,j,k)
        enddo
        enddo
        enddo
        if(timestats.ge.1) time_misc=time_misc+mytime()
 
        if(icor.eq.1)then

        if(pertcor.eq.1)then

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj+1
          do i=0,ni+1
            dum1(i,j,k)=v3d(i,j,k)-v0(i,j,k)
          enddo
          enddo
          enddo

        else

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj+1
          do i=0,ni+1
            dum1(i,j,k)=v3d(i,j,k)
          enddo
          enddo
          enddo

        endif

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni+1
            uten(i,j,k)=uten(i,j,k)+fcor*             &
             0.25*( (dum1(i  ,j,k)+dum1(i  ,j+1,k))   &
                   +(dum1(i-1,j,k)+dum1(i-1,j+1,k)) )
          enddo
          enddo
          enddo
          if(timestats.ge.1) time_cor=time_cor+mytime()

        endif

        if(axisymm.eq.1)then

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=2,ni+1
            uten(i,j,k)=uten(i,j,k)+0.5*(   &
                 ( v3d(i-1,j,k)**2)*rxh(i-1)+(v3d(i,j,k)**2)*rxh(i) )
          enddo
          enddo
          enddo

        endif

        if(hadvorder.eq.5)then
          call adv5u(xf,rxf,uf,vh,gz,mh,rho0,rr0,rf0,rrf0,rru0,dum1,dum2,dum3,dum4,divx,  &
                     rru,u3d,uten,rrv,rrw)
        elseif(hadvorder.eq.6)then
          call adv6u(xf,rxf,uf,vh,gz,mh,rho0,rr0,rf0,rrf0,rru0,dum1,dum2,dum3,dum4,divx,  &
                     rru,u3d,uten,rrv,rrw)
        endif

!--------------------------------------------------------------------
!  V-equation
 
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj+1
        do i=1,ni
          vten(i,j,k)=vten1(i,j,k)
        enddo
        enddo
        enddo
        if(timestats.ge.1) time_misc=time_misc+mytime()
 
        if(icor.eq.1)then

!--------------
          IF(axisymm.eq.0)THEN

        if(pertcor.eq.1)then

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=0,nj+1
          do i=1,ni+1
            dum1(i,j,k)=u3d(i,j,k)-u0(i,j,k)
          enddo
          enddo
          enddo

        else

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=0,nj+1
          do i=1,ni+1
            dum1(i,j,k)=u3d(i,j,k)
          enddo
          enddo
          enddo

        endif

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj+1
          do i=1,ni
            vten(i,j,k)=vten(i,j,k)-fcor*             &
             0.25*( (dum1(i,j  ,k)+dum1(i+1,j  ,k))   &
                   +(dum1(i,j-1,k)+dum1(i+1,j-1,k)) )
          enddo
          enddo
          enddo

          ELSE

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            vten(i,j,k)=vten(i,j,k)-fcor*0.5*(xf(i)*u3d(i,j,k)+xf(i+1)*u3d(i+1,j,k))*rxh(i)
          enddo
          enddo
          enddo

          ENDIF
!--------------

          if(timestats.ge.1) time_cor=time_cor+mytime()

        endif

        if(axisymm.eq.1)then

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            vten(i,j,k)=vten(i,j,k)-(v3d(i,j,k)*rxh(i))*0.5*(xf(i)*u3d(i,j,k)+xf(i+1)*u3d(i+1,j,k))*rxh(i)
          enddo
          enddo
          enddo

        endif

        if(hadvorder.eq.5)then
          call adv5v(xh,rxh,uh,xf,vf,gz,mh,rho0,rr0,rf0,rrf0,rrv0,dum1,dum2,dum3,dum4,divx,  &
                     rru,rrv,v3d,vten,rrw)
        elseif(hadvorder.eq.6)then
          call adv6v(xh,rxh,uh,xf,vf,gz,mh,rho0,rr0,rf0,rrf0,rrv0,dum1,dum2,dum3,dum4,divx,  &
                     rru,rrv,v3d,vten,rrw)
        endif

!--------------------------------------------------------------------
!  W-equation

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk+1
        do j=1,nj
        do i=1,ni
          wten(i,j,k)=wten1(i,j,k)
        enddo
        enddo
        enddo
        if(timestats.ge.1) time_misc=time_misc+mytime()
 
        if( (thsmall.eq.0) .or. (thsmall.eq.1.and.imoist.eq.1) )then
          ! buoyancy:
          IF(thsmall.eq.0)THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
            do k=1,nk
            do j=1,nj
            do i=1,ni
              dum2(i,j,k) = t11(i,j,k)/thv0(i,j,k)-1.0
            enddo
            enddo
            enddo
          ELSE
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
            do k=1,nk
            do j=1,nj
            do i=1,ni
              dum2(i,j,k) = repsm1*(t12(i,j,k)-qv0(i,j,k)) - (t13(i,j,k)-qc0(i,j,k))
            enddo
            enddo
            enddo
          ENDIF
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=2,nk
          do j=1,nj
          do i=1,ni
            wten(i,j,k)=wten(i,j,k)+govtwo*(dum2(i,j,k-1)+dum2(i,j,k))
          enddo
          enddo
          enddo
          if(timestats.ge.1) time_buoyan=time_buoyan+mytime()
        endif

        if(hadvorder.eq.5)then
          call adv5w(xh,rxh,uh,xf,vh,gz,mf,rho0,rr0,rf0,rrf0,dum1,dum2,dum3,dum4,divx,  &
                     rru,rrv,rrw,w3d,wten)
        elseif(hadvorder.eq.6)then
          call adv6w(xh,rxh,uh,xf,vh,gz,mf,rho0,rr0,rf0,rrf0,dum1,dum2,dum3,dum4,divx,  &
                     rru,rrv,rrw,w3d,wten)
        endif


!--------------------------------------------------------------------
!  Update v for axisymmetric model simulations:

        IF(axisymm.eq.1)THEN

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            v3d(i,j,k)=va(i,j,k)+dttmp*vten(i,j,k)
          enddo
          enddo
          enddo
          if(timestats.ge.1) time_misc=time_misc+mytime()

          call bcv(v3d)

        ENDIF

!--------------------------------------------------------------------
!  call sound

        IF(psolver.eq.1)THEN

          call soundns(xh,rxh,uh,xf,uf,yh,vh,yf,vf,zh,mh,mf,pi0,thv0,       &
                       radbcw,radbce,radbcs,radbcn,                &
                       divx,u0,ua,u3d,uten,v0,va,v3d,vten,wa,w3d,wten,   &
                       ppi,pp3d,sten,t11,t22,dttmp,nrk,rtime,      &
                       reqs_u,reqs_v,reqs_w,reqs_s,reqs_p,         &
                       uw31,uw32,ue31,ue32,us31,us32,un31,un32,    &
                       vw31,vw32,ve31,ve32,vs31,vs32,vn31,vn32,    &
                       ww31,ww32,we31,we32,ws31,ws32,wn31,wn32,    &
                       sw31,sw32,se31,se32,ss31,ss32,sn31,sn32,    &
                       pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2)

        ELSEIF(psolver.eq.2)THEN

          call sounde(dt,xh,rxh,uh,ruh,xf,uf,yh,vh,rvh,yf,vf,zh,mh,rmh,mf,rmf,   &
                     pi0,thv0,rho0,rr0,rf0,th0,dzdx,dzdy,            &
                     radbcw,radbce,radbcs,radbcn,                    &
                     dum1,dum2,dum3,dum4,divx,                       &
                     gx,u0,ua,u3d,uten,gy,v0,va,v3d,vten,wa,w3d,wten,      &
                     ppi,pp3d,sten,tha,th3d,thten,thterm,tk,         &
                     t11,t22,nrk,rtime,                              &
                     reqs_u,reqs_v,reqs_w,reqs_s,reqs_p,             &
                     uw31,uw32,ue31,ue32,us31,us32,un31,un32,        &
                     vw31,vw32,ve31,ve32,vs31,vs32,vn31,vn32,        &
                     ww31,ww32,we31,we32,ws31,ws32,wn31,wn32,        &
                     sw31,sw32,se31,se32,ss31,ss32,sn31,sn32,        &
                     pw31,pw32,pe31,pe32,ps31,ps32,pn31,pn32,        &
                     pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2)

        ELSEIF(psolver.eq.3)THEN

          ! rho,prs,divx are used as dummy arrays by sound

          call sound(dt,xh,rxh,uh,ruh,xf,uf,yh,vh,rvh,yf,vf,zh,mh,rmh,mf,rmf, &
                     pi0,thv0,rho0,rr0,rf0,th0,dzdx,dzdy,            &
                     radbcw,radbce,radbcs,radbcn,                    &
                     dum1,dum2,dum3,dum4,t12,t13,t23,t33,            &
                     gx,u0,ua,u3d,uten,gy,v0,va,v3d,vten,wa,w3d,wten,      &
                     ppi,pp3d,sten,tha,th3d,thten,thterm,tk,         &
                     t11,t22,rho,prs,divx,nrk,rtime,                 &
                     reqs_u,reqs_v,reqs_w,reqs_s,reqs_p,             &
                     uw31,uw32,ue31,ue32,us31,us32,un31,un32,        &
                     vw31,vw32,ve31,ve32,vs31,vs32,vn31,vn32,        &
                     ww31,ww32,we31,we32,ws31,ws32,wn31,wn32,        &
                     sw31,sw32,se31,se32,ss31,ss32,sn31,sn32,        &
                     pw31,pw32,pe31,pe32,ps31,ps32,pn31,pn32,        &
                     pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2)

        ELSEIF(psolver.eq.4.or.psolver.eq.5)THEN
          ! anelastic/incompressible solver:

          call anelp(xh,uh,xf,uf,yh,vh,yf,vf,                     &
                     zh,mh,rmh,mf,rmf,pi0,thv0,rho0,prs0,rf0,     &
                     radbcw,radbce,radbcs,radbcn,dum1,divx,       &
                     u0,ua,u3d,uten,v0,va,v3d,vten,wa,w3d,wten,   &
                     ppi,pp3d,t11,cfb,cfa,cfc,ad1,ad2,pdt,deft,rhs,trans,dttmp,nrk,rtime)

        ENDIF

!--------------------------------------------------------------------
!  radbc

        if(irbc.eq.4)then

          if(ibw.eq.1 .or. ibe.eq.1)then
            call radbcew4(ruf,radbcw,radbce,ua,u3d,dttmp)
          endif

          if(ibs.eq.1 .or. ibn.eq.1)then
            call radbcns4(rvf,radbcs,radbcn,va,v3d,dttmp)
          endif

        endif

!--------------------------------------------------------------------
! RK loop end

      ENDDO


!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CC   End of RK section   CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC


!--------------------------------------------------------------------
!  Get pressure

    IF(psolver.eq.4.or.psolver.eq.5)THEN

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        prs(i,j,k)=prs0(i,j,k)
      enddo
      enddo
      enddo
      if(timestats.ge.1) time_misc=time_misc+mytime()

    ELSE

      call calcprs(pi0,prs,pp3d)

    ENDIF

!--------------------------------------------------------------------
!  Get density

    IF(psolver.eq.4.or.psolver.eq.5)THEN

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        rho(i,j,k)=rho0(i,j,k)
      enddo
      enddo
      enddo
      if(timestats.ge.1) time_misc=time_misc+mytime()

    ELSE

      call calcrho(pi0,th0,rho,prs,pp3d,th3d,q3d)

    ENDIF

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CC   BEGIN microphysics   CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      IF(imoist.eq.1)THEN

        getdbz = .false.
        IF(output_dbz.eq.1)THEN
          rtime=sngl(mtime+dt)
          if( (rtime.ge.sngl(taptim)).or.stopit.or.ctrldropslice.eq.1.or.ctrldrophist.eq.1 )then
            getdbz = .true.
          endif
          if(getdbz)then
            if(myid.eq.0)write(outfile,*) '  Getting dbz ... '
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
            do k=1,nk
            do j=1,nj
            do i=1,ni
              sten(i,j,k)=0.0
            enddo
            enddo
            enddo
          endif
        ENDIF

!-----------------------------------------------------------------------
!  store t in dum1

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          dum1(i,j,k)=(th0(i,j,k)+th3d(i,j,k))*(pi0(i,j,k)+pp3d(i,j,k))
        enddo
        enddo
        enddo

!-----------------------------------------------------------------------
!  prep for efall calculation:  store cvm in dum2

        IF(efall.eq.1)THEN
          if(neweqts.ge.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
            do k=1,nk
            do j=1,nj
            do i=1,ni
              dum2(i,j,k)=q3d(i,j,k,nqv)
            enddo
            enddo
            enddo
            call getqli(0,q3d,dum3,dum4)
          else
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
            do k=1,nk
            do j=1,nj
            do i=1,ni
              dum2(i,j,k)=0.0
              dum3(i,j,k)=0.0
              dum4(i,j,k)=0.0
            enddo
            enddo
            enddo
          endif
!$omp parallel do default(shared)  &
!$omp private(i,j,k,n,ql)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            dum2(i,j,k)=cv+cvv*dum2(i,j,k)+cpl*dum3(i,j,k)+cpi*dum4(i,j,k)
          enddo
          enddo
          enddo
        ENDIF

!-----------------------------------------------------------------------
!  store appropriate rho for budget calculations in dum3

        IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            dum3(i,j,k)=rho(i,j,k)
          enddo
          enddo
          enddo

        ELSE

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            dum3(i,j,k) = rho(i,j,k)*pi*(xf(i+1)**2-xf(i)**2)/(dx*dy)
          enddo
          enddo
          enddo

        ENDIF


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!  NOTES:
!           sten       is used for     dbz
!
!           dum1   is   T
!           dum2   is   cvm
!           dum3   is   rho for budget calculations
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccc   Kessler scheme   cccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        IF(ptype.eq.1)THEN
          simple_comm = .false.
          call pdefq(    0.0,asq(1),ruh,rvh,rmh,rho,q3d(ib,jb,kb,1))
          call pdefq(1.0e-14,asq(2),ruh,rvh,rmh,rho,q3d(ib,jb,kb,2))
          call pdefq(1.0e-14,asq(3),ruh,rvh,rmh,rho,q3d(ib,jb,kb,3))
          call k_fallout(rho,q3d(ib,jb,kb,3),qten(ib,jb,kb,3))
          call geterain(dt,cpl,lv1,qbudget(7),ruh,rvh,dum1,dum3,q3d(ib,jb,kb,3),qten(ib,jb,kb,3))
          if(efall.ge.1)then
            call getefall(dt,cpl,ruh,rvh,mf,pi0,th0,dum1,dum2,dum3,   &
                          pp3d,th3d,q3d(ib,jb,kb,3),qten(ib,jb,kb,3))
          endif
          call fallout(dt,qbudget(6),ruh,rvh,zh,mh,mf,rain,dum3,rho,   &
                       q3d(ib,jb,kb,3),qten(ib,jb,kb,3))
          call kessler(dt,qbudget(3),qbudget(4),qbudget(5),ruh,rvh,rmh,pi0,th0,dum1,   &
                       rho,dum3,pp3d,th3d,prs,                            &
                       q3d(ib,jb,kb,nqv),q3d(ib,jb,kb,2),q3d(ib,jb,kb,3))
          call bcs(q3d(ib,jb,kb,3))
#ifdef MPI
          call comm_3s_start(q3d(ib,jb,kb,3),                               &
                     qw1(1,1,1,3),qw2(1,1,1,3),qe1(1,1,1,3),qe2(1,1,1,3),   &
                     qs1(1,1,1,3),qs2(1,1,1,3),qn1(1,1,1,3),qn2(1,1,1,3),   &
                     reqs_q(1,3))
#endif
          call satadj(4,qbudget(1),qbudget(2),ruh,rvh,rmh,pi0,th0,   &
                      rho,dum3,pp3d,prs,th3d,q3d)
          call bcs(q3d(ib,jb,kb,1))
#ifdef MPI
          call comm_3s_start(q3d(ib,jb,kb,1),                               &
                     qw1(1,1,1,1),qw2(1,1,1,1),qe1(1,1,1,1),qe2(1,1,1,1),   &
                     qs1(1,1,1,1),qs2(1,1,1,1),qn1(1,1,1,1),qn2(1,1,1,1),   &
                     reqs_q(1,1))
#endif
          call bcs(q3d(ib,jb,kb,2))
#ifdef MPI
          call comm_3s_start(q3d(ib,jb,kb,2),                               &
                     qw1(1,1,1,2),qw2(1,1,1,2),qe1(1,1,1,2),qe2(1,1,1,2),   &
                     qs1(1,1,1,2),qs2(1,1,1,2),qn1(1,1,1,2),qn2(1,1,1,2),   &
                     reqs_q(1,2))
#endif
          call bcs(th3d)
#ifdef MPI
          call comm_3s_start(th3d,sw31,sw32,se31,se32,   &
                                  ss31,ss32,sn31,sn32,reqs_s)
#endif
          call bcs(pp3d)
#ifdef MPI
          call comm_3s_start(pp3d,pw31,pw32,pe31,pe32,   &
                                  ps31,ps32,pn31,pn32,reqs_p)
#endif
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccc   Goddard LFO scheme   cccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        ELSEIF(ptype.eq.2)THEN
          simple_comm = .false.
          call pdefq(    0.0,asq(1),ruh,rvh,rmh,rho,q3d(ib,jb,kb,1))
          call pdefq(1.0e-14,asq(2),ruh,rvh,rmh,rho,q3d(ib,jb,kb,2))
          call pdefq(1.0e-14,asq(3),ruh,rvh,rmh,rho,q3d(ib,jb,kb,3))
          call pdefq(1.0e-14,asq(4),ruh,rvh,rmh,rho,q3d(ib,jb,kb,4))
          call pdefq(1.0e-14,asq(5),ruh,rvh,rmh,rho,q3d(ib,jb,kb,5))
          call pdefq(1.0e-14,asq(6),ruh,rvh,rmh,rho,q3d(ib,jb,kb,6))
          call goddard(dt,qbudget(3),qbudget(4),qbudget(5),ruh,rvh,rmh,pi0,th0,             &
                       rho,dum3,prs,pp3d,th3d,                            &
     q3d(ib,jb,kb,1), q3d(ib,jb,kb,2),q3d(ib,jb,kb,3),qten(ib,jb,kb,3),   &
     q3d(ib,jb,kb,4),qten(ib,jb,kb,4),q3d(ib,jb,kb,5),qten(ib,jb,kb,5),   &
     q3d(ib,jb,kb,6),qten(ib,jb,kb,6))
          call satadj_ice(4,qbudget(1),qbudget(2),ruh,rvh,rmh,pi0,th0,     &
                          rho,dum3,pp3d,prs,th3d,                     &
              q3d(ib,jb,kb,1),q3d(ib,jb,kb,2),q3d(ib,jb,kb,3),   &
              q3d(ib,jb,kb,4),q3d(ib,jb,kb,5),q3d(ib,jb,kb,6))
          call bcs(q3d(ib,jb,kb,1))
#ifdef MPI
          call comm_3s_start(q3d(ib,jb,kb,1),                               &
                     qw1(1,1,1,1),qw2(1,1,1,1),qe1(1,1,1,1),qe2(1,1,1,1),   &
                     qs1(1,1,1,1),qs2(1,1,1,1),qn1(1,1,1,1),qn2(1,1,1,1),   &
                     reqs_q(1,1))
#endif
          call bcs(q3d(ib,jb,kb,2))
#ifdef MPI
          call comm_3s_start(q3d(ib,jb,kb,2),                               &
                     qw1(1,1,1,2),qw2(1,1,1,2),qe1(1,1,1,2),qe2(1,1,1,2),   &
                     qs1(1,1,1,2),qs2(1,1,1,2),qn1(1,1,1,2),qn2(1,1,1,2),   &
                     reqs_q(1,2))
#endif
          call geterain(dt,cpl,lv1,qbudget(7),ruh,rvh,dum1,dum3,q3d(ib,jb,kb,3),qten(ib,jb,kb,3))
          call geterain(dt,cpi,ls1,qbudget(7),ruh,rvh,dum1,dum3,q3d(ib,jb,kb,4),qten(ib,jb,kb,4))
          call geterain(dt,cpi,ls1,qbudget(7),ruh,rvh,dum1,dum3,q3d(ib,jb,kb,5),qten(ib,jb,kb,5))
          call geterain(dt,cpi,ls1,qbudget(7),ruh,rvh,dum1,dum3,q3d(ib,jb,kb,6),qten(ib,jb,kb,6))
          if(efall.ge.1)then
            call getefall(dt,cpl,ruh,rvh,mf,pi0,th0,dum1,dum2,dum3,   &
                          pp3d,th3d,q3d(ib,jb,kb,3),qten(ib,jb,kb,3))
            call getefall(dt,cpi,ruh,rvh,mf,pi0,th0,dum1,dum2,dum3,   &
                          pp3d,th3d,q3d(ib,jb,kb,4),qten(ib,jb,kb,4))
            call getefall(dt,cpi,ruh,rvh,mf,pi0,th0,dum1,dum2,dum3,   &
                          pp3d,th3d,q3d(ib,jb,kb,5),qten(ib,jb,kb,5))
            call getefall(dt,cpi,ruh,rvh,mf,pi0,th0,dum1,dum2,dum3,   &
                          pp3d,th3d,q3d(ib,jb,kb,6),qten(ib,jb,kb,6))
          endif
          call bcs(th3d)
#ifdef MPI
          call comm_3s_start(th3d,sw31,sw32,se31,se32,   &
                                  ss31,ss32,sn31,sn32,reqs_s)
#endif
          call bcs(pp3d)
#ifdef MPI
          call comm_3s_start(pp3d,pw31,pw32,pe31,pe32,   &
                                  ps31,ps32,pn31,pn32,reqs_p)
#endif
          call fallout(dt,qbudget(6),ruh,rvh,zh,mh,mf,rain,dum3,rho,   &
                       q3d(ib,jb,kb,3),qten(ib,jb,kb,3))
          call bcs(q3d(ib,jb,kb,3))
#ifdef MPI
          call comm_3s_start(q3d(ib,jb,kb,3),                               &
                     qw1(1,1,1,3),qw2(1,1,1,3),qe1(1,1,1,3),qe2(1,1,1,3),   &
                     qs1(1,1,1,3),qs2(1,1,1,3),qn1(1,1,1,3),qn2(1,1,1,3),   &
                     reqs_q(1,3))
#endif
          call fallout(dt,qbudget(6),ruh,rvh,zh,mh,mf,rain,dum3,rho,   &
                       q3d(ib,jb,kb,4),qten(ib,jb,kb,4))
          call bcs(q3d(ib,jb,kb,4))
#ifdef MPI
          call comm_3s_start(q3d(ib,jb,kb,4),                               &
                     qw1(1,1,1,4),qw2(1,1,1,4),qe1(1,1,1,4),qe2(1,1,1,4),   &
                     qs1(1,1,1,4),qs2(1,1,1,4),qn1(1,1,1,4),qn2(1,1,1,4),   &
                     reqs_q(1,4))
#endif
          call fallout(dt,qbudget(6),ruh,rvh,zh,mh,mf,rain,dum3,rho,   &
                       q3d(ib,jb,kb,5),qten(ib,jb,kb,5))
          call bcs(q3d(ib,jb,kb,5))
#ifdef MPI
          call comm_3s_start(q3d(ib,jb,kb,5),                               &
                     qw1(1,1,1,5),qw2(1,1,1,5),qe1(1,1,1,5),qe2(1,1,1,5),   &
                     qs1(1,1,1,5),qs2(1,1,1,5),qn1(1,1,1,5),qn2(1,1,1,5),   &
                     reqs_q(1,5))
#endif
          call fallout(dt,qbudget(6),ruh,rvh,zh,mh,mf,rain,dum3,rho,   &
                       q3d(ib,jb,kb,6),qten(ib,jb,kb,6))
          call bcs(q3d(ib,jb,kb,6))
#ifdef MPI
          call comm_3s_start(q3d(ib,jb,kb,6),                               &
                     qw1(1,1,1,6),qw2(1,1,1,6),qe1(1,1,1,6),qe2(1,1,1,6),   &
                     qs1(1,1,1,6),qs2(1,1,1,6),qn1(1,1,1,6),qn2(1,1,1,6),   &
                     reqs_q(1,6))
#endif
          if(getdbz) call calcdbz(rho,q3d(ib,jb,kb,3),q3d(ib,jb,kb,5),q3d(ib,jb,kb,6),sten)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccc   Thompson scheme   ccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        ELSEIF(ptype.eq.3)THEN
          simple_comm = .true.
          call pdefq(    0.0,asq(1),ruh,rvh,rmh,rho,q3d(ib,jb,kb,1))
          call pdefq(1.0e-12,asq(2),ruh,rvh,rmh,rho,q3d(ib,jb,kb,2))
          call pdefq(1.0e-12,asq(3),ruh,rvh,rmh,rho,q3d(ib,jb,kb,3))
          call pdefq(1.0e-12,asq(4),ruh,rvh,rmh,rho,q3d(ib,jb,kb,4))
          call pdefq(1.0e-12,asq(5),ruh,rvh,rmh,rho,q3d(ib,jb,kb,5))
          call pdefq(1.0e-12,asq(6),ruh,rvh,rmh,rho,q3d(ib,jb,kb,6))
!!!          call pdefq(    1.0,asq(7),ruh,rvh,rmh,rho,q3d(ib,jb,kb,7))
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ! dum1 = pi
            ! dum2 = dz
            ! dum4 = T
            dum1(i,j,k)=pi0(i,j,k)+pp3d(i,j,k)
            dum2(i,j,k)=dz*rmh(i,j,k)
            dum4(i,j,k)=(th0(i,j,k)+th3d(i,j,k))*dum1(i,j,k)
            ! store old T in thten array:
            thten(i,j,k)=dum4(i,j,k)
          enddo
          enddo
          enddo
          call mp_gt_driver(q3d(ib,jb,kb,1),q3d(ib,jb,kb,2),q3d(ib,jb,kb,3), &
                            q3d(ib,jb,kb,4),q3d(ib,jb,kb,5),q3d(ib,jb,kb,6), &
                            q3d(ib,jb,kb,7),q3d(ib,jb,kb,8),                 &
                            th0,dum4,dum1,prs,dum2,dt,rain,                 &
                            qbudget(5),qbudget(6),                           &
                            ruh,rvh,rmh,dum3,sten,getdbz)
        IF(neweqts.ge.1)THEN
          ! for mass conservation:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            if( abs(dum4(i,j,k)-thten(i,j,k)).ge.tsmall )then
!!!              th3d(i,j,k)=th3d(i,j,k)+(dum4(i,j,k)-thten(i,j,k))
!!!              pp3d(i,j,k)=((rho(i,j,k)*(rd+rv*q3d(i,j,k,nqv))   &
!!!                                      *(th0(i,j,k)+th3d(i,j,k))*rp00)**rddcv)-pi0(i,j,k)
!!!              prs(i,j,k)=p00*((pi0(i,j,k)+pp3d(i,j,k))**cpdrd)
              prs(i,j,k)=rho(i,j,k)*rd*dum4(i,j,k)*(1.0+q3d(i,j,k,nqv)*reps)
              pp3d(i,j,k)=(prs(i,j,k)*rp00)**rovcp - pi0(i,j,k)
              th3d(i,j,k)=dum4(i,j,k)/(pi0(i,j,k)+pp3d(i,j,k)) - th0(i,j,k)
            endif
          enddo
          enddo
          enddo
        ELSE
          ! traditional thermodynamics:  p,pi remain unchanged
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            if( abs(dum4(i,j,k)-thten(i,j,k)).ge.tsmall )then
              th3d(i,j,k)=th3d(i,j,k)+(dum4(i,j,k)-thten(i,j,k))/dum1(i,j,k)
              rho(i,j,k)=prs(i,j,k)/(rd*dum4(i,j,k)*(1.0+q3d(i,j,k,nqv)*reps))
            endif
          enddo
          enddo
          enddo
        ENDIF
          if(timestats.ge.1) time_microphy=time_microphy+mytime()
          call satadj(4,qbudget(1),qbudget(2),ruh,rvh,rmh,pi0,th0,   &
                      rho,dum3,pp3d,prs,th3d,q3d)

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccc   GSR LFO scheme   cccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

        ELSEIF(ptype.eq.4)THEN
          simple_comm = .true.
          call pdefq(    0.0,asq(1),ruh,rvh,rmh,rho,q3d(ib,jb,kb,1))
          call pdefq(1.0e-14,asq(2),ruh,rvh,rmh,rho,q3d(ib,jb,kb,2))
          call pdefq(1.0e-14,asq(3),ruh,rvh,rmh,rho,q3d(ib,jb,kb,3))
          call pdefq(1.0e-14,asq(4),ruh,rvh,rmh,rho,q3d(ib,jb,kb,4))
          call pdefq(1.0e-14,asq(5),ruh,rvh,rmh,rho,q3d(ib,jb,kb,5))
          call pdefq(1.0e-14,asq(6),ruh,rvh,rmh,rho,q3d(ib,jb,kb,6))
          call lfo_ice_drive(dt, mf, pi0, prs0, pp3d, prs, th0, th3d,    &
                             qv0, rho0, q3d, qten, dum1)
          do n=2,numq
            call fallout(dt,qbudget(6),ruh,rvh,zh,mh,mf,rain,dum3,rho,   &
                         q3d(ib,jb,kb,n),qten(ib,jb,kb,n))
          enddo

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccc   Morrison scheme   cccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

        ELSEIF(ptype.eq.5)THEN
          simple_comm = .true.
          call pdefq(    0.0,asq(1),ruh,rvh,rmh,rho,q3d(ib,jb,kb,1))
          call pdefq(1.0e-12,asq(2),ruh,rvh,rmh,rho,q3d(ib,jb,kb,2))
          call pdefq(1.0e-12,asq(3),ruh,rvh,rmh,rho,q3d(ib,jb,kb,3))
          call pdefq(1.0e-12,asq(4),ruh,rvh,rmh,rho,q3d(ib,jb,kb,4))
          call pdefq(1.0e-12,asq(5),ruh,rvh,rmh,rho,q3d(ib,jb,kb,5))
          call pdefq(1.0e-12,asq(6),ruh,rvh,rmh,rho,q3d(ib,jb,kb,6))
!!!          call pdefq(    1.0,asq(7),ruh,rvh,rmh,rho,q3d(ib,jb,kb,7))
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ! dum1 = T  (this should have been calculated already)
            ! dum4 = dz
            dum4(i,j,k)=dz*rmh(i,j,k)
            ! store old T in thten array:
            thten(i,j,k)=dum1(i,j,k)
          enddo
          enddo
          enddo
          call MP_MORR_TWO_MOMENT(nstep,dum1,                                 &
                          q3d(ib,jb,kb, 1),q3d(ib,jb,kb, 2),q3d(ib,jb,kb, 3), &
                          q3d(ib,jb,kb, 4),q3d(ib,jb,kb, 5),q3d(ib,jb,kb, 6), &
                          q3d(ib,jb,kb, 7),q3d(ib,jb,kb, 8),q3d(ib,jb,kb, 9), &
                          q3d(ib,jb,kb,10),                                   &
                               prs,dt,dum4,w3d,rain,                         &
                          qbudget(1),qbudget(2),qbudget(5),qbudget(6),        &
                          ruh,rvh,rmh,dum3,sten,getdbz)
        IF(neweqts.ge.1)THEN
          ! for mass conservation:
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            if( abs(dum1(i,j,k)-thten(i,j,k)).ge.tsmall )then
!!!              th3d(i,j,k)=th3d(i,j,k)+(dum1(i,j,k)-thten(i,j,k))
!!!              pp3d(i,j,k)=((rho(i,j,k)*(rd+rv*q3d(i,j,k,nqv))   &
!!!                                      *(th0(i,j,k)+th3d(i,j,k))*rp00)**rddcv)-pi0(i,j,k)
!!!              prs(i,j,k)=p00*((pi0(i,j,k)+pp3d(i,j,k))**cpdrd)
              prs(i,j,k)=rho(i,j,k)*rd*dum1(i,j,k)*(1.0+q3d(i,j,k,nqv)*reps)
              pp3d(i,j,k)=(prs(i,j,k)*rp00)**rovcp - pi0(i,j,k)
              th3d(i,j,k)=dum1(i,j,k)/(pi0(i,j,k)+pp3d(i,j,k)) - th0(i,j,k)
            endif
          enddo
          enddo
          enddo
        ELSE
          ! traditional thermodynamics:  p,pi remain unchanged
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            if( abs(dum1(i,j,k)-thten(i,j,k)).ge.tsmall )then
              th3d(i,j,k)=th3d(i,j,k)+(dum1(i,j,k)-thten(i,j,k))/(pi0(i,j,k)+pp3d(i,j,k))
              rho(i,j,k)=prs(i,j,k)/(rd*dum1(i,j,k)*(1.0+q3d(i,j,k,nqv)*reps))
            endif
          enddo
          enddo
          enddo
        ENDIF
          if(timestats.ge.1) time_microphy=time_microphy+mytime()
          call satadj(4,qbudget(1),qbudget(2),ruh,rvh,rmh,pi0,th0,   &
                      rho,dum3,pp3d,prs,th3d,q3d)

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccc   RE87 scheme   ccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

        ELSEIF(ptype.eq.6)THEN
          simple_comm = .true.
          call pdefq(    0.0,asq(1),ruh,rvh,rmh,rho,q3d(ib,jb,kb,1))
          call pdefq(1.0e-14,asq(2),ruh,rvh,rmh,rho,q3d(ib,jb,kb,2))
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            if(q3d(i,j,k,2).gt.0.001)then
              qten(i,j,k,2) = v_t
            else
              qten(i,j,k,2) = 0.0
            endif
          enddo
          enddo
          enddo
          call geterain(dt,cpl,lv1,qbudget(7),ruh,rvh,dum1,dum3,q3d(ib,jb,kb,2),qten(ib,jb,kb,2))
          if(efall.ge.1)then
            call getefall(dt,cpl,ruh,rvh,mf,pi0,th0,dum1,dum2,dum3,   &
                          pp3d,th3d,q3d(ib,jb,kb,2),qten(ib,jb,kb,2))
          endif
          call fallout(dt,qbudget(6),ruh,rvh,zh,mh,mf,rain,dum3,rho,   &
                       q3d(ib,jb,kb,2),qten(ib,jb,kb,2))
          call satadj(4,qbudget(1),qbudget(2),ruh,rvh,rmh,pi0,th0,   &
                      rho,dum3,pp3d,prs,th3d,q3d)

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!  Milbrandt & Yao scheme
!
!        ELSEIF(ptype.eq.7)THEN
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!  Ziegler/Mansell two-moment scheme
!
!        ELSEIF(ptype.ge.26)THEN
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!  insert new microphysics schemes here
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!        ELSEIF(ptype.eq.8)THEN
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
! otherwise, stop for undefined ptype
        ELSE
          print *,'  Undefined ptype!'
          call stopcm1
        ENDIF

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!Begin:  message passing for simple_comm
        IF(simple_comm)THEN
          call bcs(th3d)
#ifdef MPI
          call comm_3s_start(th3d,sw31,sw32,se31,se32,   &
                                  ss31,ss32,sn31,sn32,reqs_s)
#endif
          call bcs(pp3d)
#ifdef MPI
          call comm_3s_start(pp3d,pw31,pw32,pe31,pe32,   &
                                  ps31,ps32,pn31,pn32,reqs_p)
#endif
          DO n=1,numq
            call bcs(q3d(ib,jb,kb,n))
#ifdef MPI
            call comm_3s_start(q3d(ib,jb,kb,n),                               &
                       qw1(1,1,1,n),qw2(1,1,1,n),qe1(1,1,1,n),qe2(1,1,1,n),   &
                       qs1(1,1,1,n),qs2(1,1,1,n),qn1(1,1,1,n),qn2(1,1,1,n),   &
                       reqs_q(1,n))
#endif
          ENDDO
        ENDIF
!Done:  message passing for simple_comm

      ENDIF

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CC   END microphysics   CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

!-----------------------------------------------------------------
!  Equate the two arrays

      if(iturb.eq.1)then
#ifdef MPI
          call comm_3t_end(tke3d,tkw1,tkw2,tke1,tke2,   &
                                 tks1,tks2,tkn1,tkn2,reqs_tk)
#endif
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=0,nk+2
        do j=0,nj+1
        do i=0,ni+1
          tkea(i,j,k)=tke3d(i,j,k)
        enddo
        enddo
        enddo
        if(timestats.ge.1) time_integ=time_integ+mytime()
      endif

      if(iptra.eq.1)then
        do n=1,npt
#ifdef MPI
            call comm_3s_end(pt3d(ib,jb,kb,n),                           &
                  tw1(1,1,1,n),tw2(1,1,1,n),te1(1,1,1,n),te2(1,1,1,n),   &
                  ts1(1,1,1,n),ts2(1,1,1,n),tn1(1,1,1,n),tn2(1,1,1,n),   &
                  reqs_t(1,n))
#endif
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=0,nk+1
          do j=0,nj+1
          do i=0,ni+1
            pta(i,j,k,n)=pt3d(i,j,k,n)
          enddo
          enddo
          enddo
          if(timestats.ge.1) time_integ=time_integ+mytime()
        enddo
      endif

#ifdef MPI
      call comm_3u_end(u3d,uw31,uw32,ue31,ue32,   &
                           us31,us32,un31,un32,reqs_u)
#endif
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=0,nk+1
      do j=0,nj+1
      do i=0,ni+2
        ua(i,j,k)=u3d(i,j,k)
      enddo
      enddo
      enddo
      if(timestats.ge.1) time_integ=time_integ+mytime()
 
#ifdef MPI
      call comm_3v_end(v3d,vw31,vw32,ve31,ve32,   &
                           vs31,vs32,vn31,vn32,reqs_v)
#endif
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=0,nk+1
      do j=0,nj+2
      do i=0,ni+1
        va(i,j,k)=v3d(i,j,k)
      enddo
      enddo
      enddo
      if(timestats.ge.1) time_integ=time_integ+mytime()
 
#ifdef MPI
      call comm_3w_end(w3d,ww31,ww32,we31,we32,   &
                           ws31,ws32,wn31,wn32,reqs_w)
#endif
      if(terrain_flag)then
        call bcwsfc(dzdx,dzdy,u3d,v3d,w3d)
        call bc2d(w3d(ib,jb,1))
      endif
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=0,nk+2
      do j=0,nj+1
      do i=0,ni+1
        wa(i,j,k)=w3d(i,j,k)
      enddo
      enddo
      enddo
      if(timestats.ge.1) time_integ=time_integ+mytime()
 
#ifndef MPI
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=0,nk+1
      do j=0,nj+1
      do i=0,ni+1
        ppi(i,j,k)=pp3d(i,j,k)
      enddo
      enddo
      enddo

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=0,nk+1
      do j=0,nj+1
      do i=0,ni+1
        tha(i,j,k)=th3d(i,j,k)
      enddo
      enddo
      enddo

      if(imoist.eq.1)then
 
        do n=1,numq

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=0,nk+1
          do j=0,nj+1
          do i=0,ni+1
            qa(i,j,k,n)=q3d(i,j,k,n)
          enddo
          enddo
          enddo

        enddo
 
      endif

      if(timestats.ge.1) time_integ=time_integ+mytime()
#else
    if(imoist.eq.0)then
      call fincomm(tha,th3d,sw31,sw32,se31,se32,   &
                            ss31,ss32,sn31,sn32,reqs_s)
      call fincomm(ppi,pp3d,pw31,pw32,pe31,pe32,   &
                            ps31,ps32,pn31,pn32,reqs_p)
    endif
#endif

!---- finish communication of moisture ----

#ifdef MPI
  IF(imoist.eq.1)THEN
    IF(simple_comm)THEN
      call fincomm(tha,th3d,sw31,sw32,se31,se32,   &
                            ss31,ss32,sn31,sn32,reqs_s)
      call fincomm(ppi,pp3d,pw31,pw32,pe31,pe32,   &
                            ps31,ps32,pn31,pn32,reqs_p)
      do n=1,numq
        call fincomm(qa(ib,jb,kb,n),q3d(ib,jb,kb,n),                        &
                     qw1(1,1,1,n),qw2(1,1,1,n),qe1(1,1,1,n),qe2(1,1,1,n),   &
                     qs1(1,1,1,n),qs2(1,1,1,n),qn1(1,1,1,n),qn2(1,1,1,n),   &
                     reqs_q(1,n))
      enddo
    ELSE
      if(ptype.eq.1)then
        call fincomm(qa(ib,jb,kb,3),q3d(ib,jb,kb,3),                        &
                     qw1(1,1,1,3),qw2(1,1,1,3),qe1(1,1,1,3),qe2(1,1,1,3),   &
                     qs1(1,1,1,3),qs2(1,1,1,3),qn1(1,1,1,3),qn2(1,1,1,3),   &
                     reqs_q(1,3))
        call fincomm(qa(ib,jb,kb,1),q3d(ib,jb,kb,1),                        &
                     qw1(1,1,1,1),qw2(1,1,1,1),qe1(1,1,1,1),qe2(1,1,1,1),   &
                     qs1(1,1,1,1),qs2(1,1,1,1),qn1(1,1,1,1),qn2(1,1,1,1),   &
                     reqs_q(1,1))
        call fincomm(qa(ib,jb,kb,2),q3d(ib,jb,kb,2),                        &
                     qw1(1,1,1,2),qw2(1,1,1,2),qe1(1,1,1,2),qe2(1,1,1,2),   &
                     qs1(1,1,1,2),qs2(1,1,1,2),qn1(1,1,1,2),qn2(1,1,1,2),   &
                     reqs_q(1,2))
        call fincomm(tha,th3d,sw31,sw32,se31,se32,   &
                              ss31,ss32,sn31,sn32,reqs_s)
        call fincomm(ppi,pp3d,pw31,pw32,pe31,pe32,   &
                              ps31,ps32,pn31,pn32,reqs_p)
      elseif(ptype.eq.2)then
        call fincomm(qa(ib,jb,kb,1),q3d(ib,jb,kb,1),                        &
                     qw1(1,1,1,1),qw2(1,1,1,1),qe1(1,1,1,1),qe2(1,1,1,1),   &
                     qs1(1,1,1,1),qs2(1,1,1,1),qn1(1,1,1,1),qn2(1,1,1,1),   &
                     reqs_q(1,1))
        call fincomm(qa(ib,jb,kb,2),q3d(ib,jb,kb,2),                        &
                     qw1(1,1,1,2),qw2(1,1,1,2),qe1(1,1,1,2),qe2(1,1,1,2),   &
                     qs1(1,1,1,2),qs2(1,1,1,2),qn1(1,1,1,2),qn2(1,1,1,2),   &
                     reqs_q(1,2))
        call fincomm(tha,th3d,sw31,sw32,se31,se32,   &
                              ss31,ss32,sn31,sn32,reqs_s)
        call fincomm(ppi,pp3d,pw31,pw32,pe31,pe32,   &
                              ps31,ps32,pn31,pn32,reqs_p)
        call fincomm(qa(ib,jb,kb,3),q3d(ib,jb,kb,3),                        &
                     qw1(1,1,1,3),qw2(1,1,1,3),qe1(1,1,1,3),qe2(1,1,1,3),   &
                     qs1(1,1,1,3),qs2(1,1,1,3),qn1(1,1,1,3),qn2(1,1,1,3),   &
                     reqs_q(1,3))
        call fincomm(qa(ib,jb,kb,4),q3d(ib,jb,kb,4),                        &
                     qw1(1,1,1,4),qw2(1,1,1,4),qe1(1,1,1,4),qe2(1,1,1,4),   &
                     qs1(1,1,1,4),qs2(1,1,1,4),qn1(1,1,1,4),qn2(1,1,1,4),   &
                     reqs_q(1,4))
        call fincomm(qa(ib,jb,kb,5),q3d(ib,jb,kb,5),                        &
                     qw1(1,1,1,5),qw2(1,1,1,5),qe1(1,1,1,5),qe2(1,1,1,5),   &
                     qs1(1,1,1,5),qs2(1,1,1,5),qn1(1,1,1,5),qn2(1,1,1,5),   &
                     reqs_q(1,5))
        call fincomm(qa(ib,jb,kb,6),q3d(ib,jb,kb,6),                        &
                     qw1(1,1,1,6),qw2(1,1,1,6),qe1(1,1,1,6),qe2(1,1,1,6),   &
                     qs1(1,1,1,6),qs2(1,1,1,6),qn1(1,1,1,6),qn2(1,1,1,6),   &
                     reqs_q(1,6))
      endif
    ENDIF

  ELSE

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=0,nk+1
      do j=0,nj+1
      do i=0,ni+1
        ppi(i,j,k)=pp3d(i,j,k)
      enddo
      enddo
      enddo

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=0,nk+1
      do j=0,nj+1
      do i=0,ni+1
        tha(i,j,k)=th3d(i,j,k)
      enddo
      enddo
      enddo
      if(timestats.ge.1) time_integ=time_integ+mytime()

  ENDIF
#endif

      if(imove.eq.1.and.imoist.eq.1)then
        call movesfc(0.0,dt,uh,vh,rain(ib,jb,2),dum1(ib,jb,1),dum1(ib,jb,2),dum1(ib,jb,3))
        if(timestats.ge.1) time_swath=time_swath+mytime()
      endif

!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cc   All done   cccccccccccccccccccccccccccccccccccccccccccccccccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

!!!#ifdef MPI
!!!      call MPI_BARRIER (MPI_COMM_WORLD,ierr)
!!!      if(timestats.ge.1) time_mpb=time_mpb+mytime()
!!!#endif

!  Calculate surface "swaths."  Move surface (if necessary). 

    IF( output_sws.eq.1 )THEN

!--------------------------------------------------------------------
! Maximum horizontal wind speed at lowest model level: 
! (include domain movement in calculation)

!$omp parallel do default(shared)  &
!$omp private(i,j,n,tem)
      do j=1,nj
      do i=1,ni
        tem = sqrt( (umove+0.5*(ua(i,j,1)+ua(i+1,j,1)))**2    &
                   +(vmove+0.5*(va(i,j,1)+va(i,j+1,1)))**2 ) 
        do n=1,nrain
          sws(i,j,n)=max(sws(i,j,n),tem)
        enddo
      enddo
      enddo

      if(imove.eq.1)then
        call movesfc(0.0,dt,uh,vh,sws(ib,jb,2),dum1(ib,jb,1),dum1(ib,jb,2),dum1(ib,jb,3))
      endif

!--------------------------------------------------------------------
!  Maximum vertical vorticity at lowest model level:

!$omp parallel do default(shared)  &
!$omp private(i,j,n,tem)
      do j=1,nj+1
      do i=1,ni+1
        tem = (va(i,j,1)-va(i-1,j,1))*rdx*uf(i)   &
             -(ua(i,j,1)-ua(i,j-1,1))*rdy*vf(j)
        do n=1,nrain
          svs(i,j,n)=max(svs(i,j,n),tem)
        enddo
      enddo
      enddo

      if(imove.eq.1)then
        call movesfc(-200000.0,dt,uh,vh,svs(ib,jb,2),dum1(ib,jb,1),dum1(ib,jb,2),dum1(ib,jb,3))
      endif

!--------------------------------------------------------------------
!  Minimum pressure perturbation at lowest model level:

!$omp parallel do default(shared)  &
!$omp private(i,j,n,tem)
      do j=1,nj
      do i=1,ni
        tem = prs(i,j,1)-prs0(i,j,1)
        do n=1,nrain
          sps(i,j,n)=min(sps(i,j,n),tem)
        enddo
      enddo
      enddo

      if(imove.eq.1)then
        call movesfc(-200000.0,dt,uh,vh,sps(ib,jb,2),dum1(ib,jb,1),dum1(ib,jb,2),dum1(ib,jb,3))
      endif

!--------------------------------------------------------------------
!  Maximum rainwater mixing ratio (qr) at lowest model level:

    IF(imoist.eq.1.and.nqr.ne.0)THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,n,tem)
      do j=1,nj
      do i=1,ni
        tem = qa(i,j,1,nqr)
        do n=1,nrain
          srs(i,j,n)=max(srs(i,j,n),tem)
        enddo
      enddo
      enddo

      if(imove.eq.1)then
        call movesfc(0.0,dt,uh,vh,srs(ib,jb,2),dum1(ib,jb,1),dum1(ib,jb,2),dum1(ib,jb,3))
      endif
    ENDIF

!--------------------------------------------------------------------
!  Maximum graupel/hail mixing ratio (qg) at lowest model level:

    IF(imoist.eq.1.and.nqg.ne.0)THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,n,tem)
      do j=1,nj
      do i=1,ni
        tem = qa(i,j,1,nqg)
        do n=1,nrain
          sgs(i,j,n)=max(sgs(i,j,n),tem)
        enddo
      enddo
      enddo

      if(imove.eq.1)then
        call movesfc(0.0,dt,uh,vh,sgs(ib,jb,2),dum1(ib,jb,1),dum1(ib,jb,2),dum1(ib,jb,3))
      endif
    ENDIF

!--------------------------------------------------------------------

      ! get height AGL:
      if( terrain_flag )then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk+1
        do j=1,nj
        do i=1,ni
          dum3(i,j,k) = zh(i,j,k)-zs(i,j)
          wten(i,j,k) = zf(i,j,k)-zs(i,j)
        enddo
        enddo
        enddo
      else
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk+1
        do j=1,nj
        do i=1,ni
          dum3(i,j,k) = zh(i,j,k)
          wten(i,j,k) = zf(i,j,k)
        enddo
        enddo
        enddo
      endif

!--------------------------------------------------------------------
!  Maximum updraft velocity (w) at 5 km AGL:

!$omp parallel do default(shared)  &
!$omp private(i,j,k,n,tem)
      do j=1,nj
      do i=1,ni
        k = 2
        ! wten is height AGL:
        do while( wten(i,j,k).lt.5000.0 )
          k = k + 1
        enddo
        tem = w3d(i,j,k)
        do n=1,nrain
          sus(i,j,n)=max(sus(i,j,n),tem)
        enddo
      enddo
      enddo

      if(imove.eq.1)then
        call movesfc(-200000.0,dt,uh,vh,sus(ib,jb,2),dum1(ib,jb,1),dum1(ib,jb,2),dum1(ib,jb,3))
      endif

!--------------------------------------------------------------------
!  Maximum integrated updraft helicity:

      ! dum3 is zh (agl), wten is zf (agl)
      call calcuh(uf,vf,dum3,wten,ua,va,wa,dum1(ib,jb,1),dum2)
!$omp parallel do default(shared)  &
!$omp private(i,j,n)
      do j=1,nj
      do i=1,ni
        do n=1,nrain
          shs(i,j,n)=max(shs(i,j,n),dum1(i,j,1))
        enddo
      enddo
      enddo

      if(imove.eq.1)then
        call movesfc(0.0,dt,uh,vh,shs(ib,jb,2),dum1(ib,jb,1),dum1(ib,jb,2),dum1(ib,jb,3))
      endif



#ifdef ORFSWATHS
! surface stuff first

! surface negative theta perturbation (surface/cold pool)
!--------------------------------------------------------------------MARK
      swindex=1
      k=1
!$omp parallel do default(shared)  &
!$omp private(i,j,k,n,tem)
      do j=1,nj
      do i=1,ni
        tem = tha(i,j,k)
        do n=1,nrain
          orfswaths(i,j,n,swindex)=min(orfswaths(i,j,n,swindex),tem)
        enddo
      enddo
      enddo

      if(imove.eq.1)then
        call movesfc(-200000,dt,uh,vh,orfswaths(ib,jb,2,swindex),dum1(ib,jb,1),dum1(ib,jb,2),dum1(ib,jb,3))
      endif

      swindex = swindex + 1

!--------------------------------------------------------------------MARK
! ORF 1km updraft
! Get index for point at or below 1km, NO TERRAIN
        i=1
        j=1
        k=1
        do while( zf(i,j,k).lt.1000.0 )
          k = k + 1
        enddo
      onekmindex=k

!$omp parallel do default(shared)  &
!$omp private(i,j,k,n,tem)
      do j=1,nj
      do i=1,ni
        tem = w3d(i,j,onekmindex)
        do n=1,nrain
          orfswaths(i,j,n,swindex)=max(orfswaths(i,j,n,swindex),tem)
        enddo
      enddo
      enddo

      if(imove.eq.1)then
        call movesfc(-200000.0,dt,uh,vh,orfswaths(ib,jb,2,swindex),dum1(ib,jb,1),dum1(ib,jb,2),dum1(ib,jb,3))
      endif

      swindex = swindex + 1

!--------------------------------------------------------------------MARK
!ORF 1km downdraft

!$omp parallel do default(shared)  &
!$omp private(i,j,k,n,tem)
      do j=1,nj
      do i=1,ni
        tem = w3d(i,j,onekmindex)
        do n=1,nrain
          orfswaths(i,j,n,swindex)=min(orfswaths(i,j,n,swindex),tem)
        enddo
      enddo
      enddo

      if(imove.eq.1)then
        call movesfc(-200000.0,dt,uh,vh,orfswaths(ib,jb,2,swindex),dum1(ib,jb,1),dum1(ib,jb,2),dum1(ib,jb,3))
      endif

      swindex = swindex + 1

!--------------------------------------------------------------------MARK
!ORF 1km vort
!$omp parallel do default(shared)  &
!$omp private(i,j,k,n,tem)
      do j=1,nj
      do i=1,ni
        tem = (va(i,j,onekmindex)-va(i-1,j,onekmindex))*rdx*uf(i)   &
             -(ua(i,j,onekmindex)-ua(i,j-1,onekmindex))*rdy*vf(j)
        do n=1,nrain
          orfswaths(i,j,n,swindex)=max(orfswaths(i,j,n,swindex),tem)
        enddo
      enddo
      enddo

      if(imove.eq.1)then
        call movesfc(-200000.0,dt,uh,vh,orfswaths(ib,jb,2,swindex),dum1(ib,jb,1),dum1(ib,jb,2),dum1(ib,jb,3))
      endif

#endif
!ORFSWATHS
!--------------------------------------------------------------------

      if(timestats.ge.1) time_swath=time_swath+mytime()
    ENDIF

!  Done with "swaths"
!--------------------------------------------------------------------
!  Step time forward, Get statistics

      mtime = mtime + dt

      if( convinit.eq.1 )then
        if( mtime.gt.convtime ) convinit = 0
      endif

      rtime=sngl(mtime)
      if( rtime.ge.sngl(stattim) .or. statfrq.le.0.0  )then
        IF(axisymm.eq.0)THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ppten(i,j,k)=rho(i,j,k)
          enddo
          enddo
          enddo
        ELSE
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ppten(i,j,k) = rho(i,j,k)*pi*(xf(i+1)**2-xf(i)**2)/(dx*dy)
          enddo
          enddo
          enddo
        ENDIF
        call statpack(nrec,ndt,dt,rtime,adt,acfl,cloudvar,qname,budname,qbudget,asq,bsq, &
                      xh,rxh,uh,ruh,xf,uf,yh,vh,rvh,vf,zh,mh,rmh,mf,    &
                      rstat,pi0,rho0,thv0,th0,qv0,u0,v0,                &
                      dum1,dum2,dum3,dum4,divx,ppten,prs,               &
                      ua,va,wa,ppi,tha,qa,qten,kmh,kmv,khh,khv,tkea,pta,u10,v10)
        stattim=stattim+statfrq
      else
        if( adapt_dt.eq.1 ) call calccfl(1,rstat,dt,acfl,uf,vf,mf,ua,va,wa,0)
      endif

!--------------------------------------------------------------------
!  Writeout and stuff

      rtime=sngl(mtime)
      if(myid.eq.0)then
        if(timeformat.eq.1)then
          write(6,110) nstep,rtime,' sec '
        elseif(timeformat.eq.2)then
          write(6,110) nstep,rtime/60.0,' min '
        elseif(timeformat.eq.3)then
          write(6,110) nstep,rtime/3600.0,' hour'
        elseif(timeformat.eq.4)then
          write(6,110) nstep,rtime/86400.0,' day '
        else
          write(6,110) nstep,rtime,' sec'
        endif
110     format(2x,i12,4x,f18.6,a5)
      endif
      if(timestats.ge.1) time_misc=time_misc+mytime()

      if( (rtime.ge.sngl(taptim)).or.stopit .or. ctrldropslice.eq.1 .or. ctrldrophist.eq.1)then
            if (ctrldropslice.eq.1) then
                  if(myid.eq.0)print *, "Control file tells us to drop a slice"
            endif
            if (ctrldrophist.eq.1) then
                  if(myid.eq.0)print *, "Control file tells us to drop a full history"
            endif
        nwrite=nwrite+1
      IF(output_format.eq.1)THEN
        nn = 1
        if(terrain_flag .and. output_interp.eq.1) nn = 2
        DO n=1,nn
          if(n.eq.1)then
            fnum = 51
          else
            fnum = 71
          endif
          call writeout(fnum,nwrite,qname,xh,xf,uf,vf,sigma,zh,zf,mf,pi0,prs0,rho0,th0,qv0,u0,v0,  &
                      zs,rain,sws,svs,sps,srs,sgs,sus,shs,thflux,qvflux,cdu,cdv,ce,dum1,dum2,dum3,dum4, &
                      rho,prs,sten,ua,uten,va,vten,wa,wten,ppi,tha,          &
                   dissten,thpten,qvpten,qcpten,qipten,upten,vpten,          &
                      lu_index,xland,mavail,tsk,tmn,tml,hml,huml,hvml,hfx,qfx,gsw,glw,tslb,   &
                      qa,kmh,kmv,khh,khv,tkea,swten,lwten,radsw,rnflx,radswnet,radlwin,pta,   &
                      num_soil_layers,u10,v10,t2,q2,znt,ust,hpbl,zol,mol,br)
        ENDDO
#ifdef NETCDF
      ELSEIF(output_format.eq.2)THEN
        call writeout_cdf(nwrite,qname,sigma,sigmaf,xh,xf,uf,yh,yf,vf,mh,zh,mf,zf, &
                      pi0,prs0,rho0,th0,qv0,u0,v0,                     &
                      zs,rain,sws,svs,sps,srs,sgs,sus,shs,thflux,qvflux,cdu,cdv,ce,dum1,dum2,dum3,dum4,  &
                      rho,prs,sten,ua,uten,va,vten,wa,wten,ppi,tha,    &
                      qa,kmh,kmv,khh,khv,tkea,pta,num_soil_layers,   &
                      lu_index,xland,mavail,tsk,tmn,tml,hml,huml,hvml,hfx,qfx,gsw,glw,tslb,   &
                      radsw,rnflx,radswnet,radlwin,u10,v10,t2,q2,znt,ust,hpbl,zol,mol,br,   &
                      dissten,thpten,qvpten,qcpten,qipten,upten,vpten,swten,lwten)
#endif
#ifdef HDFOUT
      ELSEIF(output_format.ge.3)THEN

!ORF TESTING

      wr3d = .true.
      wr2d = .false.

! Matthieu, I have been playing with only writing a certain number of
! phdf5 files at a time. In this test (next five lines commented out),
! I have 1024 cores and am writing 1024/8 at a time. When you get to
! a very large number of cores, this approach should improve I/O; I
! actually found with 1024 cores it was actually fastest to just write
! them all

      if (wr3d .or. wr2d) then
        if (len_trim(output_path) .eq. 0) then
              if(myid.eq.0)then
                 write(outfile,*) 'empty output_path'
                 write(outfile,*) 'defaulting to current working directory'
              endif
              output_path='.'
        endif
        write(ctime,102)int(rtime)
        write(cid,103)ioid
102     format(i5.5)
103     format(i4.4)
        filedir = trim(output_path)//'/'//trim(output_basename)//'.'//ctime//'.cdir/'
        dircmd = 'mkdir -p '// trim(filedir)
        if (myid.eq.0) call system(dircmd)
        call MPI_BARRIER (MPI_COMM_WORLD,ierr)

!     do ihist=0,7
!     if (ihist .eq. ioid/(nmcm/8)) then

        call writeout_mult_hdf5(rtime,qname,sigma,sigmaf,xh,xf,uf,yh,yf,vf,mh,zh,mf,zf, &
                      pi0,prs0,rho0,th0,thv0,qv0,u0,v0,                     &
                      zs,rain,sws,svs,sps,srs,sgs,sus,shs,thflux,qvflux,cdu,cdv,ce,dum1,dum2,dum3,dum4,  &
                      rho,prs,sten,ua,uten,va,vten,wa,wten,ppi,tha,    &
                      qa,kmh,kmv,khh,khv,tkea,pta,num_soil_layers,   &
                      lu_index,xland,mavail,tsk,tmn,tml,hml,huml,hvml,hfx,qfx,gsw,glw,tslb,   &
                      radsw,rnflx,radswnet,radlwin,u10,v10,t2,q2,znt,ust,hpbl,zol,mol,br,   &
                      dissten,thpten,qvpten,qcpten,qipten,upten,vpten,swten,lwten)
endif
!      endif
!      call MPI_BARRIER(MPI_COMM_WORLD,ierr)
!      enddo

#endif
      ENDIF
!ORF keep regular hist file dumps on schedule
      if (ctrldrophist.eq.0.and.ctrldropslice.eq.0)taptim=taptim+tapfrq
        if(timestats.ge.1) time_write=time_write+mytime()
      endif

      if( (rtime.ge.rsttim .and. rstfrq.gt.0) .or. ctrldroprestart .eq. 1)then
            if (ctrldroprestart.eq.1) then
                  if(myid.eq.0)print *, "Control file tells us to drop restart files"
            endif
        nrst=nrst+1
        call write_restart(nstep,nrec,prec,nwrite,nrst,nrad2d,num_soil_layers, &
                               dt,mtime,radtim,qbudget,asq,bsq,                &
                               rain,sws,svs,sps,srs,sgs,sus,shs,tsk,radbcw,radbce,radbcs,radbcn,     &
                               ua,va,wa,ppi,tha,qa,tkea,swten,lwten,   &
                               radsw,rnflx,radswnet,radlwin,rad2d,   &
                               lu_index,kpbl2d,psfc,u10,v10,hfx,qfx,xland,znt,ust, &
                               hpbl,wspd,psim,psih,gz1oz0,br,                      &
                               CHS,CHS2,CQS2,CPMM,ZOL,MAVAIL,                      &
                               MOL,RMOL,REGIME,LH,FLHC,FLQC,QGH,                   &
                               CK,CKA,CD,CDA,USTM,QSFC,T2,Q2,TH2,EMISS,THC,ALBD,   &
                               f2d,gsw,glw,chklowq,capg,snowc,tslb,                &
                               tmn,tml,t0ml,hml,h0ml,huml,hvml,tmoml,              &
                               pta,pdata,rtime)
        rsttim=rsttim+rstfrq
        if(timestats.ge.1) time_write=time_write+mytime()
      endif

!-------------------------------------------------------------------
!  Parcel update (final time step)

      if( (iprcl.eq.1).and.(rtime.ge.timax) )then
            if(myid.eq.0)write(outfile,*) '  Calling parcel driver for last step'
        call parcel_driver(prec,dt,xh,uh,ruh,yh,vh,rvh,zh,mh,rmh,mf,        &
                           pi0,thv0,th0,dum1,dum2,dum3,dum4,divx,prs,    &
                           ua,va,wa,ppi,thten,tha,qa,khv,pdata,rtime,    &
                           ploc,packet,reqs_p,                           &
                           pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2)
      endif

!-------------------------------------------------------------------

      if(stopit)then
        if(myid.eq.0)then
          print *
          print *,' Courant number has exceeded 1.5 '
          print *
          print *,' Stopping model .... '
          print *
        endif
        call stopcm1
      endif

!--------------------------------------------------------------------

      return
      end


sounde.F/       1298670057  19071 8000  100644  17926     `


      subroutine sounde(dt,xh,rxh,uh,ruh,xf,uf,yh,vh,rvh,yf,vf,zh,mh,rmh,mf,rmf,    &
                        pi0,thv0,rho0,rr0,rf0,th0,dzdx,dzdy,            &
                        radbcw,radbce,radbcs,radbcn,                    &
                        dum1,ppd,dpdzx,dpdzy,divx,                      &
                        gx,u0,ua,u3d,uten,gy,v0,va,v3d,vten,wa,w3d,wten,      &
                        ppi,pp3d,ppten,tha,th3d,thten,thterm,tk,        &
                        thv,ppterm,nrk,rtime,                           &
                        reqs_u,reqs_v,reqs_w,reqs_s,reqs_p,             &
                        uw31,uw32,ue31,ue32,us31,us32,un31,un32,        &
                        vw31,vw32,ve31,ve32,vs31,vs32,vn31,vn32,        &
                        ww31,ww32,we31,we32,ws31,ws32,wn31,wn32,        &
                        sw31,sw32,se31,se32,ss31,ss32,sn31,sn32,        &
                        pw31,pw32,pe31,pe32,ps31,ps32,pn31,pn32,        &
                        pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real :: dt
      real, dimension(ib:ie) :: xh,rxh,uh,ruh
      real, dimension(ib:ie+1) :: xf,uf
      real, dimension(jb:je) :: yh,vh,rvh
      real, dimension(jb:je+1) :: yf,vf
      real, dimension(ib:ie,jb:je,kb:ke) :: zh,mh,rmh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf,rmf
      real, dimension(ib:ie,jb:je,kb:ke) :: pi0,thv0,rho0,rr0,rf0,th0
      real, dimension(itb:ite,jtb:jte) :: dzdx,dzdy
      real, dimension(itb:ite+1,jtb:jte,ktb:kte) :: gx
      real, dimension(itb:ite,jtb:jte+1,ktb:kte) :: gy
      real, dimension(jb:je,kb:ke) :: radbcw,radbce
      real, dimension(ib:ie,kb:ke) :: radbcs,radbcn
      real, dimension(ib:ie,jb:je,kb:ke) :: dum1,ppd,dpdzx,dpdzy,divx
      real, dimension(ib:ie+1,jb:je,kb:ke) :: u0,ua,u3d,uten
      real, dimension(ib:ie,jb:je+1,kb:ke) :: v0,va,v3d,vten
      real, dimension(ib:ie,jb:je,kb:ke+1) :: wa,w3d,wten
      real, dimension(ib:ie,jb:je,kb:ke) :: ppi,pp3d,ppten
      real, dimension(ib:ie,jb:je,kb:ke) :: tha,th3d,thten,thterm,tk
      real, dimension(ib:ie,jb:je,kb:ke) :: thv,ppterm
      integer, intent(in) :: nrk
      real, intent(in) :: rtime
      integer, dimension(rmp) :: reqs_u,reqs_v,reqs_w,reqs_s,reqs_p
      real, dimension(cmp,jmp,kmp)   :: uw31,uw32,ue31,ue32
      real, dimension(imp+1,cmp,kmp) :: us31,us32,un31,un32
      real, dimension(cmp,jmp+1,kmp) :: vw31,vw32,ve31,ve32
      real, dimension(imp,cmp,kmp)   :: vs31,vs32,vn31,vn32
      real, dimension(cmp,jmp,kmp-1) :: ww31,ww32,we31,we32
      real, dimension(imp,cmp,kmp-1) :: ws31,ws32,wn31,wn32
      real, dimension(cmp,jmp,kmp)   :: sw31,sw32,se31,se32
      real, dimension(imp,cmp,kmp)   :: ss31,ss32,sn31,sn32
      real, dimension(cmp,jmp,kmp)   :: pw31,pw32,pe31,pe32
      real, dimension(imp,cmp,kmp)   :: ps31,ps32,pn31,pn32
      real, dimension(jmp,kmp) :: pw1,pw2,pe1,pe2
      real, dimension(imp,kmp) :: ps1,ps2,pn1,pn2

!-----

      integer :: i,j,k,n,nloop
      real :: tem,dts

#ifdef MPI
      include 'mpif.h'
#endif

!---------------------------------------------------------------------
!  Prepare for acoustic steps

      if(nrk.ge.2)then

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni+1
          u3d(i,j,k)=ua(i,j,k)
        enddo
        enddo
        enddo
 
      IF(axisymm.eq.0)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj+1
        do i=1,ni
          v3d(i,j,k)=va(i,j,k)
        enddo
        enddo
        enddo
      ENDIF
 
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk+1
        do j=1,nj
        do i=1,ni
          w3d(i,j,k)=wa(i,j,k)
        enddo
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=0,nj+1
        do i=0,ni+1
          pp3d(i,j,k)=ppi(i,j,k)
          ppd(i,j,k)=pp3d(i,j,k)
        enddo
        enddo
        enddo

      else

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=0,nj+1
        do i=0,ni+1
          ppd(i,j,k)=pp3d(i,j,k)
        enddo
        enddo
        enddo

      endif

        IF(thsmall.eq.1)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            th3d(i,j,k)=tha(i,j,k)
          enddo
          enddo
          enddo
        ENDIF

        if(timestats.ge.1) time_misc=time_misc+mytime()

!---------------------------------------------------------------------
 
      if(nrk.eq.1)then
!!!        nloop=1
!!!        dts=dt/3.
        nloop=nint(float(nsound)/3.0)
        dts=dt/(nloop*3.0)
        if( dts.gt.(dt/nsound) )then
          nloop=nloop+1
          dts=dt/(nloop*3.0)
        endif
      elseif(nrk.eq.2)then
        nloop=0.5*nsound
        dts=dt/nsound
      elseif(nrk.eq.3)then
        nloop=nsound
        dts=dt/nsound
      endif

      if(timestats.ge.1) time_sound=time_sound+mytime()

!---------------------------------------------------------------------

      DO N=1,NLOOP

!-----

        if(irbc.eq.2)then
 
          if(ibw.eq.1 .or. ibe.eq.1) call radbcew(radbcw,radbce,u3d)
 
          if(ibs.eq.1 .or. ibn.eq.1) call radbcns(radbcs,radbcn,v3d)
 
        endif

!-----

        if(wbc.eq.2.and.ibw.eq.1)then
!$omp parallel do default(shared)   &
!$omp private(j,k)
          do k=1,nk
          do j=1,nj
            u3d(1,j,k)=u3d(1,j,k)+dts*( -radbcw(j,k)          &
                      *(u3d(2,j,k)-u3d(1,j,k))*rdx*uh(1)   &
                         +uten(1,j,k) )
          enddo
          enddo
        endif

        if(ebc.eq.2.and.ibe.eq.1)then
!$omp parallel do default(shared)   &
!$omp private(j,k)
          do k=1,nk
          do j=1,nj
            u3d(ni+1,j,k)=u3d(ni+1,j,k)+dts*( -radbce(j,k)              &
                         *(u3d(ni+1,j,k)-u3d(ni  ,j,k))*rdx*uh(ni)   &
                         +uten(ni+1,j,k) )
          enddo
          enddo
        endif

!-----

        IF(roflux.eq.1)THEN
          call restrict_openbc_we(rvh,rmh,rho0,u3d)
        ENDIF

!-----
#ifdef MPI
        IF(n.gt.1)THEN
          call comm_1s_end_we(ppd,pw1,pw2,pe1,pe2,   &
                               ps1,ps2,pn1,pn2,reqs_p)
        ENDIF
#endif
!-----

        tem=rdx*cp*0.5

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1+ibw,ni+1-ibe
          u3d(i,j,k)=u3d(i,j,k)+dts*( uten(i,j,k)                &
                  -tem*(ppd(i,j,k)-ppd(i-1,j,k))*uf(i)*   &
                       (thv(i,j,k)+thv(i-1,j,k)) )
        enddo
        enddo
        enddo

        IF(terrain_flag)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1+ibw,ni+1-ibe
            dum1(i,j,k)=0.5*(ppd(i-1,j,k)+ppd(i,j,k))
          enddo
          enddo
          enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=2,nk-1
          do j=1,nj
          do i=1+ibw,ni+1-ibe
            dpdzx(i,j,k)=( dum1(i,j,k+1)-dum1(i,j,k-1) )*rdz2
          enddo
          enddo
          enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
          do j=1,nj
          do i=1+ibw,ni+1-ibe
            dpdzx(i,j,1 )=( dum1(i,j,2 )-dum1(i,j,1   ) )*rdz
            dpdzx(i,j,nk)=( dum1(i,j,nk)-dum1(i,j,nk-1) )*rdz
          enddo
          enddo

          tem=dts*cp*0.5

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1+ibw,ni+1-ibe
            u3d(i,j,k)=u3d(i,j,k)                                  &
                  -tem*(thv(i,j,k)+thv(i-1,j,k))*gx(i,j,k)*dpdzx(i,j,k)
          enddo
          enddo
          enddo

        ENDIF

!----------------------------------------------
!  convergence forcing:

        IF( convinit.eq.1 )THEN
          IF( rtime.le.convtime .and. nx.gt.1 )THEN
            call convinitu(myid,ib,ie,jb,je,kb,ke,ni,nj,nk,ibw,ibe,   &
                           zdeep,lamx,lamy,xcent,ycent,aconv,    &
                           xf,yh,zh,u0,u3d)
          ENDIF
        ENDIF

!----------------------------------------------

        if(timestats.ge.1) time_sound=time_sound+mytime()

        if(n.eq.nloop)then
          call bcu(u3d)
        endif

#ifdef MPI
        if(n.eq.nloop)then
          call comm_3u_start(u3d,uw31,uw32,ue31,ue32,   &
                                 us31,us32,un31,un32,reqs_u)
        endif
#endif

!-----
#ifdef MPI
        IF(n.gt.1)THEN
          call comm_1s_end_sn(ppd,pw1,pw2,pe1,pe2,   &
                               ps1,ps2,pn1,pn2,reqs_p)
        ENDIF
#endif
!-----

      IF(axisymm.eq.0)THEN

        if(sbc.eq.2.and.ibs.eq.1)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
          do k=1,nk
          do i=1,ni
            v3d(i,1,k)=v3d(i,1,k)+dts*( -radbcs(i,k)          &
                      *(v3d(i,2,k)-v3d(i,1,k))*rdy*vh(1)   &
                      +vten(i,1,k) )
          enddo
          enddo
        endif
 
        if(nbc.eq.2.and.ibn.eq.1)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
          do k=1,nk
          do i=1,ni
            v3d(i,nj+1,k)=v3d(i,nj+1,k)+dts*( -radbcn(i,k)              &
                         *(v3d(i,nj+1,k)-v3d(i,nj  ,k))*rdy*vh(nj)   &
                         +vten(i,nj+1,k) )
          enddo
          enddo
        endif

!-----

        IF(roflux.eq.1)THEN
          call restrict_openbc_sn(ruh,rmh,rho0,v3d)
        ENDIF

!-----

        tem=rdy*cp*0.5

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1+ibs,nj+1-ibn
        do i=1,ni
          v3d(i,j,k)=v3d(i,j,k)+dts*( vten(i,j,k)                &
                  -tem*(ppd(i,j,k)-ppd(i,j-1,k))*vf(j)*   &
                       (thv(i,j,k)+thv(i,j-1,k)) )
        enddo
        enddo
        enddo

        IF(terrain_flag)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=1,nk
          do j=1+ibs,nj+1-ibn
          do i=1,ni
            dum1(i,j,k)=0.5*(ppd(i,j-1,k)+ppd(i,j,k))
          enddo
          enddo
          enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=2,nk-1
          do j=1+ibs,nj+1-ibn
          do i=1,ni
            dpdzy(i,j,k)=( dum1(i,j,k+1)-dum1(i,j,k-1) )*rdz2
          enddo
          enddo
          enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
          do j=1+ibs,nj+1-ibn
          do i=1,ni
            dpdzy(i,j,1 )=( dum1(i,j,2   )-dum1(i,j,1   ) )*rdz
            dpdzy(i,j,nk)=( dum1(i,j,nk  )-dum1(i,j,nk-1) )*rdz
          enddo
          enddo

          tem=dts*cp*0.5

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=1,nk
          do j=1+ibs,nj+1-ibn
          do i=1,ni
            v3d(i,j,k)=v3d(i,j,k)                                  &
                  -tem*(thv(i,j,k)+thv(i,j-1,k))*gy(i,j,k)*dpdzy(i,j,k)
          enddo
          enddo
          enddo

        ENDIF

!----------------------------------------------
!  convergence forcing:

        IF( convinit.eq.1 )THEN
          IF( rtime.le.convtime .and. ny.gt.1 )THEN
            call convinitv(myid,ib,ie,jb,je,kb,ke,ni,nj,nk,ibs,ibn,   &
                           zdeep,lamx,lamy,xcent,ycent,aconv,    &
                           xh,yf,zh,v0,v3d)
          ENDIF
        ENDIF

!----------------------------------------------

        if(timestats.ge.1) time_sound=time_sound+mytime()

        if(n.eq.nloop)then
          call bcv(v3d)
        endif

#ifdef MPI
        if(n.eq.nloop)then
          call comm_3v_start(v3d,vw31,vw32,ve31,ve32,   &
                                 vs31,vs32,vn31,vn32,reqs_v)
        endif
#endif

      ENDIF

!-----

        tem=rdz*cp*0.5

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=1,ni
          w3d(i,j,k)=w3d(i,j,k)+dts*( wten(i,j,k)             &
                  -tem*(ppd(i,j,k)-ppd(i,j,k-1))*mf(i,j,k)*      &
                       (thv(i,j,k)+thv(i,j,k-1)) )
        enddo
        enddo
        enddo

        IF(thsmall.eq.1)THEN
          tem=dts*g
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=2,nk
          do j=1,nj
          do i=1,ni
            w3d(i,j,k)=w3d(i,j,k)+(th3d(i,j,k)+th3d(i,j,k-1))   &
                             *tem/( th0(i,j,k)+ th0(i,j,k-1))
          enddo
          enddo
          enddo
        ENDIF
        if(timestats.ge.1) time_sound=time_sound+mytime()

        if(n.eq.nloop) call bcw(w3d,1)

        if(terrain_flag) call bcwsfc(dzdx,dzdy,u3d,v3d,w3d)

#ifdef MPI
        if(n.eq.nloop)then
          call comm_3w_start(w3d,ww31,ww32,we31,we32,   &
                                 ws31,ws32,wn31,wn32,reqs_w)
        endif
#endif

!-----

    IF(axisymm.eq.0)THEN
 
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        divx(i,j,k)=(u3d(i+1,j,k)-u3d(i,j,k))*rdx*uh(i)    &
                   +(v3d(i,j+1,k)-v3d(i,j,k))*rdy*vh(j)    &
                   +(w3d(i,j,k+1)-w3d(i,j,k))*rdz*mh(i,j,k)
      enddo
      enddo
      enddo

    ELSE
 
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        divx(i,j,k)=(xf(i+1)*u3d(i+1,j,k)-xf(i)*u3d(i,j,k))*rdx*uh(i)*rxh(i)   &
                   +(w3d(i,j,k+1)-w3d(i,j,k))*rdz*mh(i,j,k)
      enddo
      enddo
      enddo

    ENDIF

        IF(terrain_flag)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=2,nk-1
          do j=1,nj
          do i=1,ni+1
            dpdzx(i,j,k)=gx(i,j,k)*(u3d(i,j,k+1)-u3d(i,j,k-1))*rdz2
          enddo
          enddo
          enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
          do j=1,nj
          do i=1,ni+1
            dpdzx(i,j, 1)=gx(i,j,1 )*(u3d(i,j,2 )-u3d(i,j,1   ))*rdz
            dpdzx(i,j,nk)=gx(i,j,nk)*(u3d(i,j,nk)-u3d(i,j,nk-1))*rdz
          enddo
          enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=2,nk-1
          do j=1,nj+1
          do i=1,ni
            dpdzy(i,j,k)=gy(i,j,k)*(v3d(i,j,k+1)-v3d(i,j,k-1))*rdz2
          enddo
          enddo
          enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
          do j=1,nj+1
          do i=1,ni
            dpdzy(i,j, 1)=gy(i,j,1 )*(v3d(i,j,2 )-v3d(i,j,1   ))*rdz
            dpdzy(i,j,nk)=gy(i,j,nk)*(v3d(i,j,nk)-v3d(i,j,nk-1))*rdz
          enddo
          enddo

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            divx(i,j,k)=divx(i,j,k)+0.5*(                  &
                          (dpdzx(i,j,k)+dpdzx(i+1,j,k))     &
                         +(dpdzy(i,j,k)+dpdzy(i,j+1,k)) )
          enddo
          enddo
          enddo
          if(timestats.ge.1) time_divx=time_divx+mytime()

        ENDIF

!-------------------------
#ifdef MPI
        IF(n.gt.1)THEN
          call comm_1s_end_misc(ppd,pw1,pw2,pe1,pe2,   &
                               ps1,ps2,pn1,pn2,reqs_p)
        ENDIF
#endif

        tem=g*0.5/cp

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ppd(i,j,k)=pp3d(i,j,k)
          pp3d(i,j,k)=pp3d(i,j,k)+dts*( ppten(i,j,k)              &
              +tem*(w3d(i,j,k)+w3d(i,j,k+1))/thv0(i,j,k)    &
              -(pi0(i,j,k)+pp3d(i,j,k))*ppterm(i,j,k)*divx(i,j,k) )
          if(abs(pp3d(i,j,k)).lt.smeps) pp3d(i,j,k)=0.0
          ppd(i,j,k)=pp3d(i,j,k)-ppd(i,j,k)-dts*ppten(i,j,k)
          ppd(i,j,k)=pp3d(i,j,k)+kdiv*ppd(i,j,k)
        enddo
        enddo
        enddo
        if(timestats.ge.1) time_sound=time_sound+mytime()

        if(n.eq.nloop .and. nrk.eq.3 .and. imoist.eq.1)then
          tem=0
        else
          if(n.eq.nloop) call bcs(pp3d)
        endif

#ifdef MPI
        if(n.eq.nloop)then
          if(nrk.lt.3.or.imoist.eq.0)then
            call comm_3s_start(pp3d,pw31,pw32,pe31,pe32,   &
                                    ps31,ps32,pn31,pn32,reqs_p)
          endif
        endif
#endif

        IF(n.lt.nloop)THEN

          call bcs(ppd)

#ifdef MPI
          call comm_1s_start(ppd,pw1,pw2,pe1,pe2,   &
                                 ps1,ps2,pn1,pn2,reqs_p)
#endif
        ENDIF

!--------------------------------------------------------------------

      IF(thsmall.eq.1)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          th3d(i,j,k)=th3d(i,j,k)+dts*( thten(i,j,k)+rr0(i,j,k)*(    &
            w3d(i,j,k)*tk(i,j,k)+w3d(i,j,k+1)*tk(i,j,k+1)  ) )
        enddo
        enddo
        enddo

        IF(neweqts.ge.1 .and. imoist.eq.1)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            th3d(i,j,k)=th3d(i,j,k)   &
                -dts*thterm(i,j,k)*(th0(i,j,k)+th3d(i,j,k))*divx(i,j,k)
          enddo
          enddo
          enddo
        ENDIF
        if(timestats.ge.1) time_sound=time_sound+mytime()

        if(n.eq.nloop)then
          if(nrk.lt.3.or.imoist.eq.0)then
            call bcs(th3d)
#ifdef MPI
            call comm_3s_start(th3d,sw31,sw32,se31,se32,   &
                                    ss31,ss32,sn31,sn32,reqs_s)
#endif
          endif
        endif

      ENDIF

!--------------------------------------------------------------------

      ENDDO

!!!      if(terrain_flag)then
!!!        call bcwsfc(dzdx,dzdy,u3d,v3d,w3d)
!!!        call bc2d(w3d(ib,jb,1))
!!!      endif

!--------------------------------------------------------------------

      return
      end


sound.F/        1298670057  19071 8000  100644  25617     `


      subroutine sound(dt,xh,rxh,uh,ruh,xf,uf,yh,vh,rvh,yf,vf,zh,mh,rmh,mf,rmf,  &
                        pi0,thv0,rho0,rr0,rf0,th0,dzdx,dzdy,            &
                        radbcw,radbce,radbcs,radbcn,                    &
                        fwk,ppd,dpdzx,dpdzy,pk,mm,qk,fpk,               &
                        gx,u0,ua,u3d,uten,gy,v0,va,v3d,vten,wa,w3d,wten,      &
                        ppi,pp3d,ppten,tha,th3d,thten,thterm,tk,        &
                        thv,ppterm,ftk,bk,sk,nrk,rtime,                 &
                        reqs_u,reqs_v,reqs_w,reqs_s,reqs_p,             &
                        uw31,uw32,ue31,ue32,us31,us32,un31,un32,        &
                        vw31,vw32,ve31,ve32,vs31,vs32,vn31,vn32,        &
                        ww31,ww32,we31,we32,ws31,ws32,wn31,wn32,        &
                        sw31,sw32,se31,se32,ss31,ss32,sn31,sn32,        &
                        pw31,pw32,pe31,pe32,ps31,ps32,pn31,pn32,        &
                        pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, intent(in) :: dt
      real, intent(in), dimension(ib:ie) :: xh,rxh,uh,ruh
      real, intent(in), dimension(ib:ie+1) :: xf,uf
      real, intent(in), dimension(jb:je) :: yh,vh,rvh
      real, intent(in), dimension(jb:je+1) :: yf,vf
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: zh,mh,rmh
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: mf,rmf
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: pi0,thv0,rho0,rr0,rf0,th0
      real, intent(in), dimension(itb:ite,jtb:jte) :: dzdx,dzdy
      real, intent(in), dimension(itb:ite+1,jtb:jte,ktb:kte) :: gx
      real, intent(in), dimension(itb:ite,jtb:jte+1,ktb:kte) :: gy
      real, intent(inout), dimension(jb:je,kb:ke) :: radbcw,radbce
      real, intent(inout), dimension(ib:ie,kb:ke) :: radbcs,radbcn
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: fwk,ppd,dpdzx,dpdzy,pk,mm,qk,fpk
      real, intent(in), dimension(ib:ie+1,jb:je,kb:ke) :: u0
      real, intent(inout), dimension(ib:ie+1,jb:je,kb:ke) :: ua,u3d,uten
      real, intent(in), dimension(ib:ie,jb:je+1,kb:ke) :: v0
      real, intent(inout), dimension(ib:ie,jb:je+1,kb:ke) :: va,v3d,vten
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke+1) :: wa,w3d,wten
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: ppi,pp3d,ppten
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: tha,th3d,thten,thterm,tk
      real, intent(in), dimension(ib:ie,jb:je,kb:ke) :: thv
      real, intent(inout), dimension(ib:ie,jb:je,kb:ke) :: ppterm,ftk,bk,sk
      integer, intent(in) :: nrk
      real, intent(in)  :: rtime
      integer, intent(inout), dimension(rmp) :: reqs_u,reqs_v,reqs_w,reqs_s,reqs_p
      real, intent(inout), dimension(cmp,jmp,kmp)   :: uw31,uw32,ue31,ue32
      real, intent(inout), dimension(imp+1,cmp,kmp) :: us31,us32,un31,un32
      real, intent(inout), dimension(cmp,jmp+1,kmp) :: vw31,vw32,ve31,ve32
      real, intent(inout), dimension(imp,cmp,kmp)   :: vs31,vs32,vn31,vn32
      real, intent(inout), dimension(cmp,jmp,kmp-1) :: ww31,ww32,we31,we32
      real, intent(inout), dimension(imp,cmp,kmp-1) :: ws31,ws32,wn31,wn32
      real, intent(inout), dimension(cmp,jmp,kmp)   :: sw31,sw32,se31,se32
      real, intent(inout), dimension(imp,cmp,kmp)   :: ss31,ss32,sn31,sn32
      real, intent(inout), dimension(cmp,jmp,kmp)   :: pw31,pw32,pe31,pe32
      real, intent(inout), dimension(imp,cmp,kmp)   :: ps31,ps32,pn31,pn32
      real, intent(inout), dimension(jmp,kmp) :: pw1,pw2,pe1,pe2
      real, intent(inout), dimension(imp,kmp) :: ps1,ps2,pn1,pn2

!-----

      integer :: i,j,k,n,nloop
      real :: tem,r1,dts
      real :: aa,bb,cc,dd

!!!      real alph,beta,asq
!!!      parameter(alph=0.60)
!!!      parameter(beta=1.0-alph)
!!!      parameter(asq=alph*alph)

      real :: beta,asq

#ifdef MPI
      include 'mpif.h'
#endif

!---------------------------------------------------------------------

      beta=1.0-alph
      asq=alph*alph

!---------------------------------------------------------------------
!  Prepare for acoustic steps

      if(nrk.ge.2)then

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni+1
          u3d(i,j,k)=ua(i,j,k)
        enddo
        enddo
        enddo
 
      IF(axisymm.eq.0)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj+1
        do i=1,ni
          v3d(i,j,k)=va(i,j,k)
        enddo
        enddo
        enddo
      ENDIF
 
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk+1
        do j=1,nj
        do i=1,ni
          w3d(i,j,k)=wa(i,j,k)
        enddo
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=0,nj+1
        do i=0,ni+1
          pp3d(i,j,k)=ppi(i,j,k)
          ppd(i,j,k)=pp3d(i,j,k)
        enddo
        enddo
        enddo

      else

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=0,nj+1
        do i=0,ni+1
          ppd(i,j,k)=pp3d(i,j,k)
        enddo
        enddo
        enddo

      endif

        IF(thsmall.eq.1)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            th3d(i,j,k)=tha(i,j,k)
          enddo
          enddo
          enddo
        ENDIF

!---------------------------------------------------------------------
 
      if(nrk.eq.1)then
!!!        nloop=1
!!!        dts=dt/3.
        nloop=nint(float(nsound)/3.0)
        dts=dt/(nloop*3.0)
        if( dts.gt.(dt/nsound) )then
          nloop=nloop+1
          dts=dt/(nloop*3.0)
        endif
      elseif(nrk.eq.2)then
        nloop=0.5*nsound
        dts=dt/nsound
      elseif(nrk.eq.3)then
        nloop=nsound
        dts=dt/nsound
      endif

!!!      print *,'  nloop,dts,dttmp = ',nloop,dts,nloop*dts

!-----------------------------------------------------------------

      tem = dts*g*0.5/cp
 
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        pk(i,j,k)=tem/thv0(i,j,k)
      enddo
      enddo
      enddo

      tem = dts*cp*0.5*rdz

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni
        mm(i,j,k)=tem*mf(i,j,k)*( thv(i,j,k-1)+thv(i,j,k) )
      enddo
      enddo
      enddo

      IF(thsmall.eq.1)THEN
        tem = dts*g
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=1,ni
          bk(i,j,k)=tem/(th0(i,j,k-1)+th0(i,j,k))
        enddo
        enddo
        enddo
      ENDIF

        IF(thsmall.eq.1.and.neweqts.ge.1.and.imoist.eq.1)THEN
          tem = dts*rdz
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            sk(i,j,k)=tem*thterm(i,j,k)*(th0(i,j,k)+th3d(i,j,k))*mh(i,j,k)
          enddo
          enddo
          enddo
        ENDIF

      if(timestats.ge.1) time_sound=time_sound+mytime()

!---------------------------------------------------------------------

      DO N=1,NLOOP

!-----

        if(irbc.eq.2)then
 
          if(ibw.eq.1 .or. ibe.eq.1) call radbcew(radbcw,radbce,u3d)
 
          if(ibs.eq.1 .or. ibn.eq.1) call radbcns(radbcs,radbcn,v3d)
 
        endif

!-----

        if(wbc.eq.2.and.ibw.eq.1)then
!$omp parallel do default(shared)   &
!$omp private(j,k)
          do k=1,nk
          do j=1,nj
            u3d(1,j,k)=u3d(1,j,k)+dts*( -radbcw(j,k)          &
                      *(u3d(2,j,k)-u3d(1,j,k))*rdx*uh(1)   &
                         +uten(1,j,k) )
          enddo
          enddo
        endif

        if(ebc.eq.2.and.ibe.eq.1)then
!$omp parallel do default(shared)   &
!$omp private(j,k)
          do k=1,nk
          do j=1,nj
            u3d(ni+1,j,k)=u3d(ni+1,j,k)+dts*( -radbce(j,k)              &
                         *(u3d(ni+1,j,k)-u3d(ni  ,j,k))*rdx*uh(ni)   &
                         +uten(ni+1,j,k) )
          enddo
          enddo
        endif

        if(timestats.ge.1) time_sound=time_sound+mytime()

!-----

        IF(roflux.eq.1)THEN
          call restrict_openbc_we(rvh,rmh,rho0,u3d)
        ENDIF

!-----
#ifdef MPI
        IF(n.gt.1)THEN
          call comm_1s_end_we(ppd,pw1,pw2,pe1,pe2,   &
                               ps1,ps2,pn1,pn2,reqs_p)
        ENDIF
#endif
!-----

        tem=rdx*cp*0.5

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1+ibw,ni+1-ibe
          u3d(i,j,k)=u3d(i,j,k)+dts*( uten(i,j,k)                &
                  -tem*(ppd(i,j,k)-ppd(i-1,j,k))*uf(i)*   &
                       (thv(i,j,k)+thv(i-1,j,k)) )
        enddo
        enddo
        enddo

        IF(terrain_flag)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1+ibw,ni+1-ibe
            fwk(i,j,k)=0.5*(ppd(i-1,j,k)+ppd(i,j,k))
          enddo
          enddo
          enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=2,nk-1
          do j=1,nj
          do i=1+ibw,ni+1-ibe
            dpdzx(i,j,k)=( fwk(i,j,k+1)-fwk(i,j,k-1) )*rdz2
          enddo
          enddo
          enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
          do j=1,nj
          do i=1+ibw,ni+1-ibe
            dpdzx(i,j,1 )=( fwk(i,j,2 )-fwk(i,j,1   ) )*rdz
            dpdzx(i,j,nk)=( fwk(i,j,nk)-fwk(i,j,nk-1) )*rdz
          enddo
          enddo

          tem=dts*cp*0.5

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1+ibw,ni+1-ibe
            u3d(i,j,k)=u3d(i,j,k)                                  &
                  -tem*(thv(i,j,k)+thv(i-1,j,k))*gx(i,j,k)*dpdzx(i,j,k)
          enddo
          enddo
          enddo

        ENDIF

!----------------------------------------------
!  convergence forcing:

        IF( convinit.eq.1 )THEN
          IF( rtime.le.convtime .and. nx.gt.1 )THEN
            call convinitu(myid,ib,ie,jb,je,kb,ke,ni,nj,nk,ibw,ibe,   &
                           zdeep,lamx,lamy,xcent,ycent,aconv,    &
                           xf,yh,zh,u0,u3d)
          ENDIF
        ENDIF

!----------------------------------------------

        if(timestats.ge.1) time_sound=time_sound+mytime()

        if(n.eq.nloop)then
          call bcu(u3d)
        endif

#ifdef MPI
        if(n.eq.nloop)then
          call comm_3u_start(u3d,uw31,uw32,ue31,ue32,   &
                                 us31,us32,un31,un32,reqs_u)
        endif
#endif

!-----
#ifdef MPI
        IF(n.gt.1)THEN
          call comm_1s_end_sn(ppd,pw1,pw2,pe1,pe2,   &
                               ps1,ps2,pn1,pn2,reqs_p)
        ENDIF
#endif
!-----

      IF(axisymm.eq.0)THEN

        if(sbc.eq.2.and.ibs.eq.1)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
          do k=1,nk
          do i=1,ni
            v3d(i,1,k)=v3d(i,1,k)+dts*( -radbcs(i,k)          &
                      *(v3d(i,2,k)-v3d(i,1,k))*rdy*vh(1)   &
                      +vten(i,1,k) )
          enddo
          enddo
        endif
 
        if(nbc.eq.2.and.ibn.eq.1)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
          do k=1,nk
          do i=1,ni
            v3d(i,nj+1,k)=v3d(i,nj+1,k)+dts*( -radbcn(i,k)              &
                         *(v3d(i,nj+1,k)-v3d(i,nj  ,k))*rdy*vh(nj)   &
                         +vten(i,nj+1,k) )
          enddo
          enddo
        endif

        if(timestats.ge.1) time_sound=time_sound+mytime()

!-----

        IF(roflux.eq.1)THEN
          call restrict_openbc_sn(ruh,rmh,rho0,v3d)
        ENDIF

!-----

        tem=rdy*cp*0.5

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1+ibs,nj+1-ibn
        do i=1,ni
          v3d(i,j,k)=v3d(i,j,k)+dts*( vten(i,j,k)                &
                  -tem*(ppd(i,j,k)-ppd(i,j-1,k))*vf(j)*   &
                       (thv(i,j,k)+thv(i,j-1,k)) )
        enddo
        enddo
        enddo

        IF(terrain_flag)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=1,nk
          do j=1+ibs,nj+1-ibn
          do i=1,ni
            fwk(i,j,k)=0.5*(ppd(i,j-1,k)+ppd(i,j,k))
          enddo
          enddo
          enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=2,nk-1
          do j=1+ibs,nj+1-ibn
          do i=1,ni
            dpdzy(i,j,k)=( fwk(i,j,k+1)-fwk(i,j,k-1) )*rdz2
          enddo
          enddo
          enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
          do j=1+ibs,nj+1-ibn
          do i=1,ni
            dpdzy(i,j,1 )=( fwk(i,j,2   )-fwk(i,j,1   ) )*rdz
            dpdzy(i,j,nk)=( fwk(i,j,nk  )-fwk(i,j,nk-1) )*rdz
          enddo
          enddo

          tem=dts*cp*0.5

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=1,nk
          do j=1+ibs,nj+1-ibn
          do i=1,ni
            v3d(i,j,k)=v3d(i,j,k)                                  &
                  -tem*(thv(i,j,k)+thv(i,j-1,k))*gy(i,j,k)*dpdzy(i,j,k)
          enddo
          enddo
          enddo

        ENDIF

!----------------------------------------------
!  convergence forcing:

        IF( convinit.eq.1 )THEN
          IF( rtime.le.convtime .and. ny.gt.1 )THEN
            call convinitv(myid,ib,ie,jb,je,kb,ke,ni,nj,nk,ibs,ibn,   &
                           zdeep,lamx,lamy,xcent,ycent,aconv,    &
                           xh,yf,zh,v0,v3d)
          ENDIF
        ENDIF

!----------------------------------------------

        if(timestats.ge.1) time_sound=time_sound+mytime()

        if(n.eq.nloop)then
          call bcv(v3d)
        endif

#ifdef MPI
        if(n.eq.nloop)then
          call comm_3v_start(v3d,vw31,vw32,ve31,ve32,   &
                                 vs31,vs32,vn31,vn32,reqs_v)
        endif
#endif

      ENDIF

!---------------------------------------------------
!  update implicit solver arrays

        tem = dts*rdz

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          qk(i,j,k)=tem*ppterm(i,j,k)*(pi0(i,j,k)+pp3d(i,j,k))*mh(i,j,k)
        enddo
        enddo
        enddo

      IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          fpk(i,j,k)=                 beta*(                                 &
            w3d(i,j,k)*(pk(i,j,k)+qk(i,j,k))                                 &
           +w3d(i,j,k+1)*(pk(i,j,k)-qk(i,j,k)) )                             &
           +dts*( ppten(i,j,k)   &
           -ppterm(i,j,k)*(pi0(i,j,k)+pp3d(i,j,k))                       &
                             *( (u3d(i+1,j,k)-u3d(i,j,k))*rdx*uh(i)  &
                               +(v3d(i,j+1,k)-v3d(i,j,k))*rdy*vh(j) ) )
        enddo
        enddo
        enddo

      ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          fpk(i,j,k)=                 beta*(                                 &
            w3d(i,j,k)*(pk(i,j,k)+qk(i,j,k))                                 &
           +w3d(i,j,k+1)*(pk(i,j,k)-qk(i,j,k)) )                             &
           +dts*( ppten(i,j,k)   &
           -ppterm(i,j,k)*(pi0(i,j,k)+pp3d(i,j,k))                       &
                             *( (xf(i+1)*u3d(i+1,j,k)-xf(i)*u3d(i,j,k))*rdx*uh(i)*rxh(i) ) )
        enddo
        enddo
        enddo

      ENDIF

        IF(thsmall.eq.1)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ftk(i,j,k)=dts*( thten(i,j,k)+beta*rr0(i,j,k)*(    &
            w3d(i,j,k)*tk(i,j,k)+w3d(i,j,k+1)*tk(i,j,k+1)  ) )
        enddo
        enddo
        enddo

        IF(neweqts.ge.1 .and. imoist.eq.1)THEN

        IF(axisymm.eq.0)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ftk(i,j,k)=ftk(i,j,k)+beta*sk(i,j,k)*( w3d(i,j,k)-w3d(i,j,k+1) )   &
             -dts*thterm(i,j,k)*(th0(i,j,k)+th3d(i,j,k))                       &
                               *( (u3d(i+1,j,k)-u3d(i,j,k))*rdx*uh(i)  &
                                 +(v3d(i,j+1,k)-v3d(i,j,k))*rdy*vh(j) )
          enddo
          enddo
          enddo
        ELSE
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ftk(i,j,k)=ftk(i,j,k)+beta*sk(i,j,k)*( w3d(i,j,k)-w3d(i,j,k+1) )   &
             -dts*thterm(i,j,k)*(th0(i,j,k)+th3d(i,j,k))                       &
                               *( (xf(i+1)*u3d(i+1,j,k)-xf(i)*u3d(i,j,k))*rdx*uh(i)*rxh(i) )
          enddo
          enddo
          enddo
        ENDIF   ! for axisymm

        ENDIF   ! for neweqts

        ENDIF   ! for thsmall

        IF(terrain_flag)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=2,nk-1
          do j=1,nj
          do i=1,ni+1
            dpdzx(i,j,k)=gx(i,j,k)*(u3d(i,j,k+1)-u3d(i,j,k-1))*rdz2
          enddo
          enddo
          enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
          do j=1,nj
          do i=1,ni+1
            dpdzx(i,j, 1)=gx(i,j,1 )*(u3d(i,j,2 )-u3d(i,j,1   ))*rdz
            dpdzx(i,j,nk)=gx(i,j,nk)*(u3d(i,j,nk)-u3d(i,j,nk-1))*rdz
          enddo
          enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=2,nk-1
          do j=1,nj+1
          do i=1,ni
            dpdzy(i,j,k)=gy(i,j,k)*(v3d(i,j,k+1)-v3d(i,j,k-1))*rdz2
          enddo
          enddo
          enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
          do j=1,nj+1
          do i=1,ni
            dpdzy(i,j, 1)=gy(i,j,1 )*(v3d(i,j,2 )-v3d(i,j,1   ))*rdz
            dpdzy(i,j,nk)=gy(i,j,nk)*(v3d(i,j,nk)-v3d(i,j,nk-1))*rdz
          enddo
          enddo

          tem = dts*0.5

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            fpk(i,j,k)=fpk(i,j,k)-tem*ppterm(i,j,k)*(pi0(i,j,k)+pp3d(i,j,k))    &
                       *( (dpdzx(i,j,k)+dpdzx(i+1,j,k))             &
                         +(dpdzy(i,j,k)+dpdzy(i,j+1,k)) )
          enddo
          enddo
          enddo

          IF(thsmall.eq.1.and.neweqts.ge.1.and.imoist.eq.1)THEN

          tem = dts*0.5

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ftk(i,j,k)=ftk(i,j,k)-tem*thterm(i,j,k)*(th0(i,j,k)+th3d(i,j,k))    &
                       *( (dpdzx(i,j,k)+dpdzx(i+1,j,k))             &
                         +(dpdzy(i,j,k)+dpdzy(i,j+1,k)) )
          enddo
          enddo
          enddo

          ENDIF

        ENDIF

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=1,ni
          fwk(i,j,k)=dts*wten(i,j,k)                            &
             -beta*mm(i,j,k)*(pp3d(i,j,k)-pp3d(i,j,k-1))
        enddo
        enddo
        enddo

        IF(thsmall.eq.1)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=2,nk
          do j=1,nj
          do i=1,ni
            fwk(i,j,k)=fwk(i,j,k)                             &
               +beta*bk(i,j,k)*(th3d(i,j,k)+th3d(i,j,k-1))
          enddo
          enddo
          enddo

        ENDIF

!--------------------------------------
!  Get boundary conditions for w

        if(terrain_flag)then
          if(timestats.ge.1) time_sound=time_sound+mytime()
          call bcwsfc(dzdx,dzdy,u3d,v3d,w3d)
        else
!$omp parallel do default(shared)  &
!$omp private(i,j)
          do j=1,nj
          do i=1,ni
            w3d(i,j,1)=0.0
          enddo
          enddo
        endif

!---------------------------------------------
!  the implicit solver ....
 
!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          dpdzx(i,j,1)=0.0
          dpdzy(i,j,1)=w3d(i,j,1)
        enddo
        enddo

      IF(thsmall.eq.1)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k,aa,bb,cc,dd,r1)
        do j=1,nj
        do k=2,nk
        do i=1,ni
          aa=asq*( mm(i,j,k)*(qk(i,j,k)-pk(i,j,k))   &
                  +bk(i,j,k)*(dts*tk(i,j,k+1)*rr0(i,j,k)-sk(i,j,k)) )
          bb=1.0+asq*( mm(i,j,k)*( qk(i,j,k)+qk(i,j,k-1)                    &
                                  +pk(i,j,k)-pk(i,j,k-1) )                  &
                      -bk(i,j,k)*(dts*tk(i,j,k)*(rr0(i,j,k)+rr0(i,j,k-1))   &
                                  +sk(i,j,k)-sk(i,j,k-1)) )
          cc=asq*( mm(i,j,k)*(pk(i,j,k-1)+qk(i,j,k-1))   &
                  +bk(i,j,k)*(dts*tk(i,j,k-1)*rr0(i,j,k-1)+sk(i,j,k-1)) )
          dd=w3d(i,j,k)+fwk(i,j,k)                                                    &
              -alph*( mm(i,j,k)*(pp3d(i,j,k)+fpk(i,j,k)-pp3d(i,j,k-1)-fpk(i,j,k-1))   &
                     -bk(i,j,k)*(th3d(i,j,k)+ftk(i,j,k)+th3d(i,j,k-1)+ftk(i,j,k-1)) )
          r1 = 1.0/(bb-cc*dpdzx(i,j,k-1))
          dpdzx(i,j,k)=aa*r1
          dpdzy(i,j,k)=(dd+cc*dpdzy(i,j,k-1))*r1
        enddo
        enddo
        enddo

      ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k,aa,bb,cc,dd,r1)
        do j=1,nj
        do k=2,nk
        do i=1,ni
          aa=asq*mm(i,j,k)*(qk(i,j,k)-pk(i,j,k))
          bb=1.0+asq*mm(i,j,k)*( qk(i,j,k)+qk(i,j,k-1)    &
                            +pk(i,j,k)-pk(i,j,k-1) )
          cc=asq*mm(i,j,k)*(pk(i,j,k-1)+qk(i,j,k-1))
          dd=w3d(i,j,k)+fwk(i,j,k)    &
              -alph*mm(i,j,k)*(pp3d(i,j,k)+fpk(i,j,k)-pp3d(i,j,k-1)-fpk(i,j,k-1))
          r1 = 1.0/(bb-cc*dpdzx(i,j,k-1))
          dpdzx(i,j,k)=aa*r1
          dpdzy(i,j,k)=(dd+cc*dpdzy(i,j,k-1))*r1
        enddo
        enddo
        enddo

      ENDIF

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          w3d(i,j,nk+1)=0.0
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do j=1,nj
        do k=nk,2,-1
        do i=1,ni
          w3d(i,j,k)=dpdzx(i,j,k)*w3d(i,j,k+1)+dpdzy(i,j,k)
        enddo
        enddo
        enddo
        if(timestats.ge.1) time_sound=time_sound+mytime()

        if(n.eq.nloop) call bcw(w3d,1)

        if(terrain_flag) call bcwsfc(dzdx,dzdy,u3d,v3d,w3d)

#ifdef MPI
        if(n.eq.nloop)then
          call comm_3w_start(w3d,ww31,ww32,we31,we32,   &
                                 ws31,ws32,wn31,wn32,reqs_w)
        endif
#endif

!-------------------------
#ifdef MPI
        IF(n.gt.1)THEN
          call comm_1s_end_misc(ppd,pw1,pw2,pe1,pe2,   &
                               ps1,ps2,pn1,pn2,reqs_p)
        ENDIF
#endif
 
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ppd(i,j,k)=pp3d(i,j,k)
          pp3d(i,j,k)=pp3d(i,j,k)+fpk(i,j,k)+alph*(    &
               w3d(i,j,k  )*(pk(i,j,k)+qk(i,j,k))          &
              +w3d(i,j,k+1)*(pk(i,j,k)-qk(i,j,k)) )
          if(abs(pp3d(i,j,k)).lt.smeps) pp3d(i,j,k)=0.0
          ppd(i,j,k)=pp3d(i,j,k)-ppd(i,j,k)-dts*ppten(i,j,k)
          ppd(i,j,k)=pp3d(i,j,k)+kdiv*ppd(i,j,k)
        enddo
        enddo
        enddo
        if(timestats.ge.1) time_sound=time_sound+mytime()

        if(n.eq.nloop .and. nrk.eq.3 .and. imoist.eq.1)then
          tem=0
        else
          if(n.eq.nloop) call bcs(pp3d)
        endif

#ifdef MPI
        if(n.eq.nloop)then
          if(nrk.lt.3.or.imoist.eq.0)then
            call comm_3s_start(pp3d,pw31,pw32,pe31,pe32,   &
                                    ps31,ps32,pn31,pn32,reqs_p)
          endif
        endif
#endif

        IF(n.lt.nloop)THEN
          call bcs(ppd)
#ifdef MPI
          call comm_1s_start(ppd,pw1,pw2,pe1,pe2,   &
                                 ps1,ps2,pn1,pn2,reqs_p)
#endif
        ENDIF

!--------------------------------------------------------------------

      IF(thsmall.eq.1)THEN

        tem = alph*dts

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          th3d(i,j,k)=th3d(i,j,k)+ftk(i,j,k)+tem*rr0(i,j,k)*(    &
            w3d(i,j,k)*tk(i,j,k)+w3d(i,j,k+1)*tk(i,j,k+1)  )
        enddo
        enddo
        enddo

        IF(neweqts.ge.1 .and. imoist.eq.1)THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            th3d(i,j,k)=th3d(i,j,k)+alph*sk(i,j,k)*( w3d(i,j,k)-w3d(i,j,k+1) )
          enddo
          enddo
          enddo
        ENDIF
        if(timestats.ge.1) time_sound=time_sound+mytime()

        if(n.eq.nloop)then
          if(nrk.lt.3.or.imoist.eq.0)then
            call bcs(th3d)
#ifdef MPI
            call comm_3s_start(th3d,sw31,sw32,se31,se32,   &
                                    ss31,ss32,sn31,sn32,reqs_s)
#endif
          endif
        endif

      ENDIF

!--------------------------------------------------------------------

      ENDDO

!!!      if(terrain_flag)then
!!!        if(timestats.ge.1) time_sound=time_sound+mytime()
!!!        call bcwsfc(dzdx,dzdy,u3d,v3d,w3d)
!!!        call bc2d(w3d(ib,jb,1))
!!!      endif

!--------------------------------------------------------------------

      return
      end



soundns.F/      1298670057  19071 8000  100644  8878      `


      subroutine soundns(xh,rxh,uh,xf,uf,yh,vh,yf,vf,zh,mh,mf,pi0,thv0,       &
                         radbcw,radbce,radbcs,radbcn,                &
                         divx,u0,ua,u3d,uten,v0,va,v3d,vten,wa,w3d,wten,   &
                         ppi,pp3d,ppten,thv,ppterm,dttmp,nrk,rtime,  &
                         reqs_u,reqs_v,reqs_w,reqs_s,reqs_p,         &
                         uw31,uw32,ue31,ue32,us31,us32,un31,un32,    &
                         vw31,vw32,ve31,ve32,vs31,vs32,vn31,vn32,    &
                         ww31,ww32,we31,we32,ws31,ws32,wn31,wn32,    &
                         sw31,sw32,se31,se32,ss31,ss32,sn31,sn32,    &
                         pw1,pw2,pe1,pe2,ps1,ps2,pn1,pn2)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, dimension(ib:ie) :: xh,rxh,uh
      real, dimension(ib:ie+1) :: xf,uf
      real, dimension(jb:je) :: yh,vh
      real, dimension(jb:je+1) :: yf,vf
      real, dimension(ib:ie,jb:je,kb:ke) :: zh,mh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, dimension(ib:ie,jb:je,kb:ke) :: pi0,thv0
      real, dimension(jb:je,kb:ke) :: radbcw,radbce
      real, dimension(ib:ie,kb:ke) :: radbcs,radbcn
      real, dimension(ib:ie,jb:je,kb:ke) :: divx
      real, dimension(ib:ie+1,jb:je,kb:ke) :: u0,ua,u3d,uten
      real, dimension(ib:ie,jb:je+1,kb:ke) :: v0,va,v3d,vten
      real, dimension(ib:ie,jb:je,kb:ke+1) :: wa,w3d,wten
      real, dimension(ib:ie,jb:je,kb:ke) :: ppi,pp3d,ppten
      real, dimension(ib:ie,jb:je,kb:ke) :: thv,ppterm
      real dttmp
      integer nrk
      real, intent(in) :: rtime
      integer, dimension(rmp) :: reqs_u,reqs_v,reqs_w,reqs_s,reqs_p
      real, dimension(cmp,jmp,kmp)   :: uw31,uw32,ue31,ue32
      real, dimension(imp+1,cmp,kmp) :: us31,us32,un31,un32
      real, dimension(cmp,jmp+1,kmp) :: vw31,vw32,ve31,ve32
      real, dimension(imp,cmp,kmp)   :: vs31,vs32,vn31,vn32
      real, dimension(cmp,jmp,kmp-1) :: ww31,ww32,we31,we32
      real, dimension(imp,cmp,kmp-1) :: ws31,ws32,wn31,wn32
      real, dimension(cmp,jmp,kmp)   :: sw31,sw32,se31,se32
      real, dimension(imp,cmp,kmp)   :: ss31,ss32,sn31,sn32
      real, dimension(jmp,kmp) :: pw1,pw2,pe1,pe2
      real, dimension(imp,kmp) :: ps1,ps2,pn1,pn2

!-----

      integer :: i,j,k
      real :: tem,tem2

#ifdef MPI
      include 'mpif.h'
#endif

!---------------------------------------------------------------------

        if(irbc.eq.2)then
 
          if(ibw.eq.1 .or. ibe.eq.1) call radbcew(radbcw,radbce,ua)
 
          if(ibs.eq.1 .or. ibn.eq.1) call radbcns(radbcs,radbcn,va)
 
        endif

!-----

        if(wbc.eq.2.and.ibw.eq.1)then
!$omp parallel do default(shared)   &
!$omp private(j,k)
          do k=1,nk
          do j=1,nj
            u3d(1,j,k)=ua(1,j,k)-dttmp*radbcw(j,k)       &
                      *(ua(2,j,k)-ua(1,j,k))*rdx*uh(1)   &
                         +dttmp*uten(1,j,k)
          enddo
          enddo
        endif

        if(ebc.eq.2.and.ibe.eq.1)then
!$omp parallel do default(shared)   &
!$omp private(j,k)
          do k=1,nk
          do j=1,nj
            u3d(ni+1,j,k)=ua(ni+1,j,k)-dttmp*radbce(j,k)           &
                         *(ua(ni+1,j,k)-ua(ni  ,j,k))*rdx*uh(ni)   &
                         +dttmp*uten(ni+1,j,k)
          enddo
          enddo
        endif

        tem=dttmp*rdx*cp*0.5

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1+ibw,ni+1-ibe
          u3d(i,j,k)=ua(i,j,k)+dttmp*uten(i,j,k)             &
                  -(tem*(ppi(i,j,k)-ppi(i-1,j,k))*uf(i)*     &
                        (thv(i,j,k)+thv(i-1,j,k)))
        enddo
        enddo
        enddo

!----------------------------------------------
!  convergence forcing:

        IF( convinit.eq.1 )THEN
          IF( rtime.le.convtime .and. nx.gt.1 )THEN
            call convinitu(myid,ib,ie,jb,je,kb,ke,ni,nj,nk,ibw,ibe,   &
                           zdeep,lamx,lamy,xcent,ycent,aconv,    &
                           xf,yh,zh,u0,u3d)
          ENDIF
        ENDIF

!----------------------------------------------

        if(timestats.ge.1) time_sound=time_sound+mytime()

        call bcu(u3d)

#ifdef MPI
        call comm_3u_start(u3d,uw31,uw32,ue31,ue32,   &
                               us31,us32,un31,un32,reqs_u)
#endif

!-----

      IF(axisymm.eq.0)THEN

        if(sbc.eq.2.and.ibs.eq.1)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
          do k=1,nk
          do i=1,ni
            v3d(i,1,k)=va(i,1,k)-dttmp*radbcs(i,k)       &
                      *(va(i,2,k)-va(i,1,k))*rdy*vh(1)   &
                      +dttmp*vten(i,1,k)
          enddo
          enddo
        endif
 
        if(nbc.eq.2.and.ibn.eq.1)then
!$omp parallel do default(shared)   &
!$omp private(i,k)
          do k=1,nk
          do i=1,ni
            v3d(i,nj+1,k)=va(i,nj+1,k)-dttmp*radbcn(i,k)           &
                         *(va(i,nj+1,k)-va(i,nj  ,k))*rdy*vh(nj)   &
                         +dttmp*vten(i,nj+1,k)
          enddo
          enddo
        endif

        tem=dttmp*rdy*cp*0.5

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1+ibs,nj+1-ibn
        do i=1,ni
          v3d(i,j,k)=va(i,j,k)+dttmp*vten(i,j,k)             &
                  -(tem*(ppi(i,j,k)-ppi(i,j-1,k))*vf(j)*     &
                        (thv(i,j,k)+thv(i,j-1,k)))
        enddo
        enddo
        enddo

!----------------------------------------------
!  convergence forcing:

        IF( convinit.eq.1 )THEN
          IF( rtime.le.convtime .and. ny.gt.1 )THEN
            call convinitv(myid,ib,ie,jb,je,kb,ke,ni,nj,nk,ibs,ibn,   &
                           zdeep,lamx,lamy,xcent,ycent,aconv,    &
                           xh,yf,zh,v0,v3d)
          ENDIF
        ENDIF

!----------------------------------------------

        if(timestats.ge.1) time_sound=time_sound+mytime()

        call bcv(v3d)

#ifdef MPI
        call comm_3v_start(v3d,vw31,vw32,ve31,ve32,   &
                               vs31,vs32,vn31,vn32,reqs_v)
#endif

      ENDIF

!-----

!$omp parallel do default(shared)   &
!$omp private(i,j,k,tem)
        do k=2,nk
        do j=1,nj
        do i=1,ni
          tem=dttmp*rdz*mf(i,j,k)*cp*0.5
          w3d(i,j,k)=wa(i,j,k)+dttmp*wten(i,j,k)             &
                  -(tem*(ppi(i,j,k)-ppi(i,j,k-1))*    &
                        (thv(i,j,k)+thv(i,j,k-1)))
        enddo
        enddo
        enddo
        if(timestats.ge.1) time_sound=time_sound+mytime()

        call bcw(w3d,1)

#ifdef MPI
        call comm_3w_start(w3d,ww31,ww32,we31,we32,   &
                               ws31,ws32,wn31,wn32,reqs_w)
#endif

!-----

    IF(axisymm.eq.0)THEN
 
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        divx(i,j,k)=(u3d(i+1,j,k)-u3d(i,j,k))*rdx*uh(i)    &
                   +(v3d(i,j+1,k)-v3d(i,j,k))*rdy*vh(j)    &
                   +(w3d(i,j,k+1)-w3d(i,j,k))*rdz*mh(i,j,k)
      enddo
      enddo
      enddo

    ELSE
 
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        divx(i,j,k)=(xf(i+1)*u3d(i+1,j,k)-xf(i)*u3d(i,j,k))*rdx*uh(i)*rxh(i)   &
                   +(w3d(i,j,k+1)-w3d(i,j,k))*rdz*mh(i,j,k)
      enddo
      enddo
      enddo

    ENDIF

        tem=dttmp*g*0.5/cp
        tem2=dttmp*rddcv

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          pp3d(i,j,k)=ppi(i,j,k)+dttmp*ppten(i,j,k)              &
              +( tem*(w3d(i,j,k)+w3d(i,j,k+1))/thv0(i,j,k) )         &
              -( (pi0(i,j,k)+ppi(i,j,k))*dttmp*ppterm(i,j,k)*divx(i,j,k) )
          if(abs(pp3d(i,j,k)).lt.smeps) pp3d(i,j,k)=0.0
        enddo
        enddo
        enddo

        if(timestats.ge.1) time_sound=time_sound+mytime()
 
        call bcs(pp3d)

#ifdef MPI
        if(nrk.lt.3.or.imoist.eq.0)then
          call comm_3s_start(pp3d,sw31,sw32,se31,se32,   &
                                  ss31,ss32,sn31,sn32,reqs_s)
        endif

!--------------------------------------------------------------------
!  Finish comm

        call comm_3u_end(u3d,uw31,uw32,ue31,ue32,   &
                             us31,us32,un31,un32,reqs_u)

!-----

        call comm_3v_end(v3d,vw31,vw32,ve31,ve32,   &
                             vs31,vs32,vn31,vn32,reqs_v)

!-----

        call comm_3w_end(w3d,ww31,ww32,we31,we32,   &
                             ws31,ws32,wn31,wn32,reqs_w)

!-----

        if(nrk.lt.3.or.imoist.eq.0)then
          call comm_3s_end(pp3d,sw31,sw32,se31,se32,   &
                                ss31,ss32,sn31,sn32,reqs_s)
        endif
#endif
!-------------------------------------------------------------------- 

      return
      end


statpack.F/     1298670057  19071 8000  100644  14169     `


      subroutine statpack(nrec,ndt,dt,rtime,adt,acfl,cloudvar,qname,budname,qbudget,asq,bsq, &
                          xh,rxh,uh,ruh,xf,uf,yh,vh,rvh,vf,zh,mh,rmh,mf,    &
                          rstat,pi0,rho0,thv0,th0,qv0,u0,v0,                &
                          dum1,dum2,dum3,dum4,divx,rho,prs,                 &
                          ua,va,wa,ppi,tha,qa,vq,kmh,kmv,khh,khv,tkea,pta,u10,v10)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
#ifdef MPI
      include 'mpif.h'
#endif

      integer :: nrec,ndt
      real :: dt,rtime
      real*8 :: adt,acfl
      logical, dimension(maxq) :: cloudvar
      character*3, dimension(maxq) :: qname
      character*6, dimension(maxq) :: budname
      real*8, dimension(nbudget) :: qbudget
      real*8, dimension(numq) :: asq,bsq
      real, dimension(ib:ie) :: xh,rxh,uh,ruh
      real, dimension(ib:ie+1) :: xf,uf
      real, dimension(jb:je) :: yh,vh,rvh
      real, dimension(jb:je+1) :: vf
      real, dimension(ib:ie,jb:je,kb:ke) :: zh,mh,rmh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, dimension(stat_out) :: rstat
      real, dimension(ib:ie,jb:je,kb:ke) :: pi0,rho0,thv0,th0,qv0
      real, dimension(ib:ie,jb:je,kb:ke) :: dum1,dum2,dum3,dum4,divx,rho,prs
      real, dimension(ib:ie+1,jb:je,kb:ke) :: u0,ua
      real, dimension(ib:ie,jb:je+1,kb:ke) :: v0,va
      real, dimension(ib:ie,jb:je,kb:ke+1) :: wa
      real, dimension(ib:ie,jb:je,kb:ke) :: ppi,tha
      real, dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: qa,vq
      real, dimension(ibc:iec,jbc:jec,kbc:kec) :: kmh,kmv,khh,khv
      real, dimension(ibt:iet,jbt:jet,kbt:ket) :: tkea
      real, dimension(ibp:iep,jbp:jep,kbp:kep,npt) :: pta
      real, intent(in), dimension(ibl:iel,jbl:jel) :: u10,v10

!-----------------------------------------------------------------------

      integer i,j,k,n,nstat
      character*6 :: text1,text2
      real qvs
      real rslf,rsif
#ifdef MPI
      real*8 var
#endif

!-----------------------------------------------------------------------

      nstat = 0

    IF( adapt_dt.eq.1 )THEN
      nstat = 1
      rstat(nstat) = sngl(  adt/float(max(1,ndt)) )
      acfl         = sngl( acfl/float(max(1,ndt)) )
      ndt  = 0
      adt  = 0.0
    ENDIF

      if(stat_w.eq.1) call maxmin(ni,nj,nk+1,wa,nstat,rstat,'WMAX  ','WMIN  ')
      if(stat_u.eq.1)then
        call maxmin(ni+1,nj,nk,ua,nstat,rstat,'UMAX  ','UMIN  ')
        call maxmin2d(ni+1,nj,ua(ib,jb,1),nstat,rstat,'SUMAX ','SUMIN ')
      endif
      if(stat_v.eq.1)then
        call maxmin(ni,nj+1,nk,va,nstat,rstat,'VMAX  ','VMIN  ')
!!!      print *,'  umax:',rstat(nstat)+rstat(nstat-1),rstat(nstat-4)+rstat(nstat-5),rstat(nstat-1)-rstat(nstat-5)
        call maxmin2d(ni,nj+1,va(ib,jb,1),nstat,rstat,'SVMAX ','SVMIN ')
      endif
      if(stat_rmw.eq.1)then
        call getrmw(nstat,rstat,xh,va)
      endif
 
      if(stat_pipert.eq.1) call maxmin(ni,nj,nk,ppi,nstat,rstat,'PPIMAX','PPIMIN')

      if(stat_prspert.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          dum2(i,j,k)=prs(i,j,k)-p00*(pi0(i,j,k)**cpdrd)
        enddo
        enddo
        enddo
        call maxmin(ni,nj,nk,dum2,nstat,rstat,'PPMAX ','PPMIN ')
      endif

      if(stat_thpert.eq.1)then
        call maxmin(ni,nj,nk,tha,nstat,rstat,'THPMAX','THPMIN')
        call maxmin2d(ni,nj,tha(ib,jb,1),nstat,rstat,'STHPMX','STHPMN')
      endif

      if(imoist.eq.1.and.stat_q.eq.1)then
        do n=1,numq
          text1='MAX   '
          text2='MIN   '
          write(text1(4:6),121) qname(n)
          write(text2(4:6),121) qname(n)
121       format(a3)
          call maxmin(ni,nj,nk,qa(ib,jb,kb,n),nstat,rstat,text1,text2)
        enddo
      endif

      if(iturb.eq.1)then
        if(stat_tke.eq.1) call maxmin(ni,nj,nkt,tkea,nstat,rstat,'TKEMAX','TKEMIN')
      endif

      if(iturb.ge.1)then
        if(stat_km.eq.1) call maxmin(ni,nj,nkt,kmh,nstat,rstat,'KMHMAX','KMHMIN')
        if(stat_km.eq.1) call maxmin(ni,nj,nkt,kmv,nstat,rstat,'KMVMAX','KMVMIN')
        if(stat_kh.eq.1) call maxmin(ni,nj,nkt,khh,nstat,rstat,'KHHMAX','KHHMIN')
        if(stat_kh.eq.1) call maxmin(ni,nj,nkt,khv,nstat,rstat,'KHVMAX','KHVMIN')
      endif

      if(stat_div.eq.1)then
      IF(axisymm.eq.0)THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          divx(i,j,k)=                                                     &
              0.5*( (rho0(i,j,k)+rho0(i+1,j,k))*ua(i+1,j,k)                &
                   -(rho0(i,j,k)+rho0(i-1,j,k))*ua(i  ,j,k) )*rdx*uh(i)    &
             +0.5*( (rho0(i,j,k)+rho0(i,j+1,k))*va(i,j+1,k)                &
                   -(rho0(i,j,k)+rho0(i,j-1,k))*va(i,j  ,k) )*rdy*vh(j)    &
             +0.5*( (rho0(i,j,k)+rho0(i,j,k+1))*wa(i,j,k+1)                &
                   -(rho0(i,j,k)+rho0(i,j,k-1))*wa(i,j,k  ) )*rdz*mh(i,j,k)
        enddo
        enddo
        enddo
      ELSE
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          divx(i,j,k)=                                                     &
              rho0(1,1,k)*( xf(i+1)*ua(i+1,j,k)                            &
                           -xf(i  )*ua(i  ,j,k) )*rdx*uh(i)*rxh(i)         &
             +0.5*( (rho0(i,j,k)+rho0(i,j,k+1))*wa(i,j,k+1)                &
                   -(rho0(i,j,k)+rho0(i,j,k-1))*wa(i,j,k  ) )*rdz*mh(i,j,k)
        enddo
        enddo
        enddo
      ENDIF
        call maxmin(ni,nj,nk,divx,nstat,rstat,'DIVMAX','DIVMIN')
      endif

      IF(imoist.eq.1)THEN

        if(stat_rh.eq.1 .or. stat_the.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k,qvs)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            qvs=rslf( prs(i,j,k) , (th0(i,j,k)+tha(i,j,k))*(pi0(i,j,k)+ppi(i,j,k)) )
            dum2(i,j,k)=qa(i,j,k,nqv)*(1.0+qvs*reps)    &
                       /(qvs*(1.0+qa(i,j,k,nqv)*reps))
          enddo
          enddo
          enddo
        endif

        if(stat_rh.eq.1)then
          call maxmin(ni,nj,nk,dum2,nstat,rstat,'RHMAX ','RHMIN ')
        endif

        if(iice.eq.1 .and. stat_rhi.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k,qvs)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            qvs=rsif( prs(i,j,k) , (th0(i,j,k)+tha(i,j,k))*(pi0(i,j,k)+ppi(i,j,k)) )
            dum3(i,j,k)=qa(i,j,k,nqv)*(1.0+qvs*reps)    &
                       /(qvs*(1.0+qa(i,j,k,nqv)*reps))
          enddo
          enddo
          enddo
          call maxmin(ni,nj,nk,dum3,nstat,rstat,'RHIMAX','RHIMIN')
        endif

      ENDIF

        if(iptra.eq.1)then
          do n=1,npt
            text1='MAXPT '
            text2='MINPT '
            write(text1(6:6),122) n
            write(text2(6:6),122) n
122         format(i1)
            call maxmin(ni,nj,nk,pta(ib,jb,kb,n),nstat,rstat,text1,text2)
          enddo
        endif

      IF(imoist.eq.1)THEN

        if(stat_the.eq.1)then
          call calcthe(zh,pi0,th0,dum4,dum2,prs,ppi,tha,qa)
          call maxmin(ni,nj,nk,dum4,nstat,rstat,'THEMAX','THEMIN')
          call maxmin2d(ni,nj,dum4(ib,jb,1),nstat,rstat,'STHEMX','STHEMN')
        endif

        if(stat_cloud.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            dum1(i,j,k)=0.0
          enddo
          enddo
          enddo
          do n=1,numq
            if(cloudvar(n))then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
              do k=1,nk
              do j=1,nj
              do i=1,ni
                dum1(i,j,k)=dum1(i,j,k)+qa(i,j,k,n)
              enddo
              enddo
              enddo
            endif
          enddo
          call cloud(nstat,rstat,zh,dum1)
        endif
      ENDIF

      if(stat_sfcprs.eq.1)then
        call maxmin2d(ni,nj,prs(ib,jb,1),nstat,rstat,'SFPMAX','SFPMIN')
      endif

      if(stat_wsp.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          dum1(i,j,k)=sqrt( (umove+0.5*(ua(i,j,k)+ua(i+1,j,k)))**2     &
                           +(vmove+0.5*(va(i,j,k)+va(i,j+1,k)))**2 )
        enddo
        enddo
        enddo
        call maxmin(ni,nj,nk,dum1,nstat,rstat,'WSPMAX','WSPMIN')
        call maxmin2d(ni,nj,dum1(ib,jb,1),nstat,rstat,'SWSPMX','SWSPMN')
      IF(idrag.eq.1)THEN
!$omp parallel do default(shared)  &
!$omp private(i,j)
! ORF coming up infinity
!       do j=1,nj
!       do i=1,ni
!         dum1(i,j,1)=sqrt( u10(i,j)**2 + v10(i,j)**2 )
!       enddo
!       enddo
!       call maxmin2d(ni,nj,dum1(ib,jb,1),nstat,rstat,'10MWMX','10MWMN')
      ENDIF
      endif

      if(stat_cfl.eq.1) call calccfl(nstat,rstat,dt,acfl,uf,vf,mf,ua,va,wa,1)

      if(stat_cfl.eq.1) call calcksmax(nstat,rstat,dt,uh,vh,mf,kmh,kmv,khh,khv)

      if(stat_vort.eq.1) call vertvort(nstat,rstat,xh,xf,uf,vf,zh,ua,va)

      if(stat_tmass.eq.1) call calcmass(nstat,rstat,ruh,rvh,rmh,rho)

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        dum1(i,j,k)=0.0
        dum2(i,j,k)=0.0
        dum3(i,j,k)=0.0
      enddo
      enddo
      enddo
 
      IF(imoist.eq.1)THEN

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          dum1(i,j,k)=qa(i,j,k,nqv)
        enddo
        enddo
        enddo

        call getqli(0,qa,dum2,dum3)

        if(stat_tmois.eq.1)then
          call totmois(nstat,rstat,qbudget(budrain),ruh,rvh,rmh,dum1,dum2,dum3,rho)
        endif

        if(stat_qmass.eq.1)then
          do n=1,numq
            IF( (n.eq.nqv) .or.                                 &
                (n.ge.nql1.and.n.le.nql2) .or.                  &
                (n.ge.nqs1.and.n.le.nqs2.and.iice.eq.1) )THEN
              text1='   MAS'
              write(text1(1:3),121) qname(n)
              call totq(nstat,rstat,ruh,rvh,rmh,qa(ib,jb,kb,n),rho,text1)
            ENDIF
          enddo
        endif

      ENDIF

        if(imoist.eq.1)then
          if(ptype.eq.1.or.ptype.eq.2)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
            do k=1,nk
            do j=1,nj
            do i=1,ni
              dum4(i,j,k)=vq(i,j,k,3)
            enddo
            enddo
            enddo
          elseif(ptype.eq.6)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
            do k=1,nk
            do j=1,nj
            do i=1,ni
              dum4(i,j,k)=vq(i,j,k,2)
            enddo
            enddo
            enddo
          else
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
            do k=1,nk
            do j=1,nj
            do i=1,ni
              dum4(i,j,k)=0.0
            enddo
            enddo
            enddo
          endif
        else
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            dum4(i,j,k)=0.0
          enddo
          enddo
          enddo
        endif
 
      if(stat_tenerg.eq.1)then
        call calcener(nstat,rstat,ruh,rvh,zh,rmh,pi0,th0,rho,ua,va,wa,ppi,tha,    &
                      dum1,dum2,dum3,dum4)
      endif

      if(stat_mo.eq.1)then
        call calcmoe(nstat,rstat,ruh,rvh,rmh,rho,ua,va,wa,dum1,dum2,dum3,dum4)
      endif

      if(stat_tmf.eq.1) call tmf(nstat,rstat,ruh,rvh,rho,wa)

!----------

      IF(imoist.eq.1 .and. stat_pcn.eq.1)THEN
#ifdef MPI
        do n=1,nbudget
          var=0.0d0
          call MPI_REDUCE(qbudget(n),var,1,MPI_DOUBLE_PRECISION,MPI_SUM,0,   &
                          MPI_COMM_WORLD,ierr)
          qbudget(n)=var
        enddo
        if(myid.eq.0)then
#endif
100     format(2x,a6,':',1x,e13.6)
 
        do n=1,nbudget
          write(6,100) budname(n),qbudget(n)
          nstat = nstat + 1
          rstat(nstat) = qbudget(n)
        enddo
#ifdef MPI
        endif
#endif
      ENDIF

      IF(imoist.eq.1 .and. stat_qsrc.eq.1)THEN
#ifdef MPI
        do n=1,numq
          var=0.0d0
          call MPI_REDUCE(asq(n),var,1,MPI_DOUBLE_PRECISION,MPI_SUM,0,   &
                          MPI_COMM_WORLD,ierr)
          asq(n)=var
        enddo
        do n=1,numq
          var=0.0d0
          call MPI_REDUCE(bsq(n),var,1,MPI_DOUBLE_PRECISION,MPI_SUM,0,   &
                          MPI_COMM_WORLD,ierr)
          bsq(n)=var
        enddo
        if(myid.eq.0)then
#endif
        do n=1,numq
          text1='as    '
          write(text1(3:5),121) qname(n)
          write(6,100) text1,asq(n)
          nstat = nstat + 1
          rstat(nstat) = asq(n)
        enddo
        do n=1,numq
          text1='bs    '
          write(text1(3:5),121) qname(n)
          write(6,100) text1,bsq(n)
          nstat = nstat + 1
          rstat(nstat) = bsq(n)
        enddo
#ifdef MPI
        endif
#endif
      ENDIF

  IF(myid.eq.0)THEN

!-----------------------------------------------------------------------
!  writeitout:  GrADS format

    IF(output_format.eq.1)THEN

      open(unit=60,file=statfile,form='unformatted',access='direct',   &
           recl=4,status='unknown')
      if( nstat.ne.stat_out )   stop 12998
      do n=1,nstat
#ifdef DP
        write(60,rec=nrec) sngl(rstat(n))
#else
        write(60,rec=nrec) rstat(n)
#endif
        nrec = nrec + 1
      enddo
      close(unit=60)

!-----------------------------------------------------------------------
!  writeitout:  netcdf format

#ifdef NETCDF
    ELSEIF(output_format.eq.2)THEN

      call writestat_nc(nrec,rtime,nstat,rstat,qname,budname)

#endif

!-----------------------------------------------------------------------
!  writeout:  hdf5 format

#ifdef HDFOUT
    ELSEIF(output_format.ge.3)THEN

      call writestat_hdf5(nrec,rtime,nstat,rstat,qname,budname)

#endif

!-----------------------------------------------------------------------

    ENDIF

  ENDIF

      if(timestats.ge.1) time_stat=time_stat+mytime()

      return
      end



thompson.F/     1298670057  19071 8000  100644  168833    `
!+---+-----------------------------------------------------------------+
!.. This subroutine computes the moisture tendencies of water vapor,
!.. cloud droplets, rain, cloud ice (pristine), snow, and graupel.
!.. Prior to WRFv2.2 this code was based on Reisner et al (1998), but
!.. few of those pieces remain.  A complete description is now found in
!.. Thompson, G., P. R. Field, R. M. Rasmussen, and W. D. Hall, 2008:
!.. Explicit Forecasts of winter precipitation using an improved bulk
!.. microphysics scheme. Part II: Implementation of a new snow
!.. parameterization.  Mon. Wea. Rev., 136, 5095-5115.
!.. Prior to WRFv3.1, this code was single-moment rain prediction as
!.. described in the reference above, but in v3.1 and higher, the
!.. scheme is two-moment rain (predicted rain number concentration).
!..
!.. Most importantly, users may wish to modify the prescribed number of
!.. cloud droplets (Nt_c; see guidelines mentioned below).  Otherwise,
!.. users may alter the rain and graupel size distribution parameters
!.. to use exponential (Marshal-Palmer) or generalized gamma shape.
!.. The snow field assumes a combination of two gamma functions (from
!.. Field et al. 2005) and would require significant modifications
!.. throughout the entire code to alter its shape as well as accretion
!.. rates.  Users may also alter the constants used for density of rain,
!.. graupel, ice, and snow, but the latter is not constant when using
!.. Paul Field's snow distribution and moments methods.  Other values
!.. users can modify include the constants for mass and/or velocity
!.. power law relations and assumed capacitances used in deposition/
!.. sublimation/evaporation/melting.
!.. Remaining values should probably be left alone.
!..
!..Author: Greg Thompson, NCAR-RAL, gthompsn@ucar.edu, 303-497-2805
!..Last modified: 21 Nov 2010
!..Adapted for CM1: 15 Dec 2010
!+---+-----------------------------------------------------------------+
!wrft:model_layer:physics
!+---+-----------------------------------------------------------------+
!
      MODULE module_mp_thompson

!      USE module_wrf_error
!     USE module_utility, ONLY: WRFU_Clock, WRFU_Alarm
!     USE module_domain, ONLY : HISTORY_ALARM, Is_alarm_tstep

      IMPLICIT NONE

      LOGICAL, PARAMETER, PRIVATE:: iiwarm = .false.
      INTEGER, PARAMETER, PRIVATE:: IFDRY = 0
      REAL, PARAMETER, PRIVATE:: T_0 = 273.15
      REAL, PARAMETER, PRIVATE:: PI = 3.1415926536

!..Densities of rain, snow, graupel, and cloud ice.
      REAL, PARAMETER, PRIVATE:: rho_w = 1000.0
      REAL, PARAMETER, PRIVATE:: rho_s = 100.0
      REAL, PARAMETER, PRIVATE:: rho_g = 400.0
      REAL, PARAMETER, PRIVATE:: rho_i = 890.0

!..Prescribed number of cloud droplets.  Set according to known data or
!.. roughly 100 per cc (100.E6 m^-3) for Maritime cases and
!.. 300 per cc (300.E6 m^-3) for Continental.  Gamma shape parameter,
!.. mu_c, calculated based on Nt_c is important in autoconversion
!.. scheme.
      ! setting to Continental by default:  GHB, 091001
!!!      REAL, PARAMETER, PRIVATE:: Nt_c = 100.E6
      REAL, PARAMETER, PRIVATE:: Nt_c = 300.E6

!..Generalized gamma distributions for rain, graupel and cloud ice.
!.. N(D) = N_0 * D**mu * exp(-lamda*D);  mu=0 is exponential.
      REAL, PARAMETER, PRIVATE:: mu_r = 0.0
      REAL, PARAMETER, PRIVATE:: mu_g = 0.0
      REAL, PARAMETER, PRIVATE:: mu_i = 0.0
      REAL, PRIVATE:: mu_c

!..Sum of two gamma distrib for snow (Field et al. 2005).
!.. N(D) = M2**4/M3**3 * [Kap0*exp(-M2*Lam0*D/M3)
!..    + Kap1*(M2/M3)**mu_s * D**mu_s * exp(-M2*Lam1*D/M3)]
!.. M2 and M3 are the (bm_s)th and (bm_s+1)th moments respectively
!.. calculated as function of ice water content and temperature.
      REAL, PARAMETER, PRIVATE:: mu_s = 0.6357
      REAL, PARAMETER, PRIVATE:: Kap0 = 490.6
      REAL, PARAMETER, PRIVATE:: Kap1 = 17.46
      REAL, PARAMETER, PRIVATE:: Lam0 = 20.78
      REAL, PARAMETER, PRIVATE:: Lam1 = 3.29

!..Y-intercept parameter for graupel is not constant and depends on
!.. mixing ratio.  Also, when mu_g is non-zero, these become equiv
!.. y-intercept for an exponential distrib and proper values are
!.. computed based on same mixing ratio and total number concentration.
      REAL, PARAMETER, PRIVATE:: gonv_min = 1.E4
      REAL, PARAMETER, PRIVATE:: gonv_max = 1.E6

!..Mass power law relations:  mass = am*D**bm
!.. Snow from Field et al. (2005), others assume spherical form.
      REAL, PARAMETER, PRIVATE:: am_r = PI*rho_w/6.0
      REAL, PARAMETER, PRIVATE:: bm_r = 3.0
      REAL, PARAMETER, PRIVATE:: am_s = 0.069
      REAL, PARAMETER, PRIVATE:: bm_s = 2.0
      REAL, PARAMETER, PRIVATE:: am_g = PI*rho_g/6.0
      REAL, PARAMETER, PRIVATE:: bm_g = 3.0
      REAL, PARAMETER, PRIVATE:: am_i = PI*rho_i/6.0
      REAL, PARAMETER, PRIVATE:: bm_i = 3.0

!..Fallspeed power laws relations:  v = (av*D**bv)*exp(-fv*D)
!.. Rain from Ferrier (1994), ice, snow, and graupel from
!.. Thompson et al (2008). Coefficient fv is zero for graupel/ice.
      REAL, PARAMETER, PRIVATE:: av_r = 4854.0
      REAL, PARAMETER, PRIVATE:: bv_r = 1.0
      REAL, PARAMETER, PRIVATE:: fv_r = 195.0
      REAL, PARAMETER, PRIVATE:: av_s = 40.0
      REAL, PARAMETER, PRIVATE:: bv_s = 0.55
      REAL, PARAMETER, PRIVATE:: fv_s = 125.0
      REAL, PARAMETER, PRIVATE:: av_g = 442.0
      REAL, PARAMETER, PRIVATE:: bv_g = 0.89
      REAL, PARAMETER, PRIVATE:: av_i = 1847.5
      REAL, PARAMETER, PRIVATE:: bv_i = 1.0

!..Capacitance of sphere and plates/aggregates: D**3, D**2
      REAL, PARAMETER, PRIVATE:: C_cube = 0.5
      REAL, PARAMETER, PRIVATE:: C_sqrd = 0.3

!..Collection efficiencies.  Rain/snow/graupel collection of cloud
!.. droplets use variables (Ef_rw, Ef_sw, Ef_gw respectively) and
!.. get computed elsewhere because they are dependent on stokes
!.. number.
      REAL, PARAMETER, PRIVATE:: Ef_si = 0.05
      REAL, PARAMETER, PRIVATE:: Ef_rs = 0.95
      REAL, PARAMETER, PRIVATE:: Ef_rg = 0.75
      REAL, PARAMETER, PRIVATE:: Ef_ri = 0.95

!..Minimum microphys values
!.. R1 value, 1.E-12, cannot be set lower because of numerical
!.. problems with Paul Field's moments and should not be set larger
!.. because of truncation problems in snow/ice growth.
      REAL, PARAMETER, PRIVATE:: R1 = 1.E-12
      REAL, PARAMETER, PRIVATE:: R2 = 1.E-8
      REAL, PARAMETER, PRIVATE:: eps = 1.E-29

!..Constants in Cooper curve relation for cloud ice number.
      REAL, PARAMETER, PRIVATE:: TNO = 5.0
      REAL, PARAMETER, PRIVATE:: ATO = 0.304

!..Rho_not used in fallspeed relations (rho_not/rho)**.5 adjustment.
      REAL, PARAMETER, PRIVATE:: rho_not = 101325.0/(287.05*298.0)

!..Schmidt number
      REAL, PARAMETER, PRIVATE:: Sc = 0.632
      REAL, PRIVATE:: Sc3

!..Homogeneous freezing temperature
      REAL, PARAMETER, PRIVATE:: HGFR = 235.16

!..Water vapor and air gas constants at constant pressure
      REAL, PARAMETER, PRIVATE:: Rv = 461.5
      REAL, PARAMETER, PRIVATE:: oRv = 1./Rv
      REAL, PARAMETER, PRIVATE:: R = 287.04
      REAL, PARAMETER, PRIVATE:: Cp = 1004.0
      ! for CM1:
      REAL, PARAMETER, PRIVATE:: cv = Cp - R
      REAL, PARAMETER, PRIVATE:: cvv = 1408.5
      REAL, PARAMETER, PRIVATE:: cpl = 4190.0
      REAL, PARAMETER, PRIVATE:: cpi = 2106.0

!..Enthalpy of sublimation, vaporization, and fusion at 0C.
      REAL, PARAMETER, PRIVATE:: lsub = 2.834E6
      REAL, PARAMETER, PRIVATE:: lvap0 = 2.5E6
      REAL, PARAMETER, PRIVATE:: lfus = lsub - lvap0
      REAL, PARAMETER, PRIVATE:: olfus = 1./lfus

!..Ice initiates with this mass (kg), corresponding diameter calc.
!..Min diameters and mass of cloud, rain, snow, and graupel (m, kg).
      REAL, PARAMETER, PRIVATE:: xm0i = 1.E-12
      REAL, PARAMETER, PRIVATE:: D0c = 1.E-6
      REAL, PARAMETER, PRIVATE:: D0r = 50.E-6
      REAL, PARAMETER, PRIVATE:: D0s = 200.E-6
      REAL, PARAMETER, PRIVATE:: D0g = 250.E-6
      REAL, PRIVATE:: D0i, xm0s, xm0g

!..Lookup table dimensions
      INTEGER, PARAMETER, PRIVATE:: nbins = 100
      INTEGER, PARAMETER, PRIVATE:: nbc = nbins
      INTEGER, PARAMETER, PRIVATE:: nbi = nbins
      INTEGER, PARAMETER, PRIVATE:: nbr = nbins
      INTEGER, PARAMETER, PRIVATE:: nbs = nbins
      INTEGER, PARAMETER, PRIVATE:: nbg = nbins
      INTEGER, PARAMETER, PRIVATE:: ntb_c = 37
      INTEGER, PARAMETER, PRIVATE:: ntb_i = 64
      INTEGER, PARAMETER, PRIVATE:: ntb_r = 37
      INTEGER, PARAMETER, PRIVATE:: ntb_s = 28
      INTEGER, PARAMETER, PRIVATE:: ntb_g = 28
      INTEGER, PARAMETER, PRIVATE:: ntb_g1 = 28
      INTEGER, PARAMETER, PRIVATE:: ntb_r1 = 37
      INTEGER, PARAMETER, PRIVATE:: ntb_i1 = 55
      INTEGER, PARAMETER, PRIVATE:: ntb_t = 9
      INTEGER, PRIVATE:: nic2, nii2, nii3, nir2, nir3, nis2, nig2, nig3

      DOUBLE PRECISION, DIMENSION(nbins+1):: xDx
      DOUBLE PRECISION, DIMENSION(nbc):: Dc, dtc
      DOUBLE PRECISION, DIMENSION(nbi):: Di, dti
      DOUBLE PRECISION, DIMENSION(nbr):: Dr, dtr
      DOUBLE PRECISION, DIMENSION(nbs):: Ds, dts
      DOUBLE PRECISION, DIMENSION(nbg):: Dg, dtg

!..Lookup tables for cloud water content (kg/m**3).
      REAL, DIMENSION(ntb_c), PARAMETER, PRIVATE:: &
      r_c = (/1.e-6,2.e-6,3.e-6,4.e-6,5.e-6,6.e-6,7.e-6,8.e-6,9.e-6, &
              1.e-5,2.e-5,3.e-5,4.e-5,5.e-5,6.e-5,7.e-5,8.e-5,9.e-5, &
              1.e-4,2.e-4,3.e-4,4.e-4,5.e-4,6.e-4,7.e-4,8.e-4,9.e-4, &
              1.e-3,2.e-3,3.e-3,4.e-3,5.e-3,6.e-3,7.e-3,8.e-3,9.e-3, &
              1.e-2/)

!..Lookup tables for cloud ice content (kg/m**3).
      REAL, DIMENSION(ntb_i), PARAMETER, PRIVATE:: &
      r_i = (/1.e-10,2.e-10,3.e-10,4.e-10, &
              5.e-10,6.e-10,7.e-10,8.e-10,9.e-10, &
              1.e-9,2.e-9,3.e-9,4.e-9,5.e-9,6.e-9,7.e-9,8.e-9,9.e-9, &
              1.e-8,2.e-8,3.e-8,4.e-8,5.e-8,6.e-8,7.e-8,8.e-8,9.e-8, &
              1.e-7,2.e-7,3.e-7,4.e-7,5.e-7,6.e-7,7.e-7,8.e-7,9.e-7, &
              1.e-6,2.e-6,3.e-6,4.e-6,5.e-6,6.e-6,7.e-6,8.e-6,9.e-6, &
              1.e-5,2.e-5,3.e-5,4.e-5,5.e-5,6.e-5,7.e-5,8.e-5,9.e-5, &
              1.e-4,2.e-4,3.e-4,4.e-4,5.e-4,6.e-4,7.e-4,8.e-4,9.e-4, &
              1.e-3/)

!..Lookup tables for rain content (kg/m**3).
      REAL, DIMENSION(ntb_r), PARAMETER, PRIVATE:: &
      r_r = (/1.e-6,2.e-6,3.e-6,4.e-6,5.e-6,6.e-6,7.e-6,8.e-6,9.e-6, &
              1.e-5,2.e-5,3.e-5,4.e-5,5.e-5,6.e-5,7.e-5,8.e-5,9.e-5, &
              1.e-4,2.e-4,3.e-4,4.e-4,5.e-4,6.e-4,7.e-4,8.e-4,9.e-4, &
              1.e-3,2.e-3,3.e-3,4.e-3,5.e-3,6.e-3,7.e-3,8.e-3,9.e-3, &
              1.e-2/)

!..Lookup tables for graupel content (kg/m**3).
      REAL, DIMENSION(ntb_g), PARAMETER, PRIVATE:: &
      r_g = (/1.e-5,2.e-5,3.e-5,4.e-5,5.e-5,6.e-5,7.e-5,8.e-5,9.e-5, &
              1.e-4,2.e-4,3.e-4,4.e-4,5.e-4,6.e-4,7.e-4,8.e-4,9.e-4, &
              1.e-3,2.e-3,3.e-3,4.e-3,5.e-3,6.e-3,7.e-3,8.e-3,9.e-3, &
              1.e-2/)

!..Lookup tables for snow content (kg/m**3).
      REAL, DIMENSION(ntb_s), PARAMETER, PRIVATE:: &
      r_s = (/1.e-5,2.e-5,3.e-5,4.e-5,5.e-5,6.e-5,7.e-5,8.e-5,9.e-5, &
              1.e-4,2.e-4,3.e-4,4.e-4,5.e-4,6.e-4,7.e-4,8.e-4,9.e-4, &
              1.e-3,2.e-3,3.e-3,4.e-3,5.e-3,6.e-3,7.e-3,8.e-3,9.e-3, &
              1.e-2/)

!..Lookup tables for rain y-intercept parameter (/m**4).
      REAL, DIMENSION(ntb_r1), PARAMETER, PRIVATE:: &
      N0r_exp = (/1.e6,2.e6,3.e6,4.e6,5.e6,6.e6,7.e6,8.e6,9.e6, &
                  1.e7,2.e7,3.e7,4.e7,5.e7,6.e7,7.e7,8.e7,9.e7, &
                  1.e8,2.e8,3.e8,4.e8,5.e8,6.e8,7.e8,8.e8,9.e8, &
                  1.e9,2.e9,3.e9,4.e9,5.e9,6.e9,7.e9,8.e9,9.e9, &
                  1.e10/)

!..Lookup tables for graupel y-intercept parameter (/m**4).
      REAL, DIMENSION(ntb_g1), PARAMETER, PRIVATE:: &
      N0g_exp = (/1.e4,2.e4,3.e4,4.e4,5.e4,6.e4,7.e4,8.e4,9.e4, &
                  1.e5,2.e5,3.e5,4.e5,5.e5,6.e5,7.e5,8.e5,9.e5, &
                  1.e6,2.e6,3.e6,4.e6,5.e6,6.e6,7.e6,8.e6,9.e6, &
                  1.e7/)

!..Lookup tables for ice number concentration (/m**3).
      REAL, DIMENSION(ntb_i1), PARAMETER, PRIVATE:: &
      Nt_i = (/1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0, &
               1.e1,2.e1,3.e1,4.e1,5.e1,6.e1,7.e1,8.e1,9.e1, &
               1.e2,2.e2,3.e2,4.e2,5.e2,6.e2,7.e2,8.e2,9.e2, &
               1.e3,2.e3,3.e3,4.e3,5.e3,6.e3,7.e3,8.e3,9.e3, &
               1.e4,2.e4,3.e4,4.e4,5.e4,6.e4,7.e4,8.e4,9.e4, &
               1.e5,2.e5,3.e5,4.e5,5.e5,6.e5,7.e5,8.e5,9.e5, &
               1.e6/)

!..For snow moments conversions (from Field et al. 2005)
      REAL, DIMENSION(10), PARAMETER, PRIVATE:: &
      sa = (/ 5.065339, -0.062659, -3.032362, 0.029469, -0.000285, &
              0.31255,   0.000204,  0.003199, 0.0,      -0.015952/)
      REAL, DIMENSION(10), PARAMETER, PRIVATE:: &
      sb = (/ 0.476221, -0.015896,  0.165977, 0.007468, -0.000141, &
              0.060366,  0.000079,  0.000594, 0.0,      -0.003577/)

!..Temperatures (5 C interval 0 to -40) used in lookup tables.
      REAL, DIMENSION(ntb_t), PARAMETER, PRIVATE:: &
      Tc = (/-0.01, -5., -10., -15., -20., -25., -30., -35., -40./)

!..Lookup tables for various accretion/collection terms.
!.. ntb_x refers to the number of elements for rain, snow, graupel,
!.. and temperature array indices.  Variables beginning with t-p/c/m/n
!.. represent lookup tables.  Save compile-time memory by making
!.. allocatable (2009Jun12, J. Michalakes).
      INTEGER, PARAMETER, PRIVATE:: R8SIZE = 8
      REAL (KIND=R8SIZE), ALLOCATABLE, DIMENSION(:,:,:,:)::             &
                tcg_racg, tmr_racg, tcr_gacr, tmg_gacr,                 &
                tnr_racg, tnr_gacr
      REAL (KIND=R8SIZE), ALLOCATABLE, DIMENSION(:,:,:,:)::             &
                tcs_racs1, tmr_racs1, tcs_racs2, tmr_racs2,             &
                tcr_sacr1, tms_sacr1, tcr_sacr2, tms_sacr2,             &
                tnr_racs1, tnr_racs2, tnr_sacr1, tnr_sacr2
      REAL (KIND=R8SIZE), ALLOCATABLE, DIMENSION(:,:)::                 &
                tpi_qcfz, tni_qcfz
      REAL (KIND=R8SIZE), ALLOCATABLE, DIMENSION(:,:,:)::               &
                tpi_qrfz, tpg_qrfz, tni_qrfz, tnr_qrfz
      REAL (KIND=R8SIZE), ALLOCATABLE, DIMENSION(:,:)::                 &
                tps_iaus, tni_iaus, tpi_ide
      REAL (KIND=R8SIZE), ALLOCATABLE, DIMENSION(:,:):: t_Efrw
      REAL (KIND=R8SIZE), ALLOCATABLE, DIMENSION(:,:):: t_Efsw
      REAL (KIND=R8SIZE), ALLOCATABLE, DIMENSION(:,:,:):: tnr_rev

!..Variables holding a bunch of exponents and gamma values (cloud water,
!.. cloud ice, rain, snow, then graupel).
      REAL, DIMENSION(3), PRIVATE:: cce, ccg
      REAL, PRIVATE::  ocg1, ocg2
      REAL, DIMENSION(7), PRIVATE:: cie, cig
      REAL, PRIVATE:: oig1, oig2, obmi
      REAL, DIMENSION(13), PRIVATE:: cre, crg
      REAL, PRIVATE:: ore1, org1, org2, org3, obmr
      REAL, DIMENSION(18), PRIVATE:: cse, csg
      REAL, PRIVATE:: oams, obms, ocms
      REAL, DIMENSION(12), PRIVATE:: cge, cgg
      REAL, PRIVATE:: oge1, ogg1, ogg2, ogg3, oamg, obmg, ocmg

!..Declaration of precomputed constants in various rate eqns.
      REAL:: t1_qr_qc, t1_qr_qi, t2_qr_qi, t1_qg_qc, t1_qs_qc, t1_qs_qi
      REAL:: t1_qr_ev, t2_qr_ev
      REAL:: t1_qs_sd, t2_qs_sd, t1_qg_sd, t2_qg_sd
      REAL:: t1_qs_me, t2_qs_me, t1_qg_me, t2_qg_me

      CHARACTER*256:: mp_debug

!..Various radar related variables
      DOUBLE PRECISION, PARAMETER, PRIVATE:: lamda_radar = 0.10         ! in meters
      DOUBLE PRECISION, PRIVATE:: K_w, PI5, lamda4
      COMPLEX*16, PRIVATE:: m_w_0, m_i_0
      DOUBLE PRECISION, DIMENSION(nbins+1), PRIVATE:: simpson
      DOUBLE PRECISION, DIMENSION(3), PARAMETER, PRIVATE:: basis =      &
                           (/1.d0/3.d0, 4.d0/3.d0, 1.d0/3.d0/)

      INTEGER, PARAMETER, PRIVATE:: slen = 20
      CHARACTER(len=slen), PRIVATE::                                    &
              mixingrulestring_s, matrixstring_s, inclusionstring_s,    &
              hoststring_s, hostmatrixstring_s, hostinclusionstring_s,  &
              mixingrulestring_g, matrixstring_g, inclusionstring_g,    &
              hoststring_g, hostmatrixstring_g, hostinclusionstring_g

!+---+
!+---+-----------------------------------------------------------------+
!..END DECLARATIONS
!+---+-----------------------------------------------------------------+
!+---+
!ctrlL

      CONTAINS

      SUBROUTINE thompson_init

      IMPLICIT NONE

      INTEGER:: i, j, k, m, n
      LOGICAL:: micro_init

!..Allocate space for lookup tables (J. Michalakes 2009Jun08).
      micro_init = .FALSE.

      if (.NOT. ALLOCATED(tcg_racg) ) then
         ALLOCATE(tcg_racg(ntb_g1,ntb_g,ntb_r1,ntb_r))
         micro_init = .TRUE.
      endif

      if (.NOT. ALLOCATED(tmr_racg)) ALLOCATE(tmr_racg(ntb_g1,ntb_g,ntb_r1,ntb_r))
      if (.NOT. ALLOCATED(tcr_gacr)) ALLOCATE(tcr_gacr(ntb_g1,ntb_g,ntb_r1,ntb_r))
      if (.NOT. ALLOCATED(tmg_gacr)) ALLOCATE(tmg_gacr(ntb_g1,ntb_g,ntb_r1,ntb_r))
      if (.NOT. ALLOCATED(tnr_racg)) ALLOCATE(tnr_racg(ntb_g1,ntb_g,ntb_r1,ntb_r))
      if (.NOT. ALLOCATED(tnr_gacr)) ALLOCATE(tnr_gacr(ntb_g1,ntb_g,ntb_r1,ntb_r))

      if (.NOT. ALLOCATED(tcs_racs1)) ALLOCATE(tcs_racs1(ntb_s,ntb_t,ntb_r1,ntb_r))
      if (.NOT. ALLOCATED(tmr_racs1)) ALLOCATE(tmr_racs1(ntb_s,ntb_t,ntb_r1,ntb_r))
      if (.NOT. ALLOCATED(tcs_racs2)) ALLOCATE(tcs_racs2(ntb_s,ntb_t,ntb_r1,ntb_r))
      if (.NOT. ALLOCATED(tmr_racs2)) ALLOCATE(tmr_racs2(ntb_s,ntb_t,ntb_r1,ntb_r))
      if (.NOT. ALLOCATED(tcr_sacr1)) ALLOCATE(tcr_sacr1(ntb_s,ntb_t,ntb_r1,ntb_r))
      if (.NOT. ALLOCATED(tms_sacr1)) ALLOCATE(tms_sacr1(ntb_s,ntb_t,ntb_r1,ntb_r))
      if (.NOT. ALLOCATED(tcr_sacr2)) ALLOCATE(tcr_sacr2(ntb_s,ntb_t,ntb_r1,ntb_r))
      if (.NOT. ALLOCATED(tms_sacr2)) ALLOCATE(tms_sacr2(ntb_s,ntb_t,ntb_r1,ntb_r))
      if (.NOT. ALLOCATED(tnr_racs1)) ALLOCATE(tnr_racs1(ntb_s,ntb_t,ntb_r1,ntb_r))
      if (.NOT. ALLOCATED(tnr_racs2)) ALLOCATE(tnr_racs2(ntb_s,ntb_t,ntb_r1,ntb_r))
      if (.NOT. ALLOCATED(tnr_sacr1)) ALLOCATE(tnr_sacr1(ntb_s,ntb_t,ntb_r1,ntb_r))
      if (.NOT. ALLOCATED(tnr_sacr2)) ALLOCATE(tnr_sacr2(ntb_s,ntb_t,ntb_r1,ntb_r))

      if (.NOT. ALLOCATED(tpi_qcfz)) ALLOCATE(tpi_qcfz(ntb_c,45))
      if (.NOT. ALLOCATED(tni_qcfz)) ALLOCATE(tni_qcfz(ntb_c,45))

      if (.NOT. ALLOCATED(tpi_qrfz)) ALLOCATE(tpi_qrfz(ntb_r,ntb_r1,45))
      if (.NOT. ALLOCATED(tpg_qrfz)) ALLOCATE(tpg_qrfz(ntb_r,ntb_r1,45))
      if (.NOT. ALLOCATED(tni_qrfz)) ALLOCATE(tni_qrfz(ntb_r,ntb_r1,45))
      if (.NOT. ALLOCATED(tnr_qrfz)) ALLOCATE(tnr_qrfz(ntb_r,ntb_r1,45))

      if (.NOT. ALLOCATED(tps_iaus)) ALLOCATE(tps_iaus(ntb_i,ntb_i1))
      if (.NOT. ALLOCATED(tni_iaus)) ALLOCATE(tni_iaus(ntb_i,ntb_i1))
      if (.NOT. ALLOCATED(tpi_ide)) ALLOCATE(tpi_ide(ntb_i,ntb_i1))

      if (.NOT. ALLOCATED(t_Efrw)) ALLOCATE(t_Efrw(nbr,nbc))
      if (.NOT. ALLOCATED(t_Efsw)) ALLOCATE(t_Efsw(nbs,nbc))

      if (.NOT. ALLOCATED(tnr_rev)) ALLOCATE(tnr_rev(nbr, ntb_r1, ntb_r))

      if (micro_init) then

!..From Martin et al. (1994), assign gamma shape parameter mu for cloud
!.. drops according to general dispersion characteristics (disp=~0.25
!.. for Maritime and 0.45 for Continental).
!.. disp=SQRT((mu+2)/(mu+1) - 1) so mu varies from 15 for Maritime
!.. to 2 for really dirty air.
      mu_c = MIN(15., (1000.E6/Nt_c + 2.))

!..Schmidt number to one-third used numerous times.
      Sc3 = Sc**(1./3.)

!..Compute min ice diam from mass, min snow/graupel mass from diam.
      D0i = (xm0i/am_i)**(1./bm_i)
      xm0s = am_s * D0s**bm_s
      xm0g = am_g * D0g**bm_g

!..These constants various exponents and gamma() assoc with cloud,
!.. rain, snow, and graupel.
      cce(1) = mu_c + 1.
      cce(2) = bm_r + mu_c + 1.
      cce(3) = bm_r + mu_c + 4.
      ccg(1) = WGAMMA(cce(1))
      ccg(2) = WGAMMA(cce(2))
      ccg(3) = WGAMMA(cce(3))
      ocg1 = 1./ccg(1)
      ocg2 = 1./ccg(2)

      cie(1) = mu_i + 1.
      cie(2) = bm_i + mu_i + 1.
      cie(3) = bm_i + mu_i + bv_i + 1.
      cie(4) = mu_i + bv_i + 1.
      cie(5) = mu_i + 2.
      cie(6) = bm_i*0.5 + mu_i + bv_i + 1.
      cie(7) = bm_i*0.5 + mu_i + 1.
      cig(1) = WGAMMA(cie(1))
      cig(2) = WGAMMA(cie(2))
      cig(3) = WGAMMA(cie(3))
      cig(4) = WGAMMA(cie(4))
      cig(5) = WGAMMA(cie(5))
      cig(6) = WGAMMA(cie(6))
      cig(7) = WGAMMA(cie(7))
      oig1 = 1./cig(1)
      oig2 = 1./cig(2)
      obmi = 1./bm_i

      cre(1) = bm_r + 1.
      cre(2) = mu_r + 1.
      cre(3) = bm_r + mu_r + 1.
      cre(4) = bm_r*2. + mu_r + 1.
      cre(5) = mu_r + bv_r + 1.
      cre(6) = bm_r + mu_r + bv_r + 1.
      cre(7) = bm_r*0.5 + mu_r + bv_r + 1.
      cre(8) = bm_r + mu_r + bv_r + 3.
      cre(9) = mu_r + bv_r + 3.
      cre(10) = mu_r + 2.
      cre(11) = 0.5*(bv_r + 5. + 2.*mu_r)
      cre(12) = bm_r*0.5 + mu_r + 1.
      cre(13) = bm_r*2. + mu_r + bv_r + 1.
      do n = 1, 13
         crg(n) = WGAMMA(cre(n))
      enddo
      obmr = 1./bm_r
      ore1 = 1./cre(1)
      org1 = 1./crg(1)
      org2 = 1./crg(2)
      org3 = 1./crg(3)

      cse(1) = bm_s + 1.
      cse(2) = bm_s + 2.
      cse(3) = bm_s*2.
      cse(4) = bm_s + bv_s + 1.
      cse(5) = bm_s*2. + bv_s + 1.
      cse(6) = bm_s*2. + 1.
      cse(7) = bm_s + mu_s + 1.
      cse(8) = bm_s + mu_s + 2.
      cse(9) = bm_s + mu_s + 3.
      cse(10) = bm_s + mu_s + bv_s + 1.
      cse(11) = bm_s*2. + mu_s + bv_s + 1.
      cse(12) = bm_s*2. + mu_s + 1.
      cse(13) = bv_s + 2.
      cse(14) = bm_s + bv_s
      cse(15) = mu_s + 1.
      cse(16) = 1.0 + (1.0 + bv_s)/2.
      cse(17) = cse(16) + mu_s + 1.
      cse(18) = bv_s + mu_s + 3.
      do n = 1, 18
         csg(n) = WGAMMA(cse(n))
      enddo
      oams = 1./am_s
      obms = 1./bm_s
      ocms = oams**obms

      cge(1) = bm_g + 1.
      cge(2) = mu_g + 1.
      cge(3) = bm_g + mu_g + 1.
      cge(4) = bm_g*2. + mu_g + 1.
      cge(5) = bm_g*2. + mu_g + bv_g + 1.
      cge(6) = bm_g + mu_g + bv_g + 1.
      cge(7) = bm_g + mu_g + bv_g + 2.
      cge(8) = bm_g + mu_g + bv_g + 3.
      cge(9) = mu_g + bv_g + 3.
      cge(10) = mu_g + 2.
      cge(11) = 0.5*(bv_g + 5. + 2.*mu_g)
      cge(12) = 0.5*(bv_g + 5.) + mu_g
      do n = 1, 12
         cgg(n) = WGAMMA(cge(n))
      enddo
      oamg = 1./am_g
      obmg = 1./bm_g
      ocmg = oamg**obmg
      oge1 = 1./cge(1)
      ogg1 = 1./cgg(1)
      ogg2 = 1./cgg(2)
      ogg3 = 1./cgg(3)

!+---+-----------------------------------------------------------------+
!..Simplify various rate eqns the best we can now.
!+---+-----------------------------------------------------------------+

!..Rain collecting cloud water and cloud ice
      t1_qr_qc = PI*.25*av_r * crg(9)
      t1_qr_qi = PI*.25*av_r * crg(9)
      t2_qr_qi = PI*.25*am_r*av_r * crg(8)

!..Graupel collecting cloud water
      t1_qg_qc = PI*.25*av_g * cgg(9)

!..Snow collecting cloud water
      t1_qs_qc = PI*.25*av_s

!..Snow collecting cloud ice
      t1_qs_qi = PI*.25*av_s

!..Evaporation of rain; ignore depositional growth of rain.
      t1_qr_ev = 0.78 * crg(10)
      t2_qr_ev = 0.308*Sc3*SQRT(av_r) * crg(11)

!..Sublimation/depositional growth of snow
      t1_qs_sd = 0.86
      t2_qs_sd = 0.28*Sc3*SQRT(av_s)

!..Melting of snow
      t1_qs_me = PI*4.*C_sqrd*olfus * 0.86
      t2_qs_me = PI*4.*C_sqrd*olfus * 0.28*Sc3*SQRT(av_s)

!..Sublimation/depositional growth of graupel
      t1_qg_sd = 0.86 * cgg(10)
      t2_qg_sd = 0.28*Sc3*SQRT(av_g) * cgg(11)

!..Melting of graupel
      t1_qg_me = PI*4.*C_cube*olfus * 0.86 * cgg(10)
      t2_qg_me = PI*4.*C_cube*olfus * 0.28*Sc3*SQRT(av_g) * cgg(11)

!..Constants for helping find lookup table indexes.
      nic2 = NINT(ALOG10(r_c(1)))
      nii2 = NINT(ALOG10(r_i(1)))
      nii3 = NINT(ALOG10(Nt_i(1)))
      nir2 = NINT(ALOG10(r_r(1)))
      nir3 = NINT(ALOG10(N0r_exp(1)))
      nis2 = NINT(ALOG10(r_s(1)))
      nig2 = NINT(ALOG10(r_g(1)))
      nig3 = NINT(ALOG10(N0g_exp(1)))

!..Create bins of cloud water (from min diameter up to 100 microns).
      Dc(1) = D0c*1.0d0
      dtc(1) = D0c*1.0d0
      do n = 2, nbc
         Dc(n) = Dc(n-1) + 1.0D-6
         dtc(n) = (Dc(n) - Dc(n-1))
      enddo

!..Create bins of cloud ice (from min diameter up to 5x min snow size).
      xDx(1) = D0i*1.0d0
      xDx(nbi+1) = 5.0d0*D0s
      do n = 2, nbi
         xDx(n) = DEXP(DFLOAT(n-1)/DFLOAT(nbi) &
                  *DLOG(xDx(nbi+1)/xDx(1)) +DLOG(xDx(1)))
      enddo
      do n = 1, nbi
         Di(n) = DSQRT(xDx(n)*xDx(n+1))
         dti(n) = xDx(n+1) - xDx(n)
      enddo

!..Create bins of rain (from min diameter up to 5 mm).
      xDx(1) = D0r*1.0d0
      xDx(nbr+1) = 0.005d0
      do n = 2, nbr
         xDx(n) = DEXP(DFLOAT(n-1)/DFLOAT(nbr) &
                  *DLOG(xDx(nbr+1)/xDx(1)) +DLOG(xDx(1)))
      enddo
      do n = 1, nbr
         Dr(n) = DSQRT(xDx(n)*xDx(n+1))
         dtr(n) = xDx(n+1) - xDx(n)
      enddo

!..Create bins of snow (from min diameter up to 2 cm).
      xDx(1) = D0s*1.0d0
      xDx(nbs+1) = 0.02d0
      do n = 2, nbs
         xDx(n) = DEXP(DFLOAT(n-1)/DFLOAT(nbs) &
                  *DLOG(xDx(nbs+1)/xDx(1)) +DLOG(xDx(1)))
      enddo
      do n = 1, nbs
         Ds(n) = DSQRT(xDx(n)*xDx(n+1))
         dts(n) = xDx(n+1) - xDx(n)
      enddo

!..Create bins of graupel (from min diameter up to 5 cm).
      xDx(1) = D0g*1.0d0
      xDx(nbg+1) = 0.05d0
      do n = 2, nbg
         xDx(n) = DEXP(DFLOAT(n-1)/DFLOAT(nbg) &
                  *DLOG(xDx(nbg+1)/xDx(1)) +DLOG(xDx(1)))
      enddo
      do n = 1, nbg
         Dg(n) = DSQRT(xDx(n)*xDx(n+1))
         dtg(n) = xDx(n+1) - xDx(n)
      enddo

!+---+-----------------------------------------------------------------+
!..Create lookup tables for most costly calculations.
!+---+-----------------------------------------------------------------+

      do m = 1, ntb_r
         do k = 1, ntb_r1
            do j = 1, ntb_g
               do i = 1, ntb_g1
                  tcg_racg(i,j,k,m) = 0.0d0
                  tmr_racg(i,j,k,m) = 0.0d0
                  tcr_gacr(i,j,k,m) = 0.0d0
                  tmg_gacr(i,j,k,m) = 0.0d0
                  tnr_racg(i,j,k,m) = 0.0d0
                  tnr_gacr(i,j,k,m) = 0.0d0
               enddo
            enddo
         enddo
      enddo

      do m = 1, ntb_r
         do k = 1, ntb_r1
            do j = 1, ntb_t
               do i = 1, ntb_s
                  tcs_racs1(i,j,k,m) = 0.0d0
                  tmr_racs1(i,j,k,m) = 0.0d0
                  tcs_racs2(i,j,k,m) = 0.0d0
                  tmr_racs2(i,j,k,m) = 0.0d0
                  tcr_sacr1(i,j,k,m) = 0.0d0
                  tms_sacr1(i,j,k,m) = 0.0d0
                  tcr_sacr2(i,j,k,m) = 0.0d0
                  tms_sacr2(i,j,k,m) = 0.0d0
                  tnr_racs1(i,j,k,m) = 0.0d0
                  tnr_racs2(i,j,k,m) = 0.0d0
                  tnr_sacr1(i,j,k,m) = 0.0d0
                  tnr_sacr2(i,j,k,m) = 0.0d0
               enddo
            enddo
         enddo
      enddo

      do k = 1, 45
         do j = 1, ntb_r1
            do i = 1, ntb_r
               tpi_qrfz(i,j,k) = 0.0d0
               tni_qrfz(i,j,k) = 0.0d0
               tpg_qrfz(i,j,k) = 0.0d0
               tnr_qrfz(i,j,k) = 0.0d0
            enddo
         enddo
         do i = 1, ntb_c
            tpi_qcfz(i,k) = 0.0d0
            tni_qcfz(i,k) = 0.0d0
         enddo
      enddo

      do j = 1, ntb_i1
         do i = 1, ntb_i
            tps_iaus(i,j) = 0.0d0
            tni_iaus(i,j) = 0.0d0
            tpi_ide(i,j) = 0.0d0
         enddo
      enddo

      do j = 1, nbc
         do i = 1, nbr
            t_Efrw(i,j) = 0.0
         enddo
         do i = 1, nbs
            t_Efsw(i,j) = 0.0
         enddo
      enddo

      do k = 1, ntb_r
         do j = 1, ntb_r1
            do i = 1, nbr
               tnr_rev(i,j,k) = 0.0d0
            enddo
         enddo
      enddo

!      CALL wrf_debug(150, 'CREATING MICROPHYSICS LOOKUP TABLES ... ')
!      WRITE (wrf_err_message, '(a, f5.2, a, f5.2, a, f5.2, a, f5.2)') &
!          ' using: mu_c=',mu_c,' mu_i=',mu_i,' mu_r=',mu_r,' mu_g=',mu_g
!      CALL wrf_debug(150, wrf_err_message)

!..Collision efficiency between rain/snow and cloud water.
!      CALL wrf_debug(200, '  creating qc collision eff tables')
      call table_Efrw
      call table_Efsw

!..Drop evaporation.
!     CALL wrf_debug(200, '  creating rain evap table')
!     call table_dropEvap

!..Initialize various constants for computing radar reflectivity.
     call radar_init

      if (.not. iiwarm) then

!..Rain collecting graupel & graupel collecting rain.
!      CALL wrf_debug(200, '  creating rain collecting graupel table')
      call qr_acr_qg

!..Rain collecting snow & snow collecting rain.
!      CALL wrf_debug(200, '  creating rain collecting snow table')
      call qr_acr_qs

!..Cloud water and rain freezing (Bigg, 1953).
!      CALL wrf_debug(200, '  creating freezing of water drops table')
      call freezeH2O

!..Conversion of some ice mass into snow category.
!      CALL wrf_debug(200, '  creating ice converting to snow table')
      call qi_aut_qs

      endif

!      CALL wrf_debug(150, ' ... DONE microphysical lookup tables')

      endif

      END SUBROUTINE thompson_init
!+---+-----------------------------------------------------------------+
!ctrlL
!+---+-----------------------------------------------------------------+
!..This is a wrapper routine designed to transfer values from 3D to 1D.
!+---+-----------------------------------------------------------------+
      SUBROUTINE mp_gt_driver(qv, qc, qr, qi, qs, qg, nci, ncr,    &
                              th0, t3d, pii, p, dzz, dt_in, RAIN,   &
                              tevar,train,                         &
                              ruh,rvh,rmh,rr,dbz3d,getdbz)

      implicit none

      include 'input.incl'
      include 'timestat.incl'

!..Subroutine arguments
!      INTEGER, INTENT(IN):: ids,ide, jds,jde, kds,kde, &
!                            ims,ime, jms,jme, kms,kme, &
!                            its,ite, jts,jte, kts,kte

      REAL, DIMENSION(ib:ie, jb:je, kb:ke), INTENT(INOUT):: &
                          qv, qc, qr, qi, qs, qg, nci, ncr, t3d, dbz3d
      REAL, DIMENSION(ib:ie, jb:je, kb:ke), INTENT(IN):: &
                          th0, pii, p, dzz, rmh, rr
      REAL, DIMENSION(ib:ie, jb:je, nrain), INTENT(INOUT):: RAIN

!      REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT)::      &
!                          SNOWNC, SNOWNCV, GRAUPELNC, GRAUPELNCV
!     REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT)::       &
!                         refl_10cm
      REAL, INTENT(IN):: dt_in
      real*8, intent(inout) :: tevar,train
      real, intent(in), dimension(ib:ie) :: ruh
      real, intent(in), dimension(jb:je) :: rvh
      logical, INTENT(IN):: getdbz
!      INTEGER, INTENT(IN):: itimestep

!     TYPE (WRFU_Clock):: grid_clock
!     TYPE (WRFU_Alarm), POINTER:: grid_alarms(:)

!..Local variables
      REAL, DIMENSION(nk):: &
                          qv1d, qc1d, qi1d, qr1d, qs1d, qg1d, ni1d, &
                          nr1d, t1d, p1d, dz1d, dBZ
!      REAL, DIMENSION(its:ite, jts:jte):: pcp_ra, pcp_sn, pcp_gr, pcp_ic
      REAL:: dt, pptrain, pptsnow, pptgraul, pptice
      REAL:: qc_max, qr_max, qs_max, qi_max, qg_max, ni_max, nr_max
      INTEGER:: i, j, k, n
      INTEGER:: imax_qc,imax_qr,imax_qi,imax_qs,imax_qg,imax_ni,imax_nr
      INTEGER:: jmax_qc,jmax_qr,jmax_qi,jmax_qs,jmax_qg,jmax_ni,jmax_nr
      INTEGER:: kmax_qc,kmax_qr,kmax_qi,kmax_qs,kmax_qg,kmax_ni,kmax_nr
      INTEGER:: i_start, j_start, i_end, j_end
      LOGICAL:: dBZ_tstep
      DOUBLE PRECISION, DIMENSION(1:nk):: prv_rev
      real :: tem1,tem2
      real*8, dimension(nj) :: bud1,bud2

!+---+

      tem1 = dx*dy*dz
      tem2 = dx*dy

!$omp parallel do default(shared)  &
!$omp private(j)
      do j=1,nj
        bud1(j)=0.0d0
        bud2(j)=0.0d0
      enddo

!      dBZ_tstep = .false.
      dBZ_tstep = getdbz
!     if ( Is_alarm_tstep(grid_clock, grid_alarms(HISTORY_ALARM)) ) then
!        dBZ_tstep = .true.
!     endif

!      i_start = its
!      j_start = jts
!      i_end   = ite
!      j_end   = jte
!
!!..For idealized testing by developer.
!      if ( (ide-ids+1).gt.4 .and. (jde-jds+1).lt.4 .and.                &
!           ids.eq.its.and.ide.eq.ite.and.jds.eq.jts.and.jde.eq.jte) then
!         i_start = its + 2
!         i_end   = ite - 1
!         j_start = jts
!         j_end   = jte
!      endif

      dt = dt_in
   
!      qc_max = 0.
!      qr_max = 0.
!      qs_max = 0.
!      qi_max = 0.
!      qg_max = 0
!      ni_max = 0.
!      nr_max = 0.
!      imax_qc = 0
!      imax_qr = 0
!      imax_qi = 0
!      imax_qs = 0
!      imax_qg = 0
!      imax_ni = 0
!      imax_nr = 0
!      jmax_qc = 0
!      jmax_qr = 0
!      jmax_qi = 0
!      jmax_qs = 0
!      jmax_qg = 0
!      jmax_ni = 0
!      jmax_nr = 0
!      kmax_qc = 0
!      kmax_qr = 0
!      kmax_qi = 0
!      kmax_qs = 0
!      kmax_qg = 0
!      kmax_ni = 0
!      kmax_nr = 0
!      do i = 1, 256
!         mp_debug(i:i) = char(0)
!      enddo

!$omp parallel do default(shared)  &
!$omp private(i,j,k,n,pptrain,pptsnow,pptgraul,pptice,   &
!$omp t1d,p1d,dz1d,qv1d,qc1d,qi1d,qr1d,qs1d,qg1d,ni1d,nr1d,prv_rev,dbz)
      j_loop:  do j = 1,nj
      i_loop:  do i = 1,ni

         pptrain = 0.
         pptsnow = 0.
         pptgraul = 0.
         pptice = 0.
!         RAINNCV(i,j) = 0.
!         IF ( PRESENT (snowncv) ) THEN
!            SNOWNCV(i,j) = 0.
!         ENDIF
!         IF ( PRESENT (graupelncv) ) THEN
!            GRAUPELNCV(i,j) = 0.
!         ENDIF
!         SR(i,j) = 0.

         do k = 1, nk
!!!            t1d(k) = th(i,k,j)*pii(i,k,j)
            t1d(k) = t3d(i,j,k)
            p1d(k) = p(i,j,k)
            dz1d(k) = dzz(i,j,k)
            qv1d(k) = qv(i,j,k)
            qc1d(k) = qc(i,j,k)
            qi1d(k) = qi(i,j,k)
            qr1d(k) = qr(i,j,k)
            qs1d(k) = qs(i,j,k)
            qg1d(k) = qg(i,j,k)
            ni1d(k) = nci(i,j,k)
            nr1d(k) = ncr(i,j,k)
         enddo

         prv_rev = 0.0

         call mp_thompson(qv1d, qc1d, qi1d, qr1d, qs1d, qg1d, ni1d, &
                      nr1d, t1d, p1d, dz1d, &
                      pptrain, pptsnow, pptgraul, pptice, &
                      1, nk, dt, i, j, prv_rev, neweqts )

         do n = 1,nrain
            RAIN(i,j,n) = RAIN(i,j,n) + 0.1*( pptrain + pptsnow + pptgraul + pptice )
            bud1(j) = bud1(j) + ( pptrain + pptsnow + pptgraul + pptice )*ruh(i)*rvh(j)*tem2
         enddo

         do k=1,nk
           bud2(j) = bud2(j) + rr(i,j,k)*prv_rev(k)*ruh(i)*rvh(j)*rmh(i,j,k)*tem1
         enddo

!         pcp_ra(i,j) = pptrain
!         pcp_sn(i,j) = pptsnow
!         pcp_gr(i,j) = pptgraul
!         pcp_ic(i,j) = pptice
!         RAINNCV(i,j) = pptrain + pptsnow + pptgraul + pptice
!         RAINNC(i,j) = RAINNC(i,j) + pptrain + pptsnow + pptgraul + pptice
!         IF ( PRESENT(snowncv) .AND. PRESENT(snownc) ) THEN
!            SNOWNCV(i,j) = pptsnow + pptice
!            SNOWNC(i,j) = SNOWNC(i,j) + pptsnow + pptice
!         ENDIF
!         IF ( PRESENT(graupelncv) .AND. PRESENT(graupelnc) ) THEN
!            GRAUPELNCV(i,j) = pptgraul
!            GRAUPELNC(i,j) = GRAUPELNC(i,j) + pptgraul
!         ENDIF
!         SR(i,j) = (pptsnow + pptgraul + pptice)/(RAINNCV(i,j)+1.e-12)

         do k = 1, nk
            qv(i,j,k) = qv1d(k)
            qc(i,j,k) = qc1d(k)
            qi(i,j,k) = qi1d(k)
            qr(i,j,k) = qr1d(k)
            qs(i,j,k) = qs1d(k)
            qg(i,j,k) = qg1d(k)
            nci(i,j,k) = ni1d(k)
            ncr(i,j,k) = nr1d(k)
!!!            th(i,j,k) = t1d(k)/pii(i,k,j)
            t3d(i,j,k) = t1d(k)
!            if (qc1d(k) .gt. qc_max) then
!             imax_qc = i
!             jmax_qc = j
!             kmax_qc = k
!             qc_max = qc1d(k)
!            elseif (qc1d(k) .lt. 0.0) then
!             write(mp_debug,*) 'WARNING, negative qc ', qc1d(k),        &
!                        ' at i,j,k=', i,j,k
!             CALL wrf_debug(150, mp_debug)
!            endif
!            if (qr1d(k) .gt. qr_max) then
!             imax_qr = i
!             jmax_qr = j
!             kmax_qr = k
!             qr_max = qr1d(k)
!            elseif (qr1d(k) .lt. 0.0) then
!             write(mp_debug,*) 'WARNING, negative qr ', qr1d(k),        &
!                        ' at i,j,k=', i,j,k
!             CALL wrf_debug(150, mp_debug)
!            endif
!            if (nr1d(k) .gt. nr_max) then
!             imax_nr = i
!             jmax_nr = j
!             kmax_nr = k
!             nr_max = nr1d(k)
!            elseif (nr1d(k) .lt. 0.0) then
!             write(mp_debug,*) 'WARNING, negative nr ', nr1d(k),        &
!                        ' at i,j,k=', i,j,k
!             CALL wrf_debug(150, mp_debug)
!            endif
!            if (qs1d(k) .gt. qs_max) then
!             imax_qs = i
!             jmax_qs = j
!             kmax_qs = k
!             qs_max = qs1d(k)
!            elseif (qs1d(k) .lt. 0.0) then
!             write(mp_debug,*) 'WARNING, negative qs ', qs1d(k),        &
!                        ' at i,j,k=', i,j,k
!             CALL wrf_debug(150, mp_debug)
!            endif
!            if (qi1d(k) .gt. qi_max) then
!             imax_qi = i
!             jmax_qi = j
!             kmax_qi = k
!             qi_max = qi1d(k)
!            elseif (qi1d(k) .lt. 0.0) then
!             write(mp_debug,*) 'WARNING, negative qi ', qi1d(k),        &
!                        ' at i,j,k=', i,j,k
!             CALL wrf_debug(150, mp_debug)
!            endif
!            if (qg1d(k) .gt. qg_max) then
!             imax_qg = i
!             jmax_qg = j
!             kmax_qg = k
!             qg_max = qg1d(k)
!            elseif (qg1d(k) .lt. 0.0) then
!             write(mp_debug,*) 'WARNING, negative qg ', qg1d(k),        &
!                        ' at i,j,k=', i,j,k
!             CALL wrf_debug(150, mp_debug)
!            endif
!            if (ni1d(k) .gt. ni_max) then
!             imax_ni = i
!             jmax_ni = j
!             kmax_ni = k
!             ni_max = ni1d(k)
!            elseif (ni1d(k) .lt. 0.0) then
!             write(mp_debug,*) 'WARNING, negative ni ', ni1d(k),        &
!                        ' at i,j,k=', i,j,k
!             CALL wrf_debug(150, mp_debug)
!            endif
!            if (qv1d(k) .lt. 0.0) then
!             if (k.lt.kte-2 .and. k.gt.kts+1) then
!                qv(i,k,j) = 0.5*(qv(i,k-1,j) + qv(i,k+1,j))
!             else
!                qv(i,k,j) = 1.E-7
!             endif
!             write(mp_debug,*) 'WARNING, negative qv ', qv1d(k),        &
!                        ' at i,j,k=', i,j,k
!             CALL wrf_debug(150, mp_debug)
!            endif
         enddo

        if (dBZ_tstep) then
         call calc_refl10cm (qv1d, qr1d, nr1d, qs1d, qg1d,       &
                     t1d, p1d, dBZ, 1, nk, i, j)
         do k =1, nk
            dbz3d(i,j,k) = MAX(-35., dBZ(k))
         enddo
        endif

      enddo i_loop
      enddo j_loop

      do j=1,nj
        train=train+bud1(j)
        tevar=tevar+bud2(j)
      enddo

      time_microphy=time_microphy+mytime()

! DEBUG - GT
!      write(mp_debug,'(a,7(a,e13.6,1x,a,i3,a,i3,a,i3,a,1x))') 'MP-GT:', &
!         'qc: ', qc_max, '(', imax_qc, ',', jmax_qc, ',', kmax_qc, ')', &
!         'qr: ', qr_max, '(', imax_qr, ',', jmax_qr, ',', kmax_qr, ')', &
!         'qi: ', qi_max, '(', imax_qi, ',', jmax_qi, ',', kmax_qi, ')', &
!         'qs: ', qs_max, '(', imax_qs, ',', jmax_qs, ',', kmax_qs, ')', &
!         'qg: ', qg_max, '(', imax_qg, ',', jmax_qg, ',', kmax_qg, ')', &
!         'ni: ', ni_max, '(', imax_ni, ',', jmax_ni, ',', kmax_ni, ')', &
!         'nr: ', nr_max, '(', imax_nr, ',', jmax_nr, ',', kmax_nr, ')'
!      CALL wrf_debug(150, mp_debug)
! END DEBUG - GT

!      do i = 1, 256
!         mp_debug(i:i) = char(0)
!      enddo

      END SUBROUTINE mp_gt_driver

!+---+-----------------------------------------------------------------+
!ctrlL
!+---+-----------------------------------------------------------------+
!+---+-----------------------------------------------------------------+
!.. This subroutine computes the moisture tendencies of water vapor,
!.. cloud droplets, rain, cloud ice (pristine), snow, and graupel.
!.. Previously this code was based on Reisner et al (1998), but few of
!.. those pieces remain.  A complete description is now found in
!.. Thompson et al. (2004, 2008).
!+---+-----------------------------------------------------------------+
!
      subroutine mp_thompson (qv1d, qc1d, qi1d, qr1d, qs1d, qg1d, ni1d, &
                          nr1d, t1d, p1d, dzq, &
                          pptrain, pptsnow, pptgraul, pptice, &
                          kts, kte, dt, ii, jj, prv_rev, neweqts )

      implicit none

!..Sub arguments
      INTEGER, INTENT(IN):: kts, kte, ii, jj
      REAL, DIMENSION(kts:kte), INTENT(INOUT):: &
                          qv1d, qc1d, qi1d, qr1d, qs1d, qg1d, ni1d, &
                          nr1d, t1d, p1d
      REAL, DIMENSION(kts:kte), INTENT(IN):: dzq
      REAL, INTENT(INOUT):: pptrain, pptsnow, pptgraul, pptice
      REAL, INTENT(IN):: dt
      integer, intent(in) :: neweqts

!..Local variables
      REAL, DIMENSION(kts:kte):: tten, qvten, qcten, qiten, &
           qrten, qsten, qgten, niten, nrten

      DOUBLE PRECISION, DIMENSION(kts:kte):: prw_vcd

      DOUBLE PRECISION, DIMENSION(kts:kte):: prr_wau, prr_rcw, prr_rcs, &
           prr_rcg, prr_sml, prr_gml, &
           prr_rci, prv_rev,          &
           pnr_wau, pnr_rcs, pnr_rcg, &
           pnr_rci, pnr_sml, pnr_gml, &
           pnr_rev, pnr_rcr, pnr_rfz

      DOUBLE PRECISION, DIMENSION(kts:kte):: pri_inu, pni_inu, pri_ihm, &
           pni_ihm, pri_wfz, pni_wfz, &
           pri_rfz, pni_rfz, pri_ide, &
           pni_ide, pri_rci, pni_rci, &
           pni_sci, pni_iau

      DOUBLE PRECISION, DIMENSION(kts:kte):: prs_iau, prs_sci, prs_rcs, &
           prs_scw, prs_sde, prs_ihm, &
           prs_ide

      DOUBLE PRECISION, DIMENSION(kts:kte):: prg_scw, prg_rfz, prg_gde, &
           prg_gcw, prg_rci, prg_rcs, &
           prg_rcg, prg_ihm

      REAL, DIMENSION(kts:kte):: temp, pres, qv
      REAL, DIMENSION(kts:kte):: rc, ri, rr, rs, rg, ni, nr
      REAL, DIMENSION(kts:kte):: rho, rhof, rhof2
      REAL, DIMENSION(kts:kte):: qvs, qvsi
      REAL, DIMENSION(kts:kte):: satw, sati, ssatw, ssati
      REAL, DIMENSION(kts:kte):: diffu, visco, vsc2, &
           tcond, lvap, ocp, lvt2
      REAL, DIMENSION(kts:kte):: econd,edep,efrz
      real :: cvm

      DOUBLE PRECISION, DIMENSION(kts:kte):: ilamr, ilamg, N0_r, N0_g
      REAL, DIMENSION(kts:kte):: mvd_r, mvd_c
      REAL, DIMENSION(kts:kte):: smob, smo2, smo1, smo0, &
           smoc, smod, smoe, smof

      REAL, DIMENSION(kts:kte):: sed_r, sed_s, sed_g, sed_i, sed_n

      REAL:: rgvm, delta_tp, orho, lfus2
      REAL, DIMENSION(4):: onstep
      DOUBLE PRECISION:: N0_exp, N0_min, lam_exp, lamc, lamr, lamg
      DOUBLE PRECISION:: lami, ilami
      REAL:: xDc, Dc_b, Dc_g, xDi, xDr, xDs, xDg, Ds_m, Dg_m
      DOUBLE PRECISION:: Dr_star
      REAL:: zeta1, zeta, taud, tau
      REAL:: stoke_r, stoke_s, stoke_g, stoke_i
      REAL:: vti, vtr, vts, vtg
      REAL, DIMENSION(kts:kte+1):: vtik, vtnik, vtrk, vtnrk, vtsk, vtgk
      REAL, DIMENSION(kts:kte):: vts_boost
      REAL:: Mrat, ils1, ils2, t1_vts, t2_vts, t3_vts, t4_vts, C_snow
      REAL:: a_, b_, loga_, A1, A2, tf
      REAL:: tempc, tc0, r_mvd1, r_mvd2, xkrat
      REAL:: xnc, xri, xni, xmi, oxmi, xrc, xrr, xnr
      REAL:: xsat, rate_max, sump, ratio
      REAL:: clap, fcd, dfcd
      REAL:: otemp, rvs, rvs_p, rvs_pp, gamsc, alphsc, t1_evap, t1_subl
      REAL:: r_frac, g_frac
      REAL:: Ef_rw, Ef_sw, Ef_gw, Ef_rr
      REAL:: dtsave, odts, odt, odzq
      REAL:: xslw1, ygra1, zans1
      INTEGER:: i, k, k2, n, nn, nstep, k_0, kbot, IT, iexfrq
      INTEGER, DIMENSION(4):: ksed1
      INTEGER:: nir, nis, nig, nii, nic
      INTEGER:: idx_tc, idx_t, idx_s, idx_g1, idx_g, idx_r1, idx_r,     &
                idx_i1, idx_i, idx_c, idx, idx_d
      LOGICAL:: melti, no_micro
      LOGICAL, DIMENSION(kts:kte):: L_qc, L_qi, L_qr, L_qs, L_qg
      LOGICAL:: debug_flag

!+---+

      debug_flag = .false.
!     if (ii.eq.315 .and. jj.eq.2) debug_flag = .true.

      no_micro = .true.
      dtsave = dt
      odt = 1./dt
      odts = 1./dtsave
      iexfrq = 1

!+---+-----------------------------------------------------------------+
!.. Source/sink terms.  First 2 chars: "pr" represents source/sink of
!.. mass while "pn" represents source/sink of number.  Next char is one
!.. of "v" for water vapor, "r" for rain, "i" for cloud ice, "w" for
!.. cloud water, "s" for snow, and "g" for graupel.  Next chars
!.. represent processes: "de" for sublimation/deposition, "ev" for
!.. evaporation, "fz" for freezing, "ml" for melting, "au" for
!.. autoconversion, "nu" for ice nucleation, "hm" for Hallet/Mossop
!.. secondary ice production, and "c" for collection followed by the
!.. character for the species being collected.  ALL of these terms are
!.. positive (except for deposition/sublimation terms which can switch
!.. signs based on super/subsaturation) and are treated as negatives
!.. where necessary in the tendency equations.
!+---+-----------------------------------------------------------------+

      do k = kts, kte
         tten(k) = 0.
         qvten(k) = 0.
         qcten(k) = 0.
         qiten(k) = 0.
         qrten(k) = 0.
         qsten(k) = 0.
         qgten(k) = 0.
         niten(k) = 0.
         nrten(k) = 0.

         prw_vcd(k) = 0.

         prv_rev(k) = 0.
         prr_wau(k) = 0.
         prr_rcw(k) = 0.
         prr_rcs(k) = 0.
         prr_rcg(k) = 0.
         prr_sml(k) = 0.
         prr_gml(k) = 0.
         prr_rci(k) = 0.
         pnr_wau(k) = 0.
         pnr_rcs(k) = 0.
         pnr_rcg(k) = 0.
         pnr_rci(k) = 0.
         pnr_sml(k) = 0.
         pnr_gml(k) = 0.
         pnr_rev(k) = 0.
         pnr_rcr(k) = 0.
         pnr_rfz(k) = 0.

         pri_inu(k) = 0.
         pni_inu(k) = 0.
         pri_ihm(k) = 0.
         pni_ihm(k) = 0.
         pri_wfz(k) = 0.
         pni_wfz(k) = 0.
         pri_rfz(k) = 0.
         pni_rfz(k) = 0.
         pri_ide(k) = 0.
         pni_ide(k) = 0.
         pri_rci(k) = 0.
         pni_rci(k) = 0.
         pni_sci(k) = 0.
         pni_iau(k) = 0.

         prs_iau(k) = 0.
         prs_sci(k) = 0.
         prs_rcs(k) = 0.
         prs_scw(k) = 0.
         prs_sde(k) = 0.
         prs_ihm(k) = 0.
         prs_ide(k) = 0.

         prg_scw(k) = 0.
         prg_rfz(k) = 0.
         prg_gde(k) = 0.
         prg_gcw(k) = 0.
         prg_rci(k) = 0.
         prg_rcs(k) = 0.
         prg_rcg(k) = 0.
         prg_ihm(k) = 0.
      enddo

!+---+-----------------------------------------------------------------+
!..Put column of data into local arrays.
!+---+-----------------------------------------------------------------+
      do k = kts, kte
         temp(k) = t1d(k)
         qv(k) = MAX(1.E-10, qv1d(k))
         pres(k) = p1d(k)
         rho(k) = 0.622*pres(k)/(R*temp(k)*(qv(k)+0.622))
         if (qc1d(k) .gt. R1) then
            no_micro = .false.
            rc(k) = qc1d(k)*rho(k)
            L_qc(k) = .true.
         else
            qc1d(k) = 0.0
            rc(k) = R1
            L_qc(k) = .false.
         endif
         if (qi1d(k) .gt. R1) then
            no_micro = .false.
            ri(k) = qi1d(k)*rho(k)
            ni(k) = MAX(R2, ni1d(k)*rho(k))
            L_qi(k) = .true.
            lami = (am_i*cig(2)*oig1*ni(k)/ri(k))**obmi
            ilami = 1./lami
            xDi = (bm_i + mu_i + 1.) * ilami
            if (xDi.lt. 20.E-6) then
             lami = cie(2)/20.E-6
             ni(k) = MIN(500.D3, cig(1)*oig2*ri(k)/am_i*lami**bm_i)
            elseif (xDi.gt. 300.E-6) then
             lami = cie(2)/300.E-6
             ni(k) = cig(1)*oig2*ri(k)/am_i*lami**bm_i
            endif
         else
            qi1d(k) = 0.0
            ni1d(k) = 0.0
            ri(k) = R1
            ni(k) = R2
            L_qi(k) = .false.
         endif

         if (qr1d(k) .gt. R1) then
            no_micro = .false.
            rr(k) = qr1d(k)*rho(k)
            nr(k) = MAX(R2, nr1d(k)*rho(k))
            L_qr(k) = .true.
            if (nr(k) .gt. R2) then
             lamr = (am_r*crg(3)*org2*nr(k)/rr(k))**obmr
             mvd_r(k) = (3.0 + mu_r + 0.672) / lamr
             if (mvd_r(k) .gt. 2.5E-3) then
                mvd_r(k) = 2.5E-3
                lamr = (3.0 + mu_r + 0.672) / mvd_r(k)
                nr(k) = crg(2)*org3*rr(k)*lamr**bm_r / am_r
             elseif (mvd_r(k) .lt. D0r*0.75) then
                mvd_r(k) = D0r*0.75
                lamr = (3.0 + mu_r + 0.672) / mvd_r(k)
                nr(k) = crg(2)*org3*rr(k)*lamr**bm_r / am_r
             endif
            else
             if (qr1d(k) .gt. R2) then
                mvd_r(k) = 1.0E-3
             else
                mvd_r(k) = 2.5E-3 / 3.0**(ALOG10(R2)-ALOG10(qr1d(k)))
             endif
             lamr = (3.0 + mu_r + 0.672) / mvd_r(k)
             nr(k) = crg(2)*org3*rr(k)*lamr**bm_r / am_r
            endif
         else
            qr1d(k) = 0.0
            nr1d(k) = 0.0
            rr(k) = R1
            nr(k) = R2
            L_qr(k) = .false.
         endif
         if (qs1d(k) .gt. R1) then
            no_micro = .false.
            rs(k) = qs1d(k)*rho(k)
            L_qs(k) = .true.
         else
            qs1d(k) = 0.0
            rs(k) = R1
            L_qs(k) = .false.
         endif
         if (qg1d(k) .gt. R1) then
            no_micro = .false.
            rg(k) = qg1d(k)*rho(k)
            L_qg(k) = .true.
         else
            qg1d(k) = 0.0
            rg(k) = R1
            L_qg(k) = .false.
         endif
      enddo


!+---+-----------------------------------------------------------------+
!..Derive various thermodynamic variables frequently used.
!.. Saturation vapor pressure (mixing ratio) over liquid/ice comes from
!.. Flatau et al. 1992; enthalpy (latent heat) of vaporization from
!.. Bohren & Albrecht 1998; others from Pruppacher & Klett 1978.
!+---+-----------------------------------------------------------------+
      do k = kts, kte
         tempc = temp(k) - 273.15
         rhof(k) = SQRT(RHO_NOT/rho(k))
         rhof2(k) = SQRT(rhof(k))
         qvs(k) = rslf(pres(k), temp(k))
         if (tempc .le. 0.0) then
          qvsi(k) = rsif(pres(k), temp(k))
         else
          qvsi(k) = qvs(k)
         endif
         satw(k) = qv(k)/qvs(k)
         sati(k) = qv(k)/qvsi(k)
         ssatw(k) = satw(k) - 1.
         ssati(k) = sati(k) - 1.
         if (abs(ssatw(k)).lt. eps) ssatw(k) = 0.0
         if (abs(ssati(k)).lt. eps) ssati(k) = 0.0
         if (no_micro .and. ssati(k).gt. 0.0) no_micro = .false.
         diffu(k) = 2.11E-5*(temp(k)/273.15)**1.94 * (101325./pres(k))
         if (tempc .ge. 0.0) then
            visco(k) = (1.718+0.0049*tempc)*1.0E-5
         else
            visco(k) = (1.718+0.0049*tempc-1.2E-5*tempc*tempc)*1.0E-5
         endif
         ocp(k) = 1./(Cp*(1.+0.887*qv(k)))
         vsc2(k) = SQRT(rho(k)/visco(k))
         lvap(k) = lvap0 + (2106.0 - 4218.0)*tempc
         tcond(k) = (5.69 + 0.0168*tempc)*1.0E-5 * 418.936
         if(neweqts.ge.1)then
           cvm = cv+cvv*qv1d(k)+cpl*(qc1d(k)+qr1d(k))   &
                               +cpi*(qi1d(k)+qs1d(k)+qg1d(k))
           econd(k) = (lvap(k)-Rv*temp(k))/cvm
            edep(k) = (lsub   -Rv*temp(k))/cvm
            efrz(k) = (lsub-lvap(k))/cvm
         else
           econd(k) = lvap(k)*ocp(k)
            edep(k) = lsub*ocp(k)
            efrz(k) = (lsub-lvap(k))*ocp(k)
         endif
      enddo

!+---+-----------------------------------------------------------------+
!..If no existing hydrometeor species and no chance to initiate ice or
!.. condense cloud water, just exit quickly!
!+---+-----------------------------------------------------------------+

      if (no_micro) return

!+---+-----------------------------------------------------------------+
!..Calculate y-intercept, slope, and useful moments for snow.
!+---+-----------------------------------------------------------------+
      if (.not. iiwarm) then
      do k = kts, kte
         if (.not. L_qs(k)) CYCLE
         tc0 = MIN(-0.1, temp(k)-273.15)
         smob(k) = rs(k)*oams

!..All other moments based on reference, 2nd moment.  If bm_s.ne.2,
!.. then we must compute actual 2nd moment and use as reference.
         if (bm_s.gt.(2.0-1.e-3) .and. bm_s.lt.(2.0+1.e-3)) then
            smo2(k) = smob(k)
         else
            loga_ = sa(1) + sa(2)*tc0 + sa(3)*bm_s &
               + sa(4)*tc0*bm_s + sa(5)*tc0*tc0 &
               + sa(6)*bm_s*bm_s + sa(7)*tc0*tc0*bm_s &
               + sa(8)*tc0*bm_s*bm_s + sa(9)*tc0*tc0*tc0 &
               + sa(10)*bm_s*bm_s*bm_s
            a_ = 10.0**loga_
            b_ = sb(1) + sb(2)*tc0 + sb(3)*bm_s &
               + sb(4)*tc0*bm_s + sb(5)*tc0*tc0 &
               + sb(6)*bm_s*bm_s + sb(7)*tc0*tc0*bm_s &
               + sb(8)*tc0*bm_s*bm_s + sb(9)*tc0*tc0*tc0 &
               + sb(10)*bm_s*bm_s*bm_s
            smo2(k) = (smob(k)/a_)**(1./b_)
         endif

!..Calculate 0th moment.  Represents snow number concentration.
         loga_ = sa(1) + sa(2)*tc0 + sa(5)*tc0*tc0 + sa(9)*tc0*tc0*tc0
         a_ = 10.0**loga_
         b_ = sb(1) + sb(2)*tc0 + sb(5)*tc0*tc0 + sb(9)*tc0*tc0*tc0
         smo0(k) = a_ * smo2(k)**b_

!..Calculate 1st moment.  Useful for depositional growth and melting.
         loga_ = sa(1) + sa(2)*tc0 + sa(3) &
               + sa(4)*tc0 + sa(5)*tc0*tc0 &
               + sa(6) + sa(7)*tc0*tc0 &
               + sa(8)*tc0 + sa(9)*tc0*tc0*tc0 &
               + sa(10)
         a_ = 10.0**loga_
         b_ = sb(1)+ sb(2)*tc0 + sb(3) + sb(4)*tc0 &
              + sb(5)*tc0*tc0 + sb(6) &
              + sb(7)*tc0*tc0 + sb(8)*tc0 &
              + sb(9)*tc0*tc0*tc0 + sb(10)
         smo1(k) = a_ * smo2(k)**b_

!..Calculate bm_s+1 (th) moment.  Useful for diameter calcs.
         loga_ = sa(1) + sa(2)*tc0 + sa(3)*cse(1) &
               + sa(4)*tc0*cse(1) + sa(5)*tc0*tc0 &
               + sa(6)*cse(1)*cse(1) + sa(7)*tc0*tc0*cse(1) &
               + sa(8)*tc0*cse(1)*cse(1) + sa(9)*tc0*tc0*tc0 &
               + sa(10)*cse(1)*cse(1)*cse(1)
         a_ = 10.0**loga_
         b_ = sb(1)+ sb(2)*tc0 + sb(3)*cse(1) + sb(4)*tc0*cse(1) &
              + sb(5)*tc0*tc0 + sb(6)*cse(1)*cse(1) &
              + sb(7)*tc0*tc0*cse(1) + sb(8)*tc0*cse(1)*cse(1) &
              + sb(9)*tc0*tc0*tc0 + sb(10)*cse(1)*cse(1)*cse(1)
         smoc(k) = a_ * smo2(k)**b_

!..Calculate bv_s+2 (th) moment.  Useful for riming.
         loga_ = sa(1) + sa(2)*tc0 + sa(3)*cse(13) &
               + sa(4)*tc0*cse(13) + sa(5)*tc0*tc0 &
               + sa(6)*cse(13)*cse(13) + sa(7)*tc0*tc0*cse(13) &
               + sa(8)*tc0*cse(13)*cse(13) + sa(9)*tc0*tc0*tc0 &
               + sa(10)*cse(13)*cse(13)*cse(13)
         a_ = 10.0**loga_
         b_ = sb(1)+ sb(2)*tc0 + sb(3)*cse(13) + sb(4)*tc0*cse(13) &
              + sb(5)*tc0*tc0 + sb(6)*cse(13)*cse(13) &
              + sb(7)*tc0*tc0*cse(13) + sb(8)*tc0*cse(13)*cse(13) &
              + sb(9)*tc0*tc0*tc0 + sb(10)*cse(13)*cse(13)*cse(13)
         smoe(k) = a_ * smo2(k)**b_

!..Calculate 1+(bv_s+1)/2 (th) moment.  Useful for depositional growth.
         loga_ = sa(1) + sa(2)*tc0 + sa(3)*cse(16) &
               + sa(4)*tc0*cse(16) + sa(5)*tc0*tc0 &
               + sa(6)*cse(16)*cse(16) + sa(7)*tc0*tc0*cse(16) &
               + sa(8)*tc0*cse(16)*cse(16) + sa(9)*tc0*tc0*tc0 &
               + sa(10)*cse(16)*cse(16)*cse(16)
         a_ = 10.0**loga_
         b_ = sb(1)+ sb(2)*tc0 + sb(3)*cse(16) + sb(4)*tc0*cse(16) &
              + sb(5)*tc0*tc0 + sb(6)*cse(16)*cse(16) &
              + sb(7)*tc0*tc0*cse(16) + sb(8)*tc0*cse(16)*cse(16) &
              + sb(9)*tc0*tc0*tc0 + sb(10)*cse(16)*cse(16)*cse(16)
         smof(k) = a_ * smo2(k)**b_

      enddo

!+---+-----------------------------------------------------------------+
!..Calculate y-intercept, slope values for graupel.
!+---+-----------------------------------------------------------------+
      N0_min = gonv_max
      do k = kte, kts, -1
         if (temp(k).lt.T_0 .and. (rc(k)+rr(k)).gt.1.E-5) then
            xslw1 = 5. + alog10(max(1.E-5, min(1.E-2, (rc(k)+rr(k)))))
         else
            xslw1 = 0.
         endif
         ygra1 = 5. + alog10(max(1.E-5, min(1.E-2, rg(k))))
         zans1 = 3.324 + (3./(5.*xslw1*ygra1/(5.*xslw1+1.+0.25*ygra1)+1.+0.25*ygra1))
         N0_exp = 10.**(zans1)
         N0_exp = MAX(DBLE(gonv_min), MIN(N0_exp, DBLE(gonv_max)))
         N0_min = MIN(N0_exp, N0_min)
         N0_exp = N0_min
         lam_exp = (N0_exp*am_g*cgg(1)/rg(k))**oge1
         lamg = lam_exp * (cgg(3)*ogg2*ogg1)**obmg
         ilamg(k) = 1./lamg
         N0_g(k) = N0_exp/(cgg(2)*lam_exp) * lamg**cge(2)
!+---+-----------------------------------------------------------------+
!     if( debug_flag .and. k.lt.42) then
!        if (k.eq.41) write(mp_debug,*) 'DEBUG-GT:   K,   zans1,      rc,        rr,         rg,        N0_g'
!        if (k.eq.41) CALL wrf_debug(0, mp_debug)
!        write(mp_debug, 'a, i2, 1x, f6.3, 1x, 4(1x,e13.6,1x)')         &
!                   '  GT ', k, zans1, rc(k), rr(k), rg(k), N0_g(k)
!        CALL wrf_debug(0, mp_debug)
!     endif
!+---+-----------------------------------------------------------------+
      enddo

      endif

!+---+-----------------------------------------------------------------+
!..Calculate y-intercept, slope values for rain.
!+---+-----------------------------------------------------------------+
      do k = kte, kts, -1
         lamr = (am_r*crg(3)*org2*nr(k)/rr(k))**obmr
         ilamr(k) = 1./lamr
         mvd_r(k) = (3.0 + mu_r + 0.672) / lamr
         N0_r(k) = nr(k)*org2*lamr**cre(2)
      enddo

!+---+-----------------------------------------------------------------+
!..Compute warm-rain process terms (except evap done later).
!+---+-----------------------------------------------------------------+

      do k = kts, kte

!..Rain self-collection follows Seifert, 1994 and drop break-up
!.. follows Verlinde and Cotton, 1993.                                        RAIN2M
         if (L_qr(k) .and. mvd_r(k).gt. D0r) then
          Ef_rr = 1.0
          if (mvd_r(k) .gt. 1750.0E-6) then
             Ef_rr = 2.0 - EXP(2300.0*(mvd_r(k)-1750.0E-6))
          endif
          pnr_rcr(k) = Ef_rr * 8.*nr(k)*rr(k)
         endif

         if (.not. L_qc(k)) CYCLE
         xDc = MAX(D0c*1.E6, ((rc(k)/(am_r*Nt_c))**obmr) * 1.E6)
         lamc = (Nt_c*am_r* ccg(2) * ocg1 / rc(k))**obmr
         mvd_c(k) = (3.0+mu_c+0.672) / lamc

!..Autoconversion follows Berry & Reinhardt (1974) with characteristic
!.. diameters correctly computed from gamma distrib of cloud droplets.
         if (rc(k).gt. 0.01e-3) then
          Dc_g = ((ccg(3)*ocg2)**obmr / lamc) * 1.E6
          Dc_b = (xDc*xDc*xDc*Dc_g*Dc_g*Dc_g - xDc*xDc*xDc*xDc*xDc*xDc) &
                 **(1./6.)
          zeta1 = 0.5*((6.25E-6*xDc*Dc_b*Dc_b*Dc_b - 0.4) &
                     + abs(6.25E-6*xDc*Dc_b*Dc_b*Dc_b - 0.4))
          zeta = 0.027*rc(k)*zeta1
          taud = 0.5*((0.5*Dc_b - 7.5) + abs(0.5*Dc_b - 7.5)) + R1
          tau  = 3.72/(rc(k)*taud)
          prr_wau(k) = zeta/tau
          prr_wau(k) = MIN(DBLE(rc(k)*odts), prr_wau(k))
          pnr_wau(k) = prr_wau(k) / (am_r*mu_c/3.*D0r*D0r*D0r/rho(k))       ! RAIN2M
         endif

!..Rain collecting cloud water.  In CE, assume Dc<<Dr and vtc=~0.
         if (L_qr(k) .and. mvd_r(k).gt. D0r .and. mvd_c(k).gt. D0c) then
          lamr = 1./ilamr(k)
          idx = 1 + INT(nbr*DLOG(mvd_r(k)/Dr(1))/DLOG(Dr(nbr)/Dr(1)))
          idx = MIN(idx, nbr)
          Ef_rw = t_Efrw(idx, INT(mvd_c(k)*1.E6))
          prr_rcw(k) = rhof(k)*t1_qr_qc*Ef_rw*rc(k)*N0_r(k) &
                         *((lamr+fv_r)**(-cre(9)))
          prr_rcw(k) = MIN(DBLE(rc(k)*odts), prr_rcw(k))
         endif
      enddo

!+---+-----------------------------------------------------------------+
!..Compute all frozen hydrometeor species' process terms.
!+---+-----------------------------------------------------------------+
      if (.not. iiwarm) then
      do k = kts, kte
         vts_boost(k) = 1.5

!..Temperature lookup table indexes.
         tempc = temp(k) - 273.15
         idx_tc = MAX(1, MIN(NINT(-tempc), 45) )
         idx_t = INT( (tempc-2.5)/5. ) - 1
         idx_t = MAX(1, -idx_t)
         idx_t = MIN(idx_t, ntb_t)
         IT = MAX(1, MIN(NINT(-tempc), 31) )

!..Cloud water lookup table index.
         if (rc(k).gt. r_c(1)) then
          nic = NINT(ALOG10(rc(k)))
          do nn = nic-1, nic+1
             n = nn
             if ( (rc(k)/10.**nn).ge.1.0 .and. &
                  (rc(k)/10.**nn).lt.10.0) goto 141
          enddo
 141      continue
          idx_c = INT(rc(k)/10.**n) + 10*(n-nic2) - (n-nic2)
          idx_c = MAX(1, MIN(idx_c, ntb_c))
         else
          idx_c = 1
         endif

!..Cloud ice lookup table indexes.
         if (ri(k).gt. r_i(1)) then
          nii = NINT(ALOG10(ri(k)))
          do nn = nii-1, nii+1
             n = nn
             if ( (ri(k)/10.**nn).ge.1.0 .and. &
                  (ri(k)/10.**nn).lt.10.0) goto 142
          enddo
 142      continue
          idx_i = INT(ri(k)/10.**n) + 10*(n-nii2) - (n-nii2)
          idx_i = MAX(1, MIN(idx_i, ntb_i))
         else
          idx_i = 1
         endif

         if (ni(k).gt. Nt_i(1)) then
          nii = NINT(ALOG10(ni(k)))
          do nn = nii-1, nii+1
             n = nn
             if ( (ni(k)/10.**nn).ge.1.0 .and. &
                  (ni(k)/10.**nn).lt.10.0) goto 143
          enddo
 143      continue
          idx_i1 = INT(ni(k)/10.**n) + 10*(n-nii3) - (n-nii3)
          idx_i1 = MAX(1, MIN(idx_i1, ntb_i1))
         else
          idx_i1 = 1
         endif

!..Rain lookup table indexes.
         if (rr(k).gt. r_r(1)) then
          nir = NINT(ALOG10(rr(k)))
          do nn = nir-1, nir+1
             n = nn
             if ( (rr(k)/10.**nn).ge.1.0 .and. &
                  (rr(k)/10.**nn).lt.10.0) goto 144
          enddo
 144      continue
          idx_r = INT(rr(k)/10.**n) + 10*(n-nir2) - (n-nir2)
          idx_r = MAX(1, MIN(idx_r, ntb_r))

          lamr = 1./ilamr(k)
          lam_exp = lamr * (crg(3)*org2*org1)**bm_r
          N0_exp = org1*rr(k)/am_r * lam_exp**cre(1)
          nir = NINT(DLOG10(N0_exp))
          do nn = nir-1, nir+1
             n = nn
             if ( (N0_exp/10.**nn).ge.1.0 .and. &
                  (N0_exp/10.**nn).lt.10.0) goto 145
          enddo
 145      continue
          idx_r1 = INT(N0_exp/10.**n) + 10*(n-nir3) - (n-nir3)
          idx_r1 = MAX(1, MIN(idx_r1, ntb_r1))
         else
          idx_r = 1
          idx_r1 = ntb_r1
         endif

!..Snow lookup table index.
         if (rs(k).gt. r_s(1)) then
          nis = NINT(ALOG10(rs(k)))
          do nn = nis-1, nis+1
             n = nn
             if ( (rs(k)/10.**nn).ge.1.0 .and. &
                  (rs(k)/10.**nn).lt.10.0) goto 146
          enddo
 146      continue
          idx_s = INT(rs(k)/10.**n) + 10*(n-nis2) - (n-nis2)
          idx_s = MAX(1, MIN(idx_s, ntb_s))
         else
          idx_s = 1
         endif

!..Graupel lookup table index.
         if (rg(k).gt. r_g(1)) then
          nig = NINT(ALOG10(rg(k)))
          do nn = nig-1, nig+1
             n = nn
             if ( (rg(k)/10.**nn).ge.1.0 .and. &
                  (rg(k)/10.**nn).lt.10.0) goto 147
          enddo
 147      continue
          idx_g = INT(rg(k)/10.**n) + 10*(n-nig2) - (n-nig2)
          idx_g = MAX(1, MIN(idx_g, ntb_g))

          lamg = 1./ilamg(k)
          lam_exp = lamg * (cgg(3)*ogg2*ogg1)**bm_g
          N0_exp = ogg1*rg(k)/am_g * lam_exp**cge(1)
          nig = NINT(DLOG10(N0_exp))
          do nn = nig-1, nig+1
             n = nn
             if ( (N0_exp/10.**nn).ge.1.0 .and. &
                  (N0_exp/10.**nn).lt.10.0) goto 148
          enddo
 148      continue
          idx_g1 = INT(N0_exp/10.**n) + 10*(n-nig3) - (n-nig3)
          idx_g1 = MAX(1, MIN(idx_g1, ntb_g1))
         else
          idx_g = 1
          idx_g1 = ntb_g1
         endif

!..Deposition/sublimation prefactor (from Srivastava & Coen 1992).
         otemp = 1./temp(k)
         rvs = rho(k)*qvsi(k)
         rvs_p = rvs*otemp*(lsub*otemp*oRv - 1.)
         rvs_pp = rvs * ( otemp*(lsub*otemp*oRv - 1.) &
                         *otemp*(lsub*otemp*oRv - 1.) &
                         + (-2.*lsub*otemp*otemp*otemp*oRv) &
                         + otemp*otemp)
         gamsc = lsub*diffu(k)/tcond(k) * rvs_p
         alphsc = 0.5*(gamsc/(1.+gamsc))*(gamsc/(1.+gamsc)) &
                    * rvs_pp/rvs_p * rvs/rvs_p
         alphsc = MAX(1.E-9, alphsc)
         xsat = ssati(k)
         if (abs(xsat).lt. 1.E-9) xsat=0.
         t1_subl = 4.*PI*( 1.0 - alphsc*xsat &
                + 2.*alphsc*alphsc*xsat*xsat &
                - 5.*alphsc*alphsc*alphsc*xsat*xsat*xsat ) &
                / (1.+gamsc)

!..Snow collecting cloud water.  In CE, assume Dc<<Ds and vtc=~0.
         if (L_qc(k) .and. mvd_c(k).gt. D0c) then
          xDs = 0.0
          if (L_qs(k)) xDs = smoc(k) / smob(k)
          if (xDs .gt. D0s) then
           idx = 1 + INT(nbs*DLOG(xDs/Ds(1))/DLOG(Ds(nbs)/Ds(1)))
           idx = MIN(idx, nbs)
           Ef_sw = t_Efsw(idx, INT(mvd_c(k)*1.E6))
           prs_scw(k) = rhof(k)*t1_qs_qc*Ef_sw*rc(k)*smoe(k)
          endif

!..Graupel collecting cloud water.  In CE, assume Dc<<Dg and vtc=~0.
          if (rg(k).ge. r_g(1) .and. mvd_c(k).gt. D0c) then
           xDg = (bm_g + mu_g + 1.) * ilamg(k)
           vtg = rhof(k)*av_g*cgg(6)*ogg3 * ilamg(k)**bv_g
           stoke_g = mvd_c(k)*mvd_c(k)*vtg*rho_w/(9.*visco(k)*xDg)
           if (xDg.gt. D0g) then
            if (stoke_g.ge.0.4 .and. stoke_g.le.10.) then
             Ef_gw = 0.55*ALOG10(2.51*stoke_g)
            elseif (stoke_g.lt.0.4) then
             Ef_gw = 0.0
            elseif (stoke_g.gt.10) then
             Ef_gw = 0.77
            endif
            prg_gcw(k) = rhof(k)*t1_qg_qc*Ef_gw*rc(k)*N0_g(k) &
                          *ilamg(k)**cge(9)
           endif
          endif
         endif

!..Rain collecting snow.  Cannot assume Wisner (1972) approximation
!.. or Mizuno (1990) approach so we solve the CE explicitly and store
!.. results in lookup table.
         if (rr(k).ge. r_r(1)) then
          if (rs(k).ge. r_s(1)) then
           if (temp(k).lt.T_0) then
            prr_rcs(k) = -(tmr_racs2(idx_s,idx_t,idx_r1,idx_r) &
                           + tcr_sacr2(idx_s,idx_t,idx_r1,idx_r) &
                           + tmr_racs1(idx_s,idx_t,idx_r1,idx_r) &
                           + tcr_sacr1(idx_s,idx_t,idx_r1,idx_r))
            prs_rcs(k) = tmr_racs2(idx_s,idx_t,idx_r1,idx_r) &
                         + tcr_sacr2(idx_s,idx_t,idx_r1,idx_r) &
                         - tcs_racs1(idx_s,idx_t,idx_r1,idx_r) &
                         - tms_sacr1(idx_s,idx_t,idx_r1,idx_r)
            prg_rcs(k) = tmr_racs1(idx_s,idx_t,idx_r1,idx_r) &
                         + tcr_sacr1(idx_s,idx_t,idx_r1,idx_r) &
                         + tcs_racs1(idx_s,idx_t,idx_r1,idx_r) &
                         + tms_sacr1(idx_s,idx_t,idx_r1,idx_r)
            prr_rcs(k) = MAX(DBLE(-rr(k)*odts), prr_rcs(k))
            prs_rcs(k) = MAX(DBLE(-rs(k)*odts), prs_rcs(k))
            prg_rcs(k) = MIN(DBLE((rr(k)+rs(k))*odts), prg_rcs(k))
            pnr_rcs(k) = tnr_racs1(idx_s,idx_t,idx_r1,idx_r)            &   ! RAIN2M
                         + tnr_racs2(idx_s,idx_t,idx_r1,idx_r)          &
                         + tnr_sacr1(idx_s,idx_t,idx_r1,idx_r)          &
                         + tnr_sacr2(idx_s,idx_t,idx_r1,idx_r)
           else
            prs_rcs(k) = -tcs_racs1(idx_s,idx_t,idx_r1,idx_r)           &
                         - tms_sacr1(idx_s,idx_t,idx_r1,idx_r)          &
                         + tmr_racs2(idx_s,idx_t,idx_r1,idx_r)          &
                         + tcr_sacr2(idx_s,idx_t,idx_r1,idx_r)
            prs_rcs(k) = MAX(DBLE(-rs(k)*odts), prs_rcs(k))
            prr_rcs(k) = -prs_rcs(k)
            pnr_rcs(k) = tnr_racs2(idx_s,idx_t,idx_r1,idx_r)            &   ! RAIN2M
                         + tnr_sacr2(idx_s,idx_t,idx_r1,idx_r)
           endif
           pnr_rcs(k) = MIN(DBLE(nr(k)*odts), pnr_rcs(k))
          endif

!..Rain collecting graupel.  Cannot assume Wisner (1972) approximation
!.. or Mizuno (1990) approach so we solve the CE explicitly and store
!.. results in lookup table.
          if (rg(k).ge. r_g(1)) then
           if (temp(k).lt.T_0) then
            prg_rcg(k) = tmr_racg(idx_g1,idx_g,idx_r1,idx_r) &
                         + tcr_gacr(idx_g1,idx_g,idx_r1,idx_r)
            prg_rcg(k) = MIN(DBLE(rr(k)*odts), prg_rcg(k))
            prr_rcg(k) = -prg_rcg(k)
            pnr_rcg(k) = tnr_racg(idx_g1,idx_g,idx_r1,idx_r)            &   ! RAIN2M
                         + tnr_gacr(idx_g1,idx_g,idx_r1,idx_r)
            pnr_rcg(k) = MIN(DBLE(nr(k)*odts), pnr_rcg(k))
           else
            prr_rcg(k) = tcg_racg(idx_g1,idx_g,idx_r1,idx_r)
            prr_rcg(k) = MIN(DBLE(rg(k)*odts), prr_rcg(k))
            prg_rcg(k) = -prr_rcg(k)
           endif
          endif
         endif

!+---+-----------------------------------------------------------------+
!..Next IF block handles only those processes below 0C.
!+---+-----------------------------------------------------------------+

         if (temp(k).lt.T_0) then

          vts_boost(k) = 1.0
          rate_max = (qv(k)-qvsi(k))*rho(k)*odts*0.999

!..Freezing of water drops into graupel/cloud ice (Bigg 1953).
          if (rr(k).gt. r_r(1)) then
           prg_rfz(k) = tpg_qrfz(idx_r,idx_r1,idx_tc)*odts
           pri_rfz(k) = tpi_qrfz(idx_r,idx_r1,idx_tc)*odts
           pni_rfz(k) = tni_qrfz(idx_r,idx_r1,idx_tc)*odts
           pnr_rfz(k) = tnr_qrfz(idx_r,idx_r1,idx_tc)*odts                 ! RAIN2M
           pnr_rfz(k) = MIN(DBLE(nr(k)*odts), pnr_rfz(k))
          elseif (rr(k).gt. R1 .and. temp(k).lt.HGFR) then
           pri_rfz(k) = rr(k)*odts
           pnr_rfz(k) = nr(k)*odts                                         ! RAIN2M
           pni_rfz(k) = pnr_rfz(k)
          endif
          if (rc(k).gt. r_c(1)) then
           pri_wfz(k) = tpi_qcfz(idx_c,idx_tc)*odts
           pri_wfz(k) = MIN(DBLE(rc(k)*odts), pri_wfz(k))
           pni_wfz(k) = tni_qcfz(idx_c,idx_tc)*odts
           pni_wfz(k) = MIN(DBLE(Nt_c*odts), pri_wfz(k)/(2.*xm0i), &
                                pni_wfz(k))
          endif

!..Nucleate ice from deposition & condensation freezing (Cooper 1986)
!.. but only if water sat and T<-12C or 25%+ ice supersaturated.
          if ( (ssati(k).ge. 0.25) .or. (ssatw(k).gt. eps &
                                .and. temp(k).lt.261.15) ) then
           xnc = MIN(250.E3, TNO*EXP(ATO*(T_0-temp(k))))
           xni = ni(k) + (pni_rfz(k)+pni_wfz(k))*dtsave
           pni_inu(k) = 0.5*(xnc-xni + abs(xnc-xni))*odts
           pri_inu(k) = MIN(DBLE(rate_max), xm0i*pni_inu(k))
           pni_inu(k) = pri_inu(k)/xm0i
          endif

!..Deposition/sublimation of cloud ice (Srivastava & Coen 1992).
          if (L_qi(k)) then
           lami = (am_i*cig(2)*oig1*ni(k)/ri(k))**obmi
           ilami = 1./lami
           xDi = MAX(DBLE(D0i), (bm_i + mu_i + 1.) * ilami)
           xmi = am_i*xDi**bm_i
           oxmi = 1./xmi
           pri_ide(k) = C_cube*t1_subl*diffu(k)*ssati(k)*rvs &
                  *oig1*cig(5)*ni(k)*ilami

           if (pri_ide(k) .lt. 0.0) then
            pri_ide(k) = MAX(DBLE(-ri(k)*odts), pri_ide(k), DBLE(rate_max))
            pni_ide(k) = pri_ide(k)*oxmi
            pni_ide(k) = MAX(DBLE(-ni(k)*odts), pni_ide(k))
           else
            pri_ide(k) = MIN(pri_ide(k), DBLE(rate_max))
            prs_ide(k) = (1.0D0-tpi_ide(idx_i,idx_i1))*pri_ide(k)
            pri_ide(k) = tpi_ide(idx_i,idx_i1)*pri_ide(k)
           endif

!..Some cloud ice needs to move into the snow category.  Use lookup
!.. table that resulted from explicit bin representation of distrib.
           if ( (idx_i.eq. ntb_i) .or. (xDi.gt. 5.0*D0s) ) then
            prs_iau(k) = ri(k)*.99*odts
            pni_iau(k) = ni(k)*.95*odts
           elseif (xDi.lt. 0.1*D0s) then
            prs_iau(k) = 0.
            pni_iau(k) = 0.
           else
            prs_iau(k) = tps_iaus(idx_i,idx_i1)*odts
            prs_iau(k) = MIN(DBLE(ri(k)*.99*odts), prs_iau(k))
            pni_iau(k) = tni_iaus(idx_i,idx_i1)*odts
            pni_iau(k) = MIN(DBLE(ni(k)*.95*odts), pni_iau(k))
           endif
          endif

!..Deposition/sublimation of snow/graupel follows Srivastava & Coen
!.. (1992).
          if (L_qs(k)) then
           C_snow = C_sqrd + (tempc+15.)*(C_cube-C_sqrd)/(-30.+15.)
           C_snow = MAX(C_sqrd, MIN(C_snow, C_cube))
           prs_sde(k) = C_snow*t1_subl*diffu(k)*ssati(k)*rvs &
                        * (t1_qs_sd*smo1(k) &
                         + t2_qs_sd*rhof2(k)*vsc2(k)*smof(k))
           if (prs_sde(k).lt. 0.) then
            prs_sde(k) = MAX(DBLE(-rs(k)*odts), prs_sde(k), DBLE(rate_max))
           else
            prs_sde(k) = MIN(prs_sde(k), DBLE(rate_max))
           endif
          endif

          if (L_qg(k) .and. ssati(k).lt. -eps) then
           prg_gde(k) = C_cube*t1_subl*diffu(k)*ssati(k)*rvs &
               * N0_g(k) * (t1_qg_sd*ilamg(k)**cge(10) &
               + t2_qg_sd*vsc2(k)*rhof2(k)*ilamg(k)**cge(11))
           if (prg_gde(k).lt. 0.) then
            prg_gde(k) = MAX(DBLE(-rg(k)*odts), prg_gde(k), DBLE(rate_max))
           else
            prg_gde(k) = MIN(prg_gde(k), DBLE(rate_max))
           endif
          endif

!..Snow collecting cloud ice.  In CE, assume Di<<Ds and vti=~0.
          if (L_qi(k)) then
           lami = (am_i*cig(2)*oig1*ni(k)/ri(k))**obmi
           ilami = 1./lami
           xDi = MAX(DBLE(D0i), (bm_i + mu_i + 1.) * ilami)
           xmi = am_i*xDi**bm_i
           oxmi = 1./xmi
           if (rs(k).ge. r_s(1)) then
            prs_sci(k) = t1_qs_qi*rhof(k)*Ef_si*ri(k)*smoe(k)
            pni_sci(k) = prs_sci(k) * oxmi
           endif

!..Rain collecting cloud ice.  In CE, assume Di<<Dr and vti=~0.
           if (rr(k).ge. r_r(1) .and. mvd_r(k).gt. 4.*xDi) then
            lamr = 1./ilamr(k)
            pri_rci(k) = rhof(k)*t1_qr_qi*Ef_ri*ri(k)*N0_r(k) &
                           *((lamr+fv_r)**(-cre(9)))
            pnr_rci(k) = rhof(k)*t1_qr_qi*Ef_ri*ni(k)*N0_r(k)           &   ! RAIN2M
                           *((lamr+fv_r)**(-cre(9)))
            pni_rci(k) = pri_rci(k) * oxmi
            prr_rci(k) = rhof(k)*t2_qr_qi*Ef_ri*ni(k)*N0_r(k) &
                           *((lamr+fv_r)**(-cre(8)))
            prr_rci(k) = MIN(DBLE(rr(k)*odts), prr_rci(k))
            prg_rci(k) = pri_rci(k) + prr_rci(k)
           endif
          endif

!..Ice multiplication from rime-splinters (Hallet & Mossop 1974).
          if (prg_gcw(k).gt. eps .and. tempc.gt.-8.0) then
           tf = 0.
           if (tempc.ge.-5.0 .and. tempc.lt.-3.0) then
            tf = 0.5*(-3.0 - tempc)
           elseif (tempc.gt.-8.0 .and. tempc.lt.-5.0) then
            tf = 0.33333333*(8.0 + tempc)
           endif
           pni_ihm(k) = 3.5E8*tf*prg_gcw(k)
           pri_ihm(k) = xm0i*pni_ihm(k)
           prs_ihm(k) = prs_scw(k)/(prs_scw(k)+prg_gcw(k)) &
                          * pri_ihm(k)
           prg_ihm(k) = prg_gcw(k)/(prs_scw(k)+prg_gcw(k)) &
                          * pri_ihm(k)
          endif

!..A portion of rimed snow converts to graupel but some remains snow.
!.. Interp from 5 to 75% as riming factor increases from 5.0 to 30.0
!.. 0.028 came from (.75-.05)/(30.-5.).  This remains ad-hoc and should
!.. be revisited.
          if (prs_scw(k).gt.5.0*prs_sde(k) .and. &
                         prs_sde(k).gt.eps) then
           r_frac = MIN(30.0D0, prs_scw(k)/prs_sde(k))
           g_frac = MIN(0.75, 0.05 + (r_frac-5.)*.028)
           vts_boost(k) = MIN(1.5, 1.1 + (r_frac-5.)*.016)
           prg_scw(k) = g_frac*prs_scw(k)
           prs_scw(k) = (1. - g_frac)*prs_scw(k)
          endif

         else

!..Melt snow and graupel and enhance from collisions with liquid.
!.. We also need to sublimate snow and graupel if subsaturated.
          if (L_qs(k)) then
           prr_sml(k) = tempc*tcond(k)*(t1_qs_me*smo1(k) &
                      + t2_qs_me*rhof2(k)*vsc2(k)*smof(k))
           prr_sml(k) = prr_sml(k) + 4218.*olfus*tempc &
                                   * (prr_rcs(k)+prs_scw(k))
           prr_sml(k) = MIN(DBLE(rs(k)*odts), prr_sml(k))
           pnr_sml(k) = smo0(k)/rs(k)*prr_sml(k) * 10.0**(-0.50*tempc)      ! RAIN2M
           pnr_sml(k) = MIN(DBLE(smo0(k)*odts), pnr_sml(k))
           if (tempc.gt.3.5 .or. rs(k).lt.0.005E-3) pnr_sml(k)=0.0

           if (ssati(k).lt. 0.) then
            prs_sde(k) = C_cube*t1_subl*diffu(k)*ssati(k)*rvs &
                         * (t1_qs_sd*smo1(k) &
                          + t2_qs_sd*rhof2(k)*vsc2(k)*smof(k))
            prs_sde(k) = MAX(DBLE(-rs(k)*odts), prs_sde(k))
           endif
          endif

          if (L_qg(k)) then
           prr_gml(k) = tempc*N0_g(k)*tcond(k) &
                    *(t1_qg_me*ilamg(k)**cge(10) &
                    + t2_qg_me*rhof2(k)*vsc2(k)*ilamg(k)**cge(11))
           prr_gml(k) = prr_gml(k) + 4218.*olfus*tempc &
                                   * (prr_rcg(k)+prg_gcw(k))
           prr_gml(k) = MIN(DBLE(rg(k)*odts), prr_gml(k))
           pnr_gml(k) = (N0_g(k) / (cgg(1)*am_g*N0_g(k)/rg(k))**oge1)   &   ! RAIN2M
                      / rg(k) * prr_gml(k) * 10.0**(-0.35*tempc)
           if (rg(k).lt.0.005E-3) pnr_gml(k)=0.0

           if (ssati(k).lt. 0.) then
            prg_gde(k) = C_cube*t1_subl*diffu(k)*ssati(k)*rvs &
                * N0_g(k) * (t1_qg_sd*ilamg(k)**cge(10) &
                + t2_qg_sd*vsc2(k)*rhof2(k)*ilamg(k)**cge(11))
            prg_gde(k) = MAX(DBLE(-rg(k)*odts), prg_gde(k))
           endif
          endif

!.. This change will be required if users run adaptive time step that
!.. results in delta-t that is generally too long to allow cloud water
!.. collection by snow/graupel above melting temperature.
!.. Credit to Bjorn-Egil Nygaard for discovering.
          if (dt .gt. 120.) then
             prr_rcw(k)=prr_rcw(k)+prs_scw(k)+prg_gcw(k)
             prs_scw(k)=0.
             prg_gcw(k)=0.
          endif

         endif

      enddo
      endif

!+---+-----------------------------------------------------------------+
!..Ensure we do not deplete more hydrometeor species than exists.
!+---+-----------------------------------------------------------------+
      do k = kts, kte

!..If ice supersaturated, ensure sum of depos growth terms does not
!.. deplete more vapor than possibly exists.  If subsaturated, limit
!.. sum of sublimation terms such that vapor does not reproduce ice
!.. supersat again.
         sump = pri_inu(k) + pri_ide(k) + prs_ide(k) &
              + prs_sde(k) + prg_gde(k)
         rate_max = (qv(k)-qvsi(k))*odts*0.999
         if ( (sump.gt. eps .and. sump.gt. rate_max) .or. &
              (sump.lt. -eps .and. sump.lt. rate_max) ) then
          ratio = rate_max/sump
          pri_inu(k) = pri_inu(k) * ratio
          pri_ide(k) = pri_ide(k) * ratio
          pni_ide(k) = pni_ide(k) * ratio
          prs_ide(k) = prs_ide(k) * ratio
          prs_sde(k) = prs_sde(k) * ratio
          prg_gde(k) = prg_gde(k) * ratio
         endif

!..Cloud water conservation.
         sump = -prr_wau(k) - pri_wfz(k) - prr_rcw(k) &
                - prs_scw(k) - prg_scw(k) - prg_gcw(k)
         rate_max = -rc(k)*odts
         if (sump.lt. rate_max .and. L_qc(k)) then
          ratio = rate_max/sump
          prr_wau(k) = prr_wau(k) * ratio
          pri_wfz(k) = pri_wfz(k) * ratio
          prr_rcw(k) = prr_rcw(k) * ratio
          prs_scw(k) = prs_scw(k) * ratio
          prg_scw(k) = prg_scw(k) * ratio
          prg_gcw(k) = prg_gcw(k) * ratio
         endif

!..Cloud ice conservation.
         sump = pri_ide(k) - prs_iau(k) - prs_sci(k) &
                - pri_rci(k)
         rate_max = -ri(k)*odts
         if (sump.lt. rate_max .and. L_qi(k)) then
          ratio = rate_max/sump
          pri_ide(k) = pri_ide(k) * ratio
          prs_iau(k) = prs_iau(k) * ratio
          prs_sci(k) = prs_sci(k) * ratio
          pri_rci(k) = pri_rci(k) * ratio
         endif

!..Rain conservation.
         sump = -prg_rfz(k) - pri_rfz(k) - prr_rci(k) &
                + prr_rcs(k) + prr_rcg(k)
         rate_max = -rr(k)*odts
         if (sump.lt. rate_max .and. L_qr(k)) then
          ratio = rate_max/sump
          prg_rfz(k) = prg_rfz(k) * ratio
          pri_rfz(k) = pri_rfz(k) * ratio
          prr_rci(k) = prr_rci(k) * ratio
          prr_rcs(k) = prr_rcs(k) * ratio
          prr_rcg(k) = prr_rcg(k) * ratio
         endif

!..Snow conservation.
         sump = prs_sde(k) - prs_ihm(k) - prr_sml(k) &
                + prs_rcs(k)
         rate_max = -rs(k)*odts
         if (sump.lt. rate_max .and. L_qs(k)) then
          ratio = rate_max/sump
          prs_sde(k) = prs_sde(k) * ratio
          prs_ihm(k) = prs_ihm(k) * ratio
          prr_sml(k) = prr_sml(k) * ratio
          prs_rcs(k) = prs_rcs(k) * ratio
         endif

!..Graupel conservation.
         sump = prg_gde(k) - prg_ihm(k) - prr_gml(k) &
              + prg_rcg(k)
         rate_max = -rg(k)*odts
         if (sump.lt. rate_max .and. L_qg(k)) then
          ratio = rate_max/sump
          prg_gde(k) = prg_gde(k) * ratio
          prg_ihm(k) = prg_ihm(k) * ratio
          prr_gml(k) = prr_gml(k) * ratio
          prg_rcg(k) = prg_rcg(k) * ratio
         endif

!..Re-enforce proper mass conservation for subsequent elements in case
!.. any of the above terms were altered.  Thanks P. Blossey. 2009Sep28
         pri_ihm(k) = prs_ihm(k) + prg_ihm(k)
         ratio = MIN( ABS(prr_rcg(k)), ABS(prg_rcg(k)) )
         prr_rcg(k) = ratio * SIGN(1.0, SNGL(prr_rcg(k)))
         prg_rcg(k) = -prr_rcg(k)
         if (temp(k).gt.T_0) then
            ratio = MIN( ABS(prr_rcs(k)), ABS(prs_rcs(k)) )
            prr_rcs(k) = ratio * SIGN(1.0, SNGL(prr_rcs(k)))
            prs_rcs(k) = -prr_rcs(k)
         endif

      enddo

!+---+-----------------------------------------------------------------+
!..Calculate tendencies of all species but constrain the number of ice
!.. to reasonable values.
!+---+-----------------------------------------------------------------+
      do k = kts, kte
         orho = 1./rho(k)
         lfus2 = lsub - lvap(k)

!..Water vapor tendency
         qvten(k) = qvten(k) + (-pri_inu(k) - pri_ide(k) &
                      - prs_ide(k) - prs_sde(k) - prg_gde(k)) &
                      * orho

!..Cloud water tendency
         qcten(k) = qcten(k) + (-prr_wau(k) - pri_wfz(k) &
                      - prr_rcw(k) - prs_scw(k) - prg_scw(k) &
                      - prg_gcw(k)) &
                      * orho

!..Cloud ice mixing ratio tendency
         qiten(k) = qiten(k) + (pri_inu(k) + pri_ihm(k) &
                      + pri_wfz(k) + pri_rfz(k) + pri_ide(k) &
                      - prs_iau(k) - prs_sci(k) - pri_rci(k)) &
                      * orho

!..Cloud ice number tendency.
         niten(k) = niten(k) + (pni_inu(k) + pni_ihm(k) &
                      + pni_wfz(k) + pni_rfz(k) + pni_ide(k) &
                      - pni_iau(k) - pni_sci(k) - pni_rci(k)) &
                      * orho

!..Cloud ice mass/number balance; keep mass-wt mean size between
!.. 20 and 300 microns.  Also no more than 500 xtals per liter.
         xri=MAX(R1,(qi1d(k) + qiten(k)*dtsave)*rho(k))
         xni=MAX(R2,(ni1d(k) + niten(k)*dtsave)*rho(k))
         if (xri.gt. R1) then
           lami = (am_i*cig(2)*oig1*xni/xri)**obmi
           ilami = 1./lami
           xDi = (bm_i + mu_i + 1.) * ilami
           if (xDi.lt. 20.E-6) then
            lami = cie(2)/20.E-6
            xni = MIN(500.D3, cig(1)*oig2*xri/am_i*lami**bm_i)
            niten(k) = (xni-ni1d(k)*rho(k))*odts*orho
           elseif (xDi.gt. 300.E-6) then
            lami = cie(2)/300.E-6
            xni = cig(1)*oig2*xri/am_i*lami**bm_i
            niten(k) = (xni-ni1d(k)*rho(k))*odts*orho
           endif
         else
          niten(k) = -ni1d(k)*odts
         endif
         xni=MAX(0.,(ni1d(k) + niten(k)*dtsave)*rho(k))
         if (xni.gt.500.E3) &
                niten(k) = (500.E3-ni1d(k)*rho(k))*odts*orho

!..Rain tendency
         qrten(k) = qrten(k) + (prr_wau(k) + prr_rcw(k) &
                      + prr_sml(k) + prr_gml(k) + prr_rcs(k) &
                      + prr_rcg(k) - prg_rfz(k) &
                      - pri_rfz(k) - prr_rci(k)) &
                      * orho

!..Rain number tendency
         nrten(k) = nrten(k) + (pnr_wau(k) + pnr_sml(k) + pnr_gml(k)    &
                      - (pnr_rfz(k) + pnr_rcr(k) + pnr_rcg(k)           &
                      + pnr_rcs(k) + pnr_rci(k)) )                      &
                      * orho

!..Rain mass/number balance; keep median volume diameter between
!.. 37 microns (D0r*0.75) and 2.5 mm.
         xrr=MAX(R1,(qr1d(k) + qrten(k)*dtsave)*rho(k))
         xnr=MAX(R2,(nr1d(k) + nrten(k)*dtsave)*rho(k))
         if (xrr.gt. R1) then
           lamr = (am_r*crg(3)*org2*xnr/xrr)**obmr
           mvd_r(k) = (3.0 + mu_r + 0.672) / lamr
           if (mvd_r(k) .gt. 2.5E-3) then
              mvd_r(k) = 2.5E-3
              lamr = (3.0 + mu_r + 0.672) / mvd_r(k)
              xnr = crg(2)*org3*xrr*lamr**bm_r / am_r
              nrten(k) = (xnr-nr1d(k)*rho(k))*odts*orho
           elseif (mvd_r(k) .lt. D0r*0.75) then
              mvd_r(k) = D0r*0.75
              lamr = (3.0 + mu_r + 0.672) / mvd_r(k)
              xnr = crg(2)*org3*xrr*lamr**bm_r / am_r
              nrten(k) = (xnr-nr1d(k)*rho(k))*odts*orho
           endif
         else
           qrten(k) = -qr1d(k)*odts
           nrten(k) = -nr1d(k)*odts
         endif

!..Snow tendency
         qsten(k) = qsten(k) + (prs_iau(k) + prs_sde(k) &
                      + prs_sci(k) + prs_scw(k) + prs_rcs(k) &
                      + prs_ide(k) - prs_ihm(k) - prr_sml(k)) &
                      * orho

!..Graupel tendency
         qgten(k) = qgten(k) + (prg_scw(k) + prg_rfz(k) &
                      + prg_gde(k) + prg_rcg(k) + prg_gcw(k) &
                      + prg_rci(k) + prg_rcs(k) - prg_ihm(k) &
                      - prr_gml(k)) &
                      * orho

!..Temperature tendency
         if (temp(k).lt.T_0) then
!!!          tten(k) = tten(k) &
!!!                    + ( lsub*ocp(k)*(pri_inu(k) + pri_ide(k) &
!!!                                     + prs_ide(k) + prs_sde(k) &
!!!                                     + prg_gde(k)) &
!!!                     + lfus2*ocp(k)*(pri_wfz(k) + pri_rfz(k) &
!!!                                     + prg_rfz(k) + prs_scw(k) &
!!!                                     + prg_scw(k) + prg_gcw(k) &
!!!                                     + prg_rcs(k) + prs_rcs(k) &
!!!                                     + prr_rci(k) + prg_rcg(k)) &
!!!                       )*orho * (1-IFDRY)
          tten(k) = tten(k) &
                    + (     edep(k)*(pri_inu(k) + pri_ide(k) &
                                     + prs_ide(k) + prs_sde(k) &
                                     + prg_gde(k)) &
                     +      efrz(k)*(pri_wfz(k) + pri_rfz(k) &
                                     + prg_rfz(k) + prs_scw(k) &
                                     + prg_scw(k) + prg_gcw(k) &
                                     + prg_rcs(k) + prs_rcs(k) &
                                     + prr_rci(k) + prg_rcg(k)) &
                       )*orho * (1-IFDRY)
         else
!!!          tten(k) = tten(k) &
!!!                    + ( lfus*ocp(k)*(-prr_sml(k) - prr_gml(k) &
!!!                                     - prr_rcg(k) - prr_rcs(k)) &
!!!                      + lsub*ocp(k)*(prs_sde(k) + prg_gde(k)) &
!!!                       )*orho * (1-IFDRY)
          tten(k) = tten(k) &
                    + (     efrz(k)*(-prr_sml(k) - prr_gml(k) &
                                     - prr_rcg(k) - prr_rcs(k)) &
                      +     edep(k)*(prs_sde(k) + prg_gde(k)) &
                       )*orho * (1-IFDRY)
         endif

      enddo

!+---+-----------------------------------------------------------------+
!..Update variables for TAU+1 before condensation & sedimention.
!+---+-----------------------------------------------------------------+
      do k = kts, kte
         temp(k) = t1d(k) + DT*tten(k)
         otemp = 1./temp(k)
         tempc = temp(k) - 273.15
         qv(k) = MAX(1.E-10, qv1d(k) + DT*qvten(k))
         rho(k) = 0.622*pres(k)/(R*temp(k)*(qv(k)+0.622))
         rhof(k) = SQRT(RHO_NOT/rho(k))
         rhof2(k) = SQRT(rhof(k))
         qvs(k) = rslf(pres(k), temp(k))
         ssatw(k) = qv(k)/qvs(k) - 1.
         if (abs(ssatw(k)).lt. eps) ssatw(k) = 0.0
         diffu(k) = 2.11E-5*(temp(k)/273.15)**1.94 * (101325./pres(k))
         if (tempc .ge. 0.0) then
            visco(k) = (1.718+0.0049*tempc)*1.0E-5
         else
            visco(k) = (1.718+0.0049*tempc-1.2E-5*tempc*tempc)*1.0E-5
         endif
         vsc2(k) = SQRT(rho(k)/visco(k))
         lvap(k) = lvap0 + (2106.0 - 4218.0)*tempc
         tcond(k) = (5.69 + 0.0168*tempc)*1.0E-5 * 418.936
         ocp(k) = 1./(Cp*(1.+0.887*qv(k)))
         lvt2(k)=lvap(k)*lvap(k)*ocp(k)*oRv*otemp*otemp

         if ((qc1d(k) + qcten(k)*DT) .gt. R1) then
            rc(k) = (qc1d(k) + qcten(k)*DT)*rho(k)
            L_qc(k) = .true.
         else
            rc(k) = R1
            L_qc(k) = .false.
         endif

         if ((qi1d(k) + qiten(k)*DT) .gt. R1) then
            ri(k) = (qi1d(k) + qiten(k)*DT)*rho(k)
            ni(k) = MAX(R2, (ni1d(k) + niten(k)*DT)*rho(k))
            L_qi(k) = .true. 
         else
            ri(k) = R1
            ni(k) = R2
            L_qi(k) = .false.
         endif

         if ((qr1d(k) + qrten(k)*DT) .gt. R1) then
            rr(k) = (qr1d(k) + qrten(k)*DT)*rho(k)
            nr(k) = MAX(R2, (nr1d(k) + nrten(k)*DT)*rho(k))
            L_qr(k) = .true.
         else
            rr(k) = R1
            nr(k) = R2
            L_qr(k) = .false.
         endif
               
         if ((qs1d(k) + qsten(k)*DT) .gt. R1) then
            rs(k) = (qs1d(k) + qsten(k)*DT)*rho(k)
            L_qs(k) = .true.
         else
            rs(k) = R1
            L_qs(k) = .false.
         endif

         if ((qg1d(k) + qgten(k)*DT) .gt. R1) then
            rg(k) = (qg1d(k) + qgten(k)*DT)*rho(k)
            L_qg(k) = .true.
         else
            rg(k) = R1
            L_qg(k) = .false.
         endif
      enddo

!+---+-----------------------------------------------------------------+
!..With tendency-updated mixing ratios, recalculate snow moments and
!.. intercepts/slopes of graupel and rain.
!+---+-----------------------------------------------------------------+
      if (.not. iiwarm) then
      do k = kts, kte
         if (.not. L_qs(k)) CYCLE
         tc0 = MIN(-0.1, temp(k)-273.15)
         smob(k) = rs(k)*oams

!..All other moments based on reference, 2nd moment.  If bm_s.ne.2,
!.. then we must compute actual 2nd moment and use as reference.
         if (bm_s.gt.(2.0-1.e-3) .and. bm_s.lt.(2.0+1.e-3)) then
            smo2(k) = smob(k)
         else
            loga_ = sa(1) + sa(2)*tc0 + sa(3)*bm_s &
               + sa(4)*tc0*bm_s + sa(5)*tc0*tc0 &
               + sa(6)*bm_s*bm_s + sa(7)*tc0*tc0*bm_s &
               + sa(8)*tc0*bm_s*bm_s + sa(9)*tc0*tc0*tc0 &
               + sa(10)*bm_s*bm_s*bm_s
            a_ = 10.0**loga_
            b_ = sb(1) + sb(2)*tc0 + sb(3)*bm_s &
               + sb(4)*tc0*bm_s + sb(5)*tc0*tc0 &
               + sb(6)*bm_s*bm_s + sb(7)*tc0*tc0*bm_s &
               + sb(8)*tc0*bm_s*bm_s + sb(9)*tc0*tc0*tc0 &
               + sb(10)*bm_s*bm_s*bm_s
            smo2(k) = (smob(k)/a_)**(1./b_)
         endif

!..Calculate bm_s+1 (th) moment.  Useful for diameter calcs.
         loga_ = sa(1) + sa(2)*tc0 + sa(3)*cse(1) &
               + sa(4)*tc0*cse(1) + sa(5)*tc0*tc0 &
               + sa(6)*cse(1)*cse(1) + sa(7)*tc0*tc0*cse(1) &
               + sa(8)*tc0*cse(1)*cse(1) + sa(9)*tc0*tc0*tc0 &
               + sa(10)*cse(1)*cse(1)*cse(1)
         a_ = 10.0**loga_
         b_ = sb(1)+ sb(2)*tc0 + sb(3)*cse(1) + sb(4)*tc0*cse(1) &
              + sb(5)*tc0*tc0 + sb(6)*cse(1)*cse(1) &
              + sb(7)*tc0*tc0*cse(1) + sb(8)*tc0*cse(1)*cse(1) &
              + sb(9)*tc0*tc0*tc0 + sb(10)*cse(1)*cse(1)*cse(1)
         smoc(k) = a_ * smo2(k)**b_

!..Calculate bm_s+bv_s (th) moment.  Useful for sedimentation.
         loga_ = sa(1) + sa(2)*tc0 + sa(3)*cse(14) &
               + sa(4)*tc0*cse(14) + sa(5)*tc0*tc0 &
               + sa(6)*cse(14)*cse(14) + sa(7)*tc0*tc0*cse(14) &
               + sa(8)*tc0*cse(14)*cse(14) + sa(9)*tc0*tc0*tc0 &
               + sa(10)*cse(14)*cse(14)*cse(14)
         a_ = 10.0**loga_
         b_ = sb(1)+ sb(2)*tc0 + sb(3)*cse(14) + sb(4)*tc0*cse(14) &
              + sb(5)*tc0*tc0 + sb(6)*cse(14)*cse(14) &
              + sb(7)*tc0*tc0*cse(14) + sb(8)*tc0*cse(14)*cse(14) &
              + sb(9)*tc0*tc0*tc0 + sb(10)*cse(14)*cse(14)*cse(14)
         smod(k) = a_ * smo2(k)**b_
      enddo

!+---+-----------------------------------------------------------------+
!..Calculate y-intercept, slope values for graupel.
!+---+-----------------------------------------------------------------+
      N0_min = gonv_max
      do k = kte, kts, -1
         if (temp(k).lt.T_0 .and. (rc(k)+rr(k)).gt.1.E-5) then
            xslw1 = 5. + alog10(max(1.E-5, min(1.E-2, (rc(k)+rr(k)))))
         else
            xslw1 = 0.
         endif
         ygra1 = 5. + alog10(max(1.E-5, min(1.E-2, rg(k))))
         zans1 = 3.324 + (3./(5.*xslw1*ygra1/(5.*xslw1+1.+0.25*ygra1)+1.+0.25*ygra1))
         N0_exp = 10.**(zans1)
         N0_exp = MAX(DBLE(gonv_min), MIN(N0_exp, DBLE(gonv_max)))
         N0_min = MIN(N0_exp, N0_min)
         N0_exp = N0_min
         lam_exp = (N0_exp*am_g*cgg(1)/rg(k))**oge1
         lamg = lam_exp * (cgg(3)*ogg2*ogg1)**obmg
         ilamg(k) = 1./lamg
         N0_g(k) = N0_exp/(cgg(2)*lam_exp) * lamg**cge(2)
      enddo

      endif

!+---+-----------------------------------------------------------------+
!..Calculate y-intercept, slope values for rain.
!+---+-----------------------------------------------------------------+
      do k = kte, kts, -1
         lamr = (am_r*crg(3)*org2*nr(k)/rr(k))**obmr
         ilamr(k) = 1./lamr
         mvd_r(k) = (3.0 + mu_r + 0.672) / lamr
         N0_r(k) = nr(k)*org2*lamr**cre(2)
      enddo

!+---+-----------------------------------------------------------------+
!..Cloud water condensation and evaporation.  Newly formulated using
!.. Newton-Raphson iterations (3 should suffice) as provided by B. Hall.
!+---+-----------------------------------------------------------------+
      do k = kts, kte
         if ( (ssatw(k).gt. eps) .or. (ssatw(k).lt. -eps .and. &
                   L_qc(k)) ) then
!          clap = (qv(k)-qvs(k))/(1. + lvt2(k)*qvs(k))
!          do n = 1, 3
!             fcd = qvs(k)* EXP(lvt2(k)*clap) - qv(k) + clap
!             dfcd = qvs(k)*lvt2(k)* EXP(lvt2(k)*clap) + 1.
!             clap = clap - fcd/dfcd
!          enddo
!          xrc = rc(k) + clap
!          if (xrc.gt. 0.0) then
!             prw_vcd(k) = clap*odt
!          else
!             prw_vcd(k) = -rc(k)/rho(k)*odt
!          endif

          ! GHB ... moved saturation adjustment to solve
          prw_vcd(k) = 0.0

!          qcten(k) = qcten(k) + prw_vcd(k)
!          qvten(k) = qvten(k) - prw_vcd(k)
!!!          tten(k) = tten(k) + lvap(k)*ocp(k)*prw_vcd(k)*(1-IFDRY)
!          tten(k) = tten(k) + econd(k)*prw_vcd(k)*(1-IFDRY)
          rc(k) = MAX(R1, (qc1d(k) + DT*qcten(k))*rho(k))
          qv(k) = MAX(1.E-10, qv1d(k) + DT*qvten(k))
          temp(k) = t1d(k) + DT*tten(k)
          rho(k) = 0.622*pres(k)/(R*temp(k)*(qv(k)+0.622))
          qvs(k) = rslf(pres(k), temp(k))
          ssatw(k) = qv(k)/qvs(k) - 1.
         endif
      enddo

!+---+-----------------------------------------------------------------+
!.. If still subsaturated, allow rain to evaporate, following
!.. Srivastava & Coen (1992).
!+---+-----------------------------------------------------------------+
      do k = kts, kte
         if ( (ssatw(k).lt. -eps) .and. L_qr(k) &
                     .and. (.not.(prw_vcd(k).gt. 0.)) ) then
          tempc = temp(k) - 273.15
          otemp = 1./temp(k)
          rhof(k) = SQRT(RHO_NOT/rho(k))
          rhof2(k) = SQRT(rhof(k))
          diffu(k) = 2.11E-5*(temp(k)/273.15)**1.94 * (101325./pres(k))
          if (tempc .ge. 0.0) then
             visco(k) = (1.718+0.0049*tempc)*1.0E-5
          else
             visco(k) = (1.718+0.0049*tempc-1.2E-5*tempc*tempc)*1.0E-5
          endif
          vsc2(k) = SQRT(rho(k)/visco(k))
          lvap(k) = lvap0 + (2106.0 - 4218.0)*tempc
          tcond(k) = (5.69 + 0.0168*tempc)*1.0E-5 * 418.936
          ocp(k) = 1./(Cp*(1.+0.887*qv(k)))

          rvs = rho(k)*qvs(k)
          rvs_p = rvs*otemp*(lvap(k)*otemp*oRv - 1.)
          rvs_pp = rvs * ( otemp*(lvap(k)*otemp*oRv - 1.) &
                          *otemp*(lvap(k)*otemp*oRv - 1.) &
                          + (-2.*lvap(k)*otemp*otemp*otemp*oRv) &
                          + otemp*otemp)
          gamsc = lvap(k)*diffu(k)/tcond(k) * rvs_p
          alphsc = 0.5*(gamsc/(1.+gamsc))*(gamsc/(1.+gamsc)) &
                     * rvs_pp/rvs_p * rvs/rvs_p
          alphsc = MAX(1.E-9, alphsc)
          xsat   = MIN(-1.E-9, ssatw(k))
          t1_evap = 2.*PI*( 1.0 - alphsc*xsat  &
                 + 2.*alphsc*alphsc*xsat*xsat  &
                 - 5.*alphsc*alphsc*alphsc*xsat*xsat*xsat ) &
                 / (1.+gamsc)

          lamr = 1./ilamr(k)
          prv_rev(k) = t1_evap*diffu(k)*(-ssatw(k))*N0_r(k)*rvs &
              * (t1_qr_ev*ilamr(k)**cre(10) &
              + t2_qr_ev*vsc2(k)*rhof2(k)*((lamr+0.5*fv_r)**(-cre(11))))
          rate_max = MIN((rr(k)/rho(k)*odts), (qvs(k)-qv(k))*odts)
          prv_rev(k) = MIN(DBLE(rate_max), prv_rev(k)/rho(k))
          pnr_rev(k) = MIN(DBLE(nr(k)*0.99/rho(k)*odts),                &   ! RAIN2M
                       prv_rev(k) * nr(k)/rr(k))

          qrten(k) = qrten(k) - prv_rev(k)
          qvten(k) = qvten(k) + prv_rev(k)
          nrten(k) = nrten(k) - pnr_rev(k)
!!!          tten(k) = tten(k) - lvap(k)*ocp(k)*prv_rev(k)*(1-IFDRY)
          tten(k) = tten(k) - econd(k)*prv_rev(k)*(1-IFDRY)

          rr(k) = MAX(R1, (qr1d(k) + DT*qrten(k))*rho(k))
          qv(k) = MAX(1.E-10, qv1d(k) + DT*qvten(k))
          nr(k) = MAX(R2, (nr1d(k) + DT*nrten(k))*rho(k))
          temp(k) = t1d(k) + DT*tten(k)
          rho(k) = 0.622*pres(k)/(R*temp(k)*(qv(k)+0.622))
         endif

      enddo

!+---+-----------------------------------------------------------------+
!..Find max terminal fallspeed (distribution mass-weighted mean
!.. velocity) and use it to determine if we need to split the timestep
!.. (var nstep>1).  Either way, only bother to do sedimentation below
!.. 1st level that contains any sedimenting particles (k=ksed1 on down).
!.. New in v3.0+ is computing separate for rain, ice, snow, and
!.. graupel species thus making code faster with credit to J. Schmidt.
!+---+-----------------------------------------------------------------+
      nstep = 0
      onstep(:) = 1.0
      ksed1(:) = 1
      do k = kte+1, kts, -1
         vtrk(k) = 0.
         vtnrk(k) = 0.
         vtik(k) = 0.
         vtnik(k) = 0.
         vtsk(k) = 0.
         vtgk(k) = 0.
      enddo
      do k = kte, kts, -1
         vtr = 0.
         rhof(k) = SQRT(RHO_NOT/rho(k))

         if (rr(k).gt. R1) then
          lamr = (am_r*crg(3)*org2*nr(k)/rr(k))**obmr
          vtr = rhof(k)*av_r*crg(6)*org3 * lamr**cre(3)                 &
                      *((lamr+fv_r)**(-cre(6)))
          vtrk(k) = vtr
! First below is technically correct:
!         vtr = rhof(k)*av_r*crg(5)*org2 * lamr**cre(2)                 &
!                     *((lamr+fv_r)**(-cre(5)))
! Test: make number fall faster (but still slower than mass)
! Goal: less prominent size sorting
          vtr = rhof(k)*av_r*crg(7)/crg(12) * lamr**cre(12)             &
                      *((lamr+fv_r)**(-cre(7)))
          vtnrk(k) = vtr
         endif

         if (MAX(vtrk(k),vtnrk(k)) .gt. 1.E-3) then
            ksed1(1) = MAX(ksed1(1), k)
            delta_tp = dzq(k)/(MAX(vtrk(k),vtnrk(k)))
            nstep = MAX(nstep, INT(DT/delta_tp + 1.))
         endif
      enddo
      if (ksed1(1) .eq. kte) ksed1(1) = kte-1
      if (nstep .gt. 0) onstep(1) = 1./REAL(nstep)

!+---+-----------------------------------------------------------------+

      if (.not. iiwarm) then

       nstep = 0
       do k = kte, kts, -1
          vti = 0.

          if (ri(k).gt. R1) then
           lami = (am_i*cig(2)*oig1*ni(k)/ri(k))**obmi
           ilami = 1./lami
           vti = rhof(k)*av_i*cig(3)*oig2 * ilami**bv_i
           vtik(k) = vti
! First below is technically correct:
!          vti = rhof(k)*av_i*cig(4)*oig1 * ilami**bv_i
! Goal: less prominent size sorting
           vti = rhof(k)*av_i*cig(6)/cig(7) * ilami**bv_i
           vtnik(k) = vti
          endif

          if (vtik(k) .gt. 1.E-3) then
             ksed1(2) = MAX(ksed1(2), k)
             delta_tp = dzq(k)/vtik(k)
             nstep = MAX(nstep, INT(DT/delta_tp + 1.))
          endif
       enddo
       if (ksed1(2) .eq. kte) ksed1(2) = kte-1
       if (nstep .gt. 0) onstep(2) = 1./REAL(nstep)

!+---+-----------------------------------------------------------------+

       nstep = 0
       do k = kte, kts, -1
          vts = 0.

          if (rs(k).gt. R2) then
           xDs = smoc(k) / smob(k)
           Mrat = 1./xDs
           ils1 = 1./(Mrat*Lam0 + fv_s)
           ils2 = 1./(Mrat*Lam1 + fv_s)
           t1_vts = Kap0*csg(4)*ils1**cse(4)
           t2_vts = Kap1*Mrat**mu_s*csg(10)*ils2**cse(10)
           ils1 = 1./(Mrat*Lam0)
           ils2 = 1./(Mrat*Lam1)
           t3_vts = Kap0*csg(1)*ils1**cse(1)
           t4_vts = Kap1*Mrat**mu_s*csg(7)*ils2**cse(7)
           vts = rhof(k)*av_s * (t1_vts+t2_vts)/(t3_vts+t4_vts)
           if (temp(k).gt. T_0) then
            vtsk(k) = MAX(vts*vts_boost(k), vtrk(k))
           else
            vtsk(k) = vts*vts_boost(k)
           endif
          endif

          if (vtsk(k) .gt. 1.E-3) then
             ksed1(3) = MAX(ksed1(3), k)
             delta_tp = dzq(k)/vtsk(k)
             nstep = MAX(nstep, INT(DT/delta_tp + 1.))
          endif
       enddo
       if (ksed1(3) .eq. kte) ksed1(3) = kte-1
       if (nstep .gt. 0) onstep(3) = 1./REAL(nstep)

!+---+-----------------------------------------------------------------+

       nstep = 0
       do k = kte, kts, -1
          vtg = 0.

          if (rg(k).gt. R2) then
           vtg = rhof(k)*av_g*cgg(6)*ogg3 * ilamg(k)**bv_g
           if (temp(k).gt. T_0) then
            vtgk(k) = MAX(vtg, vtrk(k))
           else
            vtgk(k) = vtg
           endif
          endif

          if (vtgk(k) .gt. 1.E-3) then
             ksed1(4) = MAX(ksed1(4), k)
             delta_tp = dzq(k)/vtgk(k)
             nstep = MAX(nstep, INT(DT/delta_tp + 1.))
          endif
       enddo
       if (ksed1(4) .eq. kte) ksed1(4) = kte-1
       if (nstep .gt. 0) onstep(4) = 1./REAL(nstep)
      endif

!+---+-----------------------------------------------------------------+
!..Sedimentation of mixing ratio is the integral of v(D)*m(D)*N(D)*dD,
!.. whereas neglect m(D) term for number concentration.  Therefore,
!.. cloud ice has proper differential sedimentation.
!.. New in v3.0+ is computing separate for rain, ice, snow, and
!.. graupel species thus making code faster with credit to J. Schmidt.
!+---+-----------------------------------------------------------------+

      nstep = NINT(1./onstep(1))
      do n = 1, nstep
         do k = kte, kts, -1
            sed_r(k) = vtrk(k)*rr(k)
            sed_n(k) = vtnrk(k)*nr(k)
         enddo
         k = kte
         odzq = 1./dzq(k)
         orho = 1./rho(k)
         qrten(k) = qrten(k) - sed_r(k)*odzq*onstep(1)*orho
         nrten(k) = nrten(k) - sed_n(k)*odzq*onstep(1)*orho
         rr(k) = MAX(R1, rr(k) - sed_r(k)*odzq*DT*onstep(1))
         nr(k) = MAX(R2, nr(k) - sed_n(k)*odzq*DT*onstep(1))
         do k = ksed1(1), kts, -1
            odzq = 1./dzq(k)
            orho = 1./rho(k)
            qrten(k) = qrten(k) + (sed_r(k+1)-sed_r(k)) &
                                               *odzq*onstep(1)*orho
            nrten(k) = nrten(k) + (sed_n(k+1)-sed_n(k)) &
                                               *odzq*onstep(1)*orho
            rr(k) = MAX(R1, rr(k) + (sed_r(k+1)-sed_r(k)) &
                                           *odzq*DT*onstep(1))
            nr(k) = MAX(R2, nr(k) + (sed_n(k+1)-sed_n(k)) &
                                           *odzq*DT*onstep(1))
         enddo

         pptrain = pptrain + sed_r(kts)*DT*onstep(1)
      enddo

!+---+-----------------------------------------------------------------+

      nstep = NINT(1./onstep(2))
      do n = 1, nstep
         do k = kte, kts, -1
            sed_i(k) = vtik(k)*ri(k)
            sed_n(k) = vtnik(k)*ni(k)
         enddo
         k = kte
         odzq = 1./dzq(k)
         orho = 1./rho(k)
         qiten(k) = qiten(k) - sed_i(k)*odzq*onstep(2)*orho
         niten(k) = niten(k) - sed_n(k)*odzq*onstep(2)*orho
         ri(k) = MAX(R1, ri(k) - sed_i(k)*odzq*DT*onstep(2))
         ni(k) = MAX(R2, ni(k) - sed_n(k)*odzq*DT*onstep(2))
         do k = ksed1(2), kts, -1
            odzq = 1./dzq(k)
            orho = 1./rho(k)
            qiten(k) = qiten(k) + (sed_i(k+1)-sed_i(k)) &
                                               *odzq*onstep(2)*orho
            niten(k) = niten(k) + (sed_n(k+1)-sed_n(k)) &
                                               *odzq*onstep(2)*orho
            ri(k) = MAX(R1, ri(k) + (sed_i(k+1)-sed_i(k)) &
                                           *odzq*DT*onstep(2))
            ni(k) = MAX(R2, ni(k) + (sed_n(k+1)-sed_n(k)) &
                                           *odzq*DT*onstep(2))
         enddo

         pptice = pptice + sed_i(kts)*DT*onstep(2)
      enddo

!+---+-----------------------------------------------------------------+

      nstep = NINT(1./onstep(3))
      do n = 1, nstep
         do k = kte, kts, -1
            sed_s(k) = vtsk(k)*rs(k)
         enddo
         k = kte
         odzq = 1./dzq(k)
         orho = 1./rho(k)
         qsten(k) = qsten(k) - sed_s(k)*odzq*onstep(3)*orho
         rs(k) = MAX(R1, rs(k) - sed_s(k)*odzq*DT*onstep(3))
         do k = ksed1(3), kts, -1
            odzq = 1./dzq(k)
            orho = 1./rho(k)
            qsten(k) = qsten(k) + (sed_s(k+1)-sed_s(k)) &
                                               *odzq*onstep(3)*orho
            rs(k) = MAX(R1, rs(k) + (sed_s(k+1)-sed_s(k)) &
                                           *odzq*DT*onstep(3))
         enddo

         pptsnow = pptsnow + sed_s(kts)*DT*onstep(3)
      enddo

!+---+-----------------------------------------------------------------+

      nstep = NINT(1./onstep(4))
      do n = 1, nstep
         do k = kte, kts, -1
            sed_g(k) = vtgk(k)*rg(k)
         enddo
         k = kte
         odzq = 1./dzq(k)
         orho = 1./rho(k)
         qgten(k) = qgten(k) - sed_g(k)*odzq*onstep(4)*orho
         rg(k) = MAX(R1, rg(k) - sed_g(k)*odzq*DT*onstep(4))
         do k = ksed1(4), kts, -1
            odzq = 1./dzq(k)
            orho = 1./rho(k)
            qgten(k) = qgten(k) + (sed_g(k+1)-sed_g(k)) &
                                               *odzq*onstep(4)*orho
            rg(k) = MAX(R1, rg(k) + (sed_g(k+1)-sed_g(k)) &
                                           *odzq*DT*onstep(4))
         enddo

         pptgraul = pptgraul + sed_g(kts)*DT*onstep(4)
      enddo

!+---+-----------------------------------------------------------------+
!.. Instantly melt any cloud ice into cloud water if above 0C and
!.. instantly freeze any cloud water found below HGFR.
!+---+-----------------------------------------------------------------+
      if (.not. iiwarm) then
      do k = kts, kte
         xri = MAX(0.0, qi1d(k) + qiten(k)*DT)
         if ( (temp(k).gt. T_0) .and. (xri.gt. 0.0) ) then
          qcten(k) = qcten(k) + xri*odt
          qiten(k) = qiten(k) - xri*odt
          niten(k) = -ni1d(k)*odt
!!!          tten(k) = tten(k) - lfus*ocp(k)*xri*odt*(1-IFDRY)
          tten(k) = tten(k) - efrz(k)*xri*odt*(1-IFDRY)
         endif

         xrc = MAX(0.0, qc1d(k) + qcten(k)*DT)
         if ( (temp(k).lt. HGFR) .and. (xrc.gt. 0.0) ) then
          lfus2 = lsub - lvap(k)
          qiten(k) = qiten(k) + xrc*odt
          niten(k) = niten(k) + xrc/xm0i * odt
          qcten(k) = qcten(k) - xrc*odt
!!!          tten(k) = tten(k) + lfus2*ocp(k)*xrc*odt*(1-IFDRY)
          tten(k) = tten(k) + efrz(k)*xrc*odt*(1-IFDRY)
         endif
      enddo
      endif

!+---+-----------------------------------------------------------------+
!.. All tendencies computed, apply and pass back final values to parent.
!+---+-----------------------------------------------------------------+
      do k = kts, kte
         t1d(k)  = t1d(k) + tten(k)*DT
         qv1d(k) = MAX(1.E-10, qv1d(k) + qvten(k)*DT)
         qc1d(k) = qc1d(k) + qcten(k)*DT
         if (qc1d(k) .le. R1) qc1d(k) = 0.0
         qi1d(k) = qi1d(k) + qiten(k)*DT
         ni1d(k) = ni1d(k) + niten(k)*DT
         if (qi1d(k) .le. R1) then
           qi1d(k) = 0.0
           ni1d(k) = 0.0
         else
           if (ni1d(k) .gt. R2) then
            lami = (am_i*cig(2)*oig1*ni1d(k)/qi1d(k))**obmi
            ilami = 1./lami
            xDi = (bm_i + mu_i + 1.) * ilami
            if (xDi.lt. 20.E-6) then
             lami = cie(2)/20.E-6
            elseif (xDi.gt. 300.E-6) then
             lami = cie(2)/300.E-6
            endif
           else
            lami = cie(2)/D0s
           endif
           ni1d(k) = MIN(cig(1)*oig2*qi1d(k)/am_i*lami**bm_i,           &
                         500.D3/rho(k))
         endif
         qr1d(k) = qr1d(k) + qrten(k)*DT
         nr1d(k) = nr1d(k) + nrten(k)*DT
         if (qr1d(k) .le. R1) then
           qr1d(k) = 0.0
           nr1d(k) = 0.0
         else
           if (nr1d(k) .gt. R2) then
            lamr = (am_r*crg(3)*org2*nr1d(k)/qr1d(k))**obmr
            mvd_r(k) = (3.0 + mu_r + 0.672) / lamr
            if (mvd_r(k) .gt. 2.5E-3) then
               mvd_r(k) = 2.5E-3
            elseif (mvd_r(k) .lt. D0r*0.75) then
               mvd_r(k) = D0r*0.75
            endif
           else
            if (qr1d(k) .gt. R2) then
               mvd_r(k) = 2.5E-3
            else
               mvd_r(k) = 2.5E-3 / 3.0**(ALOG10(R2)-ALOG10(qr1d(k)))
            endif
           endif
           lamr = (3.0 + mu_r + 0.672) / mvd_r(k)
           nr1d(k) = crg(2)*org3*qr1d(k)*lamr**bm_r / am_r
         endif
         qs1d(k) = qs1d(k) + qsten(k)*DT
         if (qs1d(k) .le. R1) qs1d(k) = 0.0
         qg1d(k) = qg1d(k) + qgten(k)*DT
         if (qg1d(k) .le. R1) qg1d(k) = 0.0
      enddo

      end subroutine mp_thompson
!+---+-----------------------------------------------------------------+
!+---+-----------------------------------------------------------------+
!
      subroutine radar_init

      IMPLICIT NONE
      INTEGER:: n
      PI5 = PI*PI*PI*PI*PI
      lamda4 = lamda_radar*lamda_radar*lamda_radar*lamda_radar
      m_w_0 = m_complex_water_ray (lamda_radar, 0.0d0)
      m_i_0 = m_complex_ice_maetzler (lamda_radar, 0.0d0)
      K_w = (ABS( (m_w_0*m_w_0 - 1.0) /(m_w_0*m_w_0 + 2.0) ))**2

      do n = 1, nbins+1
         simpson(n) = 0.0d0
      enddo
      do n = 1, nbins-1, 2
         simpson(n) = simpson(n) + basis(1)
         simpson(n+1) = simpson(n+1) + basis(2)
         simpson(n+2) = simpson(n+2) + basis(3)
      enddo

      do n = 1, slen
         mixingrulestring_s(n:n) = char(0)
         matrixstring_s(n:n) = char(0)
         inclusionstring_s(n:n) = char(0)
         hoststring_s(n:n) = char(0)
         hostmatrixstring_s(n:n) = char(0)
         hostinclusionstring_s(n:n) = char(0)
         mixingrulestring_g(n:n) = char(0)
         matrixstring_g(n:n) = char(0)
         inclusionstring_g(n:n) = char(0)
         hoststring_g(n:n) = char(0)
         hostmatrixstring_g(n:n) = char(0)
         hostinclusionstring_g(n:n) = char(0)
      enddo

      mixingrulestring_s = 'maxwellgarnett'
      hoststring_s = 'air'
      matrixstring_s = 'water'
      inclusionstring_s = 'spheroidal'
      hostmatrixstring_s = 'icewater'
      hostinclusionstring_s = 'spheroidal'

      mixingrulestring_g = 'maxwellgarnett'
      hoststring_g = 'air'
      matrixstring_g = 'water'
      inclusionstring_g = 'spheroidal'
      hostmatrixstring_g = 'icewater'
      hostinclusionstring_g = 'spheroidal'

      end subroutine radar_init

!+---+-----------------------------------------------------------------+
!..Compute radar reflectivity assuming 10 cm wavelength radar and using
!.. Rayleigh approximation.  Only complication is melted snow/graupel
!.. which we treat as water-coated ice spheres and use Uli Blahak's
!.. library of routines.  The meltwater fraction is simply the amount
!.. of frozen species remaining from what initially existed at the
!.. melting level interface.
!+---+-----------------------------------------------------------------+
      subroutine calc_refl10cm (qv1d, qr1d, nr1d, qs1d, qg1d, t1d, p1d, &
                          dBZ, kts, kte, ii, jj)

      IMPLICIT NONE

!..Sub arguments
      INTEGER, INTENT(IN):: kts, kte, ii, jj
      REAL, DIMENSION(kts:kte), INTENT(IN)::                            &
                          qv1d, qr1d, nr1d, qs1d, qg1d, t1d, p1d
      REAL, DIMENSION(kts:kte), INTENT(INOUT):: dBZ

!..Local variables
      REAL, DIMENSION(kts:kte):: temp, pres, qv, rho
      REAL, DIMENSION(kts:kte):: rr, nr, rs, rg

      DOUBLE PRECISION, DIMENSION(kts:kte):: ilamr, ilamg, N0_r, N0_g
      REAL, DIMENSION(kts:kte):: mvd_r
      REAL, DIMENSION(kts:kte):: smob, smo2, smoc, smoz
      REAL:: oM3, M0, Mrat, slam1, slam2

      REAL, DIMENSION(kts:kte):: ze_rain, ze_snow, ze_graupel

      DOUBLE PRECISION:: N0_exp, N0_min, lam_exp, lamr, lamg
      REAL:: a_, b_, loga_, tc0
      DOUBLE PRECISION:: fmelt_s, fmelt_g

      INTEGER:: i, k, k_0, kbot, n
      LOGICAL:: melti
      LOGICAL, DIMENSION(kts:kte):: L_qr, L_qs, L_qg

!..Single melting snow/graupel particle 70% meltwater on external sfc
      DOUBLE PRECISION, PARAMETER:: melt_outside_s = 0.7d0
      DOUBLE PRECISION, PARAMETER:: melt_outside_g = 0.7d0

      DOUBLE PRECISION:: cback, x, eta, f_d

!+---+

      do k = kts, kte
         dBZ(k) = -35.0
      enddo

!+---+-----------------------------------------------------------------+
!..Put column of data into local arrays.
!+---+-----------------------------------------------------------------+
      do k = kts, kte
         temp(k) = t1d(k)
         qv(k) = MAX(1.E-10, qv1d(k))
         pres(k) = p1d(k)
         rho(k) = 0.622*pres(k)/(R*temp(k)*(qv(k)+0.622))
         if (qr1d(k) .gt. R2) then
            rr(k) = qr1d(k)*rho(k)
            nr(k) = nr1d(k)*rho(k)
            lamr = (am_r*crg(3)*org2*nr(k)/rr(k))**obmr
            ilamr(k) = 1./lamr
            mvd_r(k) = (3.0 + mu_r + 0.672) * ilamr(k)
            if (mvd_r(k) .gt. 2.5E-3) then
               mvd_r(k) = 2.5E-3
               lamr = (3.0 + mu_r + 0.672) / mvd_r(k)
            elseif (mvd_r(k) .lt. D0r*0.75) then
               mvd_r(k) = D0r*0.75
               lamr = (3.0 + mu_r + 0.672) / mvd_r(k)
            endif
            ilamr(k) = 1./lamr
            N0_r(k) = nr(k)*org2*lamr**cre(2)
            L_qr(k) = .true.
         else
            rr(k) = R1
            nr(k) = 1.0
            L_qr(k) = .false.
         endif
         if (qs1d(k) .gt. R2) then
            rs(k) = qs1d(k)*rho(k)
            L_qs(k) = .true.
         else
            rs(k) = R1
            L_qs(k) = .false.
         endif
         if (qg1d(k) .gt. R2) then
            rg(k) = qg1d(k)*rho(k)
            L_qg(k) = .true.
         else
            rg(k) = R1
            L_qg(k) = .false.
         endif
      enddo

!+---+-----------------------------------------------------------------+
!..Calculate y-intercept, slope, and useful moments for snow.
!+---+-----------------------------------------------------------------+
      do k = kts, kte
         tc0 = MIN(-0.1, temp(k)-273.15)
         smob(k) = rs(k)*oams

!..All other moments based on reference, 2nd moment.  If bm_s.ne.2,
!.. then we must compute actual 2nd moment and use as reference.
         if (bm_s.gt.(2.0-1.e-3) .and. bm_s.lt.(2.0+1.e-3)) then
            smo2(k) = smob(k)
         else
            loga_ = sa(1) + sa(2)*tc0 + sa(3)*bm_s &
               + sa(4)*tc0*bm_s + sa(5)*tc0*tc0 &
               + sa(6)*bm_s*bm_s + sa(7)*tc0*tc0*bm_s &
               + sa(8)*tc0*bm_s*bm_s + sa(9)*tc0*tc0*tc0 &
               + sa(10)*bm_s*bm_s*bm_s
            a_ = 10.0**loga_
            b_ = sb(1) + sb(2)*tc0 + sb(3)*bm_s &
               + sb(4)*tc0*bm_s + sb(5)*tc0*tc0 &
               + sb(6)*bm_s*bm_s + sb(7)*tc0*tc0*bm_s &
               + sb(8)*tc0*bm_s*bm_s + sb(9)*tc0*tc0*tc0 &
               + sb(10)*bm_s*bm_s*bm_s
            smo2(k) = (smob(k)/a_)**(1./b_)
         endif

!..Calculate bm_s+1 (th) moment.  Useful for diameter calcs.
         loga_ = sa(1) + sa(2)*tc0 + sa(3)*cse(1) &
               + sa(4)*tc0*cse(1) + sa(5)*tc0*tc0 &
               + sa(6)*cse(1)*cse(1) + sa(7)*tc0*tc0*cse(1) &
               + sa(8)*tc0*cse(1)*cse(1) + sa(9)*tc0*tc0*tc0 &
               + sa(10)*cse(1)*cse(1)*cse(1)
         a_ = 10.0**loga_
         b_ = sb(1)+ sb(2)*tc0 + sb(3)*cse(1) + sb(4)*tc0*cse(1) &
              + sb(5)*tc0*tc0 + sb(6)*cse(1)*cse(1) &
              + sb(7)*tc0*tc0*cse(1) + sb(8)*tc0*cse(1)*cse(1) &
              + sb(9)*tc0*tc0*tc0 + sb(10)*cse(1)*cse(1)*cse(1)
         smoc(k) = a_ * smo2(k)**b_

!..Calculate bm_s*2 (th) moment.  Useful for reflectivity.
         loga_ = sa(1) + sa(2)*tc0 + sa(3)*cse(3) &
               + sa(4)*tc0*cse(3) + sa(5)*tc0*tc0 &
               + sa(6)*cse(3)*cse(3) + sa(7)*tc0*tc0*cse(3) &
               + sa(8)*tc0*cse(3)*cse(3) + sa(9)*tc0*tc0*tc0 &
               + sa(10)*cse(3)*cse(3)*cse(3)
         a_ = 10.0**loga_
         b_ = sb(1)+ sb(2)*tc0 + sb(3)*cse(3) + sb(4)*tc0*cse(3) &
              + sb(5)*tc0*tc0 + sb(6)*cse(3)*cse(3) &
              + sb(7)*tc0*tc0*cse(3) + sb(8)*tc0*cse(3)*cse(3) &
              + sb(9)*tc0*tc0*tc0 + sb(10)*cse(3)*cse(3)*cse(3)
         smoz(k) = a_ * smo2(k)**b_
      enddo

!+---+-----------------------------------------------------------------+
!..Calculate y-intercept, slope values for graupel.
!+---+-----------------------------------------------------------------+
      N0_min = gonv_max
      do k = kte, kts, -1
!-GT     N0_exp = 200.0*rho(k)/rg(k)
!-GT     N0_exp = MAX(DBLE(gonv_min), MIN(N0_exp, DBLE(gonv_max)))
         N0_exp = (gonv_max-gonv_min)*0.5D0                             &
                * tanh((0.15E-3-rg(k))/0.15E-3)                         &
                + (gonv_max+gonv_min)*0.5D0
         N0_min = MIN(N0_exp, N0_min)
         N0_exp = N0_min
         lam_exp = (N0_exp*am_g*cgg(1)/rg(k))**oge1
         lamg = lam_exp * (cgg(3)*ogg2*ogg1)**obmg
         ilamg(k) = 1./lamg
         N0_g(k) = N0_exp/(cgg(2)*lam_exp) * lamg**cge(2)
      enddo

!+---+-----------------------------------------------------------------+
!..Locate K-level of start of melting (k_0 is level above).
!+---+-----------------------------------------------------------------+
      melti = .false.
      k_0 = kts
      do k = kte-1, kts, -1
         if ( (temp(k).gt. T_0) .and. (rr(k).gt. 0.001e-3) &
                   .and. ((rs(k+1)+rg(k+1)).gt. 0.01e-3) ) then
            k_0 = MAX(k+1, k_0)
            melti=.true.
            goto 195
         endif
      enddo
 195  continue

!+---+-----------------------------------------------------------------+
!..Assume Rayleigh approximation at 10 cm wavelength. Rain (all temps)
!.. and non-water-coated snow and graupel when below freezing are
!.. simple. Integrations of m(D)*m(D)*N(D)*dD.
!+---+-----------------------------------------------------------------+

      do k = kts, kte
         ze_rain(k) = 1.e-22
         ze_snow(k) = 1.e-22
         ze_graupel(k) = 1.e-22
         if (L_qr(k)) ze_rain(k) = N0_r(k)*crg(4)*ilamr(k)**cre(4)
         if (L_qs(k)) ze_snow(k) = (0.176/0.93) * (6.0/PI)*(6.0/PI)     &
                                 * (am_s/rho_i)*(am_s/rho_i)*smoz(k)
         if (L_qg(k)) ze_graupel(k) = (0.176/0.93) * (6.0/PI)*(6.0/PI)  &
                                    * (am_g/rho_i)*(am_g/rho_i)         &
                                    * N0_g(k)*cgg(4)*ilamg(k)**cge(4)
      enddo

!+---+-----------------------------------------------------------------+
!..Special case of melting ice (snow/graupel) particles.  Assume the
!.. ice is surrounded by the liquid water.  Fraction of meltwater is
!.. extremely simple based on amount found above the melting level.
!.. Uses code from Uli Blahak (rayleigh_soak_wetgraupel and supporting
!.. routines).
!+---+-----------------------------------------------------------------+

      if (.not. iiwarm .and. melti .and. k_0.ge.2) then
       do k = k_0-1, 1, -1

!..Reflectivity contributed by melting snow
          fmelt_s = MAX(0.05d0, MIN(1.0d0-rs(k)/rs(k_0), 0.99d0))
          if (fmelt_s.gt.0.01d0 .and. fmelt_s.lt.0.999d0 .and.          &
                         L_qs(k)) then
           eta = 0.d0
           oM3 = 1./smoc(k)
           M0 = (smob(k)*oM3)
           Mrat = smob(k)*M0*M0*M0
           slam1 = M0 * Lam0
           slam2 = M0 * Lam1
           do n = 1, nbs
              x = am_s * Ds(n)**bm_s
              call rayleigh_soak_wetgraupel (x, DBLE(ocms), DBLE(obms), &
                    fmelt_s, melt_outside_s, m_w_0, m_i_0, lamda_radar, &
                    CBACK, mixingrulestring_s, matrixstring_s,          &
                    inclusionstring_s, hoststring_s,                    &
                    hostmatrixstring_s, hostinclusionstring_s)
              f_d = Mrat*(Kap0*DEXP(-slam1*Ds(n))                       &
                    + Kap1*(M0*Ds(n))**mu_s * DEXP(-slam2*Ds(n)))
              eta = eta + f_d * CBACK * simpson(n) * dts(n)
           enddo
           ze_snow(k) = SNGL(lamda4 / (pi5 * K_w) * eta)
          endif


!..Reflectivity contributed by melting graupel

          fmelt_g = MAX(0.05d0, MIN(1.0d0-rg(k)/rg(k_0), 0.99d0))
          if (fmelt_g.gt.0.01d0 .and. fmelt_g.lt.0.999d0 .and.          &
                         L_qg(k)) then
           eta = 0.d0
           lamg = 1./ilamg(k)
           do n = 1, nbg
              x = am_g * Dg(n)**bm_g
              call rayleigh_soak_wetgraupel (x, DBLE(ocmg), DBLE(obmg), &
                    fmelt_g, melt_outside_g, m_w_0, m_i_0, lamda_radar, &
                    CBACK, mixingrulestring_g, matrixstring_g,          &
                    inclusionstring_g, hoststring_g,                    &
                    hostmatrixstring_g, hostinclusionstring_g)
              f_d = N0_g(k)*Dg(n)**mu_g * DEXP(-lamg*Dg(n))
              eta = eta + f_d * CBACK * simpson(n) * dtg(n)
           enddo
           ze_graupel(k) = SNGL(lamda4 / (pi5 * K_w) * eta)
          endif

       enddo
      endif

      do k = kte, kts, -1
         dBZ(k) = 10.*log10((ze_rain(k)+ze_snow(k)+ze_graupel(k))*1.d18)
      enddo


      end subroutine calc_refl10cm
!+---+-----------------------------------------------------------------+
!+---+-----------------------------------------------------------------+
!ctrlL
!+---+-----------------------------------------------------------------+
!..Creation of the lookup tables and support functions found below here.
!+---+-----------------------------------------------------------------+
!..Rain collecting graupel (and inverse).  Explicit CE integration.
!+---+-----------------------------------------------------------------+

      subroutine qr_acr_qg

      implicit none

!..Local variables
      INTEGER:: i, j, k, m, n, n2
      INTEGER:: km, km_s, km_e
      DOUBLE PRECISION, DIMENSION(nbg):: vg, N_g
      DOUBLE PRECISION, DIMENSION(nbr):: vr, N_r
      DOUBLE PRECISION:: N0_r, N0_g, lam_exp, lamg, lamr
      DOUBLE PRECISION:: massg, massr, dvg, dvr, t1, t2, z1, z2, y1, y2

!+---+

      do n2 = 1, nbr
!        vr(n2) = av_r*Dr(n2)**bv_r * DEXP(-fv_r*Dr(n2))
         vr(n2) = -0.1021 + 4.932E3*Dr(n2) - 0.9551E6*Dr(n2)*Dr(n2)     &
              + 0.07934E9*Dr(n2)*Dr(n2)*Dr(n2)                          &
              - 0.002362E12*Dr(n2)*Dr(n2)*Dr(n2)*Dr(n2)
      enddo
      do n = 1, nbg
         vg(n) = av_g*Dg(n)**bv_g
      enddo

!..Note values returned from wrf_dm_decomp1d are zero-based, add 1 for
!.. fortran indices.  J. Michalakes, 2009Oct30.

#if ( defined( DM_PARALLEL ) && ( ! defined( STUBMPI ) ) )
      CALL wrf_dm_decomp1d ( ntb_r*ntb_r1, km_s, km_e )
#else
      km_s = 0
      km_e = ntb_r*ntb_r1 - 1
#endif

      do km = km_s, km_e
         m = km / ntb_r1 + 1
         k = mod( km , ntb_r1 ) + 1

         lam_exp = (N0r_exp(k)*am_r*crg(1)/r_r(m))**ore1
         lamr = lam_exp * (crg(3)*org2*org1)**obmr
         N0_r = N0r_exp(k)/(crg(2)*lam_exp) * lamr**cre(2)
         do n2 = 1, nbr
            N_r(n2) = N0_r*Dr(n2)**mu_r *DEXP(-lamr*Dr(n2))*dtr(n2)
         enddo

         do j = 1, ntb_g
         do i = 1, ntb_g1
            lam_exp = (N0g_exp(i)*am_g*cgg(1)/r_g(j))**oge1
            lamg = lam_exp * (cgg(3)*ogg2*ogg1)**obmg
            N0_g = N0g_exp(i)/(cgg(2)*lam_exp) * lamg**cge(2)
            do n = 1, nbg
               N_g(n) = N0_g*Dg(n)**mu_g * DEXP(-lamg*Dg(n))*dtg(n)
            enddo

            t1 = 0.0d0
            t2 = 0.0d0
            z1 = 0.0d0
            z2 = 0.0d0
            y1 = 0.0d0
            y2 = 0.0d0
            do n2 = 1, nbr
               massr = am_r * Dr(n2)**bm_r
               do n = 1, nbg
                  massg = am_g * Dg(n)**bm_g

                  dvg = 0.5d0*((vr(n2) - vg(n)) + DABS(vr(n2)-vg(n)))
                  dvr = 0.5d0*((vg(n) - vr(n2)) + DABS(vg(n)-vr(n2)))

                  t1 = t1+ PI*.25*Ef_rg*(Dg(n)+Dr(n2))*(Dg(n)+Dr(n2)) &
                      *dvg*massg * N_g(n)* N_r(n2)
                  z1 = z1+ PI*.25*Ef_rg*(Dg(n)+Dr(n2))*(Dg(n)+Dr(n2)) &
                      *dvg*massr * N_g(n)* N_r(n2)
                  y1 = y1+ PI*.25*Ef_rg*(Dg(n)+Dr(n2))*(Dg(n)+Dr(n2)) &
                      *dvg       * N_g(n)* N_r(n2)

                  t2 = t2+ PI*.25*Ef_rg*(Dg(n)+Dr(n2))*(Dg(n)+Dr(n2)) &
                      *dvr*massr * N_g(n)* N_r(n2)
                  y2 = y2+ PI*.25*Ef_rg*(Dg(n)+Dr(n2))*(Dg(n)+Dr(n2)) &
                      *dvr       * N_g(n)* N_r(n2)
                  z2 = z2+ PI*.25*Ef_rg*(Dg(n)+Dr(n2))*(Dg(n)+Dr(n2)) &
                      *dvr*massg * N_g(n)* N_r(n2)
               enddo
 97            continue
            enddo
            tcg_racg(i,j,k,m) = t1
            tmr_racg(i,j,k,m) = DMIN1(z1, r_r(m)*1.0d0)
            tcr_gacr(i,j,k,m) = t2
            tmg_gacr(i,j,k,m) = z2
            tnr_racg(i,j,k,m) = y1
            tnr_gacr(i,j,k,m) = y2
         enddo
         enddo
      enddo

!..Note wrf_dm_gatherv expects zero-based km_s, km_e (J. Michalakes, 2009Oct30).

#if ( defined( DM_PARALLEL ) && ( ! defined( STUBMPI ) ) )
      CALL wrf_dm_gatherv(tcg_racg, ntb_g*ntb_g1, km_s, km_e, R8SIZE)
      CALL wrf_dm_gatherv(tmr_racg, ntb_g*ntb_g1, km_s, km_e, R8SIZE)
      CALL wrf_dm_gatherv(tcr_gacr, ntb_g*ntb_g1, km_s, km_e, R8SIZE)
      CALL wrf_dm_gatherv(tmg_gacr, ntb_g*ntb_g1, km_s, km_e, R8SIZE)
      CALL wrf_dm_gatherv(tnr_racg, ntb_g*ntb_g1, km_s, km_e, R8SIZE)
      CALL wrf_dm_gatherv(tnr_gacr, ntb_g*ntb_g1, km_s, km_e, R8SIZE)
#endif


      end subroutine qr_acr_qg
!+---+-----------------------------------------------------------------+
!ctrlL
!+---+-----------------------------------------------------------------+
!..Rain collecting snow (and inverse).  Explicit CE integration.
!+---+-----------------------------------------------------------------+

      subroutine qr_acr_qs

      implicit none

!..Local variables
      INTEGER:: i, j, k, m, n, n2
      INTEGER:: km, km_s, km_e
      DOUBLE PRECISION, DIMENSION(nbr):: vr, D1, N_r
      DOUBLE PRECISION, DIMENSION(nbs):: vs, N_s
      DOUBLE PRECISION:: loga_, a_, b_, second, M0, M2, M3, Mrat, oM3
      DOUBLE PRECISION:: N0_r, lam_exp, lamr, slam1, slam2
      DOUBLE PRECISION:: dvs, dvr, masss, massr
      DOUBLE PRECISION:: t1, t2, t3, t4, z1, z2, z3, z4
      DOUBLE PRECISION:: y1, y2, y3, y4

!+---+

      do n2 = 1, nbr
!        vr(n2) = av_r*Dr(n2)**bv_r * DEXP(-fv_r*Dr(n2))
         vr(n2) = -0.1021 + 4.932E3*Dr(n2) - 0.9551E6*Dr(n2)*Dr(n2)     &
              + 0.07934E9*Dr(n2)*Dr(n2)*Dr(n2)                          &
              - 0.002362E12*Dr(n2)*Dr(n2)*Dr(n2)*Dr(n2)
         D1(n2) = (vr(n2)/av_s)**(1./bv_s)
      enddo
      do n = 1, nbs
         vs(n) = 1.5*av_s*Ds(n)**bv_s * DEXP(-fv_s*Ds(n))
      enddo

!..Note values returned from wrf_dm_decomp1d are zero-based, add 1 for
!.. fortran indices.  J. Michalakes, 2009Oct30.

#if ( defined( DM_PARALLEL ) && ( ! defined( STUBMPI ) ) )
      CALL wrf_dm_decomp1d ( ntb_r*ntb_r1, km_s, km_e )
#else
      km_s = 0
      km_e = ntb_r*ntb_r1 - 1
#endif

      do km = km_s, km_e
         m = km / ntb_r1 + 1
         k = mod( km , ntb_r1 ) + 1

         lam_exp = (N0r_exp(k)*am_r*crg(1)/r_r(m))**ore1
         lamr = lam_exp * (crg(3)*org2*org1)**obmr
         N0_r = N0r_exp(k)/(crg(2)*lam_exp) * lamr**cre(2)
         do n2 = 1, nbr
            N_r(n2) = N0_r*Dr(n2)**mu_r * DEXP(-lamr*Dr(n2))*dtr(n2)
         enddo

         do j = 1, ntb_t
            do i = 1, ntb_s

!..From the bm_s moment, compute plus one moment.  If we are not
!.. using bm_s=2, then we must transform to the pure 2nd moment
!.. (variable called "second") and then to the bm_s+1 moment.

               M2 = r_s(i)*oams *1.0d0
               if (bm_s.gt.2.0-1.E-3 .and. bm_s.lt.2.0+1.E-3) then
                  loga_ = sa(1) + sa(2)*Tc(j) + sa(3)*bm_s &
                     + sa(4)*Tc(j)*bm_s + sa(5)*Tc(j)*Tc(j) &
                     + sa(6)*bm_s*bm_s + sa(7)*Tc(j)*Tc(j)*bm_s &
                     + sa(8)*Tc(j)*bm_s*bm_s + sa(9)*Tc(j)*Tc(j)*Tc(j) &
                     + sa(10)*bm_s*bm_s*bm_s
                  a_ = 10.0**loga_
                  b_ = sb(1) + sb(2)*Tc(j) + sb(3)*bm_s &
                     + sb(4)*Tc(j)*bm_s + sb(5)*Tc(j)*Tc(j) &
                     + sb(6)*bm_s*bm_s + sb(7)*Tc(j)*Tc(j)*bm_s &
                     + sb(8)*Tc(j)*bm_s*bm_s + sb(9)*Tc(j)*Tc(j)*Tc(j) &
                     + sb(10)*bm_s*bm_s*bm_s
                  second = (M2/a_)**(1./b_)
               else
                  second = M2
               endif

               loga_ = sa(1) + sa(2)*Tc(j) + sa(3)*cse(1) &
                  + sa(4)*Tc(j)*cse(1) + sa(5)*Tc(j)*Tc(j) &
                  + sa(6)*cse(1)*cse(1) + sa(7)*Tc(j)*Tc(j)*cse(1) &
                  + sa(8)*Tc(j)*cse(1)*cse(1) + sa(9)*Tc(j)*Tc(j)*Tc(j) &
                  + sa(10)*cse(1)*cse(1)*cse(1)
               a_ = 10.0**loga_
               b_ = sb(1)+sb(2)*Tc(j)+sb(3)*cse(1) + sb(4)*Tc(j)*cse(1) &
                  + sb(5)*Tc(j)*Tc(j) + sb(6)*cse(1)*cse(1) &
                  + sb(7)*Tc(j)*Tc(j)*cse(1) + sb(8)*Tc(j)*cse(1)*cse(1) &
                  + sb(9)*Tc(j)*Tc(j)*Tc(j)+sb(10)*cse(1)*cse(1)*cse(1)
               M3 = a_ * second**b_

               oM3 = 1./M3
               Mrat = M2*(M2*oM3)*(M2*oM3)*(M2*oM3)
               M0   = (M2*oM3)**mu_s
               slam1 = M2 * oM3 * Lam0
               slam2 = M2 * oM3 * Lam1

               do n = 1, nbs
                  N_s(n) = Mrat*(Kap0*DEXP(-slam1*Ds(n)) &
                      + Kap1*M0*Ds(n)**mu_s * DEXP(-slam2*Ds(n)))*dts(n)
               enddo

               t1 = 0.0d0
               t2 = 0.0d0
               t3 = 0.0d0
               t4 = 0.0d0
               z1 = 0.0d0
               z2 = 0.0d0
               z3 = 0.0d0
               z4 = 0.0d0
               y1 = 0.0d0
               y2 = 0.0d0
               y3 = 0.0d0
               y4 = 0.0d0
               do n2 = 1, nbr
                  massr = am_r * Dr(n2)**bm_r
                  do n = 1, nbs
                     masss = am_s * Ds(n)**bm_s
      
                     dvs = 0.5d0*((vr(n2) - vs(n)) + DABS(vr(n2)-vs(n)))
                     dvr = 0.5d0*((vs(n) - vr(n2)) + DABS(vs(n)-vr(n2)))

                     if (massr .gt. 2.5*masss) then
                     t1 = t1+ PI*.25*Ef_rs*(Ds(n)+Dr(n2))*(Ds(n)+Dr(n2)) &
                         *dvs*masss * N_s(n)* N_r(n2)
                     z1 = z1+ PI*.25*Ef_rs*(Ds(n)+Dr(n2))*(Ds(n)+Dr(n2)) &
                         *dvs*massr * N_s(n)* N_r(n2)
                     y1 = y1+ PI*.25*Ef_rs*(Ds(n)+Dr(n2))*(Ds(n)+Dr(n2)) &
                         *dvs       * N_s(n)* N_r(n2)
                     else
                     t3 = t3+ PI*.25*Ef_rs*(Ds(n)+Dr(n2))*(Ds(n)+Dr(n2)) &
                         *dvs*masss * N_s(n)* N_r(n2)
                     z3 = z3+ PI*.25*Ef_rs*(Ds(n)+Dr(n2))*(Ds(n)+Dr(n2)) &
                         *dvs*massr * N_s(n)* N_r(n2)
                     y3 = y3+ PI*.25*Ef_rs*(Ds(n)+Dr(n2))*(Ds(n)+Dr(n2)) &
                         *dvs       * N_s(n)* N_r(n2)
                     endif

                     if (massr .gt. 2.5*masss) then
                     t2 = t2+ PI*.25*Ef_rs*(Ds(n)+Dr(n2))*(Ds(n)+Dr(n2)) &
                         *dvr*massr * N_s(n)* N_r(n2)
                     y2 = y2+ PI*.25*Ef_rs*(Ds(n)+Dr(n2))*(Ds(n)+Dr(n2)) &
                         *dvr       * N_s(n)* N_r(n2)
                     z2 = z2+ PI*.25*Ef_rs*(Ds(n)+Dr(n2))*(Ds(n)+Dr(n2)) &
                         *dvr*masss * N_s(n)* N_r(n2)
                     else
                     t4 = t4+ PI*.25*Ef_rs*(Ds(n)+Dr(n2))*(Ds(n)+Dr(n2)) &
                         *dvr*massr * N_s(n)* N_r(n2)
                     y4 = y4+ PI*.25*Ef_rs*(Ds(n)+Dr(n2))*(Ds(n)+Dr(n2)) &
                         *dvr       * N_s(n)* N_r(n2)
                     z4 = z4+ PI*.25*Ef_rs*(Ds(n)+Dr(n2))*(Ds(n)+Dr(n2)) &
                         *dvr*masss * N_s(n)* N_r(n2)
                     endif

                  enddo
               enddo
               tcs_racs1(i,j,k,m) = t1
               tmr_racs1(i,j,k,m) = DMIN1(z1, r_r(m)*1.0d0)
               tcs_racs2(i,j,k,m) = t3
               tmr_racs2(i,j,k,m) = z3
               tcr_sacr1(i,j,k,m) = t2
               tms_sacr1(i,j,k,m) = z2
               tcr_sacr2(i,j,k,m) = t4
               tms_sacr2(i,j,k,m) = z4
               tnr_racs1(i,j,k,m) = y1
               tnr_racs2(i,j,k,m) = y3
               tnr_sacr1(i,j,k,m) = y2
               tnr_sacr2(i,j,k,m) = y4
            enddo
         enddo
      enddo

!..Note wrf_dm_gatherv expects zero-based km_s, km_e (J. Michalakes, 2009Oct30).

#if ( defined( DM_PARALLEL ) && ( ! defined( STUBMPI ) ) )
      CALL wrf_dm_gatherv(tcs_racs1, ntb_s*ntb_t, km_s, km_e, R8SIZE)
      CALL wrf_dm_gatherv(tmr_racs1, ntb_s*ntb_t, km_s, km_e, R8SIZE)
      CALL wrf_dm_gatherv(tcs_racs2, ntb_s*ntb_t, km_s, km_e, R8SIZE)
      CALL wrf_dm_gatherv(tmr_racs2, ntb_s*ntb_t, km_s, km_e, R8SIZE)
      CALL wrf_dm_gatherv(tcr_sacr1, ntb_s*ntb_t, km_s, km_e, R8SIZE)
      CALL wrf_dm_gatherv(tms_sacr1, ntb_s*ntb_t, km_s, km_e, R8SIZE)
      CALL wrf_dm_gatherv(tcr_sacr2, ntb_s*ntb_t, km_s, km_e, R8SIZE)
      CALL wrf_dm_gatherv(tms_sacr2, ntb_s*ntb_t, km_s, km_e, R8SIZE)
      CALL wrf_dm_gatherv(tnr_racs1, ntb_s*ntb_t, km_s, km_e, R8SIZE)
      CALL wrf_dm_gatherv(tnr_racs2, ntb_s*ntb_t, km_s, km_e, R8SIZE)
      CALL wrf_dm_gatherv(tnr_sacr1, ntb_s*ntb_t, km_s, km_e, R8SIZE)
      CALL wrf_dm_gatherv(tnr_sacr2, ntb_s*ntb_t, km_s, km_e, R8SIZE)
#endif


      end subroutine qr_acr_qs
!+---+-----------------------------------------------------------------+
!ctrlL
!+---+-----------------------------------------------------------------+
!..This is a literal adaptation of Bigg (1954) probability of drops of
!..a particular volume freezing.  Given this probability, simply freeze
!..the proportion of drops summing their masses.
!+---+-----------------------------------------------------------------+

      subroutine freezeH2O

      implicit none

!..Local variables
      INTEGER:: i, j, k, n, n2
      DOUBLE PRECISION, DIMENSION(nbr):: N_r, massr
      DOUBLE PRECISION, DIMENSION(nbc):: N_c, massc
      DOUBLE PRECISION:: sum1, sum2, sumn1, sumn2, &
                         prob, vol, Texp, orho_w, &
                         lam_exp, lamr, N0_r, lamc, N0_c, y

!+---+

      orho_w = 1./rho_w

      do n2 = 1, nbr
         massr(n2) = am_r*Dr(n2)**bm_r
      enddo
      do n = 1, nbc
         massc(n) = am_r*Dc(n)**bm_r
      enddo

!..Freeze water (smallest drops become cloud ice, otherwise graupel).
      do k = 1, 45
!         print*, ' Freezing water for temp = ', -k
         Texp = DEXP( DFLOAT(k) ) - 1.0D0
         do j = 1, ntb_r1
            do i = 1, ntb_r
               lam_exp = (N0r_exp(j)*am_r*crg(1)/r_r(i))**ore1
               lamr = lam_exp * (crg(3)*org2*org1)**obmr
               N0_r = N0r_exp(j)/(crg(2)*lam_exp) * lamr**cre(2)
               sum1 = 0.0d0
               sum2 = 0.0d0
               sumn1 = 0.0d0
               sumn2 = 0.0d0
               do n2 = 1, nbr
                  N_r(n2) = N0_r*Dr(n2)**mu_r*DEXP(-lamr*Dr(n2))*dtr(n2)
                  vol = massr(n2)*orho_w
                  prob = 1.0D0 - DEXP(-120.0D0*vol*5.2D-4 * Texp)
                  if (massr(n2) .lt. xm0g) then
                     sumn1 = sumn1 + prob*N_r(n2)
                     sum1 = sum1 + prob*N_r(n2)*massr(n2)
                  else
                     sumn2 = sumn2 + prob*N_r(n2)
                     sum2 = sum2 + prob*N_r(n2)*massr(n2)
                  endif
               enddo
               tpi_qrfz(i,j,k) = sum1
               tni_qrfz(i,j,k) = sumn1
               tpg_qrfz(i,j,k) = sum2
               tnr_qrfz(i,j,k) = sumn2
            enddo
         enddo
         do i = 1, ntb_c
            lamc = 1.0D-6 * (Nt_c*am_r* ccg(2) * ocg1 / r_c(i))**obmr
            N0_c = 1.0D-18 * Nt_c*ocg1 * lamc**cce(1)
            sum1 = 0.0d0
            sumn2 = 0.0d0
            do n = 1, nbc
               y = Dc(n)*1.0D6
               vol = massc(n)*orho_w
               prob = 1.0D0 - DEXP(-120.0D0*vol*5.2D-4 * Texp)
               N_c(n) = N0_c* y**mu_c * EXP(-lamc*y)*dtc(n)
               N_c(n) = 1.0D24 * N_c(n)
               sumn2 = sumn2 + prob*N_c(n)
               sum1 = sum1 + prob*N_c(n)*massc(n)
            enddo
            tpi_qcfz(i,k) = sum1
            tni_qcfz(i,k) = sumn2
         enddo
      enddo

      end subroutine freezeH2O
!+---+-----------------------------------------------------------------+
!ctrlL
!+---+-----------------------------------------------------------------+
!..Cloud ice converting to snow since portion greater than min snow
!.. size.  Given cloud ice content (kg/m**3), number concentration
!.. (#/m**3) and gamma shape parameter, mu_i, break the distrib into
!.. bins and figure out the mass/number of ice with sizes larger than
!.. D0s.  Also, compute incomplete gamma function for the integration
!.. of ice depositional growth from diameter=0 to D0s.  Amount of
!.. ice depositional growth is this portion of distrib while larger
!.. diameters contribute to snow growth (as in Harrington et al. 1995).
!+---+-----------------------------------------------------------------+

      subroutine qi_aut_qs

      implicit none

!..Local variables
      INTEGER:: i, j, n2
      DOUBLE PRECISION, DIMENSION(nbi):: N_i
      DOUBLE PRECISION:: N0_i, lami, Di_mean, t1, t2
      REAL:: xlimit_intg

!+---+

      do j = 1, ntb_i1
         do i = 1, ntb_i
            lami = (am_i*cig(2)*oig1*Nt_i(j)/r_i(i))**obmi
            Di_mean = (bm_i + mu_i + 1.) / lami
            N0_i = Nt_i(j)*oig1 * lami**cie(1)
            t1 = 0.0d0
            t2 = 0.0d0
            if (SNGL(Di_mean) .gt. 5.*D0s) then
             t1 = r_i(i)
             t2 = Nt_i(j)
             tpi_ide(i,j) = 0.0D0
            elseif (SNGL(Di_mean) .lt. D0i) then
             t1 = 0.0D0
             t2 = 0.0D0
             tpi_ide(i,j) = 1.0D0
            else
             xlimit_intg = lami*D0s
             tpi_ide(i,j) = GAMMP(mu_i+2.0, xlimit_intg) * 1.0D0
             do n2 = 1, nbi
               N_i(n2) = N0_i*Di(n2)**mu_i * DEXP(-lami*Di(n2))*dti(n2)
               if (Di(n2).ge.D0s) then
                  t1 = t1 + N_i(n2) * am_i*Di(n2)**bm_i
                  t2 = t2 + N_i(n2)
               endif
             enddo
            endif
            tps_iaus(i,j) = t1
            tni_iaus(i,j) = t2
         enddo
      enddo

      end subroutine qi_aut_qs
!ctrlL
!+---+-----------------------------------------------------------------+
!..Variable collision efficiency for rain collecting cloud water using
!.. method of Beard and Grover, 1974 if a/A less than 0.25; otherwise
!.. uses polynomials to get close match of Pruppacher & Klett Fig 14-9.
!+---+-----------------------------------------------------------------+

      subroutine table_Efrw

      implicit none

!..Local variables
      DOUBLE PRECISION:: vtr, stokes, reynolds, Ef_rw
      DOUBLE PRECISION:: p, yc0, F, G, H, z, K0, X
      INTEGER:: i, j

      do j = 1, nbc
      do i = 1, nbr
         Ef_rw = 0.0
         p = Dc(j)/Dr(i)
         if (Dr(i).lt.50.E-6 .or. Dc(j).lt.3.E-6) then
          t_Efrw(i,j) = 0.0
         elseif (p.gt.0.25) then
          X = Dc(j)*1.D6
          if (Dr(i) .lt. 75.e-6) then
             Ef_rw = 0.026794*X - 0.20604
          elseif (Dr(i) .lt. 125.e-6) then
             Ef_rw = -0.00066842*X*X + 0.061542*X - 0.37089
          elseif (Dr(i) .lt. 175.e-6) then
             Ef_rw = 4.091e-06*X*X*X*X - 0.00030908*X*X*X               &
                   + 0.0066237*X*X - 0.0013687*X - 0.073022
          elseif (Dr(i) .lt. 250.e-6) then
             Ef_rw = 9.6719e-5*X*X*X - 0.0068901*X*X + 0.17305*X        &
                   - 0.65988
          elseif (Dr(i) .lt. 350.e-6) then
             Ef_rw = 9.0488e-5*X*X*X - 0.006585*X*X + 0.16606*X         &
                   - 0.56125
          else
             Ef_rw = 0.00010721*X*X*X - 0.0072962*X*X + 0.1704*X        &
                   - 0.46929
          endif
         else
          vtr = -0.1021 + 4.932E3*Dr(i) - 0.9551E6*Dr(i)*Dr(i) &
              + 0.07934E9*Dr(i)*Dr(i)*Dr(i) &
              - 0.002362E12*Dr(i)*Dr(i)*Dr(i)*Dr(i)
          stokes = Dc(j)*Dc(j)*vtr*rho_w/(9.*1.718E-5*Dr(i))
          reynolds = 9.*stokes/(p*p*rho_w)

          F = DLOG(reynolds)
          G = -0.1007D0 - 0.358D0*F + 0.0261D0*F*F
          K0 = DEXP(G)
          z = DLOG(stokes/(K0+1.D-15))
          H = 0.1465D0 + 1.302D0*z - 0.607D0*z*z + 0.293D0*z*z*z
          yc0 = 2.0D0/PI * ATAN(H)
          Ef_rw = (yc0+p)*(yc0+p) / ((1.+p)*(1.+p))

         endif

         t_Efrw(i,j) = MAX(0.0, MIN(SNGL(Ef_rw), 0.95))

      enddo
      enddo

      end subroutine table_Efrw
!ctrlL
!+---+-----------------------------------------------------------------+
!..Variable collision efficiency for snow collecting cloud water using
!.. method of Wang and Ji, 2000 except equate melted snow diameter to
!.. their "effective collision cross-section."
!+---+-----------------------------------------------------------------+

      subroutine table_Efsw

      implicit none

!..Local variables
      DOUBLE PRECISION:: Ds_m, vts, vtc, stokes, reynolds, Ef_sw
      DOUBLE PRECISION:: p, yc0, F, G, H, z, K0
      INTEGER:: i, j

      do j = 1, nbc
      vtc = 1.19D4 * (1.0D4*Dc(j)*Dc(j)*0.25D0)
      do i = 1, nbs
         vts = av_s*Ds(i)**bv_s * DEXP(-fv_s*Ds(i)) - vtc
         Ds_m = (am_s*Ds(i)**bm_s / am_r)**obmr
         p = Dc(j)/Ds_m
         if (p.gt.0.25 .or. Ds(i).lt.D0s .or. Dc(j).lt.6.E-6 &
               .or. vts.lt.1.E-3) then
          t_Efsw(i,j) = 0.0
         else
          stokes = Dc(j)*Dc(j)*vts*rho_w/(9.*1.718E-5*Ds_m)
          reynolds = 9.*stokes/(p*p*rho_w)

          F = DLOG(reynolds)
          G = -0.1007D0 - 0.358D0*F + 0.0261D0*F*F
          K0 = DEXP(G)
          z = DLOG(stokes/(K0+1.D-15))
          H = 0.1465D0 + 1.302D0*z - 0.607D0*z*z + 0.293D0*z*z*z
          yc0 = 2.0D0/PI * ATAN(H)
          Ef_sw = (yc0+p)*(yc0+p) / ((1.+p)*(1.+p))

          t_Efsw(i,j) = MAX(0.0, MIN(SNGL(Ef_sw), 0.95))
         endif

      enddo
      enddo

      end subroutine table_Efsw
!ctrlL
!+---+-----------------------------------------------------------------+
!..Integrate rain size distribution from zero to D-star to compute the
!.. number of drops smaller than D-star that evaporate in a single
!.. timestep.  Drops larger than D-star dont evaporate entirely so do
!.. not affect number concentration.
!+---+-----------------------------------------------------------------+

      subroutine table_dropEvap

      implicit none

!..Local variables
      DOUBLE PRECISION:: Nt_r, N0, lam_exp, lam
      REAL:: xlimit_intg
      INTEGER:: i, j, k

      do k = 1, ntb_r
      do j = 1, ntb_r1
         lam_exp = (N0r_exp(j)*am_r*crg(1)/r_r(k))**ore1
         lam = lam_exp * (crg(3)*org2*org1)**obmr
         N0 = N0r_exp(j)/(crg(2)*lam_exp) * lam**cre(2)
         Nt_r = N0 * crg(2) / lam**cre(2)

         do i = 1, nbr
            xlimit_intg = lam*Dr(i)
            tnr_rev(i,j,k) = GAMMP(mu_r+1.0, xlimit_intg) * Nt_r
         enddo

      enddo
      enddo

      end subroutine table_dropEvap

! TO APPLY TABLE ABOVE
!..Rain lookup table indexes.
!         Dr_star = DSQRT(-2.D0*DT * t1_evap/(2.*PI) &
!                 * 0.78*4.*diffu(k)*xsat*rvs/rho_w)
!         idx_d = NINT(1.0 + FLOAT(nbr) * DLOG(Dr_star/D0r)             &
!               / DLOG(Dr(nbr)/D0r))
!         idx_d = MAX(1, MIN(idx_d, nbr))
!
!         nir = NINT(ALOG10(rr(k)))
!         do nn = nir-1, nir+1
!            n = nn
!            if ( (rr(k)/10.**nn).ge.1.0 .and. &
!                 (rr(k)/10.**nn).lt.10.0) goto 154
!         enddo
!154      continue
!         idx_r = INT(rr(k)/10.**n) + 10*(n-nir2) - (n-nir2)
!         idx_r = MAX(1, MIN(idx_r, ntb_r))
!
!         lamr = (am_r*crg(3)*org2*nr(k)/rr(k))**obmr
!         lam_exp = lamr * (crg(3)*org2*org1)**bm_r
!         N0_exp = org1*rr(k)/am_r * lam_exp**cre(1)
!         nir = NINT(DLOG10(N0_exp))
!         do nn = nir-1, nir+1
!            n = nn
!            if ( (N0_exp/10.**nn).ge.1.0 .and. &
!                 (N0_exp/10.**nn).lt.10.0) goto 155
!         enddo
!155      continue
!         idx_r1 = INT(N0_exp/10.**n) + 10*(n-nir3) - (n-nir3)
!         idx_r1 = MAX(1, MIN(idx_r1, ntb_r1))
!
!         pnr_rev(k) = MIN(nr(k)*odts, SNGL(tnr_rev(idx_d,idx_r1,idx_r) &   ! RAIN2M
!                    * odts))
!
!ctrlL
!+---+-----------------------------------------------------------------+
!+---+-----------------------------------------------------------------+
      SUBROUTINE GCF(GAMMCF,A,X,GLN)
!     --- RETURNS THE INCOMPLETE GAMMA FUNCTION Q(A,X) EVALUATED BY ITS
!     --- CONTINUED FRACTION REPRESENTATION AS GAMMCF.  ALSO RETURNS
!     --- LN(GAMMA(A)) AS GLN.  THE CONTINUED FRACTION IS EVALUATED BY
!     --- A MODIFIED LENTZ METHOD.
!     --- USES GAMMLN
      IMPLICIT NONE
      INTEGER, PARAMETER:: ITMAX=100
      REAL, PARAMETER:: gEPS=3.E-7
      REAL, PARAMETER:: FPMIN=1.E-30
      REAL, INTENT(IN):: A, X
      REAL:: GAMMCF,GLN
      INTEGER:: I
      REAL:: AN,B,C,D,DEL,H
      GLN=GAMMLN(A)
      B=X+1.-A
      C=1./FPMIN
      D=1./B
      H=D
      DO 11 I=1,ITMAX
        AN=-I*(I-A)
        B=B+2.
        D=AN*D+B
        IF(ABS(D).LT.FPMIN)D=FPMIN
        C=B+AN/C
        IF(ABS(C).LT.FPMIN)C=FPMIN
        D=1./D
        DEL=D*C
        H=H*DEL
        IF(ABS(DEL-1.).LT.gEPS)GOTO 1
 11   CONTINUE
      PRINT *, 'A TOO LARGE, ITMAX TOO SMALL IN GCF'
 1    GAMMCF=EXP(-X+A*LOG(X)-GLN)*H
      END SUBROUTINE GCF
!  (C) Copr. 1986-92 Numerical Recipes Software 2.02
!+---+-----------------------------------------------------------------+
      SUBROUTINE GSER(GAMSER,A,X,GLN)
!     --- RETURNS THE INCOMPLETE GAMMA FUNCTION P(A,X) EVALUATED BY ITS
!     --- ITS SERIES REPRESENTATION AS GAMSER.  ALSO RETURNS LN(GAMMA(A)) 
!     --- AS GLN.
!     --- USES GAMMLN
      IMPLICIT NONE
      INTEGER, PARAMETER:: ITMAX=100
      REAL, PARAMETER:: gEPS=3.E-7
      REAL, INTENT(IN):: A, X
      REAL:: GAMSER,GLN
      INTEGER:: N
      REAL:: AP,DEL,SUM
      GLN=GAMMLN(A)
      IF(X.LE.0.)THEN
        IF(X.LT.0.) PRINT *, 'X < 0 IN GSER'
        GAMSER=0.
        RETURN
      ENDIF
      AP=A
      SUM=1./A
      DEL=SUM
      DO 11 N=1,ITMAX
        AP=AP+1.
        DEL=DEL*X/AP
        SUM=SUM+DEL
        IF(ABS(DEL).LT.ABS(SUM)*gEPS)GOTO 1
 11   CONTINUE
      PRINT *,'A TOO LARGE, ITMAX TOO SMALL IN GSER'
 1    GAMSER=SUM*EXP(-X+A*LOG(X)-GLN)
      END SUBROUTINE GSER
!  (C) Copr. 1986-92 Numerical Recipes Software 2.02
!+---+-----------------------------------------------------------------+
      REAL FUNCTION GAMMLN(XX)
!     --- RETURNS THE VALUE LN(GAMMA(XX)) FOR XX > 0.
      IMPLICIT NONE
      REAL, INTENT(IN):: XX
      DOUBLE PRECISION, PARAMETER:: STP = 2.5066282746310005D0
      DOUBLE PRECISION, DIMENSION(6), PARAMETER:: &
               COF = (/76.18009172947146D0, -86.50532032941677D0, &
                       24.01409824083091D0, -1.231739572450155D0, &
                      .1208650973866179D-2, -.5395239384953D-5/)
      DOUBLE PRECISION:: SER,TMP,X,Y
      INTEGER:: J

      X=XX
      Y=X
      TMP=X+5.5D0
      TMP=(X+0.5D0)*LOG(TMP)-TMP
      SER=1.000000000190015D0
      DO 11 J=1,6
        Y=Y+1.D0
        SER=SER+COF(J)/Y
11    CONTINUE
      GAMMLN=TMP+LOG(STP*SER/X)
      END FUNCTION GAMMLN
!  (C) Copr. 1986-92 Numerical Recipes Software 2.02
!+---+-----------------------------------------------------------------+
      REAL FUNCTION GAMMP(A,X)
!     --- COMPUTES THE INCOMPLETE GAMMA FUNCTION P(A,X)
!     --- SEE ABRAMOWITZ AND STEGUN 6.5.1
!     --- USES GCF,GSER
      IMPLICIT NONE
      REAL, INTENT(IN):: A,X
      REAL:: GAMMCF,GAMSER,GLN
      GAMMP = 0.
      IF((X.LT.0.) .OR. (A.LE.0.)) THEN
        PRINT *, 'BAD ARGUMENTS IN GAMMP'
        RETURN
      ELSEIF(X.LT.A+1.)THEN
        CALL GSER(GAMSER,A,X,GLN)
        GAMMP=GAMSER
      ELSE
        CALL GCF(GAMMCF,A,X,GLN)
        GAMMP=1.-GAMMCF
      ENDIF
      END FUNCTION GAMMP
!  (C) Copr. 1986-92 Numerical Recipes Software 2.02
!+---+-----------------------------------------------------------------+
      REAL FUNCTION WGAMMA(y)

      IMPLICIT NONE
      REAL, INTENT(IN):: y

      WGAMMA = EXP(GAMMLN(y))

      END FUNCTION WGAMMA
!+---+-----------------------------------------------------------------+
! THIS FUNCTION CALCULATES THE LIQUID SATURATION VAPOR MIXING RATIO AS
! A FUNCTION OF TEMPERATURE AND PRESSURE
!
      REAL FUNCTION RSLF(P,T)

      IMPLICIT NONE
      REAL, INTENT(IN):: P, T
      REAL:: ESL,X
      REAL, PARAMETER:: C0= .611583699E03
      REAL, PARAMETER:: C1= .444606896E02
      REAL, PARAMETER:: C2= .143177157E01
      REAL, PARAMETER:: C3= .264224321E-1
      REAL, PARAMETER:: C4= .299291081E-3
      REAL, PARAMETER:: C5= .203154182E-5
      REAL, PARAMETER:: C6= .702620698E-8
      REAL, PARAMETER:: C7= .379534310E-11
      REAL, PARAMETER:: C8=-.321582393E-13

!      X=MAX(-80.,T-273.16)

!      ESL=612.2*EXP(17.67*X/(T-29.65))
!      ESL=C0+X*(C1+X*(C2+X*(C3+X*(C4+X*(C5+X*(C6+X*(C7+X*C8)))))))
!      RSLF=.622*ESL/(P-ESL)
      ESL=611.2 * EXP( 17.67 * ( T  - 273.15 ) / ( T  - 29.65 ) )
      RSLF=0.62197185*ESL/(P-ESL)

!    ALTERNATIVE
!  ; Source: Murphy and Koop, Review of the vapour pressure of ice and
!             supercooled water for atmospheric applications, Q. J. R.
!             Meteorol. Soc (2005), 131, pp. 1539-1565.
!    ESL = EXP(54.842763 - 6763.22 / T - 4.210 * ALOG(T) + 0.000367 * T
!        + TANH(0.0415 * (T - 218.8)) * (53.878 - 1331.22
!        / T - 9.44523 * ALOG(T) + 0.014025 * T))

      END FUNCTION RSLF
!+---+-----------------------------------------------------------------+
! THIS FUNCTION CALCULATES THE ICE SATURATION VAPOR MIXING RATIO AS A
! FUNCTION OF TEMPERATURE AND PRESSURE
!
      REAL FUNCTION RSIF(P,T)

      IMPLICIT NONE
      REAL, INTENT(IN):: P, T
      REAL:: ESI,X
      REAL, PARAMETER:: C0= .609868993E03
      REAL, PARAMETER:: C1= .499320233E02
      REAL, PARAMETER:: C2= .184672631E01
      REAL, PARAMETER:: C3= .402737184E-1
      REAL, PARAMETER:: C4= .565392987E-3
      REAL, PARAMETER:: C5= .521693933E-5
      REAL, PARAMETER:: C6= .307839583E-7
      REAL, PARAMETER:: C7= .105785160E-9
      REAL, PARAMETER:: C8= .161444444E-12

!      X=MAX(-80.,T-273.16)
!      ESI=C0+X*(C1+X*(C2+X*(C3+X*(C4+X*(C5+X*(C6+X*(C7+X*C8)))))))
!      RSIF=.622*ESI/(P-ESI)
      ESI=611.2 * EXP( 21.8745584 * ( T  - 273.15 ) / ( T  - 7.66 ) )
      RSIF=0.62197185*ESI/(P-ESI)

!    ALTERNATIVE
!  ; Source: Murphy and Koop, Review of the vapour pressure of ice and
!             supercooled water for atmospheric applications, Q. J. R.
!             Meteorol. Soc (2005), 131, pp. 1539-1565.
!     ESI = EXP(9.550426 - 5723.265/T + 3.53068*ALOG(T) - 0.00728332*T)

      END FUNCTION RSIF
!+---+-----------------------------------------------------------------+
!+---+-----------------------------------------------------------------+

      COMPLEX*16 FUNCTION m_complex_water_ray(lambda,T)

!      Complex refractive Index of Water as function of Temperature T
!      [deg C] and radar wavelength lambda [m]; valid for
!      lambda in [0.001,1.0] m; T in [-10.0,30.0] deg C
!      after Ray (1972)

      IMPLICIT NONE
      DOUBLE PRECISION, INTENT(IN):: T,lambda
      DOUBLE PRECISION:: epsinf,epss,epsr,epsi
      DOUBLE PRECISION:: alpha,lambdas,sigma,nenner
      COMPLEX*16, PARAMETER:: i = (0d0,1d0)

      epsinf  = 5.27137d0 + 0.02164740d0 * T - 0.00131198d0 * T*T
      epss    = 78.54d+0 * (1.0 - 4.579d-3 * (T - 25.0)                 &
              + 1.190d-5 * (T - 25.0)*(T - 25.0)                        &
              - 2.800d-8 * (T - 25.0)*(T - 25.0)*(T - 25.0))
      alpha   = -16.8129d0/(T+273.16) + 0.0609265d0
      lambdas = 0.00033836d0 * exp(2513.98d0/(T+273.16)) * 1e-2

      nenner = 1.d0+2.d0*(lambdas/lambda)**(1d0-alpha)*sin(alpha*PI*0.5) &
             + (lambdas/lambda)**(2d0-2d0*alpha)
      epsr = epsinf + ((epss-epsinf) * ((lambdas/lambda)**(1d0-alpha)   &
           * sin(alpha*PI*0.5)+1d0)) / nenner
      epsi = ((epss-epsinf) * ((lambdas/lambda)**(1d0-alpha)            &
           * cos(alpha*PI*0.5)+0d0)) / nenner                           &
           + lambda*1.25664/1.88496
      
      m_complex_water_ray = SQRT(CMPLX(epsr,-epsi))
      
      END FUNCTION m_complex_water_ray

!+---+-----------------------------------------------------------------+
      
      COMPLEX*16 FUNCTION m_complex_ice_maetzler(lambda,T)
      
!      complex refractive index of ice as function of Temperature T
!      [deg C] and radar wavelength lambda [m]; valid for
!      lambda in [0.0001,30] m; T in [-250.0,0.0] C
!      Original comment from the Matlab-routine of Prof. Maetzler:
!      Function for calculating the relative permittivity of pure ice in
!      the microwave region, according to C. Maetzler, "Microwave
!      properties of ice and snow", in B. Schmitt et al. (eds.) Solar
!      System Ices, Astrophys. and Space Sci. Library, Vol. 227, Kluwer
!      Academic Publishers, Dordrecht, pp. 241-257 (1998). Input:
!      TK = temperature (K), range 20 to 273.15
!      f = frequency in GHz, range 0.01 to 3000
         
      IMPLICIT NONE
      DOUBLE PRECISION, INTENT(IN):: T,lambda
      DOUBLE PRECISION:: f,c,TK,B1,B2,b,deltabeta,betam,beta,theta,alfa

      c = 2.99d8
      TK = T + 273.16
      f = c / lambda * 1d-9

      B1 = 0.0207
      B2 = 1.16d-11
      b = 335.0d0
      deltabeta = EXP(-10.02 + 0.0364*(TK-273.16))
      betam = (B1/TK) * ( EXP(b/TK) / ((EXP(b/TK)-1)**2) ) + B2*f*f
      beta = betam + deltabeta
      theta = 300. / TK - 1.
      alfa = (0.00504d0 + 0.0062d0*theta) * EXP(-22.1d0*theta)
      m_complex_ice_maetzler = 3.1884 + 9.1e-4*(TK-273.16)
      m_complex_ice_maetzler = m_complex_ice_maetzler                   &
                             + CMPLX(0.0d0, (alfa/f + beta*f)) 
      m_complex_ice_maetzler = SQRT(CONJG(m_complex_ice_maetzler))
      
      END FUNCTION m_complex_ice_maetzler

!+---+-----------------------------------------------------------------+

      subroutine rayleigh_soak_wetgraupel (x_g, a_geo, b_geo, fmelt,    &
                     meltratio_outside, m_w, m_i, lambda, C_back,       &
                     mixingrule,matrix,inclusion,                       &
                     host,hostmatrix,hostinclusion)

      IMPLICIT NONE

      DOUBLE PRECISION, INTENT(in):: x_g, a_geo, b_geo, fmelt, lambda,  &
                                     meltratio_outside
      DOUBLE PRECISION, INTENT(out):: C_back
      COMPLEX*16, INTENT(in):: m_w, m_i
      CHARACTER(len=*), INTENT(in):: mixingrule, matrix, inclusion,     &
                                     host, hostmatrix, hostinclusion

      COMPLEX*16:: m_core, m_air
      DOUBLE PRECISION:: D_large, D_g, rhog, x_w, xw_a, fm, fmgrenz,    &
                         volg, vg, volair, volice, volwater,            &
                         meltratio_outside_grenz, mra
      INTEGER:: error

!     refractive index of air:
      m_air = (1.0d0,0.0d0)

!     Limiting the degree of melting --- for safety: 
      fm = DMAX1(DMIN1(fmelt, 1.0d0), 0.0d0)
!     Limiting the ratio of (melting on outside)/(melting on inside):
      mra = DMAX1(DMIN1(meltratio_outside, 1.0d0), 0.0d0)

!    ! The relative portion of meltwater melting at outside should increase
!    ! from the given input value (between 0 and 1)
!    ! to 1 as the degree of melting approaches 1,
!    ! so that the melting particle "converges" to a water drop.
!    ! Simplest assumption is linear:
      mra = mra + (1.0d0-mra)*fm

      x_w = x_g * fm

      D_g = a_geo * x_g**b_geo

      if (D_g .ge. 1d-12) then

       vg = PI/6. * D_g**3
       rhog = DMAX1(DMIN1(x_g / vg, DBLE(rho_i)), 10.0d0)
       vg = x_g / rhog
      
       meltratio_outside_grenz = 1.0d0 - rhog / rho_w

       if (mra .le. meltratio_outside_grenz) then
        !..In this case, it cannot happen that, during melting, all the
        !.. air inclusions within the ice particle get filled with
        !.. meltwater. This only happens at the end of all melting.
        volg = vg * (1.0d0 - mra * fm)
 
       else
        !..In this case, at some melting degree fm, all the air
        !.. inclusions get filled with meltwater.
        fmgrenz=(rho_i-rhog)/(mra*rho_i-rhog+rho_i*rhog/rho_w)

        if (fm .le. fmgrenz) then
         !.. not all air pockets are filled:
         volg = (1.0 - mra * fm) * vg
        else
         !..all air pockets are filled with meltwater, now the
         !.. entire ice sceleton melts homogeneously:
         volg = (x_g - x_w) / rho_i + x_w / rho_w
        endif

       endif

       D_large  = (6.0 / PI * volg) ** (1./3.)
       volice = (x_g - x_w) / (volg * rho_i)
       volwater = x_w / (rho_w * volg)
       volair = 1.0 - volice - volwater
      
       !..complex index of refraction for the ice-air-water mixture
       !.. of the particle:
       m_core = get_m_mix_nested (m_air, m_i, m_w, volair, volice,      &
                         volwater, mixingrule, host, matrix, inclusion, &
                         hostmatrix, hostinclusion, error)
       if (error .ne. 0) then
        C_back = 0.0d0
        return
       endif

       !..Rayleigh-backscattering coefficient of melting particle: 
       C_back = (ABS((m_core**2-1.0d0)/(m_core**2+2.0d0)))**2           &
                * PI5 * D_large**6 / lamda4

      else
       C_back = 0.0d0
      endif

      end subroutine rayleigh_soak_wetgraupel

!+---+-----------------------------------------------------------------+

      complex*16 function get_m_mix_nested (m_a, m_i, m_w, volair,      &
                     volice, volwater, mixingrule, host, matrix,        &
                     inclusion, hostmatrix, hostinclusion, cumulerror)

      IMPLICIT NONE

      DOUBLE PRECISION, INTENT(in):: volice, volair, volwater
      COMPLEX*16, INTENT(in):: m_a, m_i, m_w
      CHARACTER(len=*), INTENT(in):: mixingrule, host, matrix,          &
                     inclusion, hostmatrix, hostinclusion
      INTEGER, INTENT(out):: cumulerror

      DOUBLE PRECISION:: vol1, vol2
      COMPLEX*16:: mtmp
      INTEGER:: error

      !..Folded: ( (m1 + m2) + m3), where m1,m2,m3 could each be
      !.. air, ice, or water

      cumulerror = 0
      get_m_mix_nested = CMPLX(1.0d0,0.0d0)

      if (host .eq. 'air') then

       if (matrix .eq. 'air') then
        write(mp_debug,*) 'GET_M_MIX_NESTED: bad matrix: ', matrix
!       CALL wrf_debug(150, mp_debug)
        cumulerror = cumulerror + 1
       else
        vol1 = volice / MAX(volice+volwater,1d-10)
        vol2 = 1.0d0 - vol1
        mtmp = get_m_mix (m_a, m_i, m_w, 0.0d0, vol1, vol2,             &
                         mixingrule, matrix, inclusion, error)
        cumulerror = cumulerror + error
          
        if (hostmatrix .eq. 'air') then
         get_m_mix_nested = get_m_mix (m_a, mtmp, 2.0*m_a,              &
                         volair, (1.0d0-volair), 0.0d0, mixingrule,     &
                         hostmatrix, hostinclusion, error)
         cumulerror = cumulerror + error
        elseif (hostmatrix .eq. 'icewater') then
         get_m_mix_nested = get_m_mix (m_a, mtmp, 2.0*m_a,              &
                         volair, (1.0d0-volair), 0.0d0, mixingrule,     &
                         'ice', hostinclusion, error)
         cumulerror = cumulerror + error
        else
         write(mp_debug,*) 'GET_M_MIX_NESTED: bad hostmatrix: ',        &
                           hostmatrix
!        CALL wrf_debug(150, mp_debug)
         cumulerror = cumulerror + 1
        endif
       endif

      elseif (host .eq. 'ice') then

       if (matrix .eq. 'ice') then
        write(mp_debug,*) 'GET_M_MIX_NESTED: bad matrix: ', matrix
!       CALL wrf_debug(150, mp_debug)
        cumulerror = cumulerror + 1
       else
        vol1 = volair / MAX(volair+volwater,1d-10)
        vol2 = 1.0d0 - vol1
        mtmp = get_m_mix (m_a, m_i, m_w, vol1, 0.0d0, vol2,             &
                         mixingrule, matrix, inclusion, error)
        cumulerror = cumulerror + error

        if (hostmatrix .eq. 'ice') then
         get_m_mix_nested = get_m_mix (mtmp, m_i, 2.0*m_a,              &
                         (1.0d0-volice), volice, 0.0d0, mixingrule,     &
                         hostmatrix, hostinclusion, error)
         cumulerror = cumulerror + error
        elseif (hostmatrix .eq. 'airwater') then
         get_m_mix_nested = get_m_mix (mtmp, m_i, 2.0*m_a,              &
                         (1.0d0-volice), volice, 0.0d0, mixingrule,     &
                         'air', hostinclusion, error)
         cumulerror = cumulerror + error          
        else
         write(mp_debug,*) 'GET_M_MIX_NESTED: bad hostmatrix: ',        &
                           hostmatrix
!        CALL wrf_debug(150, mp_debug)
         cumulerror = cumulerror + 1
        endif
       endif

      elseif (host .eq. 'water') then

       if (matrix .eq. 'water') then
        write(mp_debug,*) 'GET_M_MIX_NESTED: bad matrix: ', matrix
!       CALL wrf_debug(150, mp_debug)
        cumulerror = cumulerror + 1
       else
        vol1 = volair / MAX(volice+volair,1d-10)
        vol2 = 1.0d0 - vol1
        mtmp = get_m_mix (m_a, m_i, m_w, vol1, vol2, 0.0d0,             &
                         mixingrule, matrix, inclusion, error)
        cumulerror = cumulerror + error

        if (hostmatrix .eq. 'water') then
         get_m_mix_nested = get_m_mix (2.0d0*m_a, mtmp, m_w,            &
                         0.0d0, (1.0d0-volwater), volwater, mixingrule, &
                         hostmatrix, hostinclusion, error)
         cumulerror = cumulerror + error
        elseif (hostmatrix .eq. 'airice') then
         get_m_mix_nested = get_m_mix (2.0d0*m_a, mtmp, m_w,            &
                         0.0d0, (1.0d0-volwater), volwater, mixingrule, &
                         'ice', hostinclusion, error)
         cumulerror = cumulerror + error          
        else
         write(mp_debug,*) 'GET_M_MIX_NESTED: bad hostmatrix: ',         &
                           hostmatrix
!        CALL wrf_debug(150, mp_debug)
         cumulerror = cumulerror + 1
        endif
       endif

      elseif (host .eq. 'none') then

       get_m_mix_nested = get_m_mix (m_a, m_i, m_w,                     &
                       volair, volice, volwater, mixingrule,            &
                       matrix, inclusion, error)
       cumulerror = cumulerror + error
        
      else
       write(mp_debug,*) 'GET_M_MIX_NESTED: unknown matrix: ', host
!      CALL wrf_debug(150, mp_debug)
       cumulerror = cumulerror + 1
      endif

      IF (cumulerror .ne. 0) THEN
       write(mp_debug,*) 'GET_M_MIX_NESTED: error encountered'
!      CALL wrf_debug(150, mp_debug)
       get_m_mix_nested = CMPLX(1.0d0,0.0d0)    
      endif

      end function get_m_mix_nested

!+---+-----------------------------------------------------------------+

      COMPLEX*16 FUNCTION get_m_mix (m_a, m_i, m_w, volair, volice,     &
                     volwater, mixingrule, matrix, inclusion, error)

      IMPLICIT NONE

      DOUBLE PRECISION, INTENT(in):: volice, volair, volwater
      COMPLEX*16, INTENT(in):: m_a, m_i, m_w
      CHARACTER(len=*), INTENT(in):: mixingrule, matrix, inclusion
      INTEGER, INTENT(out):: error

      error = 0
      get_m_mix = CMPLX(1.0d0,0.0d0)

      if (mixingrule .eq. 'maxwellgarnett') then
       if (matrix .eq. 'ice') then
        get_m_mix = m_complex_maxwellgarnett(volice, volair, volwater,  &
                           m_i, m_a, m_w, inclusion, error)
       elseif (matrix .eq. 'water') then
        get_m_mix = m_complex_maxwellgarnett(volwater, volair, volice,  &
                           m_w, m_a, m_i, inclusion, error)
       elseif (matrix .eq. 'air') then
        get_m_mix = m_complex_maxwellgarnett(volair, volwater, volice,  &
                           m_a, m_w, m_i, inclusion, error)
       else
        write(mp_debug,*) 'GET_M_MIX: unknown matrix: ', matrix
!       CALL wrf_debug(150, mp_debug)
        error = 1
       endif

      else
       write(mp_debug,*) 'GET_M_MIX: unknown mixingrule: ', mixingrule
!      CALL wrf_debug(150, mp_debug)
       error = 2
      endif

      if (error .ne. 0) then
       write(mp_debug,*) 'GET_M_MIX: error encountered'
!      CALL wrf_debug(150, mp_debug)
      endif

      END FUNCTION get_m_mix

!+---+-----------------------------------------------------------------+

      COMPLEX*16 FUNCTION m_complex_maxwellgarnett(vol1, vol2, vol3,    &
                     m1, m2, m3, inclusion, error)

      IMPLICIT NONE

      COMPLEX*16 :: m1, m2, m3
      DOUBLE PRECISION :: vol1, vol2, vol3
      CHARACTER(len=*) :: inclusion

      COMPLEX*16 :: beta2, beta3, m1t, m2t, m3t
      INTEGER, INTENT(out) :: error

      error = 0

      if (DABS(vol1+vol2+vol3-1.0d0) .gt. 1d-6) then
       write(mp_debug,*) 'M_COMPLEX_MAXWELLGARNETT: sum of the ',       &
              'partial volume fractions is not 1...ERROR'
!      CALL wrf_debug(150, mp_debug)
       m_complex_maxwellgarnett=CMPLX(-999.99d0,-999.99d0)
       error = 1
       return
      endif

      m1t = m1**2
      m2t = m2**2
      m3t = m3**2

      if (inclusion .eq. 'spherical') then
       beta2 = 3.0d0*m1t/(m2t+2.0d0*m1t)
       beta3 = 3.0d0*m1t/(m3t+2.0d0*m1t)
      elseif (inclusion .eq. 'spheroidal') then
       beta2 = 2.0d0*m1t/(m2t-m1t) * (m2t/(m2t-m1t)*LOG(m2t/m1t)-1.0d0)
       beta3 = 2.0d0*m1t/(m3t-m1t) * (m3t/(m3t-m1t)*LOG(m3t/m1t)-1.0d0)
      else
       write(mp_debug,*) 'M_COMPLEX_MAXWELLGARNETT: ',                  &
                         'unknown inclusion: ', inclusion
!      CALL wrf_debug(150, mp_debug)
       m_complex_maxwellgarnett=DCMPLX(-999.99d0,-999.99d0)
       error = 1
       return
      endif

      m_complex_maxwellgarnett = &
       SQRT(((1.0d0-vol2-vol3)*m1t + vol2*beta2*m2t + vol3*beta3*m3t) / &
       (1.0d0-vol2-vol3+vol2*beta2+vol3*beta3))

      END FUNCTION m_complex_maxwellgarnett

!+---+-----------------------------------------------------------------+
END MODULE module_mp_thompson

turbtke.F/      1298670057  19071 8000  100644  100173    `


      subroutine turbtke(dt,dodrag,dosfcflx,ruh,rvh,rmh,mf,rmf,th0,thflux,qvflux,rth0s,    &
                         nm,defsq,defh,tk,lenscl,lenh,grdscl,rgrdscl,   &
                         kmh,kmv,khh,khv,tkea,tketen,t13,t23,ua,va)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real :: dt
      logical, intent(in) :: dodrag,dosfcflx
      real, dimension(ib:ie) :: ruh
      real, dimension(jb:je) :: rvh
      real, dimension(ib:ie,jb:je,kb:ke) :: rmh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf,rmf
      real, dimension(ib:ie,jb:je,kb:ke) :: th0
      real, dimension(ib:ie,jb:je) :: thflux,qvflux,rth0s
      real, dimension(ib:ie,jb:je,kb:ke) :: nm,defsq,defh,tk,   &
                                            lenscl,lenh,grdscl,rgrdscl
      real, dimension(ibc:iec,jbc:jec,kbc:kec) :: kmh,kmv,khh,khv
      real, dimension(ibt:iet,jbt:jet,kbt:ket) :: tkea,tketen
      real, dimension(ib:ie,jb:je,kb:ke) :: t13,t23
      real, dimension(ib:ie+1,jb:je,kb:ke) :: ua
      real, dimension(ib:ie,jb:je+1,kb:ke) :: va

!----------------------------------------

      integer i,j,k
      real prinv,tem,tem1,tem2,tem3

#ifdef MPI
      integer reqs_khc(8)
      integer reqs_kvc(8)
      integer reqs_khd(8)
      integer reqs_kvd(8)
      real, dimension(nj,nk+1) :: khcw1,khcw2,khce1,khce2
      real, dimension(nj,nk+1) :: kvcw1,kvcw2,kvce1,kvce2
      real, dimension(ni,nk+1) :: khcs1,khcs2,khcn1,khcn2
      real, dimension(ni,nk+1) :: kvcs1,kvcs2,kvcn1,kvcn2
      real, dimension(nj,nk+1) :: khdw1,khdw2,khde1,khde2
      real, dimension(nj,nk+1) :: kvdw1,kvdw2,kvde1,kvde2
      real, dimension(ni,nk+1) :: khds1,khds2,khdn1,khdn2
      real, dimension(ni,nk+1) :: kvds1,kvds2,kvdn1,kvdn2
#endif

!------------------------------------------------------------------
!  get grid scale

    IF(tconfig.eq.1)THEN
      ! single length scale:  appropriate if dx,dy are nearly the same as dz

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk+1
      do j=1,nj
      do i=1,ni
        grdscl(i,j,k)=(dx*ruh(i)*dy*rvh(j)*dz*rmf(i,j,k))**0.33333333
        rgrdscl(i,j,k)=1.0/grdscl(i,j,k)
      enddo
      enddo
      enddo

    ELSEIF(tconfig.eq.2)THEN
      ! two length scales:  one for horizontal, one for vertical

!$omp parallel do default(shared)   &
!$omp private(i,j,k,tem)
      do j=1,nj
      do i=1,ni
        tem=sqrt(dx*ruh(i)*dy*rvh(j))
        do k=1,nkt
          lenh(i,j,k)=tem
        enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk+1
      do j=1,nj
      do i=1,ni
        grdscl(i,j,k)=dz*rmf(i,j,k)
        rgrdscl(i,j,k)=1.0/grdscl(i,j,k)
      enddo
      enddo
      enddo

    ENDIF

!------------------------------------------------------------------
!  Get turbulence length scale

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nkt
      do j=1,nj
      do i=1,ni
        tk(i,j,k)=max(tkea(i,j,k),1.0e-6)
        lenscl(i,j,k)=grdscl(i,j,k)
        if(nm(i,j,k).gt.1.0e-6)then
          lenscl(i,j,k)=0.8165*sqrt(tk(i,j,k)/nm(i,j,k))
          lenscl(i,j,k)=min(lenscl(i,j,k),grdscl(i,j,k))
          lenscl(i,j,k)=max(lenscl(i,j,k),1.0e-6*grdscl(i,j,k))
        endif 
      enddo
      enddo
      enddo

!----------------------------------------------
!  Get km, kh

    IF(tconfig.eq.1)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k,prinv)
      do k=1,nkt
      do j=1,nj
      do i=1,ni
        kmh(i,j,k)=0.10*sqrt(tk(i,j,k))*lenscl(i,j,k)
        kmv(i,j,k)=kmh(i,j,k)
        prinv=3.00
        if(nm(i,j,k).gt.1.0e-6)then
          prinv=min(1.0+2.00*lenscl(i,j,k)*rgrdscl(i,j,k),3.00)
        endif
        khh(i,j,k)=kmh(i,j,k)*prinv
        khv(i,j,k)=khh(i,j,k)
      enddo
      enddo
      enddo

    ELSEIF(tconfig.eq.2)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k,prinv)
      do k=1,nkt
      do j=1,nj
      do i=1,ni
        kmh(i,j,k)=0.10*sqrt(tk(i,j,k))*lenh(i,j,k)
        kmv(i,j,k)=0.10*sqrt(tk(i,j,k))*lenscl(i,j,k)
        prinv=3.00
        if(nm(i,j,k).gt.1.0e-6)then
          prinv=min(1.0+2.00*lenscl(i,j,k)*rgrdscl(i,j,k),3.00)
        endif
        khh(i,j,k)=kmh(i,j,k)*prinv
        khv(i,j,k)=kmv(i,j,k)*prinv
      enddo
      enddo
      enddo

    ENDIF

!------------------------------------------------------------
!  Buoyancy Term

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nkt
      do j=1,nj
      do i=1,ni
        tketen(i,j,k)=tketen(i,j,k)-khv(i,j,k)*nm(i,j,k)
      enddo
      enddo
      enddo

      IF(dosfcflx)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          tketen(i,j,1)=tketen(i,j,1)   &
                       +g*( thflux(i,j)*rth0s(i,j)+repsm1*qvflux(i,j) )
        enddo
        enddo

      ENDIF

!------------------------------------------------------------
! Shear term 

    IF(tconfig.eq.1)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni
        tketen(i,j,k)=tketen(i,j,k)+kmv(i,j,k)*(defsq(i,j,k)+defh(i,j,k))
      enddo
      enddo
      enddo

    ELSEIF(tconfig.eq.2)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni
        tketen(i,j,k)=tketen(i,j,k)+kmv(i,j,k)*defsq(i,j,k)   &
                                   +kmh(i,j,k)*defh(i,j,k)
      enddo
      enddo
      enddo

    ENDIF

    IF(bcturbu.eq.3)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j)
      do j=1,nj
      do i=1,ni
        tketen(i,j,1)=tketen(i,j,1)+(              &
                      ( t13(i  ,j,1)*ua(i  ,j,1)     &
                       +t13(i+1,j,1)*ua(i+1,j,1) )   &
                    + ( t23(i,j  ,1)*va(i,j  ,1)     &
                       +t23(i,j+1,1)*va(i,j+1,1) )   &
                                    )*rdz*mf(i,j,1)
      enddo
      enddo

    ENDIF

!------------------------------------------------------------
!  limit for numerical stability:

      tem1 = 0.125*dx*dx/dt
      tem2 = 0.125*dy*dy/dt

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nkt
      do j=1,nj
      do i=1,ni
        kmh(i,j,k) = min( kmh(i,j,k) , tem1*ruh(i)*ruh(i) , tem2*rvh(j)*rvh(j) )
        khh(i,j,k) = min( khh(i,j,k) , tem1*ruh(i)*ruh(i) , tem2*rvh(j)*rvh(j) )
      enddo
      enddo
      enddo

!------------------------------------------------------------
! Set values at boundaries

      if(timestats.ge.1) time_turb=time_turb+mytime()
      call bct(kmh)
      call bct(kmv)
#ifdef MPI
      call comm_1t_start(kmh,khcw1,khcw2,khce1,khce2,   &
                             khcs1,khcs2,khcn1,khcn2,reqs_khc)
      call comm_1t_start(kmv,kvcw1,kvcw2,kvce1,kvce2,   &
                             kvcs1,kvcs2,kvcn1,kvcn2,reqs_kvc)
#endif
      call bct(khh)
      call bct(khv)
#ifdef MPI
      call comm_1t_start(khh,khdw1,khdw2,khde1,khde2,   &
                             khds1,khds2,khdn1,khdn2,reqs_khd)
      call comm_1t_start(khv,kvdw1,kvdw2,kvde1,kvde2,   &
                             kvds1,kvds2,kvdn1,kvdn2,reqs_kvd)
#endif

!------------------------------------------------------------
!  Dissipation Term

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nkt
      do j=1,nj
      do i=1,ni
        tketen(i,j,k)=tketen(i,j,k)                           &
                     -(0.191+0.796*lenscl(i,j,k)*rgrdscl(i,j,k))*   &
                      tk(i,j,k)*sqrt(tk(i,j,k))/lenscl(i,j,k)
      enddo
      enddo
      enddo
      if(timestats.ge.1) time_turb=time_turb+mytime()

#ifdef MPI
!--------------------------------------------------------------

      call comm_1t_end(kmh,khcw1,khcw2,khce1,khce2,   &
                           khcs1,khcs2,khcn1,khcn2,reqs_khc)
      call bct2(kmh)
      call getcornert(kmh)
      call comm_1t_end(kmv,kvcw1,kvcw2,kvce1,kvce2,   &
                           kvcs1,kvcs2,kvcn1,kvcn2,reqs_kvc)
      call bct2(kmv)
      call getcornert(kmv)
      call comm_1t_end(khh,khdw1,khdw2,khde1,khde2,   &
                           khds1,khds2,khdn1,khdn2,reqs_khd)
      call comm_1t_end(khv,kvdw1,kvdw2,kvde1,kvde2,   &
                           kvds1,kvds2,kvdn1,kvdn2,reqs_kvd)
#endif
!--------------------------------------------------------------
!  finished
      
      return
      end


!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC


      subroutine turbsmag(dt,dodrag,dosfcflx,ruh,rvh,rmh,mf,rmf,th0,thflux,qvflux,rth0s,  &
                          nm,defsq,defh,lenscl,grdscl,lenh,            &
                          kmh,kmv,khh,khv,t13,t23,ua,va)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real :: dt
      logical, intent(in) :: dodrag,dosfcflx
      real, dimension(ib:ie) :: ruh
      real, dimension(jb:je) :: rvh
      real, dimension(ib:ie,jb:je,kb:ke) :: rmh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf,rmf
      real, dimension(ib:ie,jb:je,kb:ke) :: th0
      real, dimension(ib:ie,jb:je) :: thflux,qvflux,rth0s
      real, dimension(ib:ie,jb:je,kb:ke) :: nm,defsq,defh,lenscl,grdscl,lenh
      real, dimension(ibc:iec,jbc:jec,kbc:kec) :: kmh,kmv,khh,khv
      real, dimension(ib:ie,jb:je,kb:ke) :: t13,t23
      real, dimension(ib:ie+1,jb:je,kb:ke) :: ua
      real, dimension(ib:ie,jb:je+1,kb:ke) :: va

      integer i,j,k
      real :: tem,tem1,tem2,tem3

#ifdef MPI
      integer reqs_khc(8)
      integer reqs_kvc(8)
      real, dimension(nj,nk+1) :: khcw1,khcw2,khce1,khce2
      real, dimension(nj,nk+1) :: kvcw1,kvcw2,kvce1,kvce2
      real, dimension(ni,nk+1) :: khcs1,khcs2,khcn1,khcn2
      real, dimension(ni,nk+1) :: kvcs1,kvcs2,kvcn1,kvcn2
#endif

      real, parameter :: cs      = 0.18
      real, parameter :: prandtl = 1.0/3.00
      real, parameter :: prinv   = 1.0/prandtl

!!!      real, parameter :: c_m = 0.0856
!!!      real, parameter :: c_h = 0.214
!!!      real, parameter :: c_l = 0.816
!!!      real, parameter :: ce1 = 0.191
!!!      real, parameter :: ce2 = 0.654
!!!      real, parameter :: ric = 0.23

!-----------------------------------------------------------------------

    IF(tconfig.eq.1)THEN
      ! single length scale:  appropriate if dx,dy are nearly the same as dz

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk+1
      do j=1,nj
      do i=1,ni
        grdscl(i,j,k)=(dx*ruh(i)*dy*rvh(j)*dz*rmf(i,j,k))**0.33333333
      enddo
      enddo
      enddo

    ELSEIF(tconfig.eq.2)THEN
      ! two length scales:  one for horizontal, one for vertical

!$omp parallel do default(shared)   &
!$omp private(i,j,k,tem)
      do j=1,nj
      do i=1,ni
        tem=sqrt(dx*ruh(i)*dy*rvh(j))
        do k=1,nkt
          lenh(i,j,k)=tem
        enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk+1
      do j=1,nj
      do i=1,ni
        grdscl(i,j,k)=dz*rmf(i,j,k)
      enddo
      enddo
      enddo

    ENDIF

!-----------------------------------------------------------------------
!  Interior points:

    IF(tconfig.eq.1)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nkt-1
      do j=1,nj
      do i=1,ni
        kmh(i,j,k)=((cs*grdscl(i,j,k))**2)     &
                 *sqrt( max(defsq(i,j,k)+defh(i,j,k)-nm(i,j,k)*prinv,0.0) )
        kmv(i,j,k)=kmh(i,j,k)
      enddo
      enddo
      enddo

    ELSEIF(tconfig.eq.2)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nkt-1
      do j=1,nj
      do i=1,ni
        kmh(i,j,k)=((cs*lenh(i,j,k))**2)     &
                 *sqrt( max(defh(i,j,k),0.0) )
        kmv(i,j,k)=((cs*grdscl(i,j,k))**2)     &
                 *sqrt( max(defsq(i,j,k)-nm(i,j,k)*prinv,0.0) )
      enddo
      enddo
      enddo

    ENDIF

!------------------------------------------------------------
!  Surface:

    IF(bcturbu.eq.1.or.bcturbu.eq.2)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,tem1,tem2)
      do j=1,nj
      do i=1,ni
        kmh(i,j,1) = kmh(i,j,2)
        tem1 = 0.0
      IF(dosfcflx)THEN
        tem2 = g*( thflux(i,j)*rth0s(i,j)+repsm1*qvflux(i,j) )
      ELSE
        tem2 = 0.0
      ENDIF
        kmv(i,j,1) = ( ((cs*grdscl(i,j,1))**4)*max(tem1+tem2,0.0) )**0.33333333
      enddo
      enddo

    ELSEIF(bcturbu.eq.3)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,tem1,tem2)
      do j=1,nj
      do i=1,ni
        kmh(i,j,1) = 0.0
        tem1 = ( ( t13(i  ,j,1)*ua(i  ,j,1)     &
                  +t13(i+1,j,1)*ua(i+1,j,1) )   &
               + ( t23(i,j  ,1)*va(i,j  ,1)     &
                  +t23(i,j+1,1)*va(i,j+1,1) )   &
               )*rdz*mf(i,j,1)
      IF(dosfcflx)THEN
        tem2 = g*( thflux(i,j)*rth0s(i,j)+repsm1*qvflux(i,j) )
      ELSE
        tem2 = 0.0
      ENDIF
        kmv(i,j,1) = ( ((cs*grdscl(i,j,1))**4)*max(tem1+tem2,0.0) )**0.33333333
      enddo
      enddo

    ENDIF

!------------------------------------------------------------
!  Top of domain:

!$omp parallel do default(shared)   &
!$omp private(i,j)
      do j=1,nj
      do i=1,ni
        kmh(i,j,nkt) = 0.0
        kmv(i,j,nkt) = 0.0
      enddo
      enddo

!--------------------------------------------------------------

      if(timestats.ge.1) time_turb=time_turb+mytime()
      call bct(kmh)
      call bct(kmv)
#ifdef MPI
      call comm_1t_start(kmh,khcw1,khcw2,khce1,khce2,   &
                             khcs1,khcs2,khcn1,khcn2,reqs_khc)
      call comm_1t_start(kmv,kvcw1,kvcw2,kvce1,kvce2,   &
                             kvcs1,kvcs2,kvcn1,kvcn2,reqs_kvc)
      call comm_1t_end(kmh,khcw1,khcw2,khce1,khce2,   &
                           khcs1,khcs2,khcn1,khcn2,reqs_khc)
      call bct2(kmh)
      call getcornert(kmh)
      call comm_1t_end(kmv,kvcw1,kvcw2,kvce1,kvce2,   &
                           kvcs1,kvcs2,kvcn1,kvcn2,reqs_kvc)
      call bct2(kmv)
      call getcornert(kmv)
#endif

!--------------------------------------------------------------

      tem1 = 0.125*dx*dx/dt
      tem2 = 0.125*dy*dy/dt

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nkt+1
      do j=0,nj+1
      do i=0,ni+1
        khh(i,j,k)=kmh(i,j,k)*prinv
        ! limit for numerical stability:
        khh(i,j,k) = min( khh(i,j,k) , tem1*ruh(i)*ruh(i)   &
                                     , tem2*rvh(j)*rvh(j) )
        kmh(i,j,k) = min( kmh(i,j,k) , tem1*ruh(i)*ruh(i)   &
                                     , tem2*rvh(j)*rvh(j) )
        khv(i,j,k)=kmv(i,j,k)*prinv
      enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
      do j=0,nj+1
      do i=0,ni+1
        khh(i,j,0)=kmh(i,j,0)
        khh(i,j,1)=kmh(i,j,1)
        khv(i,j,0)=kmv(i,j,0)
        khv(i,j,1)=kmv(i,j,1)
      enddo
      enddo

!--------------------------------------------------------------

      if(timestats.ge.1) time_turb=time_turb+mytime()

      return
      end


!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC


      subroutine turbparam(nstep,zf,dt,dodrag,dosfcflx,ruh,rvh,rmh,mf,rmf,th0,thflux,qvflux,rth0s,  &
                             nm,defsq,defh,kmh,kmv,khh,khv,t13,t23,ua,va)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      integer, intent(in) :: nstep
      real, intent(in), dimension(ib:ie,jb:je,kb:ke+1) :: zf
      real :: dt
      logical, intent(in) :: dodrag,dosfcflx
      real, dimension(ib:ie) :: ruh
      real, dimension(jb:je) :: rvh
      real, dimension(ib:ie,jb:je,kb:ke) :: rmh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf,rmf
      real, dimension(ib:ie,jb:je,kb:ke) :: th0
      real, dimension(ib:ie,jb:je) :: thflux,qvflux,rth0s
      real, dimension(ib:ie,jb:je,kb:ke) :: nm,defsq,defh
      real, dimension(ibc:iec,jbc:jec,kbc:kec) :: kmh,kmv,khh,khv
      real, dimension(ib:ie,jb:je,kb:ke) :: t13,t23
      real, dimension(ib:ie+1,jb:je,kb:ke) :: ua
      real, dimension(ib:ie,jb:je+1,kb:ke) :: va

      integer i,j,k
      real :: tem1,tem2,tem3

#ifdef MPI
      integer reqs_khc(8)
      integer reqs_kvc(8)
      real, dimension(nj,nk+1) :: khcw1,khcw2,khce1,khce2
      real, dimension(nj,nk+1) :: kvcw1,kvcw2,kvce1,kvce2
      real, dimension(ni,nk+1) :: khcs1,khcs2,khcn1,khcn2
      real, dimension(ni,nk+1) :: kvcs1,kvcs2,kvcn1,kvcn2
#endif

      real, parameter :: prandtl = 1.0

      real, parameter :: prinv   = 1.0/prandtl

!--------------------------------------------------------------
!  Smagorinsky-type scheme for parameterized turbulence:
!--------------------------------------------------------------
!  Interior:

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
    do k=2,nk
    do j=1,nj
    do i=1,ni
      kmh(i,j,k)=(l_h**2)*sqrt( defh(i,j,k) )
      kmv(i,j,k)=(l_v**2)*sqrt( max(defsq(i,j,k)-nm(i,j,k)*prinv,0.0) )
    enddo
    enddo
    enddo

!--------------------------------------------------------------
!  Surface:

    IF(bcturbu.eq.1.or.bcturbu.eq.2)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,tem1,tem2)
      do j=1,nj
      do i=1,ni
        kmh(i,j,1) = kmh(i,j,2)
        tem1 = 0.0
      IF(dosfcflx)THEN
        tem2 = g*( thflux(i,j)*rth0s(i,j)+repsm1*qvflux(i,j) )
      ELSE
        tem2 = 0.0
      ENDIF
        kmv(i,j,1) = ( (l_v**4)*max(tem1+tem2,0.0) )**0.33333333
!!!        kmv(i,j,1) = ( (0.0**4)*max(tem1+tem2,0.0) )**0.33333333
      enddo
      enddo

    ELSEIF(bcturbu.eq.3)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,tem1,tem2)
      do j=1,nj
      do i=1,ni
        kmh(i,j,1) = 0.0
        tem1 = ( ( t13(i  ,j,1)*ua(i  ,j,1)     &
                  +t13(i+1,j,1)*ua(i+1,j,1) )   &
               + ( t23(i,j  ,1)*va(i,j  ,1)     &
                  +t23(i,j+1,1)*va(i,j+1,1) )   &
               )*rdz*mf(i,j,1)
      IF(dosfcflx)THEN
        tem2 = g*( thflux(i,j)*rth0s(i,j)+repsm1*qvflux(i,j) )
      ELSE
        tem2 = 0.0
      ENDIF
        kmv(i,j,1) = ( (l_v**4)*max(tem1+tem2,0.0) )**0.33333333
!!!        kmv(i,j,1) = ( (0.0**4)*max(tem1+tem2,0.0) )**0.33333333
      enddo
      enddo

    ENDIF

!------------------------------------------------------------
!  Top of domain:
!  something simple, for now:

!$omp parallel do default(shared)   &
!$omp private(i,j,tem1,tem2)
      do j=1,nj
      do i=1,ni
        kmh(i,j,  1) = 0.0
        kmv(i,j,  1) = 0.0
        kmh(i,j,nkt) = 0.0
        kmv(i,j,nkt) = 0.0
      enddo
      enddo

!--------------------------------------------------------------
! boundary conditions:

      if(timestats.ge.1) time_turb=time_turb+mytime()
      call bct(kmh)
      call bct(kmv)
#ifdef MPI
      call comm_1t_start(kmh,khcw1,khcw2,khce1,khce2,   &
                             khcs1,khcs2,khcn1,khcn2,reqs_khc)
      call comm_1t_start(kmv,kvcw1,kvcw2,kvce1,kvce2,   &
                             kvcs1,kvcs2,kvcn1,kvcn2,reqs_kvc)
      call comm_1t_end(kmh,khcw1,khcw2,khce1,khce2,   &
                           khcs1,khcs2,khcn1,khcn2,reqs_khc)
      call bct2(kmh)
      call getcornert(kmh)
      call comm_1t_end(kmv,kvcw1,kvcw2,kvce1,kvce2,   &
                           kvcs1,kvcs2,kvcn1,kvcn2,reqs_kvc)
      call bct2(kmv)
      call getcornert(kmv)
#endif

!--------------------------------------------------------------
!  calculate Kh
!  and also limit horizontal coeffs for numerical stability:

      tem1 = 0.125*dx*dx/dt
      tem2 = 0.125*dy*dy/dt

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=0,nkt+1
      do j=0,nj+1
      do i=0,ni+1
        khh(i,j,k)=kmh(i,j,k)*prinv
        khh(i,j,k) = min( khh(i,j,k) , tem1*ruh(i)*ruh(i) , tem2*rvh(j)*rvh(j) )
        kmh(i,j,k) = min( kmh(i,j,k) , tem1*ruh(i)*ruh(i) , tem2*rvh(j)*rvh(j) )
        khv(i,j,k)=kmv(i,j,k)*prinv
      enddo
      enddo
      enddo

!!$omp parallel do default(shared)   &
!!$omp private(i,j)
!      do j=0,nj+1
!      do i=0,ni+1
!        khh(i,j,0)=kmh(i,j,0)
!        khh(i,j,1)=kmh(i,j,1)
!        khv(i,j,0)=kmv(i,j,0)
!        khv(i,j,1)=kmv(i,j,1)
!      enddo
!      enddo

!--------------------------------------------------------------

      if(timestats.ge.1) time_turb=time_turb+mytime()

      return
      end


!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC


      subroutine gettau(dodrag,xf,rxf,rho0,rf0,kmh,kmv,t11,t12,t13,t22,t23,t33,ua)
      implicit none
      
      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      logical, intent(in) :: dodrag
      real, dimension(ib:ie+1) :: xf,rxf
      real, dimension(ib:ie,jb:je,kb:ke) :: rho0,rf0
      real, dimension(ibc:iec,jbc:jec,kbc:kec) :: kmh,kmv
      real, dimension(ib:ie,jb:je,kb:ke) :: t11,t12,t13,t22,t23,t33
      real, dimension(ib:ie+1,jb:je,kb:ke) :: ua
        
      integer i,j,k

!-----------------------------------------------------------------------
! Note:  turb coefficients are now defined on w points

    IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=0,nj+1
      do i=0,ni+1
        t11(i,j,k)=t11(i,j,k)*(kmh(i,j,k)+kmh(i,j,k+1))*rho0(i,j,k)
        t22(i,j,k)=t22(i,j,k)*(kmh(i,j,k)+kmh(i,j,k+1))*rho0(i,j,k)
        t33(i,j,k)=t33(i,j,k)*(kmv(i,j,k)+kmv(i,j,k+1))*rho0(i,j,k)
      enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj+1
      do i=1,ni+1
        t12(i,j,k)=t12(i,j,k)*0.03125                                         &
     *( ( (kmh(i-1,j-1,k  )+kmh(i,j,k  ))+(kmh(i-1,j,k  )+kmh(i,j-1,k  )) )   &
       +( (kmh(i-1,j-1,k+1)+kmh(i,j,k+1))+(kmh(i-1,j,k+1)+kmh(i,j-1,k+1)) ) ) &
           *( (rho0(i-1,j-1,k)+rho0(i,j,k))+(rho0(i-1,j,k)+rho0(i,j-1,k)) )
      enddo
      enddo
      enddo

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=0,ni+1
        t11(i,j,k)=t11(i,j,k)*(kmh(i,j,k)+kmh(i,j,k+1))*rho0(i,j,k)
        t33(i,j,k)=t33(i,j,k)*(kmv(i,j,k)+kmv(i,j,k+1))*rho0(i,j,k)
      enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=2,ni+1
        t22(i,j,k)=2.0*rho0(1,1,k)     &
                  *0.25*(kmh(i-1,j,k)+kmh(i,j,k)+kmh(i-1,j,k+1)+kmh(i,j,k+1))  &
                  *ua(i,j,k)*rxf(i)
      enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=2,ni+1
        t12(i,j,k)=t12(i,j,k)*rho0(1,1,k)   &
                  *0.25*(kmh(i,j,k+1)+kmh(i,j,k)+kmh(i-1,j,k+1)+kmh(i-1,j,k))
      enddo
      enddo
      enddo

    ENDIF

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj+1
      do i=1,ni+1
        t13(i,j,k)=t13(i,j,k)*0.25        &
           *( kmv(i-1,j,k)+kmv(i,j,k) )   &
           *( rf0(i-1,j,k)+rf0(i,j,k) )
        t23(i,j,k)=t23(i,j,k)*0.25        &
           *( kmv(i,j-1,k)+kmv(i,j,k) )   &
           *( rf0(i,j-1,k)+rf0(i,j,k) )
      enddo
      enddo
      enddo

!--------------------------------------------------------------
!  lateral boundary conditions for axisymmetric simulations

    IF(axisymm.eq.1)THEN

!$omp parallel do default(shared)   &
!$omp private(k)
      do k=1,nk
        t22(1,1,k)=0.0
      enddo

!$omp parallel do default(shared)   &
!$omp private(k)
      do k=1,nk
        t12(1,1,k)=0.0
      enddo

!$omp parallel do default(shared)   &
!$omp private(k)
      do k=1,nk+1
        t13(1,1,k)=0.0
      enddo

    ENDIF

!--------------------------------------------------------------
!  lower boundary conditions

    IF(dodrag)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j)
      do j=1,nj
      do i=1,ni+1
        t13(i,j,1)=t13(i,j,1)*0.5*(rf0(i-1,j,1)+rf0(i,j,1))
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
      do j=1,nj+1
      do i=1,ni
        t23(i,j,1)=t23(i,j,1)*0.5*(rf0(i,j-1,1)+rf0(i,j,1))
      enddo
      enddo

    ELSE

      IF(bcturbu.eq.1)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni+1
          t13(i,j,1)=0.0
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj+1
        do i=1,ni
          t23(i,j,1)=0.0
        enddo
        enddo

      ELSEIF(bcturbu.eq.2)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni+1
          t13(i,j,1)=t13(i,j,2)
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj+1
        do i=1,ni
          t23(i,j,1)=t23(i,j,2)
        enddo
        enddo

      ENDIF

    ENDIF

!--------------------------------------------------------------
!  upper boundary conditions

      IF(bcturbu.eq.1)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni+1
          t13(i,j,nk+1)=0.0
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj+1
        do i=1,ni
          t23(i,j,nk+1)=0.0
        enddo
        enddo

      ELSEIF(bcturbu.eq.2)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni+1
          t13(i,j,nk+1)=t13(i,j,nk)
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj+1
        do i=1,ni
          t23(i,j,nk+1)=t23(i,j,nk)
        enddo
        enddo

      ENDIF

!--------------------------------------------------------------
!  finished

      if(timestats.ge.1) time_turb=time_turb+mytime()
 
      return
      end


!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC


      subroutine calcdef(dodrag,xh,rxh,uh,xf,rxf,uf,vh,vf,mh,mf,defsq,defh,   &
                         dum3,dum4,ua,va,wa,t11,t12,t13,t22,t23,t33,gx,gy)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      logical, intent(in) :: dodrag
      real, dimension(ib:ie) :: xh,rxh,uh
      real, dimension(ib:ie+1) :: xf,rxf,uf
      real, dimension(jb:je) :: vh
      real, dimension(jb:je+1) :: vf
      real, dimension(ib:ie,jb:je,kb:ke) :: mh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, dimension(ib:ie,jb:je,kb:ke) :: defsq,defh,dum3,dum4
      real, dimension(ib:ie+1,jb:je,kb:ke) :: ua
      real, dimension(ib:ie,jb:je+1,kb:ke) :: va
      real, dimension(ib:ie,jb:je,kb:ke+1) :: wa
      real, dimension(ib:ie,jb:je,kb:ke) :: t11,t12,t13,t22,t23,t33
      real, dimension(itb:ite+1,jtb:jte,ktb:kte) :: gx
      real, dimension(itb:ite,jtb:jte+1,ktb:kte) :: gy
        
      integer i,j,k
      real :: tmp11,tmp22,tmp33,tmp12,tmp13,tmp23

!----------------------------------------------------------------------
!
!  Reference:  Mason, 1989, JAS, p. 1497
!
!----------------------------------------------------------------------
!  First, calculations assuming no terrain:

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=0,ni+1 
        t11(i,j,k)=(ua(i+1,j,k)-ua(i,j,k))*rdx*uh(i)
      enddo
      enddo
      enddo

    IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj+1 
      do i=1,ni+1
        t12(i,j,k)=(ua(i,j,k)-ua(i,j-1,k))*rdy*vf(j)   &
                  +(va(i,j,k)-va(i-1,j,k))*rdx*uf(i)
      enddo
      enddo
      enddo       

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=2,ni+1
        t12(i,j,k)=xf(i)*(va(i,j,k)*rxh(i)-va(i-1,j,k)*rxh(i-1))*rdx*uf(i)
      enddo
      enddo
      enddo

    ENDIF

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni+1
        t13(i,j,k)=(wa(i,j,k)-wa(i-1,j,k))*rdx*uf(i)   &
                  +(ua(i,j,k)-ua(i,j,k-1))*rdz*0.5*(mf(i-1,j,k)+mf(i,j,k))
      enddo
      enddo
      enddo

    IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=0,nj+1
      do i=1,ni
        t22(i,j,k)=(va(i,j+1,k)-va(i,j,k))*rdy*vh(j)
      enddo
      enddo
      enddo

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=2,ni+1
        t22(i,j,k)=ua(i,j,k)*rxf(i)
      enddo
      enddo
      enddo

    ENDIF

    IF(axisymm.eq.0)THEN
      
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj+1   
      do i=1,ni
        t23(i,j,k)=(wa(i,j,k)-wa(i,j-1,k))*rdy*vf(j)   &
                  +(va(i,j,k)-va(i,j,k-1))*rdz*0.5*(mf(i,j-1,k)+mf(i,j,k))
      enddo
      enddo
      enddo

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj   
      do i=1,ni
        t23(i,j,k)=(va(i,j,k)-va(i,j,k-1))*rdz*mf(1,1,k)
      enddo
      enddo
      enddo

    ENDIF
      
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        t33(i,j,k)=(wa(i,j,k+1)-wa(i,j,k))*rdz*mh(i,j,k)
      enddo
      enddo
      enddo

!------------------------------------------------------------------
!  lateral boundary conditions for axisymmetric simulations

    IF(axisymm.eq.1)THEN

!$omp parallel do default(shared)   &
!$omp private(k)
      do k=1,nk
        t22(1,1,k)=0.0
      enddo

!$omp parallel do default(shared)   &
!$omp private(k)
      do k=1,nk
        t12(1,1,k)=0.0
      enddo

!$omp parallel do default(shared)   &
!$omp private(k)
      do k=1,nk+1
        t13(1,1,k)=0.0
      enddo

    ENDIF

!------------------------------------------------------------------
!  lower boundary conditions

  IF(.not.dodrag)THEN

    IF(bcturbu.eq.1)THEN
      
!$omp parallel do default(shared)   &
!$omp private(i,j)
      do j=1,nj
      do i=1,ni+1 
        t13(i,j,1)=0.0
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
      do j=1,nj+1
      do i=1,ni
        t23(i,j,1)=0.0
      enddo
      enddo

    ELSEIF(bcturbu.eq.2)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j)
      do j=1,nj
      do i=1,ni+1 
        t13(i,j,1)=t13(i,j,2)
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
      do j=1,nj+1
      do i=1,ni
        t23(i,j,1)=t23(i,j,2)
      enddo
      enddo

    ELSEIF(bcturbu.eq.3)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j)
      do j=1,nj
      do i=1,ni+1
        t13(i,j,1   )= 2.0*ua(i,j,1 )*rdz*0.5*(mf(i-1,j,1   )+mf(i,j,1   ))
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
      do j=1,nj+1   
      do i=1,ni
        t23(i,j,1   )= 2.0*va(i,j,1 )*rdz*0.5*(mf(i,j-1,1   )+mf(i,j,1   ))
      enddo
      enddo

    ENDIF

  ENDIF

!------------------------------------------------------------------
!  upper boundary conditions

    IF(bcturbu.eq.1)THEN
      
!$omp parallel do default(shared)   &
!$omp private(i,j)
      do j=1,nj
      do i=1,ni+1 
        t13(i,j,nk+1)=0.0
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
      do j=1,nj+1
      do i=1,ni
        t23(i,j,nk+1)=0.0
      enddo
      enddo

    ELSEIF(bcturbu.eq.2)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j)
      do j=1,nj
      do i=1,ni+1 
        t13(i,j,nk+1)=t13(i,j,nk)
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
      do j=1,nj+1
      do i=1,ni
        t23(i,j,nk+1)=t23(i,j,nk)
      enddo
      enddo

    ELSEIF(bcturbu.eq.3)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j)
      do j=1,nj
      do i=1,ni+1
        t13(i,j,nk+1)=-2.0*ua(i,j,nk)*rdz*0.5*(mf(i-1,j,nk+1)+mf(i,j,nk+1))
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
      do j=1,nj+1   
      do i=1,ni
        t23(i,j,nk+1)=-2.0*va(i,j,nk)*rdz*0.5*(mf(i,j-1,nk+1)+mf(i,j,nk+1))
      enddo
      enddo

    ENDIF


!------------------------------------------------------------------
!  now, add the "correction" terms for terrain

      IF(terrain_flag)THEN

!-------- t11 --------

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk-1
        do j=1,nj
        do i=0,ni+2
          dum3(i,j,k)=gx(i,j,k)*(ua(i,j,k+1)-ua(i,j,k-1))*rdz2
        enddo
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj
        do i=0,ni+2
          dum3(i,j, 1)=gx(i,j,1 )*(ua(i,j,2 )-ua(i,j,1   ))*rdz
          dum3(i,j,nk)=gx(i,j,nk)*(ua(i,j,nk)-ua(i,j,nk-1))*rdz
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=0,ni+1
          t11(i,j,k)=t11(i,j,k)+0.5*(dum3(i,j,k)+dum3(i+1,j,k))
        enddo
        enddo
        enddo

!-------- t12 --------

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk-1
        do j=0,nj+1
        do i=1,ni+1
          dum3(i,j,k)=(ua(i,j,k+1)-ua(i,j,k-1))*rdz2
        enddo
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=0,nj+1
        do i=1,ni+1
          dum3(i,j,1 )=(ua(i,j,2 )-ua(i,j,1   ))*rdz
          dum3(i,j,nk)=(ua(i,j,nk)-ua(i,j,nk-1))*rdz
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=0,nj+1
        do i=1,ni+1
          dum3(i,j,k)=dum3(i,j,k)*0.25*( gy(i-1,j  ,k)+gy(i,j  ,k)    &
                                        +gy(i-1,j+1,k)+gy(i,j+1,k) )
        enddo
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk-1
        do j=1,nj+1
        do i=0,ni+1
          dum4(i,j,k)=(va(i,j,k+1)-va(i,j,k-1))*rdz2
        enddo
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj+1
        do i=0,ni+1
          dum4(i,j,1 )=(va(i,j,2 )-va(i,j,1   ))*rdz
          dum4(i,j,nk)=(va(i,j,nk)-va(i,j,nk-1))*rdz
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj+1
        do i=0,ni+1
          dum4(i,j,k)=dum4(i,j,k)*0.25*( gx(i  ,j-1,k)+gx(i  ,j,k)    &
                                        +gx(i+1,j-1,k)+gx(i+1,j,k) )
        enddo
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj+1
        do i=1,ni+1
          t12(i,j,k)=t12(i,j,k)+0.5*( (dum3(i,j-1,k)+dum3(i,j,k))  &
                                     +(dum4(i-1,j,k)+dum4(i,j,k)) )
        enddo
        enddo
        enddo

!-------- t13 --------

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=0,ni+1
          dum3(i,j,k)=0.25*( (gx(i,j,k-1)+gx(i+1,j,k-1))     &
                            +(gx(i,j,k  )+gx(i+1,j,k  )) )   &
                     *(wa(i,j,k+1)-wa(i,j,k-1))*rdz2
        enddo
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=1,ni+1
          t13(i,j,k)=t13(i,j,k)+0.5*(dum3(i,j,k)+dum3(i-1,j,k))
        enddo
        enddo
        enddo

!-------- t22 --------

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk-1
        do j=0,nj+2
        do i=1,ni
          dum3(i,j,k)=gy(i,j,k)*(va(i,j,k+1)-va(i,j,k-1))*rdz2
        enddo
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=0,nj+2
        do i=1,ni
          dum3(i,j, 1)=gy(i,j,1 )*(va(i,j,2 )-va(i,j,1   ))*rdz
          dum3(i,j,nk)=gy(i,j,nk)*(va(i,j,nk)-va(i,j,nk-1))*rdz
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=0,nj+1
        do i=1,ni
          t22(i,j,k)=t22(i,j,k)+0.5*(dum3(i,j,k)+dum3(i,j+1,k))
        enddo
        enddo
        enddo

!-------- t23 --------

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=0,nj+1
        do i=1,ni
          dum3(i,j,k)=0.25*( (gy(i,j,k-1)+gy(i,j+1,k-1))     &
                            +(gy(i,j,k  )+gy(i,j+1,k  )) )   &
                     *(wa(i,j,k+1)-wa(i,j,k-1))*rdz2
        enddo
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj+1
        do i=1,ni
          t23(i,j,k)=t23(i,j,k)+0.5*(dum3(i,j,k)+dum3(i,j-1,k))
        enddo
        enddo
        enddo

      ENDIF

!  end of terrain calculations
!----------------------------------------------------------------------
!  if l_h or l_v is zero, set appropriate terms to zero:
!    (just to be sure)

    IF( iturb.eq.3 .and. l_h.lt.tsmall )THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=0,nk+1
      do j=0,nj+1
      do i=0,ni+1
        t11(i,j,k) = 0.0
        t22(i,j,k) = 0.0
        t12(i,j,k) = 0.0
      enddo
      enddo
      enddo
    ENDIF

    IF( iturb.eq.3 .and. l_v.lt.tsmall )THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=0,nk+1
      do j=0,nj+1
      do i=0,ni+1
        t13(i,j,k) = 0.0
        t23(i,j,k) = 0.0
        t33(i,j,k) = 0.0
      enddo
      enddo
      enddo
    ENDIF

!----------------------------------------------------------------------
!  calculate D term:

    IF(axisymm.eq.0)THEN
      ! Cartesian domain:

!$omp parallel do default(shared)   &
!$omp private(i,j,k,tmp11,tmp22,tmp33,tmp12,tmp13,tmp23)
      do k=2,nk
      do j=1,nj
      do i=1,ni

        tmp11=0.5*( t11(i,j,k-1)**2 + t11(i,j,k)**2 )
        tmp22=0.5*( t22(i,j,k-1)**2 + t22(i,j,k)**2 )
        tmp33=0.5*( t33(i,j,k-1)**2 + t33(i,j,k)**2 )

        tmp12=0.125*( ( ( t12(i,j  ,k-1)**2 + t12(i+1,j+1,k-1)**2 )     &
                      + ( t12(i,j+1,k-1)**2 + t12(i+1,j  ,k-1)**2 ) )   &
                     +( ( t12(i,j  ,k  )**2 + t12(i+1,j+1,k  )**2 )     &
                      + ( t12(i,j+1,k  )**2 + t12(i+1,j  ,k  )**2 ) ) )

        tmp13=0.5*( t13(i,j,k)**2 + t13(i+1,j,k)**2 )

        tmp23=0.5*( t23(i,j,k)**2 + t23(i,j+1,k)**2 )

        defsq(i,j,k)= 2.0*( tmp33 ) + ( tmp13 + tmp23 )

        defh(i,j,k) = 2.0*( tmp11 + tmp22 ) + tmp12

      enddo
      enddo
      enddo

!--------------------------------------------
    ELSE
      ! axisymmetric domain:

!$omp parallel do default(shared)   &
!$omp private(i,j,k,tmp11,tmp22,tmp33,tmp12,tmp13,tmp23)
      do k=2,nk
      do j=1,nj
      do i=1,ni

        tmp11=0.5*( t11(i,j,k-1)**2 + t11(i,j,k)**2 )
        tmp22=0.25*( (t22(i,j,k-1)**2 + t22(i+1,j,k-1)**2)  &
                    +(t22(i,j,k  )**2 + t22(i+1,j,k  )**2) )
        tmp33=0.5*( t33(i,j,k-1)**2 + t33(i,j,k)**2 )

        tmp12=0.25*(  ( t12(i,j  ,k-1)**2 + t12(i+1,j  ,k-1)**2 )     &
                    + ( t12(i,j  ,k  )**2 + t12(i+1,j  ,k  )**2 ) )

        tmp13=0.5*( t13(i,j,k)**2 + t13(i+1,j,k)**2 )

        tmp23=      t23(i,j,k)**2

        defsq(i,j,k)= 2.0*( tmp33 ) + tmp13 + tmp23

        defh(i,j,k) = 2.0*( tmp11 + tmp22 ) + tmp12

      enddo
      enddo
      enddo

    ENDIF  ! endif for axisymm

!--------------------------------------------------------------
!  finished

      if(timestats.ge.1) time_turb=time_turb+mytime()

      return
      end


!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC


      subroutine calcnm(mf,pi0,thv0,th0,cloudvar,nm,t,qt,thv,cloud,   &
                        prs,pp,th,qa)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
      include 'goddard.incl'

      logical, dimension(maxq) :: cloudvar
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, dimension(ib:ie,jb:je,kb:ke) :: pi0,thv0,th0
      real, dimension(ib:ie,jb:je,kb:ke) :: nm,t,qt,thv,cloud,prs
      real, dimension(ib:ie,jb:je,kb:ke) :: pp,th
      real, dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: qa

      integer i,j,k,n
      real pavg,tavg,qtavg,qvs,lhv,cpml,gamma,qiavg,qsavg,qgavg,drdt
      real qlavg,qvl,qvi,fliq,fice
      real rslf,rsif

!----------------------------------------------------------------------
!  Dry nm

    IF(imoist.eq.0)then

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni
        nm(i,j,k)=alog( (th0(i,j,k)+th(i,j,k))/(th0(i,j,k-1)+th(i,j,k-1)) ) &
                    *g*rdz*mf(i,j,k)
      enddo
      enddo
      enddo

!$omp parallel do default(shared)  &
!$omp private(i,j)
      do j=1,nj
      do i=1,ni
        nm(i,j,   1)=0.0
        nm(i,j,nk+1)=0.0
      enddo
      enddo

!-----------------------------------------------------------------------
!  Moist nm

    ELSE

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        t(i,j,k)=(th0(i,j,k)+th(i,j,k))*(pi0(i,j,k)+pp(i,j,k))
      enddo
      enddo
      enddo

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        qt(i,j,k)=0.0
      enddo
      enddo
      enddo

      DO n=1,numq
        IF( (n.eq.nqv) .or.                                 &
            (n.ge.nql1.and.n.le.nql2) .or.                  &
            (n.ge.nqs1.and.n.le.nqs2.and.iice.eq.1) )THEN
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            qt(i,j,k)=qt(i,j,k)+qa(i,j,k,n)
          enddo
          enddo
          enddo
        ENDIF
      ENDDO

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        thv(i,j,k)=(th0(i,j,k)+th(i,j,k))*(1.0+reps*qa(i,j,k,nqv))   &
                                         /(1.0+qt(i,j,k))
      enddo
      enddo
      enddo

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni
        nm(i,j,k)=g*alog(thv(i,j,k)/thv(i,j,k-1))*rdz*mf(i,j,k)
      enddo
      enddo
      enddo

!$omp parallel do default(shared)  &
!$omp private(i,j)
      do j=1,nj
      do i=1,ni
        nm(i,j,   1)=0.0
        nm(i,j,nk+1)=0.0
      enddo
      enddo

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        cloud(i,j,k)=0.0
      enddo
      enddo
      enddo
      do n=1,numq
        if(cloudvar(n))then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            cloud(i,j,k)=cloud(i,j,k)+qa(i,j,k,n)
          enddo
          enddo
          enddo
        endif
      enddo

!    IF(iice.eq.0)THEN

!$omp parallel do default(shared)  &
!$omp private(i,j,k,n,pavg,tavg,qtavg,qvs,lhv,cpml,drdt,gamma)
      do k=2,nk
      do j=1,nj
      do i=1,ni
        IF( (cloud(i,j,k).ge.clwsat) .and. (cloud(i,j,k-1).ge.clwsat) )THEN
          pavg =0.5*(prs(i,j,k-1)+prs(i,j,k))
          tavg =0.5*(  t(i,j,k-1)+  t(i,j,k))
          qtavg=0.5*( qt(i,j,k-1)+ qt(i,j,k))
          qvs=rslf(pavg,tavg)
          lhv=lv1-lv2*tavg
          cpml=cp+cpv*qvs+cpl*(qtavg-qvs)

          drdt=17.67*(273.15-29.65)*qvs/((tavg-29.65)**2)
          gamma=g*(1.0+qtavg)*(1.0+lhv*qvs/(rd*tavg))/(cpml+lhv*drdt)
          nm(i,j,k)=g*( ( alog(t(i,j,k)/t(i,j,k-1))*rdz*mf(i,j,k)      &
                            +gamma/tavg )*(1.0+tavg*drdt/(eps+qvs))   &
                         -alog((1.0+qt(i,j,k))/(1.0+qt(i,j,k-1)))*rdz*mf(i,j,k) )
        ENDIF
      enddo
      enddo
      enddo

!    ELSE
!
!!$omp parallel do default(shared)  &
!!$omp private(i,j,k,pavg,tavg,qtavg,qlavg,qvl,qvi,fliq,fice,qvs,cpml,   &
!!$omp lhv,drdt,gamma,n)
!      do k=2,nk
!      do j=1,nj
!      do i=1,ni
!        IF( (cloud(i,j,k).ge.clwsat) .and. (cloud(i,j,k-1).ge.clwsat) )THEN
!          pavg =0.5*(prs(i,j,k-1)+prs(i,j,k))
!          tavg =0.5*(  t(i,j,k-1)+  t(i,j,k))
!          qtavg=0.5*( qt(i,j,k-1)+ qt(i,j,k))
!          qlavg=0.0
!          do n=nql1,nql2
!            qlavg=qlavg+0.5*( qa(i,j,k-1,n)+ qa(i,j,k,n) )
!          enddo
!          qvl=rslf(pavg,tavg)
!          qvi=rsif(pavg,tavg)
!          fliq=max(min((tavg-t00k)*rt0,1.0),0.0)
!          fice=1.0-fliq
!          qvs=fliq*qvl+fice*qvi
!          cpml=cp+cpv*qvs+cpl*qlavg+cpi*(qtavg-qlavg-qvs)
!          lhv=fliq*(lv1-lv2*tavg)+fice*(ls1-ls2*tavg)
!
!          drdt=fliq*17.67*(273.15-29.65)*qvl/((tavg-29.65)**2)    &
!              +fice*21.8745584*(273.15-7.66)*qvi/((tavg-7.66)**2)
!          if(tavg.gt.t00k.and.tavg.lt.t0k)then
!            drdt=drdt+(qvl-qvi)*rt0
!          endif
!          gamma=g*(1.0+qtavg)*(1.0+lhv*qvs/(rd*tavg))/(cpml+lhv*drdt)
!          nm(i,j,k)=g*( ( alog(t(i,j,k)/t(i,j,k-1))*rdz*mf(i,j,k)      &
!                            +gamma/tavg )*(1.0+tavg*drdt/(eps+qvs))   &
!                         -alog((1.0+qt(i,j,k))/(1.0+qt(i,j,k-1)))*rdz*mf(i,j,k) )
!        ENDIF
!      enddo
!      enddo
!      enddo
!
!    ENDIF    ! endif for iice

    ENDIF    ! endif for imoist

!----------------------------------------------------------------------

      if(timestats.ge.1) time_turb=time_turb+mytime()

      return
      end


!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC


      subroutine turbs(iflux,dt,dosfcflx,xh,rxh,uh,xf,uf,vh,vf,mh,mf,rho0,rr0,rf0,sflux,   &
                       turbx,turby,turbz,dum,dsdz,s,sten,khh,khv,gx,gy,doimpl)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      integer iflux
      real :: dt
      logical, intent(in) :: dosfcflx
      real, dimension(ib:ie) :: xh,rxh,uh
      real, dimension(ib:ie+1) :: xf,uf
      real, dimension(jb:je) :: vh
      real, dimension(jb:je+1) :: vf
      real, dimension(ib:ie,jb:je,kb:ke) :: mh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, dimension(ib:ie,jb:je,kb:ke) :: rho0,rr0,rf0
      real, dimension(ib:ie,jb:je) :: sflux
      real, dimension(ib:ie,jb:je,kb:ke) :: turbx,turby,turbz,dum,dsdz,s,sten
      real, dimension(ibc:iec,jbc:jec,kbc:kec) :: khh,khv
      real, dimension(itb:ite+1,jtb:jte,ktb:kte) :: gx
      real, dimension(itb:ite,jtb:jte+1,ktb:kte) :: gy
      logical, dimension(ib:ie,jb:je) :: doimpl

      integer :: i,j,k
      real :: rdt,tema,temb,temc
      real :: tem,r1,r2
      real, dimension(kb:ke) :: dumz
      real, dimension(nk) :: cfa,cfb,cfc,cfd,s2
      real, dimension(nk) :: lgbth,lgbph

!---------------------------------------------------------------
!  calculate and store dsdz

      IF(terrain_flag)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk-1
        do j=0,nj+1
        do i=0,ni+1
          dsdz(i,j,k)=(s(i,j,k+1)-s(i,j,k-1))*rdz2
        enddo
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=0,nj+1
        do i=0,ni+1
          dsdz(i,j,1 )=(s(i,j,2 )-s(i,j,1   ))*rdz
          dsdz(i,j,nk)=(s(i,j,nk)-s(i,j,nk-1))*rdz
        enddo
        enddo

      ENDIF

!---------------------------------------------------------------
!  x-direction

      IF(.not.terrain_flag)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni+1
          dum(i,j,k)= -0.125*( rho0(i,j,k)+rho0(i-1,j,k) )         &
                            *(  (khh(i,j,k  )+ khh(i-1,j,k  ))     &
                               +(khh(i,j,k+1)+ khh(i-1,j,k+1)) )   &
                            *(    s(i,j,k)-   s(i-1,j,k) )*rdx*uf(i)
        enddo
        enddo
        enddo

      ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni+1
          dum(i,j,k)= -0.125*( rho0(i,j,k)+rho0(i-1,j,k) )         &
                            *(  (khh(i,j,k  )+ khh(i-1,j,k  ))     &
                               +(khh(i,j,k+1)+ khh(i-1,j,k+1)) )   &
                           *( (s(i,j,k)-s(i-1,j,k))*rdx*uf(i)      &
                             +gx(i,j,k)*0.5*(dsdz(i-1,j,k)+dsdz(i,j,k)) )
        enddo
        enddo
        enddo

      ENDIF

    IF(axisymm.eq.0)THEN
 
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        turbx(i,j,k)=-(dum(i+1,j,k)-dum(i,j,k))*rdx*uh(i)
      enddo
      enddo
      enddo

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        turbx(i,j,k)=-(xf(i+1)*dum(i+1,j,k)-xf(i)*dum(i,j,k))*rdx*uh(i)*rxh(i)
      enddo
      enddo
      enddo

    ENDIF

      IF(terrain_flag)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=1,ni
          dum(i,j,k)=-khh(i,j,k)*0.5*(rho0(i,j,k-1)+rho0(i,j,k))*(  &
                      0.5*( (s(i+1,j,k)+s(i+1,j,k-1))               &
                           -(s(i-1,j,k)+s(i-1,j,k-1)) )*rdx2        &
                    +0.25*( (gx(i,j,k-1)+gx(i+1,j,k-1))             &
                           +(gx(i,j,k  )+gx(i+1,j,k  )) )           &
                         *( s(i,j,k)-s(i,j,k-1) )*rdz    )
        enddo
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          dum(i,j,1)=0.0
          dum(i,j,nk+1)=0.0
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          turbx(i,j,k)=turbx(i,j,k)-0.5*(gx(i,j,k)+gx(i+1,j,k))   &
                                       *(dum(i,j,k+1)-dum(i,j,k))*rdz
        enddo
        enddo
        enddo

      ENDIF

!---------------------------------------------------------------
!  y-direction

    IF(axisymm.eq.0)THEN

      IF(.not.terrain_flag)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj+1
        do i=1,ni
          dum(i,j,k)= -0.125*( rho0(i,j,k)+rho0(i,j-1,k) )         &
                            *(  (khh(i,j,k  )+ khh(i,j-1,k  ))     &
                               +(khh(i,j,k+1)+ khh(i,j-1,k+1)) )   &
                           *(    s(i,j,k)-   s(i,j-1,k) )*rdy*vf(j)
        enddo
        enddo
        enddo

      ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj+1
        do i=1,ni
          dum(i,j,k)= -0.125*( rho0(i,j,k)+rho0(i,j-1,k) )         &
                            *(  (khh(i,j,k  )+ khh(i,j-1,k  ))     &
                               +(khh(i,j,k+1)+ khh(i,j-1,k+1)) )   &
                           *( (s(i,j,k)-s(i,j-1,k))*rdy*vf(j)      &
                             +gy(i,j,k)*0.5*(dsdz(i,j-1,k)+dsdz(i,j,k)) )
        enddo
        enddo
        enddo

      ENDIF
 
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        turby(i,j,k)=-(dum(i,j+1,k)-dum(i,j,k))*rdy*vh(j)
      enddo
      enddo
      enddo

      IF(terrain_flag)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=1,ni
          dum(i,j,k)=-khh(i,j,k)*0.5*(rho0(i,j,k-1)+rho0(i,j,k))*(  &
                      0.5*( (s(i,j+1,k)+s(i,j+1,k-1))               &
                           -(s(i,j-1,k)+s(i,j-1,k-1)) )*rdx2        &
                    +0.25*( (gy(i,j,k-1)+gy(i,j+1,k-1))             &
                           +(gy(i,j,k  )+gy(i,j+1,k  )) )           &
                         *( s(i,j,k)-s(i,j,k-1) )*rdz    )
        enddo
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          dum(i,j,1)=0.0
          dum(i,j,nk+1)=0.0
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          turby(i,j,k)=turby(i,j,k)-0.5*(gy(i,j,k)+gy(i,j+1,k))   &
                                       *(dum(i,j,k+1)-dum(i,j,k))*rdz
        enddo
        enddo
        enddo

      ENDIF

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        turby(i,j,k)=0.0
      enddo
      enddo
      enddo

    ENDIF

!---------------------------------------------------------------------
!  z-direction

    IF( iturb.eq.3 .and. l_v.lt.tsmall )THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        turbz(i,j,k)=0.0
      enddo
      enddo
      enddo

    ELSE

      rdt = 1.0/dt
      tema = -1.0*dt*vialpha*rdz*rdz
      temb = dt*vibeta*rdz*rdz
      temc = dt*rdz

!$omp parallel do default(shared)   &
!$omp private(i,j,k,dumz,r1,r2,cfa,cfb,cfc,cfd,lgbth,lgbph,tem,s2)
    DO j=1,nj
    DO i=1,ni

      IF(doimpl(i,j))THEN
        ! implicit calculation:

        do k=1,nk
          r1 = khv(i,j,k  )*mf(i,j,k  )*rf0(i,j,k  )*mh(i,j,k)*rr0(i,j,k)
          r2 = khv(i,j,k+1)*mf(i,j,k+1)*rf0(i,j,k+1)*mh(i,j,k)*rr0(i,j,k)
          cfa(k) = tema*r1
          cfc(k) = tema*r2
          cfd(k) = s(i,j,k)   &
                 + temb*(r1*s(i,j,k-1)-(r1+r2)*s(i,j,k)+r2*s(i,j,k+1) )
        enddo
        IF(bcturbs.eq.1)THEN
          cfa( 1) = 0.0
          cfc(nk) = 0.0
        ELSEIF(bcturbs.eq.2)THEN
          cfa( 1) = 0.0
          cfc( 1) = 0.0
          cfa(nk) = 0.0
          cfc(nk) = 0.0
        ENDIF
        do k=1,nk
          cfb(k) = 1.0 - cfa(k) - cfc(k)
        enddo
        if(iflux.eq.1 .and. dosfcflx)then
          cfd(1) = cfd(1) + temc*sflux(i,j)*rf0(i,j,1)*mh(i,j,1)*rr0(i,j,1)
        endif

        lgbth(1)=-cfc(1)/cfb(1)
        lgbph(1)= cfd(1)/cfb(1)
        do k=2,nk
          tem = 1.0/(cfa(k)*lgbth(k-1)+cfb(k))
          lgbth(k)=-cfc(k)*tem
          lgbph(k)=(cfd(k)-cfa(k)*lgbph(k-1))*tem
        enddo
        s2(nk)=lgbph(nk)
        do k=nk-1,1,-1
          s2(k)=lgbth(k)*s2(k+1)+lgbph(k)
        enddo

        do k=1,nk
          turbz(i,j,k) = rho0(i,j,k)*(s2(k)-s(i,j,k))*rdt
        enddo

      ELSE
        ! explicit calculation:

        do k=2,nk
          dumz(k)=-khv(i,j,k)*(s(i,j,k)-s(i,j,k-1))*rdz*mf(i,j,k)*rf0(i,j,k)
        enddo

        IF(bcturbs.eq.1)THEN
 
          dumz(1)=0.0
          dumz(nk+1)=0.0

        ELSEIF(bcturbs.eq.2)THEN
 
          dumz(1)=dumz(2)
          dumz(nk+1)=dumz(nk)

        ENDIF

        if(iflux.eq.1 .and. dosfcflx)then
          dumz(1)=sflux(i,j)*rf0(i,j,1)
        endif

        do k=1,nk
          turbz(i,j,k)=-(dumz(k+1)-dumz(k))*rdz*mh(i,j,k)
        enddo

      ENDIF

    ENDDO
    ENDDO

  ENDIF

!---------------------------------------------------------------------

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        sten(i,j,k)=sten(i,j,k)+(turbx(i,j,k)+turby(i,j,k)+turbz(i,j,k))*rr0(i,j,k)
      enddo
      enddo
      enddo

!---------------------------------------------------------------------

      if(timestats.ge.1) time_tmix=time_tmix+mytime()

      return
      end


!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC


      subroutine turbt(dt,xh,rxh,uh,xf,uf,vh,vf,mh,mf,rho0,rr0,rf0,rrf0,   &
                       turbx,turby,turbz,dum,dtdz,t,tten,kmh,kmv,gx,gy,doimpl)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real :: dt
      real, dimension(ib:ie) :: xh,rxh,uh
      real, dimension(ib:ie+1) :: xf,uf
      real, dimension(jb:je) :: vh
      real, dimension(jb:je+1) :: vf
      real, dimension(ib:ie,jb:je,kb:ke) :: mh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, dimension(ib:ie,jb:je,kb:ke) :: rho0,rr0,rf0,rrf0
      real, dimension(ib:ie,jb:je,kb:ke) :: turbx,turby,turbz,dum,dtdz
      real, dimension(ibt:iet,jbt:jet,kbt:ket) :: t,tten
      real, dimension(ibc:iec,jbc:jec,kbc:kec) :: kmh,kmv
      real, dimension(itb:ite+1,jtb:jte,ktb:kte) :: gx
      real, dimension(itb:ite,jtb:jte+1,ktb:kte) :: gy
      logical, dimension(ib:ie,jb:je) :: doimpl

      integer :: i,j,k
      real :: rdt,tema,temb,temc
      real :: tem,r1,r2
      real, dimension(nk+1) :: cfa,cfb,cfc,cfd,cfe,cff,t2
      real, dimension(kb:ke) :: dumz

!---------------------------------------------------------------
!  calculate and store dtdz

      IF(terrain_flag)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=0,nj+1
        do i=0,ni+1
          dtdz(i,j,k)=(t(i,j,k+1)-t(i,j,k-1))*rdz2
        enddo
        enddo
        enddo

      ENDIF

!---------------------------------------------------------------
!  x-direction

      IF(.not.terrain_flag)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=1,ni+1
          dum(i,j,k)= -0.25*( rf0(i,j,k)+rf0(i-1,j,k) )   &
                           *( kmh(i,j,k)+kmh(i-1,j,k) )   &
                           *(   t(i,j,k)-  t(i-1,j,k) )*rdx*uf(i)
        enddo
        enddo
        enddo

      ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=1,ni+1
          dum(i,j,k)= -0.25*( rf0(i,j,k)+rf0(i-1,j,k) )         &
                           *( kmh(i,j,k)+kmh(i-1,j,k) )         &
                           *( (t(i,j,k)-t(i-1,j,k))*rdx*uf(i)   &
                             +0.25*(gx(i,j,k-1)+gx(i,j,k))*(dtdz(i-1,j,k)+dtdz(i,j,k)) )
        enddo
        enddo
        enddo

      ENDIF

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni
        turbx(i,j,k)=-(dum(i+1,j,k)-dum(i,j,k))*rdx*uh(i)
      enddo
      enddo
      enddo

      IF(terrain_flag)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          dum(i,j,k)=-0.5*(kmh(i,j,k)+kmh(i,j,k+1))*rho0(i,j,k)*(  &
                      0.5*( (t(i+1,j,k)+t(i+1,j,k+1))              &
                           -(t(i-1,j,k)+t(i-1,j,k+1)) )*rdx2       &
                     +0.5*( gx(i,j,k  )+gx(i+1,j,k  ) )            &
                         *( t(i,j,k+1)-t(i,j,k) )*rdz    )
        enddo
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=1,ni
          turbx(i,j,k)=turbx(i,j,k)-0.25*( (gx(i,j,k-1)+gx(i+1,j,k-1))     &
                                          +(gx(i,j,k  )+gx(i+1,j,k  )) )   &
                                        *(dum(i,j,k)-dum(i,j,k-1))*rdz
        enddo
        enddo
        enddo

      ENDIF

!---------------------------------------------------------------
!  y-direction

      IF(.not.terrain_flag)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj+1
        do i=1,ni
          dum(i,j,k)= -0.25*( rf0(i,j,k)+rf0(i,j-1,k) )   &
                           *( kmh(i,j,k)+kmh(i,j-1,k) )   &
                           *(   t(i,j,k)-  t(i,j-1,k) )*rdy*vf(j)
        enddo
        enddo
        enddo

      ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj+1
        do i=1,ni
          dum(i,j,k)= -0.25*( rf0(i,j,k)+rf0(i,j-1,k) )         &
                           *( kmh(i,j,k)+kmh(i,j-1,k) )         &
                           *( (t(i,j,k)-t(i,j-1,k))*rdy*vf(j)   &
                             +0.25*(gy(i,j,k-1)+gy(i,j,k))*(dtdz(i,j-1,k)+dtdz(i,j,k)) )
        enddo
        enddo
        enddo

      ENDIF

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni
        turby(i,j,k)=-(dum(i,j+1,k)-dum(i,j,k))*rdy*vh(j)
      enddo
      enddo
      enddo

      IF(terrain_flag)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          dum(i,j,k)=-0.5*(kmh(i,j,k)+kmh(i,j,k+1))*rho0(i,j,k)*(  &
                      0.5*( (t(i,j+1,k)+t(i,j+1,k+1))              &
                           -(t(i,j-1,k)+t(i,j-1,k+1)) )*rdy2       &
                     +0.5*( gy(i,j,k  )+gy(i,j+1,k  ) )            &
                         *( t(i,j,k+1)-t(i,j,k) )*rdz    )
        enddo
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=1,ni
          turby(i,j,k)=turby(i,j,k)-0.25*( (gy(i,j,k-1)+gy(i,j+1,k-1))     &
                                          +(gy(i,j,k  )+gy(i,j+1,k  )) )   &
                                        *(dum(i,j,k)-dum(i,j,k-1))*rdz
        enddo
        enddo
        enddo

      ENDIF

!---------------------------------------------------------------------
!  z-direction

      rdt = 1.0/dt
      tema = dt*vialpha*rdz*rdz
      temb = dt*vibeta*rdz*rdz
      temc = dt*rdz

!$omp parallel do default(shared)   &
!$omp private(i,j,k,r1,r2,cfa,cfb,cfc,cfd,cfe,cff,tem,t2,dumz)
    do j=1,nj
    do i=1,ni

    IF(doimpl(i,j))THEN

        do k=2,nk
          r1 = 0.5*(kmv(i,j,k-1)+kmv(i,j,k  ))*mh(i,j,k-1)*rho0(i,j,k-1)*mf(i,j,k)*rrf0(i,j,k)
          r2 = 0.5*(kmv(i,j,k  )+kmv(i,j,k+1))*mh(i,j,k  )*rho0(i,j,k  )*mf(i,j,k)*rrf0(i,j,k)
          cfa(k) = tema*r1
          cfc(k) = tema*r2
          cfb(k) = 1.0 + cfa(k) + cfc(k)
          cfd(k) = t(i,j,k)    &
                 + temb*(r2*t(i,j,k+1)-(r1+r2)*t(i,j,k)+r1*t(i,j,k-1))
        enddo

        cfe(1)=0.0
        cff(1)=t(i,j,1)
        do k=2,nk
          tem = 1.0/(cfb(k)-cfc(k)*cfe(k-1))
          cfe(k)=cfa(k)*tem
          cff(k)=(cfd(k)+cfc(k)*cff(k-1))*tem
        enddo
        t2(nk+1)=0.0
        do k=nk,2,-1
          t2(k)=cfe(k)*t2(k+1)+cff(k)
        enddo
        do k=2,nk
          turbz(i,j,k) = rf0(i,j,k)*(t2(k)-t(i,j,k))*rdt
        enddo

    ELSE

      do k=1,nk
        dumz(k)=-0.5*(kmv(i,j,k)+kmv(i,j,k+1))*(t(i,j,k+1)-t(i,j,k))*rdz*mh(i,j,k)*rho0(i,j,k)
      enddo
      do k=2,nk
        turbz(i,j,k)=-(dumz(k)-dumz(k-1))*rdz*mf(i,j,k)
      enddo

    ENDIF

    enddo
    enddo

!---------------------------------------------------------------------

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni
        tten(i,j,k)=tten(i,j,k)+2.0*(turbx(i,j,k)+turby(i,j,k)+turbz(i,j,k))*rrf0(i,j,k)
      enddo
      enddo
      enddo

!---------------------------------------------------------------------

      if(timestats.ge.1) time_tmix=time_tmix+mytime()

      return
      end


!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC


      subroutine turbu(dt,dodrag,xh,ruh,xf,rxf,uf,vh,mh,mf,rmf,rho0,rf0,rru0,   &
           turbx,turby,turbz,dum,u,uten,w,t11,t12,t13,t22,kmv,gx,gy,doimpl)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real :: dt
      logical, intent(in) :: dodrag
      real, dimension(ib:ie) :: xh,ruh
      real, dimension(ib:ie+1) :: xf,rxf,uf
      real, dimension(jb:je) :: vh
      real, dimension(ib:ie,jb:je,kb:ke) :: mh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf,rmf
      real, dimension(ib:ie,jb:je,kb:ke) :: rho0,rf0,rru0
      real, dimension(ib:ie,jb:je,kb:ke) :: turbx,turby,turbz,dum
      real, dimension(ib:ie+1,jb:je,kb:ke) :: u,uten
      real, dimension(ib:ie,jb:je,kb:ke+1) :: w
      real, dimension(ib:ie,jb:je,kb:ke) :: t11,t12,t13,t22
      real, dimension(ibc:iec,jbc:jec,kbc:kec) :: kmv
      real, dimension(itb:ite+1,jtb:jte,ktb:kte) :: gx
      real, dimension(itb:ite,jtb:jte+1,ktb:kte) :: gy
      logical, dimension(ib:ie,jb:je) :: doimpl

      integer :: i,j,k,ip
      real :: rdt,tema,temb,temc,temd,teme
      real :: tem,r1,r2,dwdx1,dwdx2
      real, dimension(nk) :: cfa,cfb,cfc,cfd,u2
      real, dimension(nk) :: lgbth,lgbph
      logical :: dow1,dow2

!---------------------------------------------------------------
!  x-direction

    IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni+1
        turbx(i,j,k)=(t11(i,j,k)-t11(i-1,j,k))*rdx*uf(i)
      enddo
      enddo
      enddo

    ELSE

!$omp parallel do default(shared)   &
!$omp private(j,k)
      do k=1,nk
      do j=1,nj
        turbx(1,j,k)=0.0
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=2,ni+1
        turbx(i,j,k)=( (xh(i)*t11(i,j,k)-xh(i-1)*t11(i-1,j,k))*rdx*uf(i)  &
                      -t22(i,j,k) )*rxf(i)
      enddo
      enddo
      enddo

    ENDIF

      IF(terrain_flag)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk-1
        do j=1,nj
        do i=1,ni+1
          dum(i,j,k)=( (t11(i-1,j,k+1)+t11(i,j,k+1))    &
                      -(t11(i-1,j,k-1)+t11(i,j,k-1)) )*rdz4
        enddo
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni+1
          dum(i,j,1 )=( (t11(i-1,j,2   )+t11(i,j,2   ))    &
                       -(t11(i-1,j,1   )+t11(i,j,1   )) )*rdz2
          dum(i,j,nk)=( (t11(i-1,j,nk  )+t11(i,j,nk  ))    &
                       -(t11(i-1,j,nk-1)+t11(i,j,nk-1)) )*rdz2
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni+1
          turbx(i,j,k)=turbx(i,j,k)+gx(i,j,k)*dum(i,j,k)
        enddo
        enddo
        enddo

      ENDIF

!---------------------------------------------------------------
!  y-direction

    IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni+1
        turby(i,j,k)=(t12(i,j+1,k)-t12(i,j,k))*rdy*vh(j)
      enddo
      enddo
      enddo

      IF(terrain_flag)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk-1
        do j=1,nj+1
        do i=1,ni+1
          dum(i,j,k)=0.5*(gy(i-1,j,k)+gy(i,j,k))    &
                        *(t12(i,j,k+1)-t12(i,j,k-1))*rdz2
        enddo
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj+1
        do i=1,ni+1
          dum(i,j,1 )=0.5*(gy(i-1,j,1 )+gy(i,j,1 ))    &
                         *(t12(i,j,2 )-t12(i,j,1))*rdz
          dum(i,j,nk)=0.5*(gy(i-1,j,nk)+gy(i,j,nk  ))    &
                         *(t12(i,j,nk)-t12(i,j,nk-1))*rdz
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni+1
          turby(i,j,k)=turby(i,j,k)+0.5*(dum(i,j,k)+dum(i,j+1,k))
        enddo
        enddo
        enddo

      ENDIF

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni+1
        turby(i,j,k)=0.0
      enddo
      enddo
      enddo

    ENDIF

!-----------------------------------------------------------------
!  z-direction

    IF( iturb.eq.3 .and. l_v.lt.tsmall )THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni+1
        turbz(i,j,k)=0.0
      enddo
      enddo
      enddo

    ELSE

      rdt = 0.5/dt
      tema = -0.0625*dt*vialpha*rdz*rdz
      temb =  0.0625*dt*vibeta*rdz*rdz
      temd =  0.25*dt*rdz
      temc =  0.5*dt*rdz
      teme = 0.25*dx*dx/dt

      ip = 0
      if( axisymm.eq.1 ) ip = 1

      dow1 = .false.
      dow2 = .false.

      if( iturb.eq.1 .or. iturb.eq.2 ) dow1 = .true.
      if( iturb.eq.3 .and. l_v.gt.tsmall ) dow1 = .true.
      if( dow1 .and. terrain_flag ) dow2 = .true.

      IF( dow2 )THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=0,ni+1
          dum(i,j,k)=0.25*( (gx(i,j,k-1)+gx(i+1,j,k-1))     &
                           +(gx(i,j,k  )+gx(i+1,j,k  )) )   &
                     *(w(i,j,k+1)-w(i,j,k-1))*rdz2
        enddo
        enddo
        enddo
      ENDIF

!$omp parallel do default(shared)   &
!$omp private(i,j,k,r1,r2,cfa,cfb,cfc,cfd,lgbth,lgbph,tem,u2,dwdx1,dwdx2)
    DO j=1,nj
    DO i=1+ip,ni+1

    IF(doimpl(i-1,j).or.doimpl(i,j))THEN

        do k=1,nk
          tem = (mh(i-1,j,k)+mh(i,j,k))*rru0(i,j,k)
          r1 = (kmv(i-1,j,k  )+kmv(i,j,k  ))*(mf(i-1,j,k  )+mf(i,j,k  ))   &
              *(rf0(i-1,j,k  )+rf0(i,j,k  ))*tem
          r2 = (kmv(i-1,j,k+1)+kmv(i,j,k+1))*(mf(i-1,j,k+1)+mf(i,j,k+1))   &
              *(rf0(i-1,j,k+1)+rf0(i,j,k+1))*tem
          cfa(k) = tema*r1
          cfc(k) = tema*r2
          cfd(k) = u(i,j,k)    &
                 + temb*( r2*u(i,j,k+1)-(r1+r2)*u(i,j,k)+r1*u(i,j,k-1) )
          if( dow1 )then
            dwdx2 = (w(i,j,k+1)-w(i-1,j,k+1))*rdx*uf(i)
            dwdx1 = (w(i,j,k  )-w(i-1,j,k  ))*rdx*uf(i)
          endif
          if( dow2 )then
            if(k.ne.nk) dwdx2 = dwdx2 + 0.5*(dum(i,j,k+1)+dum(i-1,j,k+1))
            if(k.ne. 1) dwdx1 = dwdx1 + 0.5*(dum(i,j,k  )+dum(i-1,j,k  ))
          endif
          if( dow1 )then
            r1 = min( 0.5*(kmv(i-1,j,k  )+kmv(i,j,k  )) , teme*ruh(i)*ruh(i) ) &
                         *(rf0(i-1,j,k  )+rf0(i,j,k  ))*tem
            r2 = min( 0.5*(kmv(i-1,j,k+1)+kmv(i,j,k+1)) , teme*ruh(i)*ruh(i) ) &
                         *(rf0(i-1,j,k+1)+rf0(i,j,k+1))*tem
            cfd(k) = cfd(k) +    &
                   temd*( r2*dwdx2   &
                        - r1*dwdx1 )
          endif
        enddo
        IF(bcturbu.eq.1)THEN
          cfa( 1) = 0.0
          cfc(nk) = 0.0
        ELSEIF(bcturbu.eq.2)THEN
          cfa( 1) = 0.0
          cfc( 1) = 0.0
          cfa(nk) = 0.0
          cfc(nk) = 0.0
        ELSEIF(bcturbu.eq.3)THEN
          cfa( 1) = 0.0
          cfc(nk) = 0.0
        ENDIF
        do k=1,nk
          cfb(k) = 1.0 - cfa(k) - cfc(k)
        enddo
        if(dodrag)then
          tem = temc*t13(i,j,1)*(mh(i-1,j,1)+mh(i,j,1))*rru0(i,j,1)
!!!          cfb(1) = cfb(1) + vialpha*tem/(1.0e-20+u(i,j,1))
!!!          cfd(1) = cfd(1) - vibeta*tem
          ! set back to simpler version:  now usable if pertflx = 1
          cfd(1) = cfd(1) - tem
        endif

        lgbth(1)=-cfc(1)/cfb(1)
        lgbph(1)= cfd(1)/cfb(1)
        do k=2,nk
          tem = 1.0/(cfa(k)*lgbth(k-1)+cfb(k))
          lgbth(k)=-cfc(k)*tem
          lgbph(k)=(cfd(k)-cfa(k)*lgbph(k-1))*tem
        enddo
        u2(nk)=lgbph(nk)
        do k=nk-1,1,-1
          u2(k)=lgbth(k)*u2(k+1)+lgbph(k)
        enddo

        do k=1,nk
          turbz(i,j,k) = (rho0(i-1,j,k)+rho0(i,j,k))*(u2(k)-u(i,j,k))*rdt
        enddo

    ELSE

      do k=1,nk
        turbz(i,j,k)=(t13(i,j,k+1)-t13(i,j,k))*rdz*0.5*(mh(i-1,j,k)+mh(i,j,k))
      enddo

    ENDIF

    ENDDO
    ENDDO

      IF(axisymm.eq.1)THEN
        DO k=1,nk
          turbz(1,1,k) = 0.0
        ENDDO
      ENDIF

  ENDIF

!-----------------------------------------------------------------

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni+1
        uten(i,j,k)=uten(i,j,k)+(turbx(i,j,k)+turby(i,j,k)+turbz(i,j,k))*rru0(i,j,k)
      enddo
      enddo
      enddo

!-------------------------------------------------------------------
!  All done

      if(timestats.ge.1) time_tmix=time_tmix+mytime()

      return
      end


!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC


      subroutine turbv(dt,dodrag,xh,rxh,uh,xf,rvh,vf,mh,mf,rho0,rf0,rrv0,   &
            turbx,turby,turbz,dum,v,vten,w,t12,t22,t23,kmv,gx,gy,doimpl)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real :: dt
      logical, intent(in) :: dodrag
      real, dimension(ib:ie) :: xh,rxh,uh
      real, dimension(ib:ie+1) :: xf
      real, dimension(jb:je) :: rvh
      real, dimension(jb:je+1) :: vf
      real, dimension(ib:ie,jb:je,kb:ke) :: mh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, dimension(ib:ie,jb:je,kb:ke) :: rho0,rf0,rrv0
      real, dimension(ib:ie,jb:je,kb:ke) :: turbx,turby,turbz,dum
      real, dimension(ib:ie,jb:je+1,kb:ke) :: v,vten
      real, dimension(ib:ie,jb:je,kb:ke+1) :: w
      real, dimension(ib:ie,jb:je,kb:ke) :: t12,t22,t23
      real, dimension(ibc:iec,jbc:jec,kbc:kec) :: kmv
      real, dimension(itb:ite+1,jtb:jte,ktb:kte) :: gx
      real, dimension(itb:ite,jtb:jte+1,ktb:kte) :: gy
      logical, dimension(ib:ie,jb:je) :: doimpl
 
      integer :: i,j,k,ip
      real :: rdt,tema,temb,temc,temd,teme
      real :: tem,r1,r2,dwdy1,dwdy2
      real, dimension(nk) :: cfa,cfb,cfc,cfd,v2
      real, dimension(nk) :: lgbth,lgbph
      logical :: dow1,dow2

!---------------------------------------------------------------
!  x-direction

    IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj+1
      do i=1,ni
        turbx(i,j,k)=(t12(i+1,j,k)-t12(i,j,k))*rdx*uh(i)
      enddo
      enddo
      enddo

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        turbx(i,j,k)=(xf(i+1)*xf(i+1)*t12(i+1,j,k)-xf(i)*xf(i)*t12(i,j,k))*rdx*uh(i)*rxh(i)*rxh(i)
      enddo
      enddo
      enddo

    ENDIF

      IF(terrain_flag)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk-1
        do j=1,nj+1
        do i=1,ni+1
          dum(i,j,k)=0.5*(gx(i,j-1,k)+gx(i,j,k))    &
                        *(t12(i,j,k+1)-t12(i,j,k-1))*rdz2
        enddo
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj+1
        do i=1,ni+1
          dum(i,j,1 )=0.5*(gx(i,j-1,1 )+gx(i,j,1 ))    &
                         *(t12(i,j,2 )-t12(i,j,1   ))*rdz
          dum(i,j,nk)=0.5*(gx(i,j-1,nk)+gx(i,j,nk))    &
                         *(t12(i,j,nk)-t12(i,j,nk-1))*rdz
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj+1
        do i=1,ni
          turbx(i,j,k)=turbx(i,j,k)+0.5*(dum(i,j,k)+dum(i+1,j,k))
        enddo
        enddo
        enddo

      ENDIF

!---------------------------------------------------------------
!  y-direction

    IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj+1
      do i=1,ni
        turby(i,j,k)=(t22(i,j,k)-t22(i,j-1,k))*rdy*vf(j)
      enddo
      enddo
      enddo

      IF(terrain_flag)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk-1
        do j=1,nj+1
        do i=1,ni
          dum(i,j,k)=( (t22(i,j-1,k+1)+t22(i,j,k+1))    &
                      -(t22(i,j-1,k-1)+t22(i,j,k-1)) )*rdz4
        enddo
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj+1
        do i=1,ni
          dum(i,j,1 )=( (t22(i,j-1,2   )+t22(i,j,2   ))    &
                       -(t22(i,j-1,1   )+t22(i,j,1   )) )*rdz2
          dum(i,j,nk)=( (t22(i,j-1,nk  )+t22(i,j,nk  ))    &
                       -(t22(i,j-1,nk-1)+t22(i,j,nk-1)) )*rdz2
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj+1
        do i=1,ni
          turby(i,j,k)=turby(i,j,k)+gy(i,j,k)*dum(i,j,k)
        enddo
        enddo
        enddo

      ENDIF

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj+1
      do i=1,ni
        turby(i,j,k)=0.0
      enddo
      enddo
      enddo

    ENDIF
 
!-----------------------------------------------------------------
!  z-direction

    IF( iturb.eq.3 .and. l_v.lt.tsmall )THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj+1
      do i=1,ni
        turbz(i,j,k)=0.0
      enddo
      enddo
      enddo

    ELSE

      rdt = 0.5/dt
      tema = -0.0625*dt*vialpha*rdz*rdz
      temb =  0.0625*dt*vibeta*rdz*rdz
      temd =  0.25*dt*rdz
      temc =  0.5*dt*rdz
      teme = 0.25*dy*dy/dt

      ip = 1
      if( axisymm.eq.1 ) ip = 0

      dow1 = .false.
      dow2 = .false.

      if( iturb.eq.1 .or. iturb.eq.2 ) dow1 = .true.
      if( iturb.eq.3 .and. l_v.gt.tsmall ) dow1 = .true.
      if( axisymm.eq.1 ) dow1 = .false.
      if( dow1 .and. terrain_flag ) dow2 = .true.

      IF( dow2 )THEN
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=0,nj+1
        do i=1,ni
          dum(i,j,k)=0.25*( (gy(i,j,k-1)+gy(i,j+1,k-1))     &
                           +(gy(i,j,k  )+gy(i,j+1,k  )) )   &
                     *(w(i,j,k+1)-w(i,j,k-1))*rdz2
        enddo
        enddo
        enddo
      ENDIF

!$omp parallel do default(shared)   &
!$omp private(i,j,k,r1,r2,cfa,cfb,cfc,cfd,lgbth,lgbph,tem,v2,dwdy1,dwdy2)
    do j=1,nj+ip
    do i=1,ni

    IF(doimpl(i,j-1).or.doimpl(i,j))THEN

        do k=1,nk
          tem = (mh(i,j-1,k)+mh(i,j,k))*rrv0(i,j,k)
          r1 = (kmv(i,j-1,k  )+kmv(i,j,k  ))*(mf(i,j-1,k  )+mf(i,j,k  ))   &
              *(rf0(i,j-1,k  )+rf0(i,j,k  ))*tem
          r2 = (kmv(i,j-1,k+1)+kmv(i,j,k+1))*(mf(i,j-1,k+1)+mf(i,j,k+1))   &
              *(rf0(i,j-1,k+1)+rf0(i,j,k+1))*tem
          cfa(k) = tema*r1
          cfc(k) = tema*r2
          cfd(k) = v(i,j,k)    &
                 + temb*( r2*v(i,j,k+1)-(r1+r2)*v(i,j,k)+r1*v(i,j,k-1) )
          if( dow1 )then
            dwdy2 = (w(i,j,k+1)-w(i,j-1,k+1))*rdy*vf(j)
            dwdy1 = (w(i,j,k  )-w(i,j-1,k  ))*rdy*vf(j)
          endif
          if( dow2 )then
            if(k.ne.nk) dwdy2 = dwdy2 + 0.5*(dum(i,j,k+1)+dum(i,j-1,k+1))
            if(k.ne. 1) dwdy1 = dwdy1 + 0.5*(dum(i,j,k  )+dum(i,j-1,k  ))
          endif
          if( dow1 )then
            r1 = min( 0.5*(kmv(i,j-1,k  )+kmv(i,j,k  )) , teme*rvh(j)*rvh(j) ) &
                         *(rf0(i,j-1,k  )+rf0(i,j,k  ))*tem
            r2 = min( 0.5*(kmv(i,j-1,k+1)+kmv(i,j,k+1)) , teme*rvh(j)*rvh(j) ) &
                         *(rf0(i,j-1,k+1)+rf0(i,j,k+1))*tem
            cfd(k) = cfd(k) +    &
                   temd*( r2*dwdy2   &
                        - r1*dwdy1 )
          endif
        enddo
        IF(bcturbu.eq.1)THEN
          cfa( 1) = 0.0
          cfc(nk) = 0.0
        ELSEIF(bcturbu.eq.2)THEN
          cfa( 1) = 0.0
          cfc( 1) = 0.0
          cfa(nk) = 0.0
          cfc(nk) = 0.0
        ELSEIF(bcturbu.eq.3)THEN
          cfa( 1) = 0.0
          cfc(nk) = 0.0
        ENDIF
        do k=1,nk
          cfb(k) = 1.0 - cfa(k) - cfc(k)
        enddo
        if(dodrag)then
          tem = temc*t23(i,j,1)*(mh(i,j-1,1)+mh(i,j,1))*rrv0(i,j,1)
          ! set back to simpler version:  now usable if pertflx = 1
!!!          cfb(1) = cfb(1) + vialpha*tem/(1.0e-20+v(i,j,1))
!!!          cfd(1) = cfd(1) - vibeta*tem
          cfd(1) = cfd(1) - tem
        endif

        lgbth(1)=-cfc(1)/cfb(1)
        lgbph(1)= cfd(1)/cfb(1)
        do k=2,nk
          tem = 1.0/(cfa(k)*lgbth(k-1)+cfb(k))
          lgbth(k)=-cfc(k)*tem
          lgbph(k)=(cfd(k)-cfa(k)*lgbph(k-1))*tem
        enddo
        v2(nk)=lgbph(nk)
        do k=nk-1,1,-1
          v2(k)=lgbth(k)*v2(k+1)+lgbph(k)
        enddo

        do k=1,nk
          turbz(i,j,k) = (rho0(i,j-1,k)+rho0(i,j,k))*(v2(k)-v(i,j,k))*rdt
        enddo

    ELSE

      do k=1,nk
        turbz(i,j,k)=(t23(i,j,k+1)-t23(i,j,k))*rdz*0.5*(mh(i,j-1,k)+mh(i,j,k))
      enddo

    ENDIF

    enddo
    enddo

  ENDIF

!-----------------------------------------------------------------

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj+1
      do i=1,ni
        vten(i,j,k)=vten(i,j,k)+(turbx(i,j,k)+turby(i,j,k)+turbz(i,j,k))*rrv0(i,j,k)
      enddo
      enddo
      enddo

!-------------------------------------------------------------------
!  All done
 
      if(timestats.ge.1) time_tmix=time_tmix+mytime()
 
      return
      end


!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

 
      subroutine turbw(dt,xh,rxh,uh,xf,vh,mh,mf,rho0,rf0,rrf0,   &
           turbx,turby,turbz,dum,w,wten,t13,t23,t33,kmv,gx,gy,doimpl)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      real :: dt
      real, dimension(ib:ie) :: xh,rxh,uh
      real, dimension(ib:ie+1) :: xf
      real, dimension(jb:je) :: vh
      real, dimension(ib:ie,jb:je,kb:ke) :: mh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, dimension(ib:ie,jb:je,kb:ke) :: rho0,rf0,rrf0
      real, dimension(ib:ie,jb:je,kb:ke) :: turbx,turby,turbz,dum
      real, dimension(ib:ie,jb:je,kb:ke+1) :: w,wten
      real, dimension(ib:ie,jb:je,kb:ke) :: t13,t23,t33
      real, dimension(ibc:iec,jbc:jec,kbc:kec) :: kmv
      real, dimension(itb:ite+1,jtb:jte,ktb:kte) :: gx
      real, dimension(itb:ite,jtb:jte+1,ktb:kte) :: gy
      logical, dimension(ib:ie,jb:je) :: doimpl
 
      integer :: i,j,k
      real :: rdt,tema,temb,temc
      real :: tem,r1,r2
      real, dimension(nk+1) :: cfa,cfb,cfc,cfd,cfe,cff,w2

!----------------------------------------------------------------
!  x-direction

    IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni
        turbx(i,j,k)=(t13(i+1,j,k)-t13(i,j,k))*rdx*uh(i)
      enddo
      enddo
      enddo

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni
        turbx(i,j,k)=(xf(i+1)*t13(i+1,j,k)-xf(i)*t13(i,j,k))*rdx*uh(i)*rxh(i)
      enddo
      enddo
      enddo

    ENDIF

      IF(terrain_flag)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni+1
          dum(i,j,k)=(t13(i,j,k+1)-t13(i,j,k))*rdz
        enddo
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=1,ni
          turbx(i,j,k)=turbx(i,j,k)+0.0625*( (gx(i,j,k-1)+gx(i+1,j,k-1))       &
                                            +(gx(i,j,k  )+gx(i+1,j,k  )) )     &
                                          *( (dum(i,j,k-1)+dum(i+1,j,k-1))     &
                                            +(dum(i,j,k  )+dum(i+1,j,k  )) )
        enddo
        enddo
        enddo

      ENDIF

!----------------------------------------------------------------
!  y-direction

    IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni
        turby(i,j,k)=(t23(i,j+1,k)-t23(i,j,k))*rdy*vh(j)
      enddo
      enddo
      enddo

      IF(terrain_flag)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj+1
        do i=1,ni
          dum(i,j,k)=(t23(i,j,k+1)-t23(i,j,k))*rdz
        enddo
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=1,ni
          turby(i,j,k)=turby(i,j,k)+0.0625*( (gy(i,j,k-1)+gy(i,j+1,k-1))       &
                                            +(gy(i,j,k  )+gy(i,j+1,k  )) )     &
                                          *( (dum(i,j,k-1)+dum(i,j+1,k-1))     &
                                            +(dum(i,j,k  )+dum(i,j+1,k  )) )
        enddo
        enddo
        enddo

      ENDIF

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni
        turby(i,j,k)=0.0
      enddo
      enddo
      enddo

    ENDIF

!-----------------------------------------------------------------
!  z-direction

    IF( iturb.eq.3 .and. l_v.lt.tsmall )THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni
        turbz(i,j,k)=0.0
      enddo
      enddo
      enddo

    ELSE

      rdt = 1.0/dt
      tema = dt*vialpha*rdz*rdz
      temb = dt*vibeta*rdz*rdz
      temc = dt*rdz

!$omp parallel do default(shared)   &
!$omp private(i,j,k,r1,r2,cfa,cfb,cfc,cfd,cfe,cff,tem,w2)
    do j=1,nj
    do i=1,ni

    IF(doimpl(i,j))THEN

        do k=2,nk
          r1 = (kmv(i,j,k-1)+kmv(i,j,k  ))*mh(i,j,k-1)*rho0(i,j,k-1)*mf(i,j,k)*rrf0(i,j,k)
          r2 = (kmv(i,j,k  )+kmv(i,j,k+1))*mh(i,j,k  )*rho0(i,j,k  )*mf(i,j,k)*rrf0(i,j,k)
          cfa(k) = tema*r1
          cfc(k) = tema*r2
          cfb(k) = 1.0 + cfa(k) + cfc(k)
          cfd(k) = w(i,j,k)    &
                 + temb*(r2*w(i,j,k+1)-(r1+r2)*w(i,j,k)+r1*w(i,j,k-1))
        enddo

        cfe(1)=0.0
        cff(1)=w(i,j,1)
        do k=2,nk
          tem = 1.0/(cfb(k)-cfc(k)*cfe(k-1))
          cfe(k)=cfa(k)*tem
          cff(k)=(cfd(k)+cfc(k)*cff(k-1))*tem
        enddo
        w2(nk+1)=0.0
        do k=nk,2,-1
          w2(k)=cfe(k)*w2(k+1)+cff(k)
        enddo
        do k=2,nk
          turbz(i,j,k) = rf0(i,j,k)*(w2(k)-w(i,j,k))*rdt
        enddo

    ELSE

      do k=2,nk
        turbz(i,j,k)=(t33(i,j,k)-t33(i,j,k-1))*rdz*mf(i,j,k)
      enddo

    ENDIF

    enddo
    enddo

  ENDIF

!-----------------------------------------------------------------

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk
      do j=1,nj
      do i=1,ni
        wten(i,j,k)=wten(i,j,k)+(turbx(i,j,k)+turby(i,j,k)+turbz(i,j,k))*rrf0(i,j,k)
      enddo
      enddo
      enddo

!-------------------------------------------------------------------
!  All done

      if(timestats.ge.1) time_tmix=time_tmix+mytime()
 
      return
      end


!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC


      subroutine getepsilon(rxh,uh,xf,rxf,uf,yh,vh,yf,vf,mh,mf,rr0,rrf0,   &
                            dum1,dum2,dum3,dum4,dum5,tem1,tem2,epsd,       &
                            t11,t12,t13,t22,t23,t33,ua,va,wa,gx,gy)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'

      real, dimension(ib:ie) :: rxh,uh
      real, dimension(ib:ie+1) :: xf,rxf,uf
      real, dimension(jb:je) :: yh,vh
      real, dimension(jb:je+1) :: yf,vf
      real, dimension(ib:ie,jb:je,kb:ke) :: mh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf
      real, dimension(ib:ie,jb:je,kb:ke) :: rr0,rrf0
      real, dimension(ib:ie,jb:je,kb:ke) :: dum1,dum2,dum3,dum4,dum5,tem1,tem2,epsd
      real, dimension(ib:ie,jb:je,kb:ke) :: t11,t12,t13,t22,t23,t33
      real, dimension(ib:ie+1,jb:je,kb:ke) :: ua
      real, dimension(ib:ie,jb:je+1,kb:ke) :: va
      real, dimension(ib:ie,jb:je,kb:ke+1) :: wa
      real, dimension(itb:ite+1,jtb:jte,ktb:kte) :: gx
      real, dimension(itb:ite,jtb:jte+1,ktb:kte) :: gy

      integer :: i,j,k
      real :: tmp11,tmp22,tmp33,tmp12,tmp13,tmp23

!-----------------------------------------------------------------------
!  Cartesian grid:

      IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj+1
        do i=1,ni+1
          dum1(i,j,k)=(ua(i,j,k)-ua(i,j-1,k))*rdy*vf(j)   &
                     +(va(i,j,k)-va(i-1,j,k))*rdx*uf(i)
        enddo
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=1,ni+1
          dum2(i,j,k)=(wa(i,j,k)-wa(i-1,j,k))*rdx*uf(i)   &
                     +(ua(i,j,k)-ua(i,j,k-1))*rdz*0.5*(mf(i-1,j,k)+mf(i,j,k))
        enddo
        enddo
        enddo

        IF(bcturbu.eq.1.or.bcturbu.eq.2)THEN
!$omp parallel do default(shared)  &
!$omp private(i,j)
          do j=1,nj
          do i=1,ni+1
            dum2(i,j,1)=0.0
            dum2(i,j,nk+1)=0.0
          enddo
          enddo
        ELSEIF(bcturbu.eq.3)THEN
!$omp parallel do default(shared)  &
!$omp private(i,j)
          do j=1,nj
          do i=1,ni+1
            dum2(i,j,1)=2.0*ua(i,j,1)*rdz*0.5*(mf(i-1,j,1)+mf(i,j,1))
            dum2(i,j,nk+1)=-2.0*ua(i,j,nk)*rdz*0.5*(mf(i-1,j,nk+1)+mf(i,j,nk+1))
          enddo
          enddo
        ENDIF

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj+1
        do i=1,ni
          dum3(i,j,k)=(wa(i,j,k)-wa(i,j-1,k))*rdy*vf(j)   &
                     +(va(i,j,k)-va(i,j,k-1))*rdz*0.5*(mf(i,j-1,k)+mf(i,j,k))
        enddo
        enddo
        enddo

        IF(bcturbu.eq.1.or.bcturbu.eq.2)THEN
!$omp parallel do default(shared)  &
!$omp private(i,j)
          do j=1,nj+1
          do i=1,ni
            dum3(i,j,1)=0.0
            dum3(i,j,nk+1)=0.0
          enddo
          enddo
        ELSEIF(bcturbu.eq.3)THEN
!$omp parallel do default(shared)  &
!$omp private(i,j)
          do j=1,nj+1
          do i=1,ni
            dum3(i,j,1)=2.0*va(i,j,1)*rdz*0.5*(mf(i,j-1,1)+mf(i,j,1))
            dum3(i,j,nk+1)=-2.0*va(i,j,nk)*rdz*0.5*(mf(i,j-1,nk+1)+mf(i,j,nk+1))
          enddo
          enddo
        ENDIF

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          dum4(i,j,k)=(ua(i+1,j,k)-ua(i,j,k))*rdx*uh(i)
        enddo
        enddo
        enddo

!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          dum5(i,j,k)=(va(i,j+1,k)-va(i,j,k))*rdy*vh(j)
        enddo
        enddo
        enddo

!------------------------------------------------------------------
!  now, add the "correction" terms for terrain

      IF(terrain_flag)THEN

!-------- dum1 --------

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk-1
        do j=0,nj+1
        do i=1,ni+1
          tem1(i,j,k)=(ua(i,j,k+1)-ua(i,j,k-1))*rdz2
        enddo
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=0,nj+1
        do i=1,ni+1
          tem1(i,j,1 )=(ua(i,j,2 )-ua(i,j,1   ))*rdz
          tem1(i,j,nk)=(ua(i,j,nk)-ua(i,j,nk-1))*rdz
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=0,nj+1
        do i=1,ni+1
          tem1(i,j,k)=tem1(i,j,k)*0.25*( gy(i-1,j  ,k)+gy(i,j  ,k)    &
                                        +gy(i-1,j+1,k)+gy(i,j+1,k) )
        enddo
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk-1
        do j=1,nj+1
        do i=0,ni+1
          tem2(i,j,k)=(va(i,j,k+1)-va(i,j,k-1))*rdz2
        enddo
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj+1
        do i=0,ni+1
          tem2(i,j,1 )=(va(i,j,2 )-va(i,j,1   ))*rdz
          tem2(i,j,nk)=(va(i,j,nk)-va(i,j,nk-1))*rdz
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj+1
        do i=0,ni+1
          tem2(i,j,k)=tem2(i,j,k)*0.25*( gx(i  ,j-1,k)+gx(i  ,j,k)    &
                                        +gx(i+1,j-1,k)+gx(i+1,j,k) )
        enddo
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj+1
        do i=1,ni+1
          dum1(i,j,k)=dum1(i,j,k)+0.5*( (tem1(i,j-1,k)+tem1(i,j,k))  &
                                       +(tem2(i-1,j,k)+tem2(i,j,k)) )
        enddo
        enddo
        enddo

!-------- dum2 --------

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=0,ni+1
          tem1(i,j,k)=0.25*( (gx(i,j,k-1)+gx(i+1,j,k-1))     &
                            +(gx(i,j,k  )+gx(i+1,j,k  )) )   &
                     *(wa(i,j,k+1)-wa(i,j,k-1))*rdz2
        enddo
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=1,ni+1
          dum2(i,j,k)=dum2(i,j,k)+0.5*(tem1(i,j,k)+tem1(i-1,j,k))
        enddo
        enddo
        enddo

!-------- dum3 --------

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=0,nj+1
        do i=1,ni
          tem1(i,j,k)=0.25*( (gy(i,j,k-1)+gy(i,j+1,k-1))     &
                            +(gy(i,j,k  )+gy(i,j+1,k  )) )   &
                     *(wa(i,j,k+1)-wa(i,j,k-1))*rdz2
        enddo
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj+1
        do i=1,ni
          dum3(i,j,k)=dum3(i,j,k)+0.5*(tem1(i,j,k)+tem1(i,j-1,k))
        enddo
        enddo
        enddo

!-------- dum4 --------

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk-1
        do j=1,nj
        do i=0,ni+2
          tem1(i,j,k)=gx(i,j,k)*(ua(i,j,k+1)-ua(i,j,k-1))*rdz2
        enddo
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=1,nj
        do i=0,ni+2
          tem1(i,j, 1)=gx(i,j,1 )*(ua(i,j,2 )-ua(i,j,1   ))*rdz
          tem1(i,j,nk)=gx(i,j,nk)*(ua(i,j,nk)-ua(i,j,nk-1))*rdz
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=0,ni+1
          dum4(i,j,k)=dum4(i,j,k)+0.5*(tem1(i,j,k)+tem1(i+1,j,k))
        enddo
        enddo
        enddo

!-------- dum5 --------

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk-1
        do j=0,nj+2
        do i=1,ni
          tem1(i,j,k)=gy(i,j,k)*(va(i,j,k+1)-va(i,j,k-1))*rdz2
        enddo
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j)
        do j=0,nj+2
        do i=1,ni
          tem1(i,j, 1)=gy(i,j,1 )*(va(i,j,2 )-va(i,j,1   ))*rdz
          tem1(i,j,nk)=gy(i,j,nk)*(va(i,j,nk)-va(i,j,nk-1))*rdz
        enddo
        enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=0,nj+1
        do i=1,ni
          dum5(i,j,k)=dum5(i,j,k)+0.5*(tem1(i,j,k)+tem1(i,j+1,k))
        enddo
        enddo
        enddo

      ENDIF

!------------------------------------------------------------------

!$omp parallel do default(shared)  &
!$omp private(i,j,k,tmp11,tmp22,tmp33,tmp12,tmp13,tmp23)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          tmp11 = t11(i,j,k)*dum4(i,j,k)
          tmp22 = t22(i,j,k)*dum5(i,j,k)
          tmp33 = t33(i,j,k)*(wa(i,j,k+1)-wa(i,j,k))*rdz*mh(i,j,k)
          tmp12 = 0.25*( ( t12(i  ,j  ,k)*dum1(i  ,j  ,k)   &
                          +t12(i+1,j+1,k)*dum1(i+1,j+1,k) ) &
                        +( t12(i+1,j  ,k)*dum1(i+1,j  ,k)   &
                          +t12(i  ,j+1,k)*dum1(i  ,j+1,k) ) )
          tmp13 = 0.25*( ( t13(i  ,j,k  )*dum2(i  ,j,k  )   &
                          +t13(i+1,j,k  )*dum2(i+1,j,k  ) ) &
                        +( t13(i  ,j,k+1)*dum2(i  ,j,k+1)   &
                          +t13(i+1,j,k+1)*dum2(i+1,j,k+1) ) )
          tmp23 = 0.25*( ( t23(i,j  ,k  )*dum3(i,j  ,k  )   &
                          +t23(i,j+1,k  )*dum3(i,j+1,k  ) ) &
                        +( t23(i,j  ,k+1)*dum3(i,j  ,k+1)   &
                          +t23(i,j+1,k+1)*dum3(i,j+1,k+1) ) )
          epsd(i,j,k) = rr0(i,j,k)*((tmp11+tmp22+tmp33)+tmp12+(tmp13+tmp23))
        enddo
        enddo
        enddo

!-----------------------------------------------------------------------
!  Axisymmetric grid:

      ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=2,ni+1
          dum1(i,j,k)=xf(i)*(va(i,j,k)*rxh(i)-va(i-1,j,k)*rxh(i-1))*rdx*uf(i)
        enddo
        enddo
        enddo
!$omp parallel do default(shared)   &
!$omp private(j,k)
        do k=1,nk
        do j=1,nj
          dum1(1,j,k)=0.0
        enddo
        enddo
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj
        do i=1,ni+1
          dum2(i,j,k)=(wa(i,j,k)-wa(i-1,j,k))*rdx*uf(i)   &
                     +(ua(i,j,k)-ua(i,j,k-1))*rdz*mf(1,1,k)
        enddo
        enddo
        enddo
        IF(bcturbu.eq.1.or.bcturbu.eq.2)THEN
!$omp parallel do default(shared)  &
!$omp private(i,j)
          do j=1,nj
          do i=1,ni+1
            dum2(i,j,1)=0.0
            dum2(i,j,nk+1)=0.0
          enddo
          enddo
        ELSEIF(bcturbu.eq.3)THEN
!$omp parallel do default(shared)  &
!$omp private(i,j)
          do j=1,nj
          do i=1,ni+1
            dum2(i,j,1)=2.0*ua(i,j,1)*rdz*mf(1,1,1)
            dum2(i,j,nk+1)=-2.0*ua(i,j,nk)*rdz*mf(1,1,nk+1)
          enddo
          enddo
        ENDIF
!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=2,nk
        do j=1,nj+1
        do i=1,ni
          dum3(i,j,k)=(va(i,j,k)-va(i,j,k-1))*rdz*mf(1,1,k)
        enddo
        enddo
        enddo
        IF(bcturbu.eq.1.or.bcturbu.eq.2)THEN
!$omp parallel do default(shared)  &
!$omp private(i,j)
          do j=1,nj+1
          do i=1,ni
            dum3(i,j,1)=0.0
            dum3(i,j,nk+1)=0.0
          enddo
          enddo
        ELSEIF(bcturbu.eq.3)THEN
!$omp parallel do default(shared)  &
!$omp private(i,j)
          do j=1,nj+1
          do i=1,ni
            dum3(i,j,1)=2.0*va(i,j,1)*rdz*mf(1,1,1)
            dum3(i,j,nk+1)=-2.0*va(i,j,nk)*rdz*mf(1,1,nk+1)
          enddo
          enddo
        ENDIF
!$omp parallel do default(shared)  &
!$omp private(i,j,k,tmp11,tmp22,tmp33,tmp12,tmp13,tmp23)
        do k=1,nk
        do j=1,nj
        do i=1,ni  
          tmp11 = t11(i,j,k)*(ua(i+1,j,k)-ua(i,j,k))*rdx*uh(i)
          tmp33 = t33(i,j,k)*(wa(i,j,k+1)-wa(i,j,k))*rdz*mh(i,j,k)
          tmp22 = 0.5*( t22(i  ,j,k)*ua(i  ,j,k)*rxf(i  )   &
                       +t22(i+1,j,k)*ua(i+1,j,k)*rxf(i+1) )
          tmp12 = 0.5*( t12(i  ,j,k)*dum1(i  ,j,k) &
                       +t12(i+1,j,k)*dum1(i+1,j,k) )
          tmp23 = 0.5*( t23(i,j,k  )*dum3(i,j,k  ) &
                       +t23(i,j,k+1)*dum3(i,j,k+1) )
          tmp13 = 0.25*( t13(i  ,j,k  )*dum2(i  ,j,k  ) &
                        +t13(i+1,j,k  )*dum2(i+1,j,k  ) &
                        +t13(i  ,j,k+1)*dum2(i  ,j,k+1) &
                        +t13(i+1,j,k+1)*dum2(i+1,j,k+1) )
          epsd(i,j,k) = rr0(1,1,k)*(tmp11+tmp22+tmp33+tmp12+tmp13+tmp23)
        enddo
        enddo
        enddo

      ENDIF

!-----------------------------------------------------------------------

      if(timestats.ge.1) time_turb=time_turb+mytime()

      return
      end


weno.F/         1298670057  19071 8000  100644  7977      `


      subroutine wenos(bflag,bsq,xh,rxh,uh,ruh,xf,vh,rvh,gz,mh,rmh,      &
                       rho0,rr0,rf0,rrf0,advx,advy,advz,dum,   &
                       divx,rru,rrv,rrw,s,sten,dt)
      implicit none

      include 'input.incl'
      include 'constants.incl'
      include 'timestat.incl'
 
      integer bflag
      real*8 bsq
      real, dimension(ib:ie) :: xh,rxh,uh,ruh
      real, dimension(ib:ie+1) :: xf
      real, dimension(jb:je) :: vh,rvh
      real, dimension(itb:ite,jtb:jte) :: gz
      real, dimension(ib:ie,jb:je,kb:ke) :: mh,rmh,rho0,rr0,rf0,rrf0
      real, dimension(ib:ie,jb:je,kb:ke) :: advx,advy,advz,dum,divx
      real, dimension(ib:ie+1,jb:je,kb:ke) :: rru
      real, dimension(ib:ie,jb:je+1,kb:ke) :: rrv
      real, dimension(ib:ie,jb:je,kb:ke+1) :: rrw
      real, dimension(ib:ie,jb:je,kb:ke) :: s,sten
      real :: dt

      integer i,j,k

      real s1,s2,s3,s4,s5
      real f1,f2,f3
      real b1,b2,b3
      real w1,w2,w3
      real tem

      real epsilon,onedsix,thdtw
      parameter(epsilon=1.0e-08)
      parameter(onedsix=1.0/6.0)
      parameter(thdtw=13.0/12.0)

      real, parameter :: tem2 = 1.0/6.0
      real, parameter :: tem3 = 1.0/12.0
 
!----------------------------------------------------------------
! Advection in x-direction

!$omp parallel do default(shared)   &
!$omp private(i,j,k,s1,s2,s3,s4,s5,f1,f2,f3,b1,b2,b3,w1,w2,w3)
      do k=1,nk
      do j=1,nj
      do i=1,ni+1
        if(rru(i,j,k).ge.0.0)then
          s1=s(i-3,j,k)
          s2=s(i-2,j,k)
          s3=s(i-1,j,k)
          s4=s(i  ,j,k)
          s5=s(i+1,j,k)
        else
          s1=s(i+2,j,k)
          s2=s(i+1,j,k)
          s3=s(i  ,j,k)
          s4=s(i-1,j,k)
          s5=s(i-2,j,k)
        endif

        f1=( 2.0*s1 -7.0*s2 +11.0*s3 )*onedsix
        f2=(    -s2 +5.0*s3  +2.0*s4 )*onedsix
        f3=( 2.0*s3 +5.0*s4      -s5 )*onedsix

        b1=thdtw*( s1 -2.0*s2 +s3 )**2 + 0.25*(     s1 -4.0*s2 +3.0*s3 )**2
        b2=thdtw*( s2 -2.0*s3 +s4 )**2 + 0.25*(     s2             -s4 )**2
        b3=thdtw*( s3 -2.0*s4 +s5 )**2 + 0.25*( 3.0*s3 -4.0*s4     +s5 )**2
 
        w1=0.10/(epsilon+b1)**2
        w2=0.60/(epsilon+b2)**2
        w3=0.30/(epsilon+b3)**2
 
        dum(i,j,k)=rru(i,j,k)*((w1*f1)+(w2*f2)+(w3*f3))/(w1+w2+w3)
      enddo
      enddo
      enddo

    IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        advx(i,j,k)=-(dum(i+1,j,k)-dum(i,j,k))*rdx*uh(i)
      enddo
      enddo
      enddo

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        advx(i,j,k)=-(xf(i+1)*dum(i+1,j,k)-xf(i)*dum(i,j,k))*rdx*uh(i)*rxh(i)
      enddo
      enddo
      enddo

    ENDIF

      IF(stat_qsrc.eq.1.and.(wbc.eq.2.or.ebc.eq.2).and.bflag.eq.1)THEN
        if(timestats.ge.1) time_advs=time_advs+mytime()
        call bsx(dt,bsq,rvh,rmh,dum)
      ENDIF

!----------------------------------------------------------------
! Advection in y-direction

    IF(axisymm.eq.0)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k,s1,s2,s3,s4,s5,f1,f2,f3,b1,b2,b3,w1,w2,w3)
      do k=1,nk
      do j=1,nj+1
      do i=1,ni
        if(rrv(i,j,k).ge.0.0)then
          s1=s(i,j-3,k)
          s2=s(i,j-2,k)
          s3=s(i,j-1,k)
          s4=s(i,j  ,k)
          s5=s(i,j+1,k)
        else
          s1=s(i,j+2,k)
          s2=s(i,j+1,k)
          s3=s(i,j  ,k)
          s4=s(i,j-1,k)
          s5=s(i,j-2,k)
        endif

        f1=( 2.0*s1 -7.0*s2 +11.0*s3 )*onedsix
        f2=(    -s2 +5.0*s3  +2.0*s4 )*onedsix
        f3=( 2.0*s3 +5.0*s4      -s5 )*onedsix

        b1=thdtw*( s1 -2.0*s2 +s3 )**2 + 0.25*(     s1 -4.0*s2 +3.0*s3 )**2
        b2=thdtw*( s2 -2.0*s3 +s4 )**2 + 0.25*(     s2             -s4 )**2
        b3=thdtw*( s3 -2.0*s4 +s5 )**2 + 0.25*( 3.0*s3 -4.0*s4     +s5 )**2
 
        w1=0.10/(epsilon+b1)**2
        w2=0.60/(epsilon+b2)**2
        w3=0.30/(epsilon+b3)**2
 
        dum(i,j,k)=rrv(i,j,k)*((w1*f1)+(w2*f2)+(w3*f3))/(w1+w2+w3)
      enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        advy(i,j,k)=-(dum(i,j+1,k)-dum(i,j,k))*rdy*vh(j)
      enddo
      enddo
      enddo

      IF(stat_qsrc.eq.1.and.(sbc.eq.2.or.nbc.eq.2).and.bflag.eq.1)THEN
        if(timestats.ge.1) time_advs=time_advs+mytime()
        call bsy(dt,bsq,ruh,rmh,dum)
      ENDIF

    ELSE

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        advy(i,j,k)=0.0
      enddo
      enddo
      enddo

    ENDIF

!----------------------------------------------------------------
! Advection in z-direction

!$omp parallel do default(shared)   &
!$omp private(i,j,k,s1,s2,s3,s4,s5,f1,f2,f3,b1,b2,b3,w1,w2,w3)
      do k=4,nk-2
      do j=1,nj
      do i=1,ni
        if(rrw(i,j,k).ge.0.0)then
          s1=s(i,j,k-3)
          s2=s(i,j,k-2)
          s3=s(i,j,k-1)
          s4=s(i,j,k  )
          s5=s(i,j,k+1)
        else
          s1=s(i,j,k+2)
          s2=s(i,j,k+1)
          s3=s(i,j,k  )
          s4=s(i,j,k-1)
          s5=s(i,j,k-2)
        endif

        f1=( 2.0*s1 -7.0*s2 +11.0*s3 )*onedsix
        f2=(    -s2 +5.0*s3  +2.0*s4 )*onedsix
        f3=( 2.0*s3 +5.0*s4      -s5 )*onedsix

        b1=thdtw*( s1 -2.0*s2 +s3 )**2 + 0.25*(     s1 -4.0*s2 +3.0*s3 )**2
        b2=thdtw*( s2 -2.0*s3 +s4 )**2 + 0.25*(     s2             -s4 )**2
        b3=thdtw*( s3 -2.0*s4 +s5 )**2 + 0.25*( 3.0*s3 -4.0*s4     +s5 )**2
 
        w1=0.10/(epsilon+b1)**2
        w2=0.60/(epsilon+b2)**2
        w3=0.30/(epsilon+b3)**2
 
        dum(i,j,k)=rrw(i,j,k)*((w1*f1)+(w2*f2)+(w3*f3))/(w1+w2+w3)
      enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=3,(nk-1),(nk-4)
      do j=1,nj
      do i=1,ni
#ifdef SGN
        ! this form of code is used for IBM/xlf compiler:
        dum(i,j,k)=rrw(i,j,k)*( 7.0*(s(i,j,k  )+s(i,j,k-1))          &
                                   -(s(i,j,k+1)+s(i,j,k-2))          &
        -sign(1.0,rrw(i,j,k))*( 3.0*(s(i,j,k  )-s(i,j,k-1))          &
                                   -(s(i,j,k+1)-s(i,j,k-2)) ) )*tem3
#else
        ! this seems to be faster on most other platforms:
        if(rrw(i,j,k).ge.0.)then
          dum(i,j,k)=rrw(i,j,k)    &
                    *(-s(i,j,k-2)+5.*s(i,j,k-1)+2.*s(i,j,k))*tem2
        else
          dum(i,j,k)=rrw(i,j,k)    &
                    *(-s(i,j,k+1)+5.*s(i,j,k)+2.*s(i,j,k-1))*tem2
        endif
#endif
      enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=2,nk,(nk-2)
      do j=1,nj
      do i=1,ni
        dum(i,j,k)=rrw(i,j,k)*0.5*(s(i,j,k-1)+s(i,j,k))
      enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,(nk+1),nk
      do j=1,nj
      do i=1,ni
        dum(i,j,k)=0.0
      enddo
      enddo
      enddo

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        advz(i,j,k)=-(dum(i,j,k+1)-dum(i,j,k))*rdz*mh(i,j,k)
      enddo
      enddo
      enddo

      IF(terrain_flag)THEN

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          advz(i,j,k)=advz(i,j,k)/gz(i,j)
        enddo
        enddo
        enddo

      ENDIF

!----------------------------------------------------------------

!$omp parallel do default(shared)   &
!$omp private(i,j,k)
      do k=1,nk
      do j=1,nj
      do i=1,ni
        sten(i,j,k)=sten(i,j,k)+( advx(i,j,k)+advy(i,j,k)+advz(i,j,k)    &
                                 +s(i,j,k)*divx(i,j,k) )*rr0(i,j,k)
      enddo
      enddo
      enddo

!----------------------------------------------------------------

      if(timestats.ge.1) time_advs=time_advs+mytime()
 
      return
      end



writeout.F/     1298670057  19071 8000  100644  81164     `


      subroutine setup_output(tdef,qname,budname,xh,xf,yh,yf,xfref,yfref,zh,zf)
      implicit none

      include 'input.incl'
#ifdef MPI
      include 'mpif.h'
#endif

      character*15 :: tdef
      character*3, dimension(maxq) :: qname
      character*6, dimension(maxq) :: budname
      real, dimension(ib:ie) :: xh
      real, dimension(ib:ie+1) :: xf
      real, dimension(jb:je) :: yh
      real, dimension(jb:je+1) :: yf
      real, dimension(-2:nx+4) :: xfref
      real, dimension(-2:ny+4) :: yfref
      real, dimension(ib:ie,jb:je,kb:ke) :: zh
      real, dimension(ib:ie,jb:je,kb:ke+1) :: zf

!-----------------------------------------------------------------------

      integer :: i,j,k,n,flag
      character*8 text1
      character*30 text2
      character*50 fname
      character*8,  dimension(:), allocatable :: varname
      character*30, dimension(:), allocatable :: vardesc

!-----------------------------------------------------------------------
! get length of output_path string

    flag=0
    n=0
    do while( flag.eq.0 .and. n.le.70 )
      n=n+1
      if( output_path(n:n).eq.' ' .or. output_path(n:n).eq.'.' ) flag=1
    enddo

    strlen=n-1

!--------------------------------------
! get length of output_basename string

    flag=0
    n=0
    do while( flag.eq.0 .and. n.le.70 )
      n=n+1
      if( output_basename(n:n).eq.' ' .or. output_basename(n:n).eq.'.' ) flag=1
    enddo

    baselen=n-1

!------

    totlen = strlen + baselen

      string = '                                                                      '
    statfile = '                                                                      '
     sstring = '                                                                      '

  if(strlen.gt.0)then
      string(1:strlen) = output_path(1:strlen)
    statfile(1:strlen) = output_path(1:strlen)
  endif

      string(strlen+1:strlen+baselen) = output_basename(1:baselen)
    statfile(strlen+1:strlen+baselen) = output_basename(1:baselen)
     sstring(1:baselen) = output_basename(1:baselen)

    statfile(totlen+1:totlen+1+12) = '_stats.dat  '

    if(myid.eq.0)then
          write(outfile,*)
          write(outfile,*) '  writing ctl files ... '
          write(outfile,*)
          write(outfile,*) '  strlen          = ',strlen
          write(outfile,*) '  baselen         = ',baselen
          write(outfile,*) '  totlen          = ',totlen
        if(strlen.gt.0)then
          write(outfile,*) '  output_path     = ',output_path(1:strlen)
        endif
          write(outfile,*) '  output_basename = ',output_basename(1:baselen)
          write(outfile,*) '  statfile        = ',statfile
          write(outfile,*)
    endif

      IF( myid.eq.0 )THEN
        if(output_filetype.eq.2)then
          tdef = '00:00Z03JUL0001'
        else
          tdef = '00:00Z03JUL2000'
        endif
        IF( radopt.ge.1 )THEN
          write(tdef( 1: 2),237) hour
          write(tdef( 4: 5),237) minute
          write(tdef( 7: 8),237) day
        if(output_filetype.eq.2)then
          write(tdef(12:15),238) 1
        else
          write(tdef(12:15),238) year
        endif
237       format(i2.2)
238       format(i4.4)
          IF( month.eq.1 )THEN
            write(tdef(9:11),239) 'JAN'
          ELSEIF( month.eq.2 )THEN
            write(tdef(9:11),239) 'FEB'
          ELSEIF( month.eq.3 )THEN
            write(tdef(9:11),239) 'MAR'
          ELSEIF( month.eq.4 )THEN
            write(tdef(9:11),239) 'APR'
          ELSEIF( month.eq.5 )THEN
            write(tdef(9:11),239) 'MAY'
          ELSEIF( month.eq.6 )THEN
            write(tdef(9:11),239) 'JUN'
          ELSEIF( month.eq.7 )THEN
            write(tdef(9:11),239) 'JUL'
          ELSEIF( month.eq.8 )THEN
            write(tdef(9:11),239) 'AUG'
          ELSEIF( month.eq.9 )THEN
            write(tdef(9:11),239) 'SEP'
          ELSEIF( month.eq.10 )THEN
            write(tdef(9:11),239) 'OCT'
          ELSEIF( month.eq.11 )THEN
            write(tdef(9:11),239) 'NOV'
          ELSEIF( month.eq.12 )THEN
            write(tdef(9:11),239) 'DEC'
          ELSE
            print *
            print *,'  Invalid value for MONTH '
            print *
            print *,'  Stopping CM1 .... '
            print *
            call stopcm1
          ENDIF
239       format(a3)
        ENDIF
      ENDIF

!-----------------------------------------------------------------------
!  GrADS descriptor files
!-----------------------------------------------------------------------

  grads_descriptors: IF( output_format.eq.1 )THEN

      IF(myid.eq.0)THEN

        allocate( varname(1000) )
        allocate( vardesc(1000) )

!----------------------------
! s file:
! accounts for both 2d and 3d variables:

    sout2d = 0
    s_out = 0

    ! all 2d variables MUST be listed first:

    if(output_rain   .eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'rn      '
      vardesc(s_out) = 'accumulated rainfall (cm)     '
    endif
    if(output_sws    .eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'sws     '
      vardesc(s_out) = 'max wind speed lwst lvl (m/s) '
      s_out = s_out + 1
      varname(s_out) = 'svs     '
      vardesc(s_out) = 'max vert vort lwst lvl (s-1)  '
      s_out = s_out + 1
      varname(s_out) = 'sps     '
      vardesc(s_out) = 'min pressure lowest level (Pa)'
      s_out = s_out + 1
      varname(s_out) = 'srs     '
      vardesc(s_out) = 'max sfc rainwater (kg/kg)     '
      s_out = s_out + 1
      varname(s_out) = 'sgs     '
      vardesc(s_out) = 'max sfc graupel/hail (kg/kg)  '
      s_out = s_out + 1
      varname(s_out) = 'sus     '
      vardesc(s_out) = 'max w at 5 km AGL (m/s)       '
      s_out = s_out + 1
      varname(s_out) = 'shs     '
      vardesc(s_out) = 'max integrated uh (m2/s2)     '
    endif
    if(nrain.eq.2)then
      if(output_rain   .eq.1)then
        s_out = s_out + 1
        varname(s_out) = 'rn2     '
        vardesc(s_out) = 'translated rainfall (cm)      '
      endif
      if(output_sws    .eq.1)then
        s_out = s_out + 1
        varname(s_out) = 'sws2    '
        vardesc(s_out) = 'translated max wind (m/s)     '
        s_out = s_out + 1
        varname(s_out) = 'svs2    '
        vardesc(s_out) = 'translated max vorticity (s-1)'
        s_out = s_out + 1
        varname(s_out) = 'sps2    '
        vardesc(s_out) = 'translated min pressure (Pa)  '
        s_out = s_out + 1
        varname(s_out) = 'srs2    '
        vardesc(s_out) = 'translated max rainwater      '
        s_out = s_out + 1
        varname(s_out) = 'sgs2    '
        vardesc(s_out) = 'translated max graupel/hail   '
        s_out = s_out + 1
        varname(s_out) = 'sus2    '
        vardesc(s_out) = 'translated max w at 5 km (m/s)'
        s_out = s_out + 1
        varname(s_out) = 'shs2    '
        vardesc(s_out) = 'translated max integrated uh  '
      endif
    endif
    if(output_uh.eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'uh      '
      vardesc(s_out) = 'integ. updraft helicity (m2/s2'
    endif
    if(output_coldpool.eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'cpc     '
      vardesc(s_out) = 'cold pool intensity C (m/s)   '
      s_out = s_out + 1
      varname(s_out) = 'cph     '
      vardesc(s_out) = 'cold pool depth h (m AGL)     '
    endif
    if(output_sfcflx .eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'thflux  '
      vardesc(s_out) = 'sfc theta flux (K m/s)        '
      s_out = s_out + 1
      varname(s_out) = 'qvflux  '
      vardesc(s_out) = 'sfc water vapor flux (g/g m/s)'
      s_out = s_out + 1
      varname(s_out) = 'cd      '
      vardesc(s_out) = 'exchange coeff for momentum   '
      s_out = s_out + 1
      varname(s_out) = 'ce      '
      vardesc(s_out) = 'exchange coeff for enthalpy   '
      s_out = s_out + 1
      varname(s_out) = 'tsk     '
      vardesc(s_out) = 'soil/ocean temperature (K)    '
    endif
    if(output_zs     .eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'zs      '
      vardesc(s_out) = 'terrain height (m)            '
    endif
    if(output_dbz    .eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'cref    '
      vardesc(s_out) = 'composite reflectivity (dBZ)  '
    endif
    if(output_sfcparams.eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'xland   '
      vardesc(s_out) = 'land/water flag (1=land,2=wtr)'
      s_out = s_out + 1
      varname(s_out) = 'lu      '
      vardesc(s_out) = 'land use index                '
      s_out = s_out + 1
      varname(s_out) = 'mavail  '
      vardesc(s_out) = 'surface moisture availability '
    endif
    if((output_sfcparams.eq.1).and.(sfcmodel.eq.2.or.oceanmodel.eq.2))then
      s_out = s_out + 1
      varname(s_out) = 'tmn     '
      vardesc(s_out) = 'deep-layer soil temperature (K'
      s_out = s_out + 1
      varname(s_out) = 'hfx     '
      vardesc(s_out) = 'heat flux at surface (W/m^2)  '
      s_out = s_out + 1
      varname(s_out) = 'qfx     '
      vardesc(s_out) = 'moisture flux at sfc (kg/m^2/s'
      s_out = s_out + 1
      varname(s_out) = 'gsw     '
      vardesc(s_out) = 'downward SW flux at sfc (W/m2)'
      s_out = s_out + 1
      varname(s_out) = 'glw     '
      vardesc(s_out) = 'downward LW flux at sfc (W/m2)'
    endif
    if((output_sfcparams.eq.1).and.(sfcmodel.eq.2))then
      s_out = s_out + 1
      varname(s_out) = 'tslb1   '
      vardesc(s_out) = 'soil temp, layer 1 (K)        '
      s_out = s_out + 1
      varname(s_out) = 'tslb2   '
      vardesc(s_out) = 'soil temp, layer 2 (K)        '
      s_out = s_out + 1
      varname(s_out) = 'tslb3   '
      vardesc(s_out) = 'soil temp, layer 3 (K)        '
      s_out = s_out + 1
      varname(s_out) = 'tslb4   '
      vardesc(s_out) = 'soil temp, layer 4 (K)        '
      s_out = s_out + 1
      varname(s_out) = 'tslb5   '
      vardesc(s_out) = 'soil temp, layer 5 (K)        '
    endif
    if(output_sfcparams.eq.1.and.oceanmodel.eq.2)then
      s_out = s_out + 1
      varname(s_out) = 'tml     '
      vardesc(s_out) = 'ocean mixed layer temp (K)    '
      s_out = s_out + 1
      varname(s_out) = 'hml     '
      vardesc(s_out) = 'ocean mixed layer depth (m)   '
      s_out = s_out + 1
      varname(s_out) = 'huml    '
      vardesc(s_out) = 'ocean mixed layer u vel. (m/s)'
      s_out = s_out + 1
      varname(s_out) = 'hvml    '
      vardesc(s_out) = 'ocean mixed layer v vel. (m/s)'
    endif
    if(output_radten.eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'radsw   '
      vardesc(s_out) = 'solar radiation at surface    '
      s_out = s_out + 1
      varname(s_out) = 'rnflx   '
      vardesc(s_out) = 'net radiation absorbed by sfc '
      s_out = s_out + 1
      varname(s_out) = 'radswnet'
      vardesc(s_out) = 'net solar radiation           '
      s_out = s_out + 1
      varname(s_out) = 'radlwin '
      vardesc(s_out) = 'incoming longwave radiation   '
    endif
    IF(output_sfcdiags.eq.1)THEN
      s_out = s_out + 1
      varname(s_out) = 'u10     '
      vardesc(s_out) = 'diagnostic 10m u wind (m/s)   '
      s_out = s_out + 1
      varname(s_out) = 'v10     '
      vardesc(s_out) = 'diagnostic 10m v wind (m/s)   '
      s_out = s_out + 1
      varname(s_out) = 't2      '
      vardesc(s_out) = 'diagnostic 2m temperature (K) '
      s_out = s_out + 1
      varname(s_out) = 'q2      '
      vardesc(s_out) = 'diagnostic 2m mixing ratio g/g'
      s_out = s_out + 1
      varname(s_out) = 'znt     '
      vardesc(s_out) = 'roughness length (m)          '
      s_out = s_out + 1
      varname(s_out) = 'ust     '
      vardesc(s_out) = 'u* in similarity theory (m/s) '
      s_out = s_out + 1
      varname(s_out) = 'hpbl    '
    if(ipbl.eq.1)then
      vardesc(s_out) = 'PBL height (m) (from PBL schem'
    else
      vardesc(s_out) = 'rough estimate of PBL hght (m)'
    endif
      s_out = s_out + 1
      varname(s_out) = 'zol     '
      vardesc(s_out) = 'z/L (z over Monin-Obukhov len)'
      s_out = s_out + 1
      varname(s_out) = 'mol     '
      vardesc(s_out) = 'T* (similarity theory) (K)    '
      s_out = s_out + 1
      varname(s_out) = 'br      '
      vardesc(s_out) = 'bulk Richardson No in sfc lay.'
    ENDIF

    ! done with 2d variables

    sout2d = s_out

    ! Now, all 3d variables:

    if(output_zh     .eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'zh      '
      vardesc(s_out) = 'height on model levels (m)    '
    endif
    if(output_th     .eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'th      '
      vardesc(s_out) = 'potential temp. (K)           '
    endif
    if(output_thpert .eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'thpert  '
      vardesc(s_out) = 'potential temp. pert. (K)     '
    endif
    if(output_prs    .eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'prs     '
      vardesc(s_out) = 'pressure (Pa)                 '
    endif
    if(output_prspert.eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'prspert '
      vardesc(s_out) = 'pressure pert. (Pa)           '
    endif
    if(output_pi     .eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'pi      '
      vardesc(s_out) = 'nondimensional pressure       '
    endif
    if(output_pipert .eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'pipert  '
      vardesc(s_out) = 'nondimensional pressure pert. '
    endif
    if(output_rho    .eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'rho     '
      vardesc(s_out) = 'density (kg/m^3)              '
    endif
    if(output_rhopert.eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'rhopert '
      vardesc(s_out) = 'density pert. (kg/m^3)        '
    endif
    if(iptra         .eq.1)then
      do n=1,npt
        text1='pt      '
        if(n.lt.10)then
          write(text1(3:3),155) n
155       format(i1.1)
        else
          write(text1(3:4),154) n
154       format(i2.2)
        endif
        s_out = s_out + 1
        varname(s_out) = text1
        vardesc(s_out) = 'passive tracer                '
      enddo
    endif
    if(output_qv     .eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'qv      '
      vardesc(s_out) = 'water vapor mixing ratio      '
    endif
    if(output_qvpert .eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'qvpert  '
      vardesc(s_out) = 'qv pert                       '
    endif
    if(output_q      .eq.1)then
      do n=1,numq
        if(n.ne.nqv)then
          text1='        '
          text2='                              '
          write(text1(1:3),156) qname(n)
          write(text2(1:3),156) qname(n)
156       format(a3)
          s_out = s_out + 1
          varname(s_out) = text1
          vardesc(s_out) = text2
        endif
      enddo
    endif
    if(output_dbz    .eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'dbz     '
      vardesc(s_out) = 'reflectivity (dBZ)            '
    endif
    if(output_uinterp.eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'uinterp '
      vardesc(s_out) = 'u interp. to scalar points    '
    endif
    if(output_vinterp.eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'vinterp '
      vardesc(s_out) = 'v interp. to scalar points    '
    endif
    if(output_winterp.eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'winterp '
      vardesc(s_out) = 'w interp. to scalar points    '
    endif
    if(output_vort.eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'xvort   '
      vardesc(s_out) = 'horiz vorticity (x) (s^-1)    '
      s_out = s_out + 1
      varname(s_out) = 'yvort   '
      vardesc(s_out) = 'horiz vorticity (y) (s^-1)    '
      s_out = s_out + 1
      varname(s_out) = 'zvort   '
      vardesc(s_out) = 'vertical vorticity (s^-1)     '
    endif
    if(output_basestate.eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'pi0     '
      vardesc(s_out) = 'base-state nondim. pressure   '
      s_out = s_out + 1
      varname(s_out) = 'th0     '
      vardesc(s_out) = 'base-state potential temp (K) '
      s_out = s_out + 1
      varname(s_out) = 'prs0    '
      vardesc(s_out) = 'base-state pressure (Pa)      '
      s_out = s_out + 1
      varname(s_out) = 'qv0     '
      vardesc(s_out) = 'base-state qv (kg/kg)         '
    endif
    if(output_dissten.eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'dissten '
      vardesc(s_out) = 'dissipative heating tendency  '
    endif
    if(output_pblten.eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'thpten  '
      vardesc(s_out) = 'pbl tendency:  theta          '
      s_out = s_out + 1
      varname(s_out) = 'qvpten  '
      vardesc(s_out) = 'pbl tendency:  qv             '
      s_out = s_out + 1
      varname(s_out) = 'qcpten  '
      vardesc(s_out) = 'pbl tendency:  qc             '
      s_out = s_out + 1
      varname(s_out) = 'qipten  '
      vardesc(s_out) = 'pbl tendency:  qi             '
      s_out = s_out + 1
      varname(s_out) = 'upten   '
      vardesc(s_out) = 'pbl tendency:  u              '
      s_out = s_out + 1
      varname(s_out) = 'vpten   '
      vardesc(s_out) = 'pbl tendency:  v              '
    endif
    if(output_radten.eq.1)then
      s_out = s_out + 1
      varname(s_out) = 'swten   '
      vardesc(s_out) = 'pot temp tendency, sw rad (K/s'
      s_out = s_out + 1
      varname(s_out) = 'lwten   '
      vardesc(s_out) = 'pot temp tendency, lw rad (K/s'
    endif

    sout3d = s_out - sout2d

!----------------------------
!  ready to write GrADS descriptor file:

  IF(s_out.ge.1)THEN
    string(totlen+1:totlen+1+12) = '_s.ctl'
    if(myid.eq.0)write(outfile,*) string
    open(unit=50,file=string,status='unknown')

  if(output_filetype.eq.1)then
    sstring(baselen+1:baselen+1+12) = '_s.dat'
  elseif(output_filetype.eq.2)then
    sstring(baselen+1:baselen+1+12) = '_%y4_s.dat'
  endif
    write(50,201) sstring
!!!    write(50,222)
    if(output_filetype.eq.2) write(50,221)
    write(50,202)
    write(50,203)
    if(stretch_x.ge.1)then
      write(50,214) nx
      do i=1,nx
        write(50,217) 0.001*0.5*(xfref(i)+xfref(i+1))
      enddo
    else
      write(50,204) nx,xh(1)/1000.0,dx/1000.0
    endif
    if(stretch_y.ge.1)then
      write(50,215) ny
      do j=1,ny
        write(50,217) 0.001*0.5*(yfref(j)+yfref(j+1))
      enddo
    else
      write(50,205) ny,yh(1)/1000.0,dy/1000.0
    endif
    if(stretch_z.eq.0)then
      write(50,206) nz,0.5*dz/1000.0,dz/1000.0
    else
      write(50,216) nz
      do k=1,nz
        write(50,217) 0.001*zh(1,1,k)
      enddo
    endif
  if(output_filetype.eq.1)then
    write(50,207) int(1+timax/tapfrq),tdef,max(1,int(tapfrq/60.0))
  elseif(output_filetype.eq.2)then
    write(50,227) int(1+timax/tapfrq),tdef
  endif
    write(50,208) s_out
    ! account for both 2d and 3d output files:
    do n=1,sout2d
      write(50,209) varname(n), 0,vardesc(n)
    enddo
    do n=sout2d+1,s_out
      write(50,209) varname(n),nk,vardesc(n)
    enddo
    write(50,210)
    close(unit=50)
  ENDIF

!-----------------------------------
! i file:  (for interpolated output when using terrain)
!   follows s file very closely:
!   no need to re-define varname,vardesc...

  IF(s_out.ge.1 .and. terrain_flag .and. output_interp.eq.1)THEN
    string(totlen+1:totlen+1+12) = '_i.ctl'
    if(myid.eq.0)write(outfile,*) string
    open(unit=50,file=string,status='unknown')

  if(output_filetype.eq.1)then
    sstring(baselen+1:baselen+1+12) = '_i.dat'
  elseif(output_filetype.eq.2)then
    sstring(baselen+1:baselen+1+12) = '_%y4_i.dat'
  endif

    write(50,201) sstring
!!!    write(50,222)
    if(output_filetype.eq.2) write(50,221)
    write(50,202)
    write(50,203)
    if(stretch_x.ge.1)then
      write(50,214) nx
      do i=1,nx
        write(50,217) 0.001*0.5*(xfref(i)+xfref(i+1))
      enddo
    else
      write(50,204) nx,xh(1)/1000.0,dx/1000.0
    endif
    if(stretch_y.ge.1)then
      write(50,215) ny
      do j=1,ny
        write(50,217) 0.001*0.5*(yfref(j)+yfref(j+1))
      enddo
    else
      write(50,205) ny,yh(1)/1000.0,dy/1000.0
    endif
    if(stretch_z.eq.0)then
      write(50,206) nz,0.5*dz/1000.0,dz/1000.0
    else
      write(50,216) nz
      do k=1,nz
        write(50,217) 0.001*zh(1,1,k)
      enddo
    endif
  if(output_filetype.eq.1)then
    write(50,207) int(1+timax/tapfrq),tdef,max(1,int(tapfrq/60.0))
  elseif(output_filetype.eq.2)then
    write(50,227) int(1+timax/tapfrq),tdef
  endif
    write(50,208) s_out
    ! account for both 2d and 3d output files:
    do n=1,sout2d
      write(50,209) varname(n), 0,vardesc(n)
    enddo
    do n=sout2d+1,s_out
      write(50,209) varname(n),nk,vardesc(n)
    enddo
    write(50,210)
    close(unit=50)
  ENDIF

!-----------------------------------
! u file:
! I have assumed that all variables are 3d for this file.

    u_out = 0

    if(output_u    .eq.1)then
      u_out = u_out + 1
      varname(u_out) = 'u       '
      vardesc(u_out) = 'E-W velocity (m/s)            '
    endif
    if(output_upert.eq.1)then
      u_out = u_out + 1
      varname(u_out) = 'upert   '
      vardesc(u_out) = 'u pert. (m/s)                 '
    endif
    if(output_basestate.eq.1)then
      u_out = u_out + 1
      varname(u_out) = 'u0      '
      vardesc(u_out) = 'base-state u (m/s)            '
    endif

  IF(u_out.ge.1)THEN
    string(totlen+1:totlen+1+12) = '_u.ctl'
    if(myid.eq.0)write(outfile,*) string
    open(unit=50,file=string,status='unknown')

  if(output_filetype.eq.1)then
    sstring(baselen+1:baselen+1+12) = '_u.dat'
  elseif(output_filetype.eq.2)then
    sstring(baselen+1:baselen+1+12) = '_%y4_u.dat'
  endif

    write(50,201) sstring
    if(output_filetype.eq.2) write(50,221)
    write(50,202)
    write(50,203)
    if(stretch_x.ge.1)then
      write(50,214) nx+1
      do i=1,nx+1
        write(50,217) 0.001*xfref(i)
      enddo
    else
      write(50,204) nx+1,xf(1)/1000.0,dx/1000.0
    endif
    if(stretch_y.ge.1)then
      write(50,215) ny
      do j=1,ny
        write(50,217) 0.001*0.5*(yfref(j)+yfref(j+1))
      enddo
    else
      write(50,205) ny,yh(1)/1000.0,dy/1000.0
    endif
    if(stretch_z.eq.0)then
      write(50,206) nz,0.5*dz/1000.0,dz/1000.0
    else
      write(50,216) nz
      do k=1,nz
        write(50,217) 0.001*zh(1,1,k)
      enddo
    endif
  if(output_filetype.eq.1)then
    write(50,207) int(1+timax/tapfrq),tdef,max(1,int(tapfrq/60.0))
  elseif(output_filetype.eq.2)then
    write(50,227) int(1+timax/tapfrq),tdef
  endif
    write(50,208) u_out
    ! assumes all variables are 3d:
    do n=1,u_out
      write(50,209) varname(n),nk,vardesc(n)
    enddo
    write(50,210)
    close(unit=50)
  ENDIF

!-----------------------------------
! v file:
! I have assumed that all variables are 3d for this file.

    v_out = 0

    if(output_v    .eq.1)then
      v_out = v_out + 1
      varname(v_out) = 'v       '
      vardesc(v_out) = 'N-S velocity (m/s)            '
    endif
    if(output_vpert.eq.1)then
      v_out = v_out + 1
      varname(v_out) = 'vpert   '
      vardesc(v_out) = 'v pert (m/s)                  '
    endif
    if(output_basestate.eq.1)then
      v_out = v_out + 1
      varname(v_out) = 'v0      '
      vardesc(v_out) = 'base-state v (m/s)            '
    endif

  IF(v_out.ge.1)THEN
    string(totlen+1:totlen+1+12) = '_v.ctl'
    if(myid.eq.0)write(outfile,*) string
    open(unit=50,file=string,status='unknown')

  if(output_filetype.eq.1)then
    sstring(baselen+1:baselen+1+12) = '_v.dat'
  elseif(output_filetype.eq.2)then
    sstring(baselen+1:baselen+1+12) = '_%y4_v.dat'
  endif

    write(50,201) sstring
    if(output_filetype.eq.2) write(50,221)
    write(50,202)
    write(50,203)
    if(stretch_x.ge.1)then
      write(50,214) nx
      do i=1,nx
        write(50,217) 0.001*0.5*(xfref(i)+xfref(i+1))
      enddo
    else
      write(50,204) nx,xh(1)/1000.0,dx/1000.0
    endif
    if(stretch_y.ge.1)then
      write(50,215) ny+1
      do j=1,ny+1
        write(50,217) 0.001*yfref(j)
      enddo
    else
      write(50,205) ny+1,yf(1)/1000.0,dy/1000.0
    endif
    if(stretch_z.eq.0)then
      write(50,206) nz,0.5*dz/1000.0,dz/1000.0
    else
      write(50,216) nz
      do k=1,nz
        write(50,217) 0.001*zh(1,1,k)
      enddo
    endif
  if(output_filetype.eq.1)then
    write(50,207) int(1+timax/tapfrq),tdef,max(1,int(tapfrq/60.0))
  elseif(output_filetype.eq.2)then
    write(50,227) int(1+timax/tapfrq),tdef
  endif
    write(50,208) v_out
    ! assumes all variables are 3d:
    do n=1,v_out
      write(50,209) varname(n),nk,vardesc(n)
    enddo
    write(50,210)
    close(unit=50)
  ENDIF

!-----------------------------------
! w file:
! I have assumed that all variables are 3d for this file.

    w_out = 0

    if(output_w  .eq.1)then
      w_out = w_out + 1
      varname(w_out) = 'w       '
      vardesc(w_out) = 'vertical velocity (m/s)       '
    endif
    if(output_tke.eq.1)then
      w_out = w_out + 1
      varname(w_out) = 'tke     '
      vardesc(w_out) = 'turb. kinetic energy (m^2/s^2)'
    endif
    if(output_km .eq.1)then
      w_out = w_out + 1
      varname(w_out) = 'kmh     '
      IF( ipbl.eq.1 )THEN
        vardesc(w_out) = 'turb. coef. for mo. (2D Smag.)'
      ELSE
        vardesc(w_out) = 'turb. coef. for mo. (m^2/s)   '
      ENDIF
      w_out = w_out + 1
      varname(w_out) = 'kmv     '
      IF( ipbl.eq.1 )THEN
        vardesc(w_out) = 'turb. coef. for mo. (from YSU)'
      ELSE
        vardesc(w_out) = 'turb. coef. for mo. (m^2/s)   '
      ENDIF
    endif
    if(output_kh .eq.1)then
      w_out = w_out + 1
      varname(w_out) = 'khh     '
      IF( ipbl.eq.1 )THEN
        vardesc(w_out) = 'turb. coef. for scalar (2D Sm)'
      ELSE
        vardesc(w_out) = 'turb. coef. for scalar (m^2/s)'
      ENDIF
      w_out = w_out + 1
      varname(w_out) = 'khv     '
      IF( ipbl.eq.1 )THEN
        vardesc(w_out) = 'turb. coef. for scalar (YSU)  '
      ELSE
        vardesc(w_out) = 'turb. coef. for scalar (m^2/s)'
      ENDIF
    endif

  IF(w_out.ge.1)THEN
    string(totlen+1:totlen+1+12) = '_w.ctl'
    if(myid.eq.0)write(outfile,*) string
    open(unit=50,file=string,status='unknown')

  if(output_filetype.eq.1)then
    sstring(baselen+1:baselen+1+12) = '_w.dat'
  elseif(output_filetype.eq.2)then
    sstring(baselen+1:baselen+1+12) = '_%y4_w.dat'
  endif

    write(50,201) sstring
    if(output_filetype.eq.2) write(50,221)
    write(50,202)
    write(50,203)
    if(stretch_x.ge.1)then
      write(50,214) nx
      do i=1,nx
        write(50,217) 0.001*0.5*(xfref(i)+xfref(i+1))
      enddo
    else
      write(50,204) nx,xh(1)/1000.0,dx/1000.0
    endif
    if(stretch_y.ge.1)then
      write(50,215) ny
      do j=1,ny
        write(50,217) 0.001*0.5*(yfref(j)+yfref(j+1))
      enddo
    else
      write(50,205) ny,yh(1)/1000.0,dy/1000.0
    endif
    if(stretch_z.eq.0)then
      write(50,206) nz+1,0.0,dz/1000.0
    else
      write(50,216) nz+1
      do k=1,nz+1
        write(50,217) 0.001*zf(1,1,k)
      enddo
    endif
  if(output_filetype.eq.1)then
    write(50,207) int(1+timax/tapfrq),tdef,max(1,int(tapfrq/60.0))
  elseif(output_filetype.eq.2)then
    write(50,227) int(1+timax/tapfrq),tdef
  endif
    write(50,208) w_out
    ! assumes all variables are 3d:
    do n=1,w_out
      write(50,209) varname(n),nk+1,vardesc(n)
    enddo
    write(50,210)
    close(unit=50)
  ENDIF

!-----------------------------------

if(myid.eq.0)write(outfile,*)

201   format('dset ^',a70)
202   format('title CM1 output')
221   format('options template')
222   format('byteswapped')
203   format('undef -99999999.')
204   format('xdef ',i6,' linear ',f13.6,1x,f13.6)
214   format('xdef ',i6,' levels ')
205   format('ydef ',i6,' linear ',f13.6,1x,f13.6)
215   format('ydef ',i6,' levels ')
206   format('zdef ',i6,' linear ',f13.6,1x,f13.6)
216   format('zdef ',i6,' levels ')
217   format(2x,f13.6)
207   format('tdef ',i10,' linear ',a15,' ',i5,'MN')
227   format('tdef ',i10,' linear ',a15,' 1YR')
208   format('vars ',i4)
209   format(a8,2x,i6,'  99  ',a30)
210   format('endvars')

211   format(2x,f7.3)

!-----------------------------------------------------------------------

      call write_statsctl(tdef,qname,budname,1+nint(timax/max(statfrq,dtl)))

!-----------------------------------------------------------------------
!  Parcel data file:

      if(iprcl.eq.1.and.myid.eq.0)then

        string(totlen+1:totlen+1+12) = '_pdata.ctl  '
        if(myid.eq.0)write(outfile,*) string
        open(unit=50,file=string,status='unknown')

        sstring(baselen+1:baselen+1+12) = '_pdata.dat  '

        write(50,401) sstring
        write(50,402)
        write(50,403)
        write(50,404) nparcels
        write(50,405)
        write(50,406)
        write(50,407) 1+int(timax/prclfrq),tdef,max(1,int(prclfrq/60.0))
        write(50,408) npvals - 3
        write(50,409) 'x       ','x (m)                         '
        write(50,409) 'y       ','y (m)                         '
        write(50,409) 'z       ','z (m)                         '
        write(50,409) 'qv      ','water vapor mixing ratio      '
        write(50,409) 'qc      ','cloud water mixing ratio      '
        write(50,409) 'qr      ','rain water mixing ratio       '
        write(50,409) 'nm      ','squared Brunt-Vaisala frqncy  '
        write(50,409) 'u       ','u (m/s)                       '
        write(50,409) 'v       ','v (m/s)                       '
        write(50,409) 'w       ','w (m/s)                       '
        write(50,409) 'kh      ','turb. coef. for scalar (m^2/s)'
        write(50,409) 'the     ','theta-e (K)                   '
        write(50,409) 'b       ','buoyancy (m/s^2)              '
        write(50,409) 'dpdz    ','dpdz tendency (m/s^2)         '
        write(50,410)

401     format('dset ^',a70)
402     format('undef -9999.')
403     format('title ctl file for pdata.dat')
404     format('xdef ',i10,' linear 1 1')
405     format('ydef          1 linear 1 1')
406     format('zdef          1 linear 1 1')
407     format('tdef ',i10,' linear ',a15,' ',i5,'MN')
408     format('vars ',i6)
409     format(a8,' 1 99 ',a30)
410     format('endvars')

        close(unit=50)

      endif

!-----------------------------------------------------------------------

        deallocate( varname )
        deallocate( vardesc )

      ENDIF     ! endif for myid=0

#ifdef MPI
      call MPI_BCAST(sout2d,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(sout3d,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(s_out ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(u_out ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(v_out ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(w_out ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      call MPI_BCAST(z_out ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
#endif

if(myid.eq.0)then
      write(outfile,*)
      write(outfile,*) '  sout2d = ',sout2d
      write(outfile,*) '  sout3d = ',sout3d
      write(outfile,*) '  s_out  = ',s_out
      write(outfile,*) '  u_out  = ',u_out
      write(outfile,*) '  v_out  = ',v_out
      write(outfile,*) '  w_out  = ',w_out
      write(outfile,*) '  z_out  = ',z_out
endif

  ENDIF grads_descriptors

  if(myid.eq.0)write(outfile,*)

!-----------------------------------------------------------------------

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine write_statsctl(tdef,qname,budname,numt)
      implicit none
      include 'input.incl'

      character*15, intent(in) :: tdef
      character*3, intent(in), dimension(maxq) :: qname
      character*6, intent(in), dimension(maxq) :: budname
      integer, intent(in) :: numt

      integer :: n
      character*8 text1
      character*30 text2
      character*50 fname

!  Subroutine to write GrADS stats descriptor file:
!-----------------------------------------------------------------------
!  write descriptors for stats file:

    string(totlen+1:totlen+1+12) = '_stats.ctl  '
    if(myid.eq.0)write(outfile,*) string
    open(unit=50,file=string,status='unknown')

    sstring(baselen+1:baselen+1+12) = '_stats.dat  '

    write(50,301) sstring
    write(50,302)
    write(50,303)
    write(50,304)
    write(50,305)
    write(50,306)
    write(50,307) numt,tdef,max(1,int(max(statfrq,60.0)/60.0))
    write(50,308) stat_out
    IF( adapt_dt.eq.1 )   write(50,309) 'dt      ','average timestep dt (s)       '
    if(stat_w      .eq.1) write(50,309) 'wmax    ','max vertical velocity (m/s)   '
    if(stat_w      .eq.1) write(50,309) 'wmin    ','min vertical velocity (m/s)   '
    if(stat_u      .eq.1) write(50,309) 'umax    ','max E-W velocity (m/s)        '
    if(stat_u      .eq.1) write(50,309) 'umin    ','min E-W velocity (m/s)        '
    if(stat_u      .eq.1) write(50,309) 'sumax   ','max E-W velocity lwst lvl(m/s)'
    if(stat_u      .eq.1) write(50,309) 'sumin   ','min E-W velocity lwst lvl(m/s)'
    if(stat_v      .eq.1) write(50,309) 'vmax    ','max N-S velocity (m/s)        '
    if(stat_v      .eq.1) write(50,309) 'vmin    ','min N-S velocity (m/s)        '
    if(stat_v      .eq.1) write(50,309) 'svmax   ','max N-S velocity lwst lvl(m/s)'
    if(stat_v      .eq.1) write(50,309) 'svmin   ','min N-S velocity lwst lvl(m/s)'
    if(stat_rmw    .eq.1) write(50,309) 'rmw     ','radius of maximum V (m)       '
    if(stat_pipert .eq.1) write(50,309) 'ppimax  ','max pi pert.                  '
    if(stat_pipert .eq.1) write(50,309) 'ppimin  ','min pi pert.                  '
    if(stat_prspert.eq.1) write(50,309) 'ppmax   ','max prs pert.(Pa)             '
    if(stat_prspert.eq.1) write(50,309) 'ppmin   ','min prs pert.(Pa)             '
    if(stat_thpert .eq.1) write(50,309) 'thpmax  ','max potential temp. pert. (K) '
    if(stat_thpert .eq.1) write(50,309) 'thpmin  ','min potential temp. pert. (K) '
    if(stat_thpert .eq.1) write(50,309) 'sthpmax ','max pot temp pert lwst lvl (K)'
    if(stat_thpert .eq.1) write(50,309) 'sthpmin ','min pot temp pert lwst lvl (K)'
    if(stat_q      .eq.1)then
      do n=1,numq
        text1='max     '
        text2='max                           '
        write(text1(4:6),156) qname(n)
        write(text2(5:7),156) qname(n)
        write(50,309) text1,text2
        text1='min     '
        text2='min                           '
        write(text1(4:6),156) qname(n)
        write(text2(5:7),156) qname(n)
        write(50,309) text1,text2
      enddo
    endif
    if(stat_tke    .eq.1) write(50,309) 'tkemax  ','max tke (m^2/s^2)             '
    if(stat_tke    .eq.1) write(50,309) 'tkemin  ','min tke (m^2/s^2)             '
    if(stat_km     .eq.1) write(50,309) 'kmhmax  ','max kmh (m^2/s)               '
    if(stat_km     .eq.1) write(50,309) 'kmhmin  ','min kmh (m^2/s)               '
    if(stat_km     .eq.1) write(50,309) 'kmvmax  ','max kmv (m^2/s)               '
    if(stat_km     .eq.1) write(50,309) 'kmvmin  ','min kmv (m^2/s)               '
    if(stat_kh     .eq.1) write(50,309) 'khhmax  ','max khh (m^2/s)               '
    if(stat_kh     .eq.1) write(50,309) 'khhmin  ','min khh (m^2/s)               '
    if(stat_kh     .eq.1) write(50,309) 'khvmax  ','max khv (m^2/s)               '
    if(stat_kh     .eq.1) write(50,309) 'khvmin  ','min khv (m^2/s)               '
    if(stat_div    .eq.1) write(50,309) 'divmax  ','max 3d divergence             '
    if(stat_div    .eq.1) write(50,309) 'divmin  ','min 3d divergence             '
    if(stat_rh     .eq.1) write(50,309) 'rhmax   ','max relative humidity         '
    if(stat_rh     .eq.1) write(50,309) 'rhmin   ','min relative humidity         '
    if(stat_rhi    .eq.1) write(50,309) 'rhimax  ','max relative humidity wrt ice '
    if(stat_rhi    .eq.1) write(50,309) 'rhimin  ','min relative humidity wrt ice '
    if(iptra       .eq.1)then
      do n=1,npt
        text1='maxpt   '
        text2='max pt                        '
        write(text1(6:6),157) n
        write(text2(7:7),157) n
157     format(i1)
        write(50,309) text1,text2
        text1='minpt   '
        text2='min pt                        '
        write(text1(6:6),157) n
        write(text2(7:7),157) n
        write(50,309) text1,text2
      enddo
    endif
    if(stat_the    .eq.1) write(50,309) 'themax  ','max theta-e below 10 km       '
    if(stat_the    .eq.1) write(50,309) 'themin  ','min theta-e below 10 km       '
    if(stat_the    .eq.1) write(50,309) 'sthemax ','max theta-e at lowest level   '
    if(stat_the    .eq.1) write(50,309) 'sthemin ','min theta-e at lowest level   '
    if(stat_cloud  .eq.1) write(50,309) 'qctop   ','max cloud top height (m)      '
    if(stat_cloud  .eq.1) write(50,309) 'qcbot   ','min cloud base height (m)     '
    if(stat_sfcprs .eq.1) write(50,309) 'sprsmax ','max pressure at lowest lvl (Pa'
    if(stat_sfcprs .eq.1) write(50,309) 'sprsmin ','min pressure at lowest lvl (Pa'
    if(stat_wsp    .eq.1) write(50,309) 'wspmax  ','max wind speed (m/s)          '
    if(stat_wsp    .eq.1) write(50,309) 'wspmin  ','min wind speed (m/s)          '
    if(stat_wsp    .eq.1) write(50,309) 'swspmax ','max wind speed lowst lvl (m/s)'
    if(stat_wsp    .eq.1) write(50,309) 'swspmin ','min wind speed lowst lvl (m/s)'
  IF(idrag.eq.1)THEN
    if(stat_wsp    .eq.1) write(50,309) 'wsp10max','max 10 m wind speed (m/s)     '
    if(stat_wsp    .eq.1) write(50,309) 'wsp10min','min 10 m wind speed (m/s)     '
  ENDIF
  IF( adapt_dt.eq.1 )THEN
    if(stat_cfl    .eq.1) write(50,309) 'cflmax  ','max Courant number (average)  '
  ELSE
    if(stat_cfl    .eq.1) write(50,309) 'cflmax  ','max Courant number            '
  ENDIF
    if(stat_cfl    .eq.1) write(50,309) 'kshmax  ','max horiz K stability factor  '
    if(stat_cfl    .eq.1) write(50,309) 'ksvmax  ','max vert K stability factor   '
    if(stat_vort   .eq.1) write(50,309) 'vortsfc ','max vert. vort. lwst lvl (1/s)'
    if(stat_vort   .eq.1) write(50,309) 'vort1km ','max vert. vort. at 1 km (1/s) '
    if(stat_vort   .eq.1) write(50,309) 'vort2km ','max vert. vort. at 2 km (1/s) '
    if(stat_vort   .eq.1) write(50,309) 'vort3km ','max vert. vort. at 3 km (1/s) '
    if(stat_vort   .eq.1) write(50,309) 'vort4km ','max vert. vort. at 4 km (1/s) '
    if(stat_vort   .eq.1) write(50,309) 'vort5km ','max vert. vort. at 5 km (1/s) '
    if(stat_tmass  .eq.1) write(50,309) 'tmass   ','total mass of (dry) air       '
    if(stat_tmois  .eq.1) write(50,309) 'tmois   ','total moisture                '
    if(stat_qmass  .eq.1)then
      do n=1,numq
        IF( (n.eq.nqv) .or.                                 &
            (n.ge.nql1.and.n.le.nql2) .or.                  &
            (n.ge.nqs1.and.n.le.nqs2.and.iice.eq.1) )THEN
          text1='mass    '
          text2='total mass of                 '
          write(text1( 5: 7),156) qname(n)
          write(text2(15:17),156) qname(n)
          write(50,309) text1,text2
        ENDIF
      enddo
    endif
    if(stat_tenerg .eq.1) write(50,309) 'ek      ','total kinetic energy          '
    if(stat_tenerg .eq.1) write(50,309) 'ei      ','total internal energy         '
    if(stat_tenerg .eq.1) write(50,309) 'ep      ','total potential energy        '
    if(stat_tenerg .eq.1) write(50,309) 'le      ','total latent energy (sort of) '
    if(stat_tenerg .eq.1) write(50,309) 'et      ','total energy                  '
    if(stat_mo     .eq.1) write(50,309) 'tmu     ','total E-W momentum            '
    if(stat_mo     .eq.1) write(50,309) 'tmv     ','total N-S momentum            '
    if(stat_mo     .eq.1) write(50,309) 'tmw     ','total vertical momentum       '
    if(stat_tmf    .eq.1) write(50,309) 'tmfu    ','total upward mass flux        '
    if(stat_tmf    .eq.1) write(50,309) 'tmfd    ','total downward mass flux      '
    if(stat_pcn    .eq.1)then
      do n=1,nbudget
        text1='        '
        text2='                              '
        write(text1(1:6),158) budname(n)
        write(text2(1:6),158) budname(n)
158     format(a6)
        write(50,309) text1,text2
      enddo
    endif
    if(stat_qsrc   .eq.1)then
      do n=1,numq
        text1='as      '
        text2='artificial source of          '
        write(text1( 3: 5),156) qname(n)
        write(text2(22:24),156) qname(n)
        write(50,309) text1,text2
      enddo
      do n=1,numq
        text1='bs      '
        text2='bndry source/sink of          '
        write(text1( 3: 5),156) qname(n)
        write(text2(22:24),156) qname(n)
        write(50,309) text1,text2
      enddo
    endif
    write(50,310)

156   format(a3)
301   format('dset ^',a70)
302   format('undef -9999.')
303   format('title ctl file for stats.dat')
304   format('xdef 1 linear 1 1')
305   format('ydef 1 linear 1 1')
306   format('zdef 1 linear 1 1')
307   format('tdef ',i10,' linear ',a15,' ',i5,'MN')
308   format('vars ',i6)
309   format(a8,' 1 99 ',a30)
310   format('endvars')

      close(unit=50)

      return
      end subroutine write_statsctl


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine writeout(fnum,nwrite,qname,xh,xf,uf,vf,sigma,zh,zf,mf,pi0,prs0,rho0,th0,qv0,u0,v0,  &
                          zs,rain,sws,svs,sps,srs,sgs,sus,shs,thflux,qvflux,cdu,cdv,ce,dum1,dum2,dum3,dum4, &
                          rho,prs,dbz,ua,dumu,va,dumv,wa,dumw,ppi,tha,        &
                   dissten,thpten,qvpten,qcpten,qipten,upten,vpten,           &
                          lu_index,xland,mavail,tsk,tmn,tml,hml,huml,hvml,hfx,qfx,gsw,glw,tslb,   &
                          qa,kmh,kmv,khh,khv,tkea,swten,lwten,radsw,rnflx,radswnet,radlwin,pta,   &
                          num_soil_layers,u10,v10,t2,q2,znt,ust,hpbl,zol,mol,br)
      implicit none

      include 'input.incl'
      include 'constants.incl'
#ifdef MPI
      include 'mpif.h'
#endif

      integer, intent(in) :: fnum,nwrite
      character*3, dimension(maxq), intent(in) :: qname
      real, intent(in), dimension(ib:ie) :: xh
      real, dimension(ib:ie+1), intent(in) :: xf,uf
      real, dimension(jb:je+1), intent(in) :: vf
      real, dimension(kb:ke), intent(in) :: sigma
      real, dimension(ib:ie,jb:je,kb:ke), intent(in) :: zh
      real, dimension(ib:ie,jb:je,kb:ke+1), intent(in) :: zf,mf
      real, dimension(ib:ie,jb:je,kb:ke), intent(in) :: pi0,prs0,rho0,th0,qv0
      real, dimension(itb:ite,jtb:jte), intent(in) :: zs
      real, dimension(ib:ie,jb:je,nrain), intent(in) :: rain,sws,svs,sps,srs,sgs,sus,shs
      real, dimension(ib:ie,jb:je), intent(in) :: thflux,qvflux,cdu,cdv,ce
      real, dimension(ib:ie,jb:je,kb:ke), intent(inout) :: dum1,dum2,dum3,dum4
      real, dimension(ib:ie,jb:je,kb:ke), intent(in) :: rho,prs,dbz
      real, dimension(ib:ie+1,jb:je,kb:ke), intent(in) :: u0,ua
      real, dimension(ib:ie+1,jb:je,kb:ke), intent(inout) :: dumu
      real, dimension(ib:ie,jb:je+1,kb:ke), intent(in) :: v0,va
      real, dimension(ib:ie,jb:je+1,kb:ke), intent(inout) :: dumv
      real, dimension(ib:ie,jb:je,kb:ke+1), intent(in) :: wa
      real, dimension(ib:ie,jb:je,kb:ke+1), intent(inout) :: dumw
      real, dimension(ib:ie,jb:je,kb:ke), intent(in) :: ppi,tha
      real, dimension(ib:ie,jb:je,kb:ke), intent(in) :: dissten
      real, dimension(ibb:ieb,jbb:jeb,kbb:keb), intent(in) :: thpten,qvpten,qcpten,qipten,upten,vpten
      integer, dimension(ibl:iel,jbl:jel), intent(in) :: lu_index
      real, dimension(ib:ie,jb:je), intent(in) :: tsk
      real, dimension(ibl:iel,jbl:jel), intent(in) :: xland,mavail,tmn,tml,hml,huml,hvml,hfx,qfx,gsw,glw
      real, dimension(ibl:iel,jbl:jel,num_soil_layers), intent(in) :: tslb
      real, dimension(ibm:iem,jbm:jem,kbm:kem,numq), intent(in) :: qa
      real, dimension(ibc:iec,jbc:jec,kbc:kec), intent(in) :: kmh,kmv,khh,khv
      real, dimension(ibt:iet,jbt:jet,kbt:ket), intent(in) :: tkea
      real, dimension(ibr:ier,jbr:jer,kbr:ker), intent(in) :: swten,lwten
      real, dimension(ni,nj), intent(in) :: radsw,rnflx,radswnet,radlwin
      real, dimension(ibp:iep,jbp:jep,kbp:kep,npt), intent(in) :: pta
      integer, intent(in) :: num_soil_layers
      real, dimension(ibl:iel,jbl:jel), intent(in) :: u10,v10,t2,q2,znt,ust,hpbl,zol,mol,br

      integer i,j,k,n,irec
#ifdef MPI
      character*80 sname,uname,vname,wname,zname
#endif

!--------------------------------------------------------------
!  writeout data on scalar-points

#ifndef MPI
if(myid.eq.0)write(outfile,*)
  IF(output_filetype.eq.1)THEN
    if(s_out.ge.1)then
      if(fnum.eq.51)then
        string(totlen+1:totlen+1+12) = '_s.dat'
      elseif(fnum.eq.71)then
        string(totlen+1:totlen+1+12) = '_i.dat'
      endif
      if(myid.eq.0)write(outfile,*) string
      open(unit=fnum,file=string,form='unformatted',access='direct',   &
           recl=(ni*nj*4),status='unknown')
!!!      irec=1+(nwrite-1)*( nrain*output_rain + nrain*output_sws + output_zs + 4*output_sfcflx +   &
!!!                          nk*(s_out-nrain*output_rain-nrain*output_sws-output_zs-4*output_sfcflx) )
      irec=1+(nwrite-1)*( sout2d + nk*sout3d )
    endif
    if(u_out.ge.1)then
      string(totlen+1:totlen+1+12) = '_u.dat'
      if(myid.eq.0)write(outfile,*) string
      open(unit=52,file=string,form='unformatted',access='direct',   &
           recl=((ni+1)*nj*4),status='unknown')
    endif
    if(v_out.ge.1)then
      string(totlen+1:totlen+1+12) = '_v.dat'
      if(myid.eq.0)write(outfile,*) string
      open(unit=53,file=string,form='unformatted',access='direct',   &
           recl=(ni*(nj+1)*4),status='unknown')
    endif
    if(w_out.ge.1)then
      string(totlen+1:totlen+1+12) = '_w.dat'
      if(myid.eq.0)write(outfile,*) string
      open(unit=54,file=string,form='unformatted',access='direct',   &
           recl=(ni*nj*4),status='unknown')
    endif
  ELSEIF(output_filetype.eq.2)THEN
    if(s_out.ge.1)then
      if(fnum.eq.51)then
        string(totlen+1:totlen+1+12) = '_XXXX_s.dat'
      elseif(fnum.eq.71)then
        string(totlen+1:totlen+1+12) = '_XXXX_i.dat'
      endif
      write(string(totlen+2:totlen+5),102) nwrite
102   format(i4.4)
if(myid.eq.0)write(outfile,*) string
      open(unit=fnum,file=string,form='unformatted',access='direct',   &
           recl=(ni*nj*4),status='unknown')
      irec=1
    endif
    if(u_out.ge.1)then
      string(totlen+1:totlen+1+12) = '_XXXX_u.dat'
      write(string(totlen+2:totlen+5),102) nwrite
      if(myid.eq.0)write(outfile,*) string
      open(unit=52,file=string,form='unformatted',access='direct',   &
           recl=((ni+1)*nj*4),status='unknown')
    endif
    if(v_out.ge.1)then
      string(totlen+1:totlen+1+12) = '_XXXX_v.dat'
      write(string(totlen+2:totlen+5),102) nwrite
      if(myid.eq.0)write(outfile,*) string
      open(unit=53,file=string,form='unformatted',access='direct',   &
           recl=(ni*(nj+1)*4),status='unknown')
    endif
    if(w_out.ge.1)then
      string(totlen+1:totlen+1+12) = '_XXXX_w.dat'
      write(string(totlen+2:totlen+5),102) nwrite
      if(myid.eq.0)write(outfile,*) string
      open(unit=54,file=string,form='unformatted',access='direct',   &
           recl=(ni*nj*4),status='unknown')
    endif
  ELSE
        if(myid.eq.0)write(outfile,*) '  Invalid option for output_filetype'
    call stopcm1
  ENDIF
#else
      irec=1

      sname = '                                                                                '
      uname = '                                                                                '
      vname = '                                                                                '
      wname = '                                                                                '
      zname = '                                                                                '

    if(strlen.gt.0)then
      sname(1:strlen) = output_path(1:strlen)
      uname(1:strlen) = output_path(1:strlen)
      vname(1:strlen) = output_path(1:strlen)
      wname(1:strlen) = output_path(1:strlen)
      zname(1:strlen) = output_path(1:strlen)
    endif

      sname(strlen+1:strlen+baselen) = output_basename(1:baselen)
      uname(strlen+1:strlen+baselen) = output_basename(1:baselen)
      vname(strlen+1:strlen+baselen) = output_basename(1:baselen)
      wname(strlen+1:strlen+baselen) = output_basename(1:baselen)
      zname(strlen+1:strlen+baselen) = output_basename(1:baselen)

      if(fnum.eq.51)then
        sname(totlen+1:totlen+1+16) = '_XXXX_YYYY_s.dat'
      elseif(fnum.eq.71)then
        sname(totlen+1:totlen+1+16) = '_XXXX_YYYY_i.dat'
      endif
      uname(totlen+1:totlen+1+16) = '_XXXX_YYYY_u.dat'
      vname(totlen+1:totlen+1+16) = '_XXXX_YYYY_v.dat'
      wname(totlen+1:totlen+1+16) = '_XXXX_YYYY_w.dat'
      zname(totlen+1:totlen+1+16) = '_XXXX_YYYY_z.dat'

      write(sname(totlen+2:totlen+ 5),100) myid
      write(sname(totlen+7:totlen+10),100) nwrite

      write(uname(totlen+2:totlen+ 5),100) myid
      write(uname(totlen+7:totlen+10),100) nwrite

      write(vname(totlen+2:totlen+ 5),100) myid
      write(vname(totlen+7:totlen+10),100) nwrite

      write(wname(totlen+2:totlen+ 5),100) myid
      write(wname(totlen+7:totlen+10),100) nwrite

      write(zname(totlen+2:totlen+ 5),100) myid
      write(zname(totlen+7:totlen+10),100) nwrite

100   format(i4.4)

if(myid.eq.0)write(outfile,*)
if(myid.eq.0)write(outfile,*) '  myid,sname=',myid,'   ',sname
      open(unit=fnum,file=sname,                   &
           form='unformatted',access='direct',   &
           recl=(ni*nj*4),status='unknown')

      if(u_out.ge.1)then
            if(myid.eq.0)write(outfile,*) '  myid,uname=',myid,'   ',uname
        open(unit=52,file=uname,                   &
             form='unformatted',access='direct',   &
             recl=((ni+1)*nj*4),status='unknown')
      endif

      if(v_out.ge.1)then
            if(myid.eq.0)write(outfile,*) '  myid,vname=',myid,'   ',vname
        open(unit=53,file=vname,                   &
             form='unformatted',access='direct',   &
             recl=(ni*(nj+1)*4),status='unknown')
      endif

      if(w_out.ge.1)then
            if(myid.eq.0)write(outfile,*) '  myid,wname=',myid,'   ',wname
        open(unit=54,file=wname,                   &
             form='unformatted',access='direct',   &
             recl=(ni*nj*4),status='unknown')
      endif
#endif

      if(output_rain.eq.1) call write2d(fnum,ni,nj,ngxy,irec,rain(ib,jb,1))
      if(output_sws .eq.1) call write2d(fnum,ni,nj,ngxy,irec,sws(ib,jb,1))
      if(output_sws .eq.1) call write2d(fnum,ni,nj,ngxy,irec,svs(ib,jb,1))
      if(output_sws .eq.1) call write2d(fnum,ni,nj,ngxy,irec,sps(ib,jb,1))
      if(output_sws .eq.1) call write2d(fnum,ni,nj,ngxy,irec,srs(ib,jb,1))
      if(output_sws .eq.1) call write2d(fnum,ni,nj,ngxy,irec,sgs(ib,jb,1))
      if(output_sws .eq.1) call write2d(fnum,ni,nj,ngxy,irec,sus(ib,jb,1))
      if(output_sws .eq.1) call write2d(fnum,ni,nj,ngxy,irec,shs(ib,jb,1))
      if(nrain.eq.2)then
        if(output_rain.eq.1) call write2d(fnum,ni,nj,ngxy,irec,rain(ib,jb,2))
        if(output_sws .eq.1) call write2d(fnum,ni,nj,ngxy,irec,sws(ib,jb,2))
        if(output_sws .eq.1) call write2d(fnum,ni,nj,ngxy,irec,svs(ib,jb,2))
        if(output_sws .eq.1) call write2d(fnum,ni,nj,ngxy,irec,sps(ib,jb,2))
        if(output_sws .eq.1) call write2d(fnum,ni,nj,ngxy,irec,srs(ib,jb,2))
        if(output_sws .eq.1) call write2d(fnum,ni,nj,ngxy,irec,sgs(ib,jb,2))
        if(output_sws .eq.1) call write2d(fnum,ni,nj,ngxy,irec,sus(ib,jb,2))
        if(output_sws .eq.1) call write2d(fnum,ni,nj,ngxy,irec,shs(ib,jb,2))
      endif
      if(output_uh.eq.1)then
        ! get height AGL:
        if( terrain_flag )then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk+1
          do j=1,nj
          do i=1,ni
            dum3(i,j,k) = zh(i,j,k)-zs(i,j)
            dumw(i,j,k) = zf(i,j,k)-zs(i,j)
          enddo
          enddo
          enddo
        else
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk+1
          do j=1,nj
          do i=1,ni
            dum3(i,j,k) = zh(i,j,k)
            dumw(i,j,k) = zf(i,j,k)
          enddo
          enddo
          enddo
        endif
        call calcuh(uf,vf,dum3,dumw,ua,va,wa,dum1(ib,jb,1),dum2)
        call write2d(fnum,ni,nj,ngxy,irec,dum1(ib,jb,1))
      endif
      if(output_coldpool.eq.1)then
        call calccpch(zf,th0,qv0,dum1(ib,jb,1),dum1(ib,jb,2),tha,qa)
        call write2d(fnum,ni,nj,ngxy,irec,dum1(ib,jb,1))
        call write2d(fnum,ni,nj,ngxy,irec,dum1(ib,jb,2))
      endif
      if(output_sfcflx.eq.1) call write2d(fnum,ni,nj,ngxy,irec,thflux)
      if(output_sfcflx.eq.1) call write2d(fnum,ni,nj,ngxy,irec,qvflux)
      if(output_sfcflx.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          dum1(i,j,1)=0.25*( (cdu(i,j)+cdu(i+1,j))   &
                            +(cdv(i,j)+cdv(i,j+1)) )
        enddo
        enddo
        call write2d(fnum,ni,nj,ngxy,irec,dum1(ib,jb,1))
      endif
      if(output_sfcflx.eq.1) call write2d(fnum,ni,nj,ngxy,irec,ce)
      if(output_sfcflx.eq.1) call write2d(fnum,ni,nj,ngxy,irec,tsk(ib,jb))
      if(output_zs  .eq.1) call write2d(fnum,ni,nj,ngxy,irec,zs)
      if(output_dbz   .eq.1)then
        call calccref(dum1(ib,jb,1),dbz)
        call write2d(fnum,ni,nj,ngxy,irec,dum1(ib,jb,1))
      endif

    if(output_sfcparams.eq.1)then
      call write2d(fnum,ni,nj,ngxy,irec,xland(ib,jb))
!$omp parallel do default(shared)  &
!$omp private(i,j)
      do j=1,nj
      do i=1,ni
        dum1(i,j,1)=float(lu_index(i,j))
      enddo
      enddo
      call write2d(fnum,ni,nj,ngxy,irec,dum1(ib,jb,1))
      call write2d(fnum,ni,nj,ngxy,irec,mavail(ib,jb))
    endif
    if((output_sfcparams.eq.1).and.(sfcmodel.eq.2.or.oceanmodel.eq.2))then
      call write2d(fnum,ni,nj,ngxy,irec,tmn(ib,jb))
      call write2d(fnum,ni,nj,ngxy,irec,hfx(ib,jb))
      call write2d(fnum,ni,nj,ngxy,irec,qfx(ib,jb))
      call write2d(fnum,ni,nj,ngxy,irec,gsw(ib,jb))
      call write2d(fnum,ni,nj,ngxy,irec,glw(ib,jb))
    endif

    if((output_sfcparams.eq.1).and.(sfcmodel.eq.2))then
      call write2d(fnum,ni,nj,ngxy,irec,tslb(ib,jb,1))
      call write2d(fnum,ni,nj,ngxy,irec,tslb(ib,jb,2))
      call write2d(fnum,ni,nj,ngxy,irec,tslb(ib,jb,3))
      call write2d(fnum,ni,nj,ngxy,irec,tslb(ib,jb,4))
      call write2d(fnum,ni,nj,ngxy,irec,tslb(ib,jb,5))
    endif

      if(output_sfcparams.eq.1.and.oceanmodel.eq.2)then
        call write2d(fnum,ni,nj,ngxy,irec,tml(ib,jb))
        call write2d(fnum,ni,nj,ngxy,irec,hml(ib,jb))
        call write2d(fnum,ni,nj,ngxy,irec,huml(ib,jb))
        call write2d(fnum,ni,nj,ngxy,irec,hvml(ib,jb))
      endif

      if( output_radten.eq.1 )then
        write(fnum,rec=irec) ((radsw(i,j),i=1,ni),j=1,nj)
        irec=irec+1
        write(fnum,rec=irec) ((rnflx(i,j),i=1,ni),j=1,nj)
        irec=irec+1
        write(fnum,rec=irec) ((radswnet(i,j),i=1,ni),j=1,nj)
        irec=irec+1
        write(fnum,rec=irec) ((radlwin(i,j),i=1,ni),j=1,nj)
        irec=irec+1
      endif

      IF(output_sfcdiags.eq.1)THEN
        call write2d(fnum,ni,nj,ngxy,irec,u10)
        call write2d(fnum,ni,nj,ngxy,irec,v10)
        call write2d(fnum,ni,nj,ngxy,irec, t2)
        call write2d(fnum,ni,nj,ngxy,irec, q2)
        call write2d(fnum,ni,nj,ngxy,irec,znt)
        call write2d(fnum,ni,nj,ngxy,irec,ust)
        call write2d(fnum,ni,nj,ngxy,irec,hpbl)
        call write2d(fnum,ni,nj,ngxy,irec,zol)
        call write2d(fnum,ni,nj,ngxy,irec,mol)
        call write2d(fnum,ni,nj,ngxy,irec,br)
      ENDIF

!--- 3D vars below here:

      dum1=zh
      if(fnum.eq.71)then
        do k=1,nk
        do j=1,nj
        do i=1,ni
!!!          dum1(i,j,k)=(k*dz-0.5*dz)-zs(i,j)
          dum1(i,j,k)=sigma(k)-zs(i,j)
        enddo
        enddo
        enddo
      endif
      if(output_zh  .eq.1) call write3d(fnum,ni,nj,nk,ngxy,ngz,irec,dum1)
      if(output_th  .eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          dum1(i,j,k)=th0(i,j,k)+tha(i,j,k)
        enddo
        enddo
        enddo
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call write3d(fnum,ni,nj,nk,ngxy,ngz,irec,dum1)
      endif
      dum1=tha
      if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
      if(output_thpert .eq.1) call write3d(fnum,ni,nj,nk,ngxy,ngz,irec,dum1)
      dum1=prs
      if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
      if(output_prs    .eq.1) call write3d(fnum,ni,nj,nk,ngxy,ngz,irec,dum1)
      if(output_prspert.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          dum1(i,j,k)=prs(i,j,k)-p00*(pi0(i,j,k)**cpdrd)
        enddo
        enddo
        enddo
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call write3d(fnum,ni,nj,nk,ngxy,ngz,irec,dum1)
      endif
      if(output_pi.eq.1)then  
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          dum1(i,j,k)=pi0(i,j,k)+ppi(i,j,k)
        enddo
        enddo
        enddo
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call write3d(fnum,ni,nj,nk,ngxy,ngz,irec,dum1)
      endif
      dum1=ppi
      if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
      if(output_pipert .eq.1) call write3d(fnum,ni,nj,nk,ngxy,ngz,irec,dum1)
      dum1=rho
      if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
      if(output_rho    .eq.1) call write3d(fnum,ni,nj,nk,ngxy,ngz,irec,dum1)
      if(output_rhopert.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          dum1(i,j,k)=rho(i,j,k)-rho0(i,j,k)
        enddo
        enddo
        enddo
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call write3d(fnum,ni,nj,nk,ngxy,ngz,irec,dum1)
      endif
      if(iptra.eq.1)then
        do n=1,npt
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            dum1(i,j,k)=pta(i,j,k,n)
          enddo
          enddo
          enddo
          if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
          call write3d(fnum,ni,nj,nk,ngxy,ngz,irec,dum1)
        enddo
      endif
      if(imoist.eq.1)then
        do k=1,nk
        do j=1,nj
        do i=1,ni
          dum1(i,j,k)=qa(i,j,k,nqv)
        enddo
        enddo
        enddo
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        if(output_qv    .eq.1) call write3d(fnum,ni,nj,nk,ngxy,ngz,irec,dum1)
        if(output_qvpert.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            dum1(i,j,k)=qa(i,j,k,nqv)-qv0(i,j,k)
          enddo
          enddo
          enddo
          if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
          call write3d(fnum,ni,nj,nk,ngxy,ngz,irec,dum1)
        endif
        if(output_q.eq.1)then
          do n=1,numq
            if(n.ne.nqv)then
              do k=1,nk
              do j=1,nj
              do i=1,ni
                dum1(i,j,k)=qa(i,j,k,n)
              enddo
              enddo
              enddo
              if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
              call write3d(fnum,ni,nj,nk,ngxy,ngz,irec,dum1)
            endif
          enddo
        endif
        dum1=dbz
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        if(output_dbz   .eq.1) call write3d(fnum,ni,nj,nk,ngxy,ngz,irec,dum1)
      endif
      if(output_uinterp.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          dum1(i,j,k)=0.5*(ua(i,j,k)+ua(i+1,j,k))
        enddo
        enddo
        enddo
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call write3d(fnum,ni,nj,nk,ngxy,ngz,irec,dum1)
      endif
      if(output_vinterp.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          dum1(i,j,k)=0.5*(va(i,j,k)+va(i,j+1,k))
        enddo
        enddo
        enddo
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call write3d(fnum,ni,nj,nk,ngxy,ngz,irec,dum1)
      endif
      if(output_winterp.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          dum1(i,j,k)=0.5*(wa(i,j,k)+wa(i,j,k+1))
        enddo
        enddo
        enddo
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call write3d(fnum,ni,nj,nk,ngxy,ngz,irec,dum1)
      endif

      if(output_vort.eq.1)then
        call calcvort(xh,xf,uf,vf,zh,mf,zf,ua,va,wa,dum2,dum3,dum4,dum1)
        dum1=dum2
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call write3d(fnum,ni,nj,nk,ngxy,ngz,irec,dum1)
        dum1=dum3
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call write3d(fnum,ni,nj,nk,ngxy,ngz,irec,dum1)
        dum1=dum4
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call write3d(fnum,ni,nj,nk,ngxy,ngz,irec,dum1)
      endif

      if(output_basestate.eq.1)then
        dum1=pi0
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call write3d(fnum,ni,nj,nk,ngxy,ngz,irec,dum1)
        dum1=th0
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call write3d(fnum,ni,nj,nk,ngxy,ngz,irec,dum1)
        dum1=prs0
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call write3d(fnum,ni,nj,nk,ngxy,ngz,irec,dum1)
        dum1=qv0
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call write3d(fnum,ni,nj,nk,ngxy,ngz,irec,dum1)
      endif

      if(output_dissten.eq.1)then
        dum1=dissten
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call write3d(fnum,ni,nj,nk,ngxy,ngz,irec,dum1)
      endif

      if(output_pblten.eq.1)then
        dum1=thpten
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call write3d(fnum,ni,nj,nk,ngxy,ngz,irec,dum1)
        dum1=qvpten
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call write3d(fnum,ni,nj,nk,ngxy,ngz,irec,dum1)
        dum1=qcpten
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call write3d(fnum,ni,nj,nk,ngxy,ngz,irec,dum1)
        dum1=qipten
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call write3d(fnum,ni,nj,nk,ngxy,ngz,irec,dum1)
        dum1=upten
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call write3d(fnum,ni,nj,nk,ngxy,ngz,irec,dum1)
        dum1=vpten
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call write3d(fnum,ni,nj,nk,ngxy,ngz,irec,dum1)
      endif

      if( output_radten.eq.1 )then
        dum1=swten
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call write3d(fnum,ni,nj,nk,ngxy,ngz,irec,dum1)
        dum1=lwten
        if(fnum.eq.71) call zinterp(sigma,zs,zh,dum1,dum2)
        call write3d(fnum,ni,nj,nk,ngxy,ngz,irec,dum1)
      endif


!--------------------------------------------------------------
!  writeout data on u-points

      irec=1+(nwrite-1)*nk*u_out
      if(output_filetype.eq.2) irec=1
#ifdef MPI
      irec=1
#endif

      if(output_u    .eq.1) call write3d(52,ni+1,nj,nk,ngxy,ngz,irec,ua)

      if(output_upert.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni+1
          dumu(i,j,k)=ua(i,j,k)-u0(i,j,k)
        enddo
        enddo
        enddo
        call write3d(52,ni+1,nj,nk,ngxy,ngz,irec,dumu)
      endif

      if(output_basestate.eq.1) call write3d(52,ni+1,nj,nk,ngxy,ngz,irec,u0)

!--------------------------------------------------------------
!  writeout data on v-points

      irec=1+(nwrite-1)*nk*v_out
      if(output_filetype.eq.2) irec=1
#ifdef MPI
      irec=1
#endif

      if(output_v    .eq.1) call write3d(53,ni,nj+1,nk,ngxy,ngz,irec,va)

      if(output_vpert.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj+1
        do i=1,ni
          dumv(i,j,k)=va(i,j,k)-v0(i,j,k)
        enddo
        enddo
        enddo
        call write3d(53,ni,nj+1,nk,ngxy,ngz,irec,dumv)
      endif

      if(output_basestate.eq.1) call write3d(53,ni,nj+1,nk,ngxy,ngz,irec,v0)

!--------------------------------------------------------------
!  writeout data on w-points

      irec=1+(nwrite-1)*(nk+1)*w_out
      if(output_filetype.eq.2) irec=1
#ifdef MPI
      irec=1
#endif

      if(output_w  .eq.1)                call write3d(54,ni,nj,nk+1,ngxy,ngz,irec,wa)
      if(output_tke.eq.1.and.iturb.eq.1) call write3d(54,ni,nj,nk+1,ngxy,ngz,irec,tkea)
      if(output_km .eq.1)                call write3d(54,ni,nj,nk+1,ngxy,ngz,irec,kmh)
      if(output_km .eq.1)                call write3d(54,ni,nj,nk+1,ngxy,ngz,irec,kmv)
      if(output_kh .eq.1)                call write3d(54,ni,nj,nk+1,ngxy,ngz,irec,khh)
      if(output_kh .eq.1)                call write3d(54,ni,nj,nk+1,ngxy,ngz,irec,khv)

!--------------------------------------------------------------

if(myid.eq.0)then
      write(outfile,*)
      write(outfile,*) 'Done Writing Data to File: nwrite=',nwrite
      write(outfile,*)
endif

      close(unit=fnum)
      if(u_out.ge.1)then
        close(unit=52)
      endif
      if(v_out.ge.1)then
        close(unit=53)
      endif
      if(w_out.ge.1)then
        close(unit=54)
      endif
#ifdef MPI
      call MPI_BARRIER (MPI_COMM_WORLD,ierr)
#endif

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine write2d(fileunit,numi,numj,ngxy,irec,var)
      implicit none

      integer, intent(in) :: fileunit,numi,numj,ngxy
      integer, intent(inout) :: irec
      real, intent(in), dimension(1-ngxy:numi+ngxy,1-ngxy:numj+ngxy) :: var

      integer i,j

!----------------------------------

#ifdef DP
      write(fileunit,rec=irec) ((sngl(var(i,j)),i=1,numi),j=1,numj)
#else
      write(fileunit,rec=irec) ((var(i,j),i=1,numi),j=1,numj)
#endif
      irec=irec+1

!----------------------------------

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine write3d(fileunit,numi,numj,numk,ngxy,ngz,irec,var)
      implicit none

      integer, intent(in) :: fileunit,numi,numj,numk,ngxy,ngz
      integer, intent(inout) :: irec
      real, intent(in), dimension(1-ngxy:numi+ngxy,1-ngxy:numj+ngxy,1-ngz:numk+ngz) :: var

      integer i,j,k

!----------------------------------

      do k=1,numk
#ifdef DP
        write(fileunit,rec=irec) ((sngl(var(i,j,k)),i=1,numi),j=1,numj)
#else
        write(fileunit,rec=irec) ((var(i,j,k),i=1,numi),j=1,numj)
#endif
        irec=irec+1
      enddo

!----------------------------------

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine write_restart(nstep,nrec,prec,nwrite,nrst,nrad2d,num_soil_layers,      &
                               dt,mtime,radtim,qbudget,asq,bsq,                &
                               rain,sws,svs,sps,srs,sgs,sus,shs,tsk,radbcw,radbce,radbcs,radbcn,     &
                               ua,va,wa,ppi,tha,qa,tkea,swten,lwten,               &
                               radsw,rnflx,radswnet,radlwin,rad2d,                 &
                               lu_index,kpbl2d,psfc,u10,v10,hfx,qfx,xland,znt,ust, &
                               hpbl,wspd,psim,psih,gz1oz0,br,                      &
                               CHS,CHS2,CQS2,CPMM,ZOL,MAVAIL,                      &
                               MOL,RMOL,REGIME,LH,FLHC,FLQC,QGH,                   &
                               CK,CKA,CD,CDA,USTM,QSFC,T2,Q2,TH2,EMISS,THC,ALBD,   &
                               f2d,gsw,glw,chklowq,capg,snowc,tslb,                &
                               tmn,tml,t0ml,hml,h0ml,huml,hvml,tmoml,              &
                               pta,pdata,rtime)
      implicit none

      include 'input.incl'
      include 'constants.incl'

      integer :: nstep,nrec,prec,nwrite,nrst
      integer :: nrad2d,num_soil_layers
      real :: dt
      real*8 :: mtime,radtim
      real*8, dimension(nbudget) :: qbudget
      real*8, dimension(numq) :: asq,bsq
      real, dimension(ib:ie,jb:je,nrain) :: rain,sws,svs,sps,srs,sgs,sus,shs
      real, dimension(ib:ie,jb:je) :: tsk
      real, dimension(jb:je,kb:ke) :: radbcw,radbce
      real, dimension(ib:ie,kb:ke) :: radbcs,radbcn
      real, dimension(ib:ie+1,jb:je,kb:ke) :: ua
      real, dimension(ib:ie,jb:je+1,kb:ke) :: va
      real, dimension(ib:ie,jb:je,kb:ke+1) :: wa
      real, dimension(ib:ie,jb:je,kb:ke) :: ppi,tha
      real, dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: qa
      real, dimension(ibt:iet,jbt:jet,kbt:ket) :: tkea
      real, dimension(ibr:ier,jbr:jer,kbr:ker) :: swten,lwten
      real, dimension(ni,nj) :: radsw,rnflx,radswnet,radlwin
      real, dimension(ni,nj,nrad2d) :: rad2d
      integer, intent(in), dimension(ibl:iel,jbl:jel) :: lu_index
      integer, intent(in), dimension(ibl:iel,jbl:jel) :: kpbl2d
      real, intent(in), dimension(ibl:iel,jbl:jel) :: psfc,u10,v10,hfx,qfx,xland,znt,ust, &
                                      hpbl,wspd,psim,psih,gz1oz0,br,          &
                                      CHS,CHS2,CQS2,CPMM,ZOL,MAVAIL,          &
                                      MOL,RMOL,REGIME,LH,FLHC,FLQC,QGH,   &
                                      CK,CKA,CD,CDA,USTM,QSFC,T2,Q2,TH2,EMISS,THC,ALBD,   &
                                      f2d,gsw,glw,chklowq,capg,snowc
      real, intent(in), dimension(ibl:iel,jbl:jel,num_soil_layers) :: tslb
      real, intent(in), dimension(ibl:iel,jbl:jel) :: tmn,tml,t0ml,hml,h0ml,huml,hvml,tmoml
      real, dimension(ibp:iep,jbp:jep,kbp:kep,npt) :: pta
      real, dimension(npvals,nparcels) :: pdata
      real rtime

      character*80 fname

!-----------------------------------------------------------------------

      fname = '                                                                                '
    if(strlen.gt.0)then
      fname(1:strlen) = output_path(1:strlen)
    endif
      fname(strlen+1:strlen+baselen) = output_basename(1:baselen)
      fname(totlen+1:totlen+1+18) = '_rst_XXXX_YYYY.dat'

      write(fname(totlen+ 6:totlen+ 9),101) myid
      write(fname(totlen+11:totlen+14),101) nrst
101   format(i4.4)

if(myid.eq.0)then
      write(outfile,*)
      write(outfile,*) '  Writing to restart file!'
      write(outfile,*) '  fname=',fname
      write(outfile,*)
endif

      open(unit=50,file=fname,form='unformatted',status='unknown')

      write(50) nstep
      write(50) nrec
      write(50) prec
      write(50) nwrite
      write(50) nrst
      write(50) rtime
      write(50) dt
      write(50) mtime
      write(50) radtim
      write(50) qbudget
      write(50) asq
      write(50) bsq
      write(50) rain
      write(50) sws
      write(50) svs
      write(50) sps
      write(50) srs
      write(50) sgs
      write(50) sus
      write(50) shs
      write(50) tsk
      write(50) ua
      write(50) va
      write(50) wa
      write(50) ppi
      write(50) tha
      if(imoist.eq.1) write(50) qa
      if(iturb.eq.1) write(50) tkea
      if(radopt.eq.1)then
        write(50) swten
        write(50) lwten
        write(50) radsw
        write(50) rnflx
        write(50) radswnet
        write(50) radlwin
        write(50) rad2d
      endif
      if((oceanmodel.eq.2).or.(ipbl.eq.1).or.(sfcmodel.ge.1))then
        ! I don't know how many of these are really needed in restart
        ! files, but let's include them all for now ... just to be safe
        write(50) lu_index
        write(50) kpbl2d
        write(50) psfc
        write(50) u10
        write(50) v10
        write(50) hfx
        write(50) qfx
        write(50) xland
        write(50) znt
        write(50) ust
        write(50) hpbl
        write(50) wspd
        write(50) psim
        write(50) psih
        write(50) gz1oz0
        write(50) br
        write(50) CHS
        write(50) CHS2
        write(50) CQS2
        write(50) CPMM
        write(50) ZOL
        write(50) MAVAIL
        write(50) MOL
        write(50) RMOL
        write(50) REGIME
        write(50) LH
        write(50) TMN
        write(50) FLHC
        write(50) FLQC
        write(50) QGH
        write(50) CK
        write(50) CKA
        write(50) CD
        write(50) CDA
        write(50) USTM
        write(50) QSFC
        write(50) T2
        write(50) Q2
        write(50) TH2
        write(50) EMISS
        write(50) THC
        write(50) ALBD
        write(50) gsw
        write(50) glw
        write(50) chklowq
        write(50) capg
        write(50) snowc
        write(50) tslb
      endif
      if(oceanmodel.eq.2)then
        write(50) tml
        write(50) t0ml
        write(50) hml
        write(50) h0ml
        write(50) huml
        write(50) hvml
        write(50) tmoml
      endif
      if(iptra.eq.1) write(50) pta
      if(iprcl.eq.1) write(50) pdata
      if(irbc.eq.4.and.ibw.eq.1) write(50) radbcw
      if(irbc.eq.4.and.ibe.eq.1) write(50) radbce
      if(irbc.eq.4.and.ibs.eq.1) write(50) radbcs
      if(irbc.eq.4.and.ibn.eq.1) write(50) radbcn

      close(unit=50)

      return
      end


!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine read_restart(nstep,nrec,prec,nwrite,nrst,nrad2d,num_soil_layers,   &
                              stattim,taptim,rsttim,  &
                              dt,mtime,radtim,qbudget,asq,bsq,              &
                              rain,sws,svs,sps,srs,sgs,sus,shs,tsk,radbcw,radbce,radbcs,radbcn,         &
                              ua,va,wa,ppi,tha,qa,tkea,swten,lwten,   &
                              radsw,rnflx,radswnet,radlwin,rad2d,   &
                               lu_index,kpbl2d,psfc,u10,v10,hfx,qfx,xland,znt,ust, &
                               hpbl,wspd,psim,psih,gz1oz0,br,                      &
                               CHS,CHS2,CQS2,CPMM,ZOL,MAVAIL,                      &
                               MOL,RMOL,REGIME,LH,FLHC,FLQC,QGH,                   &
                               CK,CKA,CD,CDA,USTM,QSFC,T2,Q2,TH2,EMISS,THC,ALBD,   &
                               f2d,gsw,glw,chklowq,capg,snowc,tslb,                &
                               tmn,tml,t0ml,hml,h0ml,huml,hvml,tmoml,              &
                              pta,pdata,rtime)
      implicit none

      include 'input.incl'
      include 'constants.incl'

      integer :: nstep,nrec,prec,nwrite,nrst
      integer :: nrad2d,num_soil_layers
      real*8 :: stattim,taptim,rsttim
      real :: dt
      real*8 :: mtime,radtim
      real*8, dimension(nbudget) :: qbudget
      real*8, dimension(numq) :: asq,bsq
      real, dimension(ib:ie,jb:je,nrain) :: rain,sws,svs,sps,srs,sgs,sus,shs
      real, dimension(ib:ie,jb:je) :: tsk
      real, dimension(jb:je,kb:ke) :: radbcw,radbce
      real, dimension(ib:ie,kb:ke) :: radbcs,radbcn
      real, dimension(ib:ie+1,jb:je,kb:ke) :: ua
      real, dimension(ib:ie,jb:je+1,kb:ke) :: va
      real, dimension(ib:ie,jb:je,kb:ke+1) :: wa
      real, dimension(ib:ie,jb:je,kb:ke) :: ppi,tha
      real, dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: qa
      real, dimension(ibt:iet,jbt:jet,kbt:ket) :: tkea
      real, dimension(ibr:ier,jbr:jer,kbr:ker) :: swten,lwten
      real, dimension(ni,nj) :: radsw,rnflx,radswnet,radlwin
      real, dimension(ni,nj,nrad2d) :: rad2d
      integer, intent(inout), dimension(ibl:iel,jbl:jel) :: lu_index
      integer, intent(inout), dimension(ibl:iel,jbl:jel) :: kpbl2d
      real, intent(inout), dimension(ibl:iel,jbl:jel) :: psfc,u10,v10,hfx,qfx,xland,znt,ust, &
                                      hpbl,wspd,psim,psih,gz1oz0,br,          &
                                      CHS,CHS2,CQS2,CPMM,ZOL,MAVAIL,          &
                                      MOL,RMOL,REGIME,LH,FLHC,FLQC,QGH,   &
                                      CK,CKA,CD,CDA,USTM,QSFC,T2,Q2,TH2,EMISS,THC,ALBD,   &
                                      f2d,gsw,glw,chklowq,capg,snowc
      real, intent(inout), dimension(ibl:iel,jbl:jel,num_soil_layers) :: tslb
      real, intent(inout), dimension(ibl:iel,jbl:jel) :: tmn,tml,t0ml,hml,h0ml,huml,hvml,tmoml
      real, dimension(ibp:iep,jbp:jep,kbp:kep,npt) :: pta
      real, dimension(npvals,nparcels) :: pdata
      real rtime

      character*80 fname

!-----------------------------------------------------------------------

      fname = '                                                                                '
    if(strlen.gt.0)then
      fname(1:strlen) = output_path(1:strlen)
    endif
      fname(strlen+1:strlen+baselen) = output_basename(1:baselen)
      fname(totlen+1:totlen+1+18) = '_rst_XXXX_YYYY.dat'

      write(fname(totlen+ 6:totlen+ 9),101) myid
      write(fname(totlen+11:totlen+14),101) rstnum
101   format(i4.4)

if(myid.eq.0)then
      write(outfile,*)
      write(outfile,*) '  Reading from restart file!'
      write(outfile,*) '  fname=',fname
      write(outfile,*)
endif

      open(unit=50,file=fname,form='unformatted',status='old')

      read(50) nstep
      read(50) nrec
      read(50) prec
      read(50) nwrite
      read(50) nrst
      read(50) rtime
      read(50) dt
      read(50) mtime
      read(50) radtim
      read(50) qbudget
      read(50) asq
      read(50) bsq
      read(50) rain
      read(50) sws
      read(50) svs
      read(50) sps
      read(50) srs
      read(50) sgs
      read(50) sus
      read(50) shs
      read(50) tsk
      read(50) ua
      read(50) va
      read(50) wa
      read(50) ppi
      read(50) tha
      if(imoist.eq.1) read(50) qa
      if(iturb.eq.1) read(50) tkea
      if(radopt.eq.1)then
        read(50) swten
        read(50) lwten
        read(50) radsw
        read(50) rnflx
        read(50) radswnet
        read(50) radlwin
        read(50) rad2d
      endif
      if((oceanmodel.eq.2).or.(ipbl.eq.1).or.(sfcmodel.ge.1))then
        ! I don't know how many of these are really needed in restart
        ! files, but let's include them all for now ... just to be safe
        read(50) lu_index
        read(50) kpbl2d
        read(50) psfc
        read(50) u10
        read(50) v10
        read(50) hfx
        read(50) qfx
        read(50) xland
        read(50) znt
        read(50) ust
        read(50) hpbl
        read(50) wspd
        read(50) psim
        read(50) psih
        read(50) gz1oz0
        read(50) br
        read(50) CHS
        read(50) CHS2
        read(50) CQS2
        read(50) CPMM
        read(50) ZOL
        read(50) MAVAIL
        read(50) MOL
        read(50) RMOL
        read(50) REGIME
        read(50) LH
        read(50) TMN
        read(50) FLHC
        read(50) FLQC
        read(50) QGH
        read(50) CK
        read(50) CKA
        read(50) CD
        read(50) CDA
        read(50) USTM
        read(50) QSFC
        read(50) T2
        read(50) Q2
        read(50) TH2
        read(50) EMISS
        read(50) THC
        read(50) ALBD
        read(50) gsw
        read(50) glw
        read(50) chklowq
        read(50) capg
        read(50) snowc
        read(50) tslb
      endif
      if(oceanmodel.eq.2)then
        read(50) tml
        read(50) t0ml
        read(50) hml
        read(50) h0ml
        read(50) huml
        read(50) hvml
        read(50) tmoml
      endif
      if(iptra.eq.1) read(50) pta
      if(iprcl.eq.1) read(50) pdata
      if(irbc.eq.4.and.ibw.eq.1) read(50) radbcw
      if(irbc.eq.4.and.ibe.eq.1) read(50) radbce
      if(irbc.eq.4.and.ibs.eq.1) read(50) radbcs
      if(irbc.eq.4.and.ibn.eq.1) read(50) radbcn

      close(unit=50)

!---------

      stattim=rtime+statfrq
      taptim=rtime+tapfrq
      rsttim=rtime+rstfrq
      prcltim=rtime+prclfrq
      if( output_format.ge.2 )then
        nrec=nrec-1
      else
        nrec=nrec-stat_out
      endif

      if(myid.eq.0)then
            write(outfile,*) nrec,stattim,taptim,rsttim
            write(outfile,*)
      endif

!---------

      return
      end


writeout_nc.F/  1298670057  19071 8000  100644  116498    `

!-------------------------------------------------------------
!
!  This subroutine writes data in NetCDF files.
!
!  Code originally written by Daniel Kirshbaum
!  Code last modified by George Bryan, 110111
!
!-------------------------------------------------------------


      subroutine writeout_cdf(nwrite,qname,sigma,sigmaf,xh,xf,uf,yh,yf,vf,mh,zh,mf,zf,    &
                          pi0,prs0,rho0,th0,qv0,u0,v0,                        &
                          zs,rain,sws,svs,sps,srs,sgs,sus,shs,thflux,qvflux,cdu,cdv,ce,dum1,dum2,dum3,dum4, &
                          rho,prs,dbz,ua,dumu,va,dumv,wa,dumw,ppi,tha,        &
                          qa,kmh,kmv,khh,khv,tkea,pta,num_soil_layers,   &
                          lu_index,xland,mavail,tsk,tmn,tml,hml,huml,hvml,hfx,qfx,gsw,glw,tslb,   &
                          radsw,rnflx,radswnet,radlwin,u10,v10,t2,q2,znt,ust,hpbl,zol,mol,br,  &
                          dissten,thpten,qvpten,qcpten,qipten,upten,vpten,swten,lwten)
      implicit none

      include 'input.incl'
      include 'constants.incl'

#ifdef MPI
      include 'mpif.h'
#endif

      integer :: nwrite
      character*3, dimension(maxq) :: qname
      real, dimension(kb:ke) :: sigma
      real, dimension(kb:ke+1) :: sigmaf
      real, dimension(ib:ie) :: xh
      real, dimension(ib:ie+1) :: xf,uf
      real, dimension(jb:je) :: yh
      real, dimension(jb:je+1) :: yf,vf
      real, dimension(ib:ie,jb:je,kb:ke) :: mh,zh,pi0,prs0,rho0,th0,qv0
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf,zf
      real, dimension(itb:ite,jtb:jte) :: zs
      real, dimension(ib:ie,jb:je,nrain) :: rain,sws,svs,sps,srs,sgs,sus,shs
      real, dimension(ib:ie,jb:je) :: thflux,qvflux,cdu,cdv,ce
      real, dimension(ib:ie,jb:je,kb:ke) :: dum1,dum2,dum3,dum4,rho,prs,dbz
      real, dimension(ib:ie+1,jb:je,kb:ke) :: u0,ua,dumu
      real, dimension(ib:ie,jb:je+1,kb:ke) :: v0,va,dumv
      real, dimension(ib:ie,jb:je,kb:ke+1) :: wa,dumw
      real, dimension(ib:ie,jb:je,kb:ke) :: ppi,tha
      real, dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: qa
      real, dimension(ibc:iec,jbc:jec,kbc:kec) :: kmh,kmv,khh,khv
      real, dimension(ibt:iet,jbt:jet,kbt:ket) :: tkea
      real, dimension(ibp:iep,jbp:jep,kbp:kep,npt) :: pta
      integer, intent(in) :: num_soil_layers
      integer, dimension(ibl:iel,jbl:jel), intent(in) :: lu_index
      real, dimension(ib:ie,jb:je), intent(in) :: tsk
      real, dimension(ibl:iel,jbl:jel), intent(in) :: xland,mavail,tmn,tml,hml,huml,hvml,hfx,qfx,gsw,glw
      real, dimension(ibl:iel,jbl:jel,num_soil_layers), intent(in) :: tslb
      real, dimension(ni,nj), intent(in) :: radsw,rnflx,radswnet,radlwin
      real, dimension(ibl:iel,jbl:jel), intent(in) :: u10,v10,t2,q2,znt,ust,hpbl,zol,mol,br
      real, dimension(ib:ie,jb:je,kb:ke), intent(in) :: dissten
      real, dimension(ibb:ieb,jbb:jeb,kbb:keb), intent(in) :: thpten,qvpten,qcpten,qipten,upten,vpten
      real, dimension(ibr:ier,jbr:jer,kbr:ker), intent(in) :: swten,lwten

#ifdef NETCDF

      include 'netcdf.inc'
      integer i,j,k,n,irec
#ifdef MPI
      character*80 sname,uname,vname,wname
#endif

      ! Users of GrADS might want to set coards to .true.
      logical, parameter :: coards = .false.

      integer :: cdfid,ncid    ! ID for the netCDF file to be created
      integer :: time_index,status,dimid,varid
      integer :: niid,njid,nkid,nip1id,njp1id,nkp1id,timeid,oneid
      character*80  cdf_out    ! Name of the netCDF output file
      character*8 chid

      real, dimension(ni,nj) :: d2d
      real, dimension(ni,nj,nk) :: ds
      real, dimension(ni+1,nj,nk) :: du
      real, dimension(ni,nj+1,nk) :: dv
      real, dimension(ni,nj,nk+1) :: dw

!-------------------------------------------------------------
! Declare and set integer values for the netCDF dimensions 
!-------------------------------------------------------------

      integer :: nip1,njp1
      real :: actual_time
      real :: x_min, x_max, y_min, y_max, z_min, z_max
      real :: x_mns, x_mxs, y_mns, y_mxs, z_mns, z_mxs

      logical :: allinfo

!--------------------------------------------------------------
! Initializing some things
!--------------------------------------------------------------

      time_index = nwrite
      if(output_filetype.eq.2) time_index = 1

    if(coards)then
      if(tapfrq.lt.60.0)then
        print *
        print *,'  Output frequency cannot be less than 60 s for coards format'
        print *
        call stopcm1
      endif
      actual_time = (nwrite-1)*tapfrq/60.0
    else
      actual_time = (nwrite-1)*tapfrq
    endif

      nip1=ni+1
      njp1=nj+1

!--------------------------------------------------------------
!  Write data to cdf file
!--------------------------------------------------------------

#ifndef MPI
    IF(output_filetype.eq.1)THEN
      cdf_out = 'cm1out.nc'
    ELSEIF(output_filetype.eq.2)THEN
      cdf_out = 'cm1out_XXXX.nc'
      write(cdf_out(8:11),100) nwrite
    ELSE
          if(myid.eq.0)write(outfile,*) '  Invalid option for output_filetype'
      call stopcm1
    ENDIF
#else

      cdf_out = 'cm1out_XXXX_YYYY.cdf'

      write(cdf_out( 8:11),100) myid
      write(cdf_out(13:16),100) nwrite
#endif

100   format(i4.4)

!--------------------------------------------------------------
!  if this is the start of a file, then do this stuff:

    allinfo = .false.
    IF(nwrite.eq.1) allinfo=.true.
    IF(output_filetype.eq.2) allinfo=.true.
#ifdef MPI
    allinfo = .true.
#endif

    ifallinfo: IF(allinfo)THEN

!--------------------------------------------------------------
! Determine start and end locations for data
!--------------------------------------------------------------

      x_min = xf(1)
      x_max = xf(nip1)
      x_mns = xh(1)
      x_mxs = xh(ni)

      y_min = yf(1)
      y_max = yf(njp1)
      y_mns = yh(1)
      y_mxs = yh(nj)

    if(terrain_flag)then
      z_min = sigmaf(1)
      z_max = sigmaf(nkp1)
      z_mns = sigma(1)
      z_mxs = sigma(nk)
    else
      z_min = zf(1,1,1)
      z_max = zf(1,1,nkp1)
      z_mns = zh(1,1,1)
      z_mxs = zh(1,1,nk)
    endif

!-----------------------------------------------------------------------
!  BEGIN NEW:
      call disp_err( nf_create(cdf_out,nf_write,ncid), .true. )

      status = nf_def_dim(ncid,'ni',ni,niid)
      status = nf_def_dim(ncid,'nj',nj,njid)
      status = nf_def_dim(ncid,'nk',nk,nkid)
      status = nf_def_dim(ncid,'nip1',nip1,nip1id)
      status = nf_def_dim(ncid,'njp1',njp1,njp1id)
      status = nf_def_dim(ncid,'nkp1',nkp1,nkp1id)
      status = nf_def_dim(ncid,'time',nf_unlimited,timeid)
      status = nf_def_dim(ncid,'one',1,oneid)

    IF(icor.eq.1)THEN
      status = nf_def_var(ncid,"f_cor",nf_real,1,oneid,varid)
      status = nf_put_att_text(ncid,varid,"def",18,"Coriolis parameter")
      status = nf_put_att_text(ncid,varid,"units",3,"1/s")
    ENDIF

    if(.not.coards)then
      status = nf_def_var(ncid,"ztop",nf_real,1,oneid,varid)
      status = nf_put_att_text(ncid,varid,"units",2,"km")
    endif

    IF(coards)THEN

      status = nf_def_var(ncid,"time",nf_real,1,timeid,varid)
      status = nf_put_att_text(ncid,varid,"def",34,"time since beginning of simulation")
      status = nf_put_att_text(ncid,varid,"units",33,"minutes since 2000-07-03 00:00:00")

      status = nf_def_var(ncid,"ni",nf_real,1,niid,varid)
      status = nf_put_att_text(ncid,varid,"def",40,"west-east location of scalar grid points")
      status = nf_put_att_text(ncid,varid,"units",11,"degree_east")

      status = nf_def_var(ncid,"nip1",nf_real,1,nip1id,varid)
      status = nf_put_att_text(ncid,varid,"def",45,"west-east location of staggered u grid points")
      status = nf_put_att_text(ncid,varid,"units",11,"degree_east")

      status = nf_def_var(ncid,"nj",nf_real,1,njid,varid)
      status = nf_put_att_text(ncid,varid,"def",42,"south-north location of scalar grid points")
      status = nf_put_att_text(ncid,varid,"units",12,"degree_north")

      status = nf_def_var(ncid,"njp1",nf_real,1,njp1id,varid)
      status = nf_put_att_text(ncid,varid,"def",47,"south-north location of staggered v grid points")
      status = nf_put_att_text(ncid,varid,"units",12,"degree_north")

      status = nf_def_var(ncid,"nk",nf_real,1,nkid,varid)
      status = nf_put_att_text(ncid,varid,"def",36,"nominal height of scalar grid points")
      status = nf_put_att_text(ncid,varid,"units",2,"km")

      status = nf_def_var(ncid,"nkp1",nf_real,1,nkp1id,varid)
      status = nf_put_att_text(ncid,varid,"def",41,"nominal height of staggered w grid points")
      status = nf_put_att_text(ncid,varid,"units",2,"km")

    ELSE

      status = nf_def_var(ncid,"time",nf_real,1,timeid,varid)
      status = nf_put_att_text(ncid,varid,"def",34,"time since beginning of simulation")
      status = nf_put_att_text(ncid,varid,"units",33,"seconds since 2000-07-03 00:00:00")

      status = nf_def_var(ncid,"xh",nf_real,1,niid,varid)
      status = nf_put_att_text(ncid,varid,"def",40,"west-east location of scalar grid points")
      status = nf_put_att_text(ncid,varid,"units",2,"km")

      status = nf_def_var(ncid,"xf",nf_real,1,nip1id,varid)
      status = nf_put_att_text(ncid,varid,"def",45,"west-east location of staggered u grid points")
      status = nf_put_att_text(ncid,varid,"units",2,"km")

      status = nf_def_var(ncid,"yh",nf_real,1,njid,varid)
      status = nf_put_att_text(ncid,varid,"def",42,"south-north location of scalar grid points")
      status = nf_put_att_text(ncid,varid,"units",2,"km")

      status = nf_def_var(ncid,"yf",nf_real,1,njp1id,varid)
      status = nf_put_att_text(ncid,varid,"def",47,"south-north location of staggered v grid points")
      status = nf_put_att_text(ncid,varid,"units",2,"km")

      status = nf_def_var(ncid,"z",nf_real,1,nkid,varid)
      status = nf_put_att_text(ncid,varid,"def",36,"nominal height of scalar grid points")
      status = nf_put_att_text(ncid,varid,"units",2,"km")

      status = nf_def_var(ncid,"zf",nf_real,1,nkp1id,varid)
      status = nf_put_att_text(ncid,varid,"def",41,"nominal height of staggered w grid points")
      status = nf_put_att_text(ncid,varid,"units",2,"km")

    ENDIF

!--------------------------------------------------------
!  Just to be sure:

        status = nf_inq_dimid(ncid,'time',timeid)
        status = nf_inq_dimid(ncid,'ni',niid)
        status = nf_inq_dimid(ncid,'nj',njid)
        status = nf_inq_dimid(ncid,'nk',nkid)
        status = nf_inq_dimid(ncid,'nip1',nip1id)
        status = nf_inq_dimid(ncid,'njp1',njp1id)
        status = nf_inq_dimid(ncid,'nkp1',nkp1id)

!--------------------------------------------------------

      if (output_zs.eq.1.and.terrain_flag) then
        status = nf_def_var(ncid,"zs",nf_real,2,(/niid,njid/),varid)
        status = nf_put_att_text(ncid,varid,"def",14,"terrain height")
        status = nf_put_att_text(ncid,varid,"units",1,"m")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
      endif

      if (output_zh.eq.1.and.terrain_flag) then
        status = nf_def_var(ncid,"zh",nf_real,3,(/niid,njid,nkid/),varid)
        status = nf_put_att_text(ncid,varid,"def",43,"height (above ground) of scalar grid points")
        status = nf_put_att_text(ncid,varid,"units",1,"m")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_mns)
      endif

      if (output_basestate.eq.1) then

        status = nf_def_var(ncid,"pi0",nf_real,3,(/niid,njid,nkid/),varid)
        status = nf_put_att_text(ncid,varid,"def",34,"base-state nondimensional pressure")
        status = nf_put_att_text(ncid,varid,"units",13,"dimensionless")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_mns)

        status = nf_def_var(ncid,"th0",nf_real,3,(/niid,njid,nkid/),varid)
        status = nf_put_att_text(ncid,varid,"def",32,"base-state potential temperature")
        status = nf_put_att_text(ncid,varid,"units",1,"K")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_mns)

        status = nf_def_var(ncid,"prs0",nf_real,3,(/niid,njid,nkid/),varid)
        status = nf_put_att_text(ncid,varid,"def",19,"base-state pressure")
        status = nf_put_att_text(ncid,varid,"units",2,"Pa")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_mns)

        status = nf_def_var(ncid,"qv0",nf_real,3,(/niid,njid,nkid/),varid)
        status = nf_put_att_text(ncid,varid,"def",35,"base-state water vapor mixing ratio")
        status = nf_put_att_text(ncid,varid,"units",5,"kg/kg")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_mns)

        status = nf_def_var(ncid,"u0",nf_real,3,(/nip1id,njid,nkid/),varid)
        status = nf_put_att_text(ncid,varid,"def",34,"base-state x-component of velocity")
        status = nf_put_att_text(ncid,varid,"units",3,"m/s")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_min)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_mns)

        status = nf_def_var(ncid,"v0",nf_real,3,(/niid,njp1id,nkid/),varid)
        status = nf_put_att_text(ncid,varid,"def",34,"base-state y-component of velocity")
        status = nf_put_att_text(ncid,varid,"units",3,"m/s")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_min)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_mns)

      endif

! 2D variables

      if(output_rain.eq.1)then
        status = nf_def_var(ncid,"rain",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",28,"accumulated surface rainfall")
        status = nf_put_att_text(ncid,varid,"units",2,"cm")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
      endif
      if(output_sws.eq.1) then
        status = nf_def_var(ncid,"sws",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",29,"max windspeed at lowest level")
        status = nf_put_att_text(ncid,varid,"units",3,"m/s")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_def_var(ncid,"svs",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",34,"max vert vorticity at lowest level")
        status = nf_put_att_text(ncid,varid,"units",3,"s-1")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_def_var(ncid,"sps",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",28,"min pressure at lowest level")
        status = nf_put_att_text(ncid,varid,"units",2,"Pa")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_def_var(ncid,"srs",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",21,"max surface rainwater")
        status = nf_put_att_text(ncid,varid,"units",5,"kg/kg")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_def_var(ncid,"sgs",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",24,"max surface graupel/hail")
        status = nf_put_att_text(ncid,varid,"units",5,"kg/kg")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_def_var(ncid,"sus",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",17,"max w at 5 km AGL")
        status = nf_put_att_text(ncid,varid,"units",3,"m/s")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_def_var(ncid,"shs",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",31,"max integrated updraft helicity")
        status = nf_put_att_text(ncid,varid,"units",5,"m2/s2")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
      endif
      IF(nrain.eq.2)THEN
        if(output_rain.eq.1)then
          status = nf_def_var(ncid,"rain2",nf_real,3,(/niid,njid,timeid/),varid)
          status = nf_put_att_text(ncid,varid,"def",59,"accumulated surface rainfall, translated with moving domain")
          status = nf_put_att_text(ncid,varid,"units",2,"cm")
          status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
          status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        endif
        if(output_sws.eq.1) then
          status = nf_def_var(ncid,"sws2",nf_real,3,(/niid,njid,timeid/),varid)
          status = nf_put_att_text(ncid,varid,"def",60,"max windspeed at lowest level, translated with moving domain")
          status = nf_put_att_text(ncid,varid,"units",3,"m/s")
          status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
          status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
          status = nf_def_var(ncid,"svs2",nf_real,3,(/niid,njid,timeid/),varid)
          status = nf_put_att_text(ncid,varid,"def",60,"max vorticity at lowest level, translated with moving domain")
          status = nf_put_att_text(ncid,varid,"units",3,"s-1")
          status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
          status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
          status = nf_def_var(ncid,"sps2",nf_real,3,(/niid,njid,timeid/),varid)
          status = nf_put_att_text(ncid,varid,"def",59,"min pressure at lowest level, translated with moving domain")
          status = nf_put_att_text(ncid,varid,"units",2,"Pa")
          status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
          status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
          status = nf_def_var(ncid,"srs2",nf_real,3,(/niid,njid,timeid/),varid)
          status = nf_put_att_text(ncid,varid,"def",52,"max surface rainwater, translated with moving domain")
          status = nf_put_att_text(ncid,varid,"units",5,"kg/kg")
          status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
          status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
          status = nf_def_var(ncid,"sgs2",nf_real,3,(/niid,njid,timeid/),varid)
          status = nf_put_att_text(ncid,varid,"def",55,"max surface graupel/hail, translated with moving domain")
          status = nf_put_att_text(ncid,varid,"units",5,"kg/kg")
          status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
          status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
          status = nf_def_var(ncid,"sus2",nf_real,3,(/niid,njid,timeid/),varid)
          status = nf_put_att_text(ncid,varid,"def",48,"max w at 5 km AGL, translated with moving domain")
          status = nf_put_att_text(ncid,varid,"units",3,"m/s")
          status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
          status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
          status = nf_def_var(ncid,"shs2",nf_real,3,(/niid,njid,timeid/),varid)
          status = nf_put_att_text(ncid,varid,"def",42,"translated max integrated updraft helicity")
          status = nf_put_att_text(ncid,varid,"units",5,"m2/s2")
          status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
          status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        endif
      ENDIF

      IF(output_uh.eq.1)THEN
        status = nf_def_var(ncid,"uh",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",27,"integrated updraft helicity")
        status = nf_put_att_text(ncid,varid,"units",5,"m2/s2")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
      ENDIF

      IF (output_dbz.eq.1) THEN
        status = nf_def_var(ncid,"cref",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",28,"composite reflectivity (dBZ)")
        status = nf_put_att_text(ncid,varid,"units",3,"dBZ")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
      ENDIF

      IF (output_coldpool.eq.1) THEN
        status = nf_def_var(ncid,"cpc",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",21,"cold pool intensity C")
        status = nf_put_att_text(ncid,varid,"units",3,"m/s")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_def_var(ncid,"cph",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",17,"cold pool depth h")
        status = nf_put_att_text(ncid,varid,"units",5,"m AGL")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
      ENDIF

      if (output_sfcflx.eq.1) then
        status = nf_def_var(ncid,"thflux",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",40,"surface potential temperature flux")
        status = nf_put_att_text(ncid,varid,"units",10,"K m s^{-1}")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)

        status = nf_def_var(ncid,"qvflux",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",40,"surface water vapor flux")
        status = nf_put_att_text(ncid,varid,"units",19,"kg kg^{-1} m s^{-1}")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)

        status = nf_def_var(ncid,"cd",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",2,"cd")
        status = nf_put_att_text(ncid,varid,"units",14,"nondimensional")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)

        status = nf_def_var(ncid,"ce",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",2,"ce")
        status = nf_put_att_text(ncid,varid,"units",14,"nondimensional")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)

        status = nf_def_var(ncid,"tsk",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",22,"soil/ocean temperature")
        status = nf_put_att_text(ncid,varid,"units",1,"K")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
      endif

      if(output_sfcparams.eq.1)then
        status = nf_def_var(ncid,"xland",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",32,"land/water flag (1=land,2=water)")
        status = nf_put_att_text(ncid,varid,"units",12,"integer flag")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)

        status = nf_def_var(ncid,"lu",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",14,"land use index")
        status = nf_put_att_text(ncid,varid,"units",12,"integer flag")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)

        status = nf_def_var(ncid,"mavail",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",29,"surface moisture availability")
        status = nf_put_att_text(ncid,varid,"units",12,"integer flag")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
      endif

      if((output_sfcparams.eq.1).and.(sfcmodel.eq.2.or.oceanmodel.eq.2))then
        status = nf_def_var(ncid,"tmn",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",27,"deep-layer soil temperature")
        status = nf_put_att_text(ncid,varid,"units",1,"K")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)

        status = nf_def_var(ncid,"hfx",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",20,"heat flux at surface")
        status = nf_put_att_text(ncid,varid,"units",5,"W/m^2")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)

        status = nf_def_var(ncid,"qfx",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",21,"surface moisture flux")
        status = nf_put_att_text(ncid,varid,"units",5,"W/m^2")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)

        status = nf_def_var(ncid,"gsw",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",27,"downward SW flux at surface")
        status = nf_put_att_text(ncid,varid,"units",5,"W/m^2")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)

        status = nf_def_var(ncid,"glw",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",27,"downward LW flux at surface")
        status = nf_put_att_text(ncid,varid,"units",5,"W/m^2")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
      endif

      if((output_sfcparams.eq.1).and.(sfcmodel.eq.2))then
        status = nf_def_var(ncid,"tslb1",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",18,"soil temp, layer 1")
        status = nf_put_att_text(ncid,varid,"units",1,"K")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)

        status = nf_def_var(ncid,"tslb2",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",18,"soil temp, layer 2")
        status = nf_put_att_text(ncid,varid,"units",1,"K")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)

        status = nf_def_var(ncid,"tslb3",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",18,"soil temp, layer 3")
        status = nf_put_att_text(ncid,varid,"units",1,"K")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)

        status = nf_def_var(ncid,"tslb4",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",18,"soil temp, layer 4")
        status = nf_put_att_text(ncid,varid,"units",1,"K")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)

        status = nf_def_var(ncid,"tslb5",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",18,"soil temp, layer 5")
        status = nf_put_att_text(ncid,varid,"units",1,"K")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
      endif

      if(output_sfcparams.eq.1.and.oceanmodel.eq.2)then
        status = nf_def_var(ncid,"tml",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",29,"ocean mixed layer temperature")
        status = nf_put_att_text(ncid,varid,"units",1,"K")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)

        status = nf_def_var(ncid,"hml",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",23,"ocean mixed layer depth")
        status = nf_put_att_text(ncid,varid,"units",1,"m")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)

        status = nf_def_var(ncid,"huml",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",24,"ocean mixed layer u vel.")
        status = nf_put_att_text(ncid,varid,"units",3,"m/s")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)

        status = nf_def_var(ncid,"hvml",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",24,"ocean mixed layer v vel.")
        status = nf_put_att_text(ncid,varid,"units",3,"m/s")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
      endif

      if(output_radten.eq.1)then
        status = nf_def_var(ncid,"radsw",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",26,"solar radiation at surface")
        status = nf_put_att_text(ncid,varid,"units",5,"w/m^2")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)

        status = nf_def_var(ncid,"rnflx",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",33,"net radiation absorbed by surface")
        status = nf_put_att_text(ncid,varid,"units",5,"W/m^2")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)

        status = nf_def_var(ncid,"radswnet",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",19,"net solar radiation")
        status = nf_put_att_text(ncid,varid,"units",5,"W/m^2")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)

        status = nf_def_var(ncid,"radlwin",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",27,"incoming longwave radiation")
        status = nf_put_att_text(ncid,varid,"units",5,"W/m^2")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
      endif

      IF(output_sfcdiags.eq.1)THEN
        status = nf_def_var(ncid,"u10",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",22,"diagnostic 10 m u wind")
        status = nf_put_att_text(ncid,varid,"units",3,"m/s")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)

        status = nf_def_var(ncid,"v10",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",22,"diagnostic 10 m v wind")
        status = nf_put_att_text(ncid,varid,"units",3,"m/s")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)

        status = nf_def_var(ncid,"t2",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",26,"diagnostic 2 m temperature")
        status = nf_put_att_text(ncid,varid,"units",1,"K")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)

        status = nf_def_var(ncid,"q2",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",27,"diagnostic 2 m mixing ratio")
        status = nf_put_att_text(ncid,varid,"units",5,"kg/kg")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)

        status = nf_def_var(ncid,"znt",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",16,"roughness length")
        status = nf_put_att_text(ncid,varid,"units",1,"m")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)

        status = nf_def_var(ncid,"ust",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",23,"u* in similarity theory")
        status = nf_put_att_text(ncid,varid,"units",3,"m/s")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)

        status = nf_def_var(ncid,"hpbl",nf_real,3,(/niid,njid,timeid/),varid)
      if(ipbl.eq.1)then
        status = nf_put_att_text(ncid,varid,"def",28,"PBL height (from PBL scheme)")
      else
        status = nf_put_att_text(ncid,varid,"def",28,"rough estimate of PBL height")
      endif
        status = nf_put_att_text(ncid,varid,"units",1,"m")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)

        status = nf_def_var(ncid,"zol",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",33,"z/L (z over Monin-Obukhov length)")
        status = nf_put_att_text(ncid,varid,"units",3,"   ")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)

        status = nf_def_var(ncid,"mol",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",22,"T* (similarity theory)")
        status = nf_put_att_text(ncid,varid,"units",1,"K")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)

        status = nf_def_var(ncid,"br",nf_real,3,(/niid,njid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",39,"bulk Richardson number in surface layer")
        status = nf_put_att_text(ncid,varid,"units",1," ")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
      ENDIF

! 3D variables

      if(output_u.eq.1)then
        status = nf_def_var(ncid,"u",nf_real,4,(/nip1id,njid,nkid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",23,"velocity in x-direction")
        status = nf_put_att_text(ncid,varid,"units",3,"m/s")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_min)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_mns)
      endif
      if(output_upert.eq.1)then
        status = nf_def_var(ncid,"upert",nf_real,4,(/nip1id,njid,nkid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",36,"perturbation velocity in x-direction")
        status = nf_put_att_text(ncid,varid,"units",3,"m/s")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_min)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_mns)
      endif
      if(output_v.eq.1)then
        status = nf_def_var(ncid,"v",nf_real,4,(/niid,njp1id,nkid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",23,"velocity in y-direction")
        status = nf_put_att_text(ncid,varid,"units",3,"m/s")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_min)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_mns)
      endif
      if(output_vpert.eq.1)then
        status = nf_def_var(ncid,"vpert",nf_real,4,(/niid,njp1id,nkid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",36,"perturbation velocity in y-direction")
        status = nf_put_att_text(ncid,varid,"units",3,"m/s")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_min)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_mns)
      endif
      if(output_w.eq.1)then
        status = nf_def_var(ncid,"w",nf_real,4,(/niid,njid,nkp1id,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",23,"velocity in z-direction")
        status = nf_put_att_text(ncid,varid,"units",3,"m/s")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_min)
      endif

      if(output_rho.eq.1)then
        status = nf_def_var(ncid,"rho",nf_real,4,(/niid,njid,nkid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",18,"density of dry air")
        status = nf_put_att_text(ncid,varid,"units",6,"kg/m^3")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_mns)
      endif
      if(output_rhopert.eq.1)then
        status = nf_def_var(ncid,"rhopert",nf_real,4,(/niid,njid,nkid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",31,"perturbation density of dry air")
        status = nf_put_att_text(ncid,varid,"units",6,"kg/m^3")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_mns)
      endif
      if(output_th.eq.1)then
        status = nf_def_var(ncid,"th",nf_real,4,(/niid,njid,nkid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",21,"potential temperature")
        status = nf_put_att_text(ncid,varid,"units",1,"K")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_mns)
      endif
      if(output_thpert.eq.1)then
        status = nf_def_var(ncid,"thpert",nf_real,4,(/niid,njid,nkid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",34,"perturbation potential temperature")
        status = nf_put_att_text(ncid,varid,"units",1,"K")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_mns)
      endif

      if(output_pi.eq.1)then
        status = nf_def_var(ncid,"pi",nf_real,4,(/niid,njid,nkid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",23,"nondimensional pressure")
        status = nf_put_att_text(ncid,varid,"units",13,"dimensionless")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_mns)
      endif
      if(output_pipert.eq.1)then
        status = nf_def_var(ncid,"pipert",nf_real,4,(/niid,njid,nkid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",36,"perturbation nondimensional pressure")
        status = nf_put_att_text(ncid,varid,"units",13,"dimensionless")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_mns)
      endif
      if(output_prs.eq.1)then
        status = nf_def_var(ncid,"prs",nf_real,4,(/niid,njid,nkid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",8,"pressure")
        status = nf_put_att_text(ncid,varid,"units",2,"Pa")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_mns)
      endif
      if(output_prspert.eq.1)then
        status = nf_def_var(ncid,"prspert",nf_real,4,(/niid,njid,nkid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",21,"perturbation pressure")
        status = nf_put_att_text(ncid,varid,"units",2,"Pa")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_mns)
      endif
    IF(imoist.eq.1)THEN
      if(output_qv.eq.1)then
        status = nf_def_var(ncid,"qv",nf_real,4,(/niid,njid,nkid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",24,"water vapor mixing ratio")
        status = nf_put_att_text(ncid,varid,"units",5,"kg/kg")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_mns)
      endif
      if(output_qvpert.eq.1)then
        status = nf_def_var(ncid,"qvpert",nf_real,4,(/niid,njid,nkid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",37,"perturbation water vapor mixing ratio")
        status = nf_put_att_text(ncid,varid,"units",5,"kg/kg")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_mns)
      endif
        if(output_q.eq.1)then
        do n=1,numq
          if(n.ne.nqv)then
            status = nf_def_var(ncid,qname(n),nf_real,4,(/niid,njid,nkid,timeid/),varid)
            if(idm.eq.1.and.n.ge.nnc1.and.n.le.nnc2)then
              status = nf_put_att_text(ncid,varid,"def",20,"number concentration")
              status = nf_put_att_text(ncid,varid,"units",7,"kg^{-1}")
            else
              status = nf_put_att_text(ncid,varid,"def",12,"mixing ratio")
              status = nf_put_att_text(ncid,varid,"units",5,"kg/kg")
            endif
            status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
            status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
            status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_mns)
          endif
        enddo
      endif
      if(output_dbz.eq.1)then
        status = nf_def_var(ncid,"dbz",nf_real,4,(/niid,njid,nkid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",12,"reflectivity")
        status = nf_put_att_text(ncid,varid,"units",3,"dBZ")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_mns)
      endif
    ENDIF
    IF(iptra.eq.1)THEN
      do n=1,npt
        chid = 'pt      '
        write(chid(3:4),111) n
111     format(i2.2)
        status = nf_def_var(ncid,chid,nf_real,4,(/niid,njid,nkid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",30,"mixing ratio of passive tracer")
        status = nf_put_att_text(ncid,varid,"units",5,"kg/kg")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_mns)
      enddo
    ENDIF
    IF(iturb.ge.1)THEN
      IF(output_km.eq.1)THEN
        !----
        status = nf_def_var(ncid,"kmh",nf_real,4,(/niid,njid,nkp1id,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",64,"eddy mixing coefficient for momentum in the horizontal direction")
        status = nf_put_att_text(ncid,varid,"units",5,"m^2/s")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_min)
        !----
        status = nf_def_var(ncid,"kmv",nf_real,4,(/niid,njid,nkp1id,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",62,"eddy mixing coefficient for momentum in the vertical direction")
        status = nf_put_att_text(ncid,varid,"units",5,"m^2/s")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_min)
        !----
      ENDIF
      IF(output_kh.eq.1)THEN
        !----
        status = nf_def_var(ncid,"khh",nf_real,4,(/niid,njid,nkp1id,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",63,"eddy mixing coefficient for scalars in the horizontal direction")
        status = nf_put_att_text(ncid,varid,"units",5,"m^2/s")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_min)
        !----
        status = nf_def_var(ncid,"khv",nf_real,4,(/niid,njid,nkp1id,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",61,"eddy mixing coefficient for scalars in the vertical direction")
        status = nf_put_att_text(ncid,varid,"units",5,"m^2/s")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_min)
        !----
      ENDIF
    ENDIF
      IF((iturb.eq.1).and.(output_tke.eq.1))THEN
        status = nf_def_var(ncid,"tke",nf_real,4,(/niid,njid,nkp1id,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",33,"subgrid turbulence kinetic energy")
        status = nf_put_att_text(ncid,varid,"units",7,"m^2/s^2")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_min)
      ENDIF

      if(output_uinterp.eq.1)then
        status = nf_def_var(ncid,"uinterp",nf_real,4,(/niid,njid,nkid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",54,"velocity in x-direction, interpolated to scalar points")
        status = nf_put_att_text(ncid,varid,"units",3,"m/s")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_mns)
      endif
      if(output_vinterp.eq.1)then
        status = nf_def_var(ncid,"vinterp",nf_real,4,(/niid,njid,nkid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",54,"velocity in y-direction, interpolated to scalar points")
        status = nf_put_att_text(ncid,varid,"units",3,"m/s")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_mns)
      endif
      if(output_winterp.eq.1)then
        status = nf_def_var(ncid,"winterp",nf_real,4,(/niid,njid,nkid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",54,"velocity in z-direction, interpolated to scalar points")
        status = nf_put_att_text(ncid,varid,"units",3,"m/s")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_mns)
      endif

      if(output_vort.eq.1)then
        status = nf_def_var(ncid,"xvort",nf_real,4,(/niid,njid,nkid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",24,"horizontal vorticity (x)")
        status = nf_put_att_text(ncid,varid,"units",4,"s^-1")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_mns)

        status = nf_def_var(ncid,"yvort",nf_real,4,(/niid,njid,nkid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",24,"horizontal vorticity (y)")
        status = nf_put_att_text(ncid,varid,"units",4,"s^-1")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_mns)

        status = nf_def_var(ncid,"zvort",nf_real,4,(/niid,njid,nkid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",18,"vertical vorticity")
        status = nf_put_att_text(ncid,varid,"units",4,"s^-1")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_mns)
      endif

      if(output_dissten.eq.1)then
        status = nf_def_var(ncid,"dissten",nf_real,4,(/niid,njid,nkid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",28,"dissipative heating tendency")
        status = nf_put_att_text(ncid,varid,"units",3,"K/s")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_mns)
      endif

      if(output_pblten.eq.1)then
        status = nf_def_var(ncid,"thpten",nf_real,4,(/niid,njid,nkid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",19,"pbl tendency: theta")
        status = nf_put_att_text(ncid,varid,"units",4,"    ")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_mns)

        status = nf_def_var(ncid,"qvpten",nf_real,4,(/niid,njid,nkid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",16,"pbl tendency: qv")
        status = nf_put_att_text(ncid,varid,"units",4,"    ")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_mns)

        status = nf_def_var(ncid,"qcpten",nf_real,4,(/niid,njid,nkid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",16,"pbl tendency: qc")
        status = nf_put_att_text(ncid,varid,"units",4,"    ")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_mns)

        status = nf_def_var(ncid,"qipten",nf_real,4,(/niid,njid,nkid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",16,"pbl tendency: qi")
        status = nf_put_att_text(ncid,varid,"units",4,"    ")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_mns)

        status = nf_def_var(ncid,"upten",nf_real,4,(/niid,njid,nkid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",15,"pbl tendency: u")
        status = nf_put_att_text(ncid,varid,"units",4,"    ")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_mns)

        status = nf_def_var(ncid,"vpten",nf_real,4,(/niid,njid,nkid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",15,"pbl tendency: v")
        status = nf_put_att_text(ncid,varid,"units",4,"    ")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_mns)
      endif

      if(output_radten.eq.1)then
        status = nf_def_var(ncid,"swten",nf_real,4,(/niid,njid,nkid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",25,"pot temp tendency, sw rad")
        status = nf_put_att_text(ncid,varid,"units",4,"    ")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_mns)

        status = nf_def_var(ncid,"lwten",nf_real,4,(/niid,njid,nkid,timeid/),varid)
        status = nf_put_att_text(ncid,varid,"def",25,"pot temp tendency, lw rad")
        status = nf_put_att_text(ncid,varid,"units",3,"K/s")
        status = nf_put_att_real(ncid,varid,"x_min",nf_real,1,0.001*x_mns)
        status = nf_put_att_real(ncid,varid,"y_min",nf_real,1,0.001*y_mns)
        status = nf_put_att_real(ncid,varid,"z_min",nf_real,1,0.001*z_mns)
      endif

      status = nf_put_att_text(ncid,NF_GLOBAL,'Conventions',6,'COARDS')
      status = nf_put_att_real(ncid,NF_GLOBAL,'x_min'  ,nf_real,1,0.001*x_min)
      status = nf_put_att_real(ncid,NF_GLOBAL,'x_max'  ,nf_real,1,0.001*x_max)
      status = nf_put_att_real(ncid,NF_GLOBAL,'x_delta',nf_real,1,0.001*dx)
      status = nf_put_att_text(ncid,NF_GLOBAL,'x_units',2,'km')
      status = nf_put_att_text(ncid,NF_GLOBAL,'x_label',1,'x')
      status = nf_put_att_real(ncid,NF_GLOBAL,'y_min'  ,nf_real,1,0.001*y_min)
      status = nf_put_att_real(ncid,NF_GLOBAL,'y_max'  ,nf_real,1,0.001*y_max)
      status = nf_put_att_real(ncid,NF_GLOBAL,'y_delta',nf_real,1,0.001*dy)
      status = nf_put_att_text(ncid,NF_GLOBAL,'y_units',2,'km')
      status = nf_put_att_text(ncid,NF_GLOBAL,'y_label',1,'y')
      status = nf_put_att_real(ncid,NF_GLOBAL,'z_min'  ,nf_real,1,0.001*z_min)
      status = nf_put_att_real(ncid,NF_GLOBAL,'z_max'  ,nf_real,1,0.001*z_max)
      status = nf_put_att_real(ncid,NF_GLOBAL,'z_delta',nf_real,1,0.001*dz)
      status = nf_put_att_text(ncid,NF_GLOBAL,'z_units',2,'km')
      status = nf_put_att_text(ncid,NF_GLOBAL,'z_label',1,'z')

      status = nf_enddef(ncid)

! ... end of defs
!--------------------------------------------------
! begin data ... initial time ...

    IF(icor.eq.1)THEN
      status = nf_inq_varid(ncid,'f_cor',varid)
      status = nf_put_var_real(ncid,varid,fcor)
    ENDIF

    if(.not.coards)then
      status = nf_inq_varid(ncid,'ztop',varid)
      status = nf_put_var_real(ncid,varid,0.001*ztop)
    endif

      if(coards)then
        status = nf_inq_varid(ncid,'ni',varid)
      else
        status = nf_inq_varid(ncid,'xh',varid)
      endif
      do i=1,ni
        status = nf_put_var1_real(ncid,varid,i,0.001*xh(i))
      enddo

      if(coards)then
        status = nf_inq_varid(ncid,'nip1',varid)
      else
        status = nf_inq_varid(ncid,'xf',varid)
      endif
      do i=1,ni+1
        status = nf_put_var1_real(ncid,varid,i,0.001*xf(i))
      enddo

      if(coards)then
        status = nf_inq_varid(ncid,'nj',varid)
      else
        status = nf_inq_varid(ncid,'yh',varid)
      endif
      do j=1,nj
        status = nf_put_var1_real(ncid,varid,j,0.001*yh(j))
      enddo

      if(coards)then
        status = nf_inq_varid(ncid,'njp1',varid)
      else
        status = nf_inq_varid(ncid,'yf',varid)
      endif
      do j=1,nj+1
        status = nf_put_var1_real(ncid,varid,j,0.001*yf(j))
      enddo

      if(coards)then
        status = nf_inq_varid(ncid,'nk',varid)
      else
        status = nf_inq_varid(ncid,'z',varid)
      endif
      if(terrain_flag)then
        do k=1,nk
          status = nf_put_var1_real(ncid,varid,k,0.001*sigma(k))
        enddo
      else
        do k=1,nk
          status = nf_put_var1_real(ncid,varid,k,0.001*zh(1,1,k))
        enddo
      endif

      if(coards)then
        status = nf_inq_varid(ncid,'nkp1',varid)
      else
        status = nf_inq_varid(ncid,'zf',varid)
      endif
      if(terrain_flag)then
        do k=1,nk+1
          status = nf_put_var1_real(ncid,varid,k,0.001*sigmaf(k))
        enddo
      else
        do k=1,nk+1
          status = nf_put_var1_real(ncid,varid,k,0.001*zf(1,1,k))
        enddo
      endif

!----------------------------------------------------------

      if (output_zs.eq.1.and.terrain_flag) then
        do j=1,nj
        do i=1,ni
          d2d(i,j)=zs(i,j)
        enddo
        enddo
        status = nf_inq_varid(ncid,'zs',varid)
        call checkstatus(status)
        status = nf_put_var_real(ncid,varid,d2d)
        call checkstatus(status)
      endif
      if (output_zh.eq.1.and.terrain_flag) then
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ds(i,j,k)=zh(i,j,k)
        enddo
        enddo
        enddo
        status = nf_inq_varid(ncid,'zh',varid)
        call checkstatus(status)
        status = nf_put_var_real(ncid,varid,ds)
        call checkstatus(status)
      endif

      if (output_basestate.eq.1) then
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ds(i,j,k)=pi0(i,j,k)
        enddo
        enddo
        enddo
        status = nf_inq_varid(ncid,'pi0',varid)
        call checkstatus(status)
        status = nf_put_var_real(ncid,varid,ds)
        call checkstatus(status)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ds(i,j,k)=th0(i,j,k)
        enddo
        enddo
        enddo
        status = nf_inq_varid(ncid,'th0',varid)
        call checkstatus(status)
        status = nf_put_var_real(ncid,varid,ds)
        call checkstatus(status)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ds(i,j,k)=prs0(i,j,k)
        enddo
        enddo
        enddo
        status = nf_inq_varid(ncid,'prs0',varid)
        call checkstatus(status)
        status = nf_put_var_real(ncid,varid,ds)
        call checkstatus(status)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ds(i,j,k)=qv0(i,j,k)
        enddo
        enddo
        enddo
        status = nf_inq_varid(ncid,'qv0',varid)
        call checkstatus(status)
        status = nf_put_var_real(ncid,varid,ds)
        call checkstatus(status)
        do k=1,nk
        do j=1,nj
        do i=1,ni+1
          du(i,j,k)=u0(i,j,k)
        enddo
        enddo
        enddo
        status = nf_inq_varid(ncid,'u0',varid)
        call checkstatus(status)
        status = nf_put_var_real(ncid,varid,du)
        call checkstatus(status)
        do k=1,nk
        do j=1,nj+1
        do i=1,ni
          dv(i,j,k)=v0(i,j,k)
        enddo
        enddo
        enddo
        status = nf_inq_varid(ncid,'v0',varid)
        call checkstatus(status)
        status = nf_put_var_real(ncid,varid,dv)
        call checkstatus(status)
      endif

      ! ... end if info at initial time only

    ELSE

      ! Not initial time ... open file ...

      call disp_err( nf_open(cdf_out,nf_write,ncid), .true. )

    ENDIF ifallinfo

!------------------------------------------------------------------
!------------------------------------------------------------------
!------------------------------------------------------------------
! Main data dump:

      status = nf_inq_varid(ncid,'time',varid)
      call checkstatus(status)
      status = nf_put_var1_real(ncid,varid,time_index,actual_time)
      call checkstatus(status)

        if(output_rain.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j)
          do j=1,nj
          do i=1,ni
            d2d(i,j)=rain(i,j,1)
          enddo
          enddo
          call write2d_nc('rain    ',ncid,time_index,ni,nj,d2d)
        endif
        if(output_sws .eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j)
          do j=1,nj
          do i=1,ni
            d2d(i,j)=sws(i,j,1)
          enddo
          enddo
          call write2d_nc('sws     ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
          do j=1,nj
          do i=1,ni
            d2d(i,j)=svs(i,j,1)
          enddo
          enddo
          call write2d_nc('svs     ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
          do j=1,nj
          do i=1,ni
            d2d(i,j)=sps(i,j,1)
          enddo
          enddo
          call write2d_nc('sps     ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
          do j=1,nj
          do i=1,ni
            d2d(i,j)=srs(i,j,1)
          enddo
          enddo
          call write2d_nc('srs     ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
          do j=1,nj
          do i=1,ni
            d2d(i,j)=sgs(i,j,1)
          enddo
          enddo
          call write2d_nc('sgs     ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
          do j=1,nj
          do i=1,ni
            d2d(i,j)=sus(i,j,1)
          enddo
          enddo
          call write2d_nc('sus     ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
          do j=1,nj
          do i=1,ni
            d2d(i,j)=shs(i,j,1)
          enddo
          enddo
          call write2d_nc('shs     ',ncid,time_index,ni,nj,d2d)
        endif
        IF(nrain.eq.2)THEN
          if(output_rain.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j)
            do j=1,nj
            do i=1,ni
              d2d(i,j)=rain(i,j,2)
            enddo
            enddo
            call write2d_nc('rain2   ',ncid,time_index,ni,nj,d2d)
          endif
          if(output_sws .eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j)
            do j=1,nj
            do i=1,ni
              d2d(i,j)=sws(i,j,2)
            enddo
            enddo
            call write2d_nc('sws2    ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
            do j=1,nj
            do i=1,ni
              d2d(i,j)=svs(i,j,2)
            enddo
            enddo
            call write2d_nc('svs2    ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
            do j=1,nj
            do i=1,ni
              d2d(i,j)=sps(i,j,2)
            enddo
            enddo
            call write2d_nc('sps2    ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
            do j=1,nj
            do i=1,ni
              d2d(i,j)=srs(i,j,2)
            enddo
            enddo
            call write2d_nc('srs2    ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
            do j=1,nj
            do i=1,ni
              d2d(i,j)=sgs(i,j,2)
            enddo
            enddo
            call write2d_nc('sgs2    ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
            do j=1,nj
            do i=1,ni
              d2d(i,j)=sus(i,j,2)
            enddo
            enddo
            call write2d_nc('sus2    ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
            do j=1,nj
            do i=1,ni
              d2d(i,j)=shs(i,j,2)
            enddo
            enddo
            call write2d_nc('shs2    ',ncid,time_index,ni,nj,d2d)
          endif
        ENDIF
      if(output_uh.eq.1)then
        ! get height AGL:
        if( terrain_flag )then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk+1
          do j=1,nj
          do i=1,ni
            dum3(i,j,k) = zh(i,j,k)-zs(i,j)
            dumw(i,j,k) = zf(i,j,k)-zs(i,j)
          enddo
          enddo
          enddo
        else
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk+1
          do j=1,nj
          do i=1,ni
            dum3(i,j,k) = zh(i,j,k)
            dumw(i,j,k) = zf(i,j,k)
          enddo
          enddo
          enddo
        endif
        call calcuh(uf,vf,dum3,dumw,ua,va,wa,dum1(ib,jb,1),dum2)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=dum1(i,j,1)
        enddo
        enddo
        call write2d_nc('uh      ',ncid,time_index,ni,nj,d2d)
      endif
      if(output_dbz.eq.1)then
        call calccref(dum1(ib,jb,1),dbz)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=dum1(i,j,1)
        enddo
        enddo
        call write2d_nc('cref    ',ncid,time_index,ni,nj,d2d)
      endif
      if(output_coldpool.eq.1)then
        call calccpch(zf,th0,qv0,dum1(ib,jb,1),dum1(ib,jb,2),tha,qa)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=dum1(i,j,1)
        enddo
        enddo
        call write2d_nc('cpc     ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=dum1(i,j,2)
        enddo
        enddo
        call write2d_nc('cph     ',ncid,time_index,ni,nj,d2d)
      endif
      if(output_sfcflx.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=thflux(i,j)
        enddo
        enddo
        call write2d_nc('thflux  ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=qvflux(i,j)
        enddo
        enddo
        call write2d_nc('qvflux  ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=0.25*( (cdu(i,j)+cdu(i+1,j))   &
                         +(cdv(i,j)+cdv(i,j+1)) )
        enddo
        enddo
        call write2d_nc('cd      ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=ce(i,j)
        enddo
        enddo
        call write2d_nc('ce      ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=tsk(i,j)
        enddo
        enddo
        call write2d_nc('tsk     ',ncid,time_index,ni,nj,d2d)
      endif

      if(output_sfcparams.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=xland(i,j)
        enddo
        enddo
        call write2d_nc('xland   ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=lu_index(i,j)
        enddo
        enddo
        call write2d_nc('lu      ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=mavail(i,j)
        enddo
        enddo
        call write2d_nc('mavail  ',ncid,time_index,ni,nj,d2d)
      endif

      if((output_sfcparams.eq.1).and.(sfcmodel.eq.2.or.oceanmodel.eq.2))then
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=tmn(i,j)
        enddo
        enddo
        call write2d_nc('tmn     ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=hfx(i,j)
        enddo
        enddo
        call write2d_nc('hfx     ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=qfx(i,j)
        enddo
        enddo
        call write2d_nc('qfx     ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=gsw(i,j)
        enddo
        enddo
        call write2d_nc('gsw     ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=glw(i,j)
        enddo
        enddo
        call write2d_nc('glw     ',ncid,time_index,ni,nj,d2d)
      endif

      if((output_sfcparams.eq.1).and.(sfcmodel.eq.2))then
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=tslb(i,j,1)
        enddo
        enddo
        call write2d_nc('tslb1   ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=tslb(i,j,2)
        enddo
        enddo
        call write2d_nc('tslb2   ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=tslb(i,j,3)
        enddo
        enddo
        call write2d_nc('tslb3   ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=tslb(i,j,4)
        enddo
        enddo
        call write2d_nc('tslb4   ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=tslb(i,j,5)
        enddo
        enddo
        call write2d_nc('tslb5   ',ncid,time_index,ni,nj,d2d)
      endif

      if(output_sfcparams.eq.1.and.oceanmodel.eq.2)then
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=tml(i,j)
        enddo
        enddo
        call write2d_nc('tml     ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=hml(i,j)
        enddo
        enddo
        call write2d_nc('hml     ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=huml(i,j)
        enddo
        enddo
        call write2d_nc('huml    ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=hvml(i,j)
        enddo
        enddo
        call write2d_nc('hvml    ',ncid,time_index,ni,nj,d2d)
      endif

      if( output_radten.eq.1 )then
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=radsw(i,j)
        enddo
        enddo
        call write2d_nc('radsw   ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=rnflx(i,j)
        enddo
        enddo
        call write2d_nc('rnflx   ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=radswnet(i,j)
        enddo
        enddo
        call write2d_nc('radswnet',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=radlwin(i,j)
        enddo
        enddo
        call write2d_nc('radlwin ',ncid,time_index,ni,nj,d2d)
      endif

      IF(output_sfcdiags.eq.1)THEN
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=u10(i,j)
        enddo
        enddo
        call write2d_nc('u10     ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=v10(i,j)
        enddo
        enddo
        call write2d_nc('v10     ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=t2(i,j)
        enddo
        enddo
        call write2d_nc('t2      ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=q2(i,j)
        enddo
        enddo
        call write2d_nc('q2      ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=znt(i,j)
        enddo
        enddo
        call write2d_nc('znt     ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=ust(i,j)
        enddo
        enddo
        call write2d_nc('ust     ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=hpbl(i,j)
        enddo
        enddo
        call write2d_nc('hpbl    ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=zol(i,j)
        enddo
        enddo
        call write2d_nc('zol     ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=mol(i,j)
        enddo
        enddo
        call write2d_nc('mol     ',ncid,time_index,ni,nj,d2d)
!$omp parallel do default(shared)  &
!$omp private(i,j)
        do j=1,nj
        do i=1,ni
          d2d(i,j)=br(i,j)
        enddo
        enddo
        call write2d_nc('br      ',ncid,time_index,ni,nj,d2d)
      ENDIF

!---------------------------------------------

      if(output_u.eq.1) then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni+1
          du(i,j,k)=ua(i,j,k)
        enddo
        enddo
        enddo
        call write3d_nc('u       ',ncid,time_index,ni+1,nj,nk,du)
      endif
      if(output_upert.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni+1
          du(i,j,k)=ua(i,j,k)-u0(i,j,k)
        enddo
        enddo
        enddo
        call write3d_nc('upert   ',ncid,time_index,ni+1,nj,nk,du)
      endif
      if(output_v.eq.1) then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj+1
        do i=1,ni
          dv(i,j,k)=va(i,j,k)
        enddo
        enddo
        enddo
        call write3d_nc('v       ',ncid,time_index,ni,nj+1,nk,dv)
      endif
      if(output_vpert.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj+1
        do i=1,ni
          dv(i,j,k)=va(i,j,k)-v0(i,j,k)
        enddo
        enddo
        enddo
        call write3d_nc('vpert   ',ncid,time_index,ni,nj+1,nk,dv)
      endif
      if(output_w.eq.1) then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk+1
        do j=1,nj
        do i=1,ni
          dw(i,j,k)=wa(i,j,k)
        enddo
        enddo
        enddo
        call write3d_nc('w       ',ncid,time_index,ni,nj,nk+1,dw)
      endif

      if(output_rho.eq.1) then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ds(i,j,k)=rho(i,j,k)
        enddo
        enddo
        enddo
        call write3d_nc('rho     ',ncid,time_index,ni,nj,nk,ds)
      endif
      if(output_rhopert.eq.1) then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ds(i,j,k)=rho(i,j,k)-rho0(i,j,k)
        enddo
        enddo
        enddo
        call write3d_nc('rhopert ',ncid,time_index,ni,nj,nk,ds)
      endif
      if(output_th.eq.1) then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ds(i,j,k)=tha(i,j,k)+th0(i,j,k)
        enddo
        enddo
        enddo
        call write3d_nc('th      ',ncid,time_index,ni,nj,nk,ds)
      endif
      if(output_thpert.eq.1) then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ds(i,j,k)=tha(i,j,k)
        enddo
        enddo
        enddo
        call write3d_nc('thpert  ',ncid,time_index,ni,nj,nk,ds)
      endif
      if(output_pi.eq.1) then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ds(i,j,k)=pi0(i,j,k)+ppi(i,j,k)
        enddo
        enddo
        enddo
        call write3d_nc('pi      ',ncid,time_index,ni,nj,nk,ds)
      endif
      if(output_pipert.eq.1) then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ds(i,j,k)=ppi(i,j,k)
        enddo
        enddo
        enddo
        call write3d_nc('pipert  ',ncid,time_index,ni,nj,nk,ds)
      endif
      if(output_prs.eq.1) then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ds(i,j,k)=prs(i,j,k)
        enddo
        enddo
        enddo
        call write3d_nc('prs     ',ncid,time_index,ni,nj,nk,ds)
      endif
      if(output_prspert.eq.1) then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ds(i,j,k)=prs(i,j,k)-p00*(pi0(i,j,k)**cpdrd)
        enddo
        enddo
        enddo
        call write3d_nc('prspert ',ncid,time_index,ni,nj,nk,ds)
      endif
    IF(imoist.eq.1)THEN
      if(output_qv.eq.1) then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ds(i,j,k)=qa(i,j,k,nqv)
        enddo
        enddo
        enddo
        call write3d_nc('qv      ',ncid,time_index,ni,nj,nk,ds)
      endif
      if(output_qvpert.eq.1) then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ds(i,j,k)=qa(i,j,k,nqv)-qv0(i,j,k)
        enddo
        enddo
        enddo
        call write3d_nc('qvpert  ',ncid,time_index,ni,nj,nk,ds)
      endif
      if (output_q.eq.1) then
        chid = '        '
        do n=1,numq
          if(n.ne.nqv)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
            do k=1,nk
            do j=1,nj
            do i=1,ni
              ds(i,j,k)=qa(i,j,k,n)
            enddo
            enddo
            enddo
            write(chid(1:3),110) qname(n)
110         format(a3)
            call write3d_nc(chid,ncid,time_index,ni,nj,nk,ds)
          endif
        enddo
      endif
      if(output_dbz.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ds(i,j,k)=dbz(i,j,k)
        enddo
        enddo
        enddo
        call write3d_nc('dbz     ',ncid,time_index,ni,nj,nk,ds)
      endif
    ENDIF  ! endif for imoist=1
      IF(iptra.eq.1)THEN
        do n=1,npt
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=pta(i,j,k,n)
          enddo
          enddo
          enddo
          chid = 'pt      '
          write(chid(3:4),112) n
112       format(i2.2)
          call write3d_nc(chid,ncid,time_index,ni,nj,nk,ds)
        enddo
      ENDIF

    IF(iturb.ge.1)THEN
      if(output_km.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk+1
        do j=1,nj
        do i=1,ni
          dw(i,j,k)=kmh(i,j,k)
        enddo
        enddo
        enddo
        call write3d_nc('kmh     ',ncid,time_index,ni,nj,nk+1,dw)
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk+1
        do j=1,nj
        do i=1,ni
          dw(i,j,k)=kmv(i,j,k)
        enddo
        enddo
        enddo
        call write3d_nc('kmv     ',ncid,time_index,ni,nj,nk+1,dw)
      endif
      if(output_kh.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk+1
        do j=1,nj
        do i=1,ni
          dw(i,j,k)=khh(i,j,k)
        enddo
        enddo
        enddo
        call write3d_nc('khh     ',ncid,time_index,ni,nj,nk+1,dw)
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk+1
        do j=1,nj
        do i=1,ni
          dw(i,j,k)=khv(i,j,k)
        enddo
        enddo
        enddo
        call write3d_nc('khv     ',ncid,time_index,ni,nj,nk+1,dw)
      endif
    ENDIF

      IF((iturb.eq.1).and.(output_tke.eq.1))then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk+1
        do j=1,nj
        do i=1,ni
          dw(i,j,k)=tkea(i,j,k)
        enddo
        enddo
        enddo
        call write3d_nc('tke     ',ncid,time_index,ni,nj,nk+1,dw)
      ENDIF

      if(output_uinterp.eq.1) then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ds(i,j,k)=0.5*(ua(i,j,k)+ua(i+1,j,k))
        enddo
        enddo
        enddo
        call write3d_nc('uinterp ',ncid,time_index,ni,nj,nk,ds)
      endif
      if(output_vinterp.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ds(i,j,k)=0.5*(va(i,j,k)+va(i,j+1,k))
        enddo
        enddo
        enddo
        call write3d_nc('vinterp ',ncid,time_index,ni,nj,nk,ds)
      endif
      if(output_winterp.eq.1) then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ds(i,j,k)=0.5*(wa(i,j,k)+wa(i,j,k+1))
        enddo
        enddo
        enddo
        call write3d_nc('winterp ',ncid,time_index,ni,nj,nk,ds)
      endif

      if(output_vort.eq.1)then
        call calcvort(xh,xf,uf,vf,zh,mf,zf,ua,va,wa,dum1,dum2,dum3,dum4)
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ds(i,j,k)=dum1(i,j,k)
        enddo
        enddo
        enddo
        call write3d_nc('xvort   ',ncid,time_index,ni,nj,nk,ds)
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ds(i,j,k)=dum2(i,j,k)
        enddo
        enddo
        enddo
        call write3d_nc('yvort   ',ncid,time_index,ni,nj,nk,ds)
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ds(i,j,k)=dum3(i,j,k)
        enddo
        enddo
        enddo
        call write3d_nc('zvort   ',ncid,time_index,ni,nj,nk,ds)
      endif

      if(output_dissten.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ds(i,j,k)=dissten(i,j,k)
        enddo
        enddo
        enddo
        call write3d_nc('dissten ',ncid,time_index,ni,nj,nk,ds)
      endif

      if(output_pblten.eq.1)then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ds(i,j,k)=thpten(i,j,k)
        enddo
        enddo
        enddo
        call write3d_nc('thpten  ',ncid,time_index,ni,nj,nk,ds)
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ds(i,j,k)=qvpten(i,j,k)
        enddo
        enddo
        enddo
        call write3d_nc('qvpten  ',ncid,time_index,ni,nj,nk,ds)
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ds(i,j,k)=qcpten(i,j,k)
        enddo
        enddo
        enddo
        call write3d_nc('qcpten  ',ncid,time_index,ni,nj,nk,ds)
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ds(i,j,k)=qipten(i,j,k)
        enddo
        enddo
        enddo
        call write3d_nc('qipten  ',ncid,time_index,ni,nj,nk,ds)
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ds(i,j,k)=upten(i,j,k)
        enddo
        enddo
        enddo
        call write3d_nc('upten   ',ncid,time_index,ni,nj,nk,ds)
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ds(i,j,k)=vpten(i,j,k)
        enddo
        enddo
        enddo
        call write3d_nc('vpten   ',ncid,time_index,ni,nj,nk,ds)
      endif

      if( output_radten.eq.1 )then
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ds(i,j,k)=swten(i,j,k)
        enddo
        enddo
        enddo
        call write3d_nc('swten   ',ncid,time_index,ni,nj,nk,ds)
!$omp parallel do default(shared)  &
!$omp private(i,j,k)
        do k=1,nk
        do j=1,nj
        do i=1,ni
          ds(i,j,k)=lwten(i,j,k)
        enddo
        enddo
        enddo
        call write3d_nc('lwten   ',ncid,time_index,ni,nj,nk,ds)
      endif

!------------------------------------------------------------------
!------------------------------------------------------------------
!------------------------------------------------------------------
!  All done ... close file ...

      call disp_err( nf_close(ncid) , .true. )

#endif

if(myid.eq.0)then
      write(outfile,*)
      write(outfile,*) 'Done Writing Data to File: nwrite=',nwrite
      write(outfile,*)
endif

      return
      end


#ifdef NETCDF
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine checkstatus(status)
      implicit none

      integer :: status

      include 'netcdf.inc'

      if(status.ne.nf_noerr)then
        print *,'  Error ... '
        print *,nf_strerror(status)
        call stopcm1
      endif

      return
      end subroutine checkstatus

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine write2d_nc(chid,ncid,time_index,ni,nj,d2d)
      implicit none

      include 'netcdf.inc'

      character*8, intent(in) :: chid
      integer, intent(in) :: ncid,time_index,ni,nj
      real, dimension(ni,nj), intent(inout) :: d2d

      integer :: varid,status

!----------------------------------

      status = nf_inq_varid(ncid,chid,varid)
      if(status.ne.nf_noerr)then
        print *,'  Error in write2d_nc, chid = ',chid
        print *,nf_strerror(status)
        call stopcm1
      endif

      status = nf_put_vara_real(ncid,varid,(/1,1,time_index/),(/ni,nj,1/),d2d)
      if(status.ne.nf_noerr)then
        print *,'  Error in write2d_nc, chid = ',chid
        print *,nf_strerror(status)
        call stopcm1
      endif

!----------------------------------

      return
      end subroutine write2d_nc

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


      subroutine write3d_nc(chid,ncid,time_index,ni,nj,nk,ds)
      implicit none

      include 'netcdf.inc'

      character*8, intent(in) :: chid
      integer, intent(in) :: ncid,time_index,ni,nj,nk
      real, dimension(ni,nj), intent(inout) :: ds

      integer :: varid,status

!----------------------------------

      status = nf_inq_varid(ncid,chid,varid)
      if(status.ne.nf_noerr)then
        print *,'  Error in write3d_nc, chid = ',chid
        print *,nf_strerror(status)
        call stopcm1
      endif

      status = nf_put_vara_real(ncid,varid,(/1,1,1,time_index/),(/ni,nj,nk,1/),ds)
      if(status.ne.nf_noerr)then
        print *,'  Error in write3d_nc, chid = ',chid
        print *,nf_strerror(status)
        call stopcm1
      endif

!----------------------------------

      return
      end subroutine write3d_nc

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine writestat_nc(nrec,rtime,nstat,rstat,qname,budname)
      implicit none

      include 'input.incl'

      integer, intent(inout) :: nrec
      real,    intent(in)    :: rtime
      integer, intent(in)    :: nstat
      real, dimension(stat_out), intent(in) :: rstat
      character*3, dimension(maxq), intent(in) :: qname
      character*6, dimension(maxq), intent(in) :: budname

      include 'netcdf.inc'
      integer :: n,ncid,status,dimid,varid,time_index
      character*8  :: text1
      character*30 :: text2

  IF(nrec.eq.1)THEN
    ! Definitions/descriptions:

    call disp_err( nf_create('cm1out_stats.nc',nf_write,ncid), .true. )

    status = nf_def_dim(ncid,"xh",1,dimid)
    status = nf_def_dim(ncid,"yh",1,dimid)
    status = nf_def_dim(ncid,"zh",1,dimid)
    status = nf_def_dim(ncid,"time",nf_unlimited,dimid)

    status = nf_def_var(ncid,"xh",nf_real,1,(/1/),varid)
    status = nf_put_att_text(ncid,varid,"def",18,"west-east location")
    status = nf_put_att_text(ncid,varid,"units",11,"degree_east")

    status = nf_def_var(ncid,"yh",nf_real,1,(/2/),varid)
    status = nf_put_att_text(ncid,varid,"def",20,"south-north location")
    status = nf_put_att_text(ncid,varid,"units",12,"degree_north")

    status = nf_def_var(ncid,"zh",nf_real,1,(/3/),varid)
    status = nf_put_att_text(ncid,varid,"def",6,"height")
    status = nf_put_att_text(ncid,varid,"units",1,"m")

    status = nf_def_var(ncid,"time",nf_real,1,(/4/),varid)
    status = nf_put_att_text(ncid,varid,"def",4,"time")
    status = nf_put_att_text(ncid,varid,"units",7,"seconds")

    IF(adapt_dt.eq.1)THEN
      status = nf_def_var(ncid,"dt",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"average timestep dt           ")
      status = nf_put_att_text(ncid,varid,"units",7,"seconds")
    ENDIF
    IF(stat_w.eq.1)THEN
      status = nf_def_var(ncid,"wmax",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"maximum vertical velocity     ")
      status = nf_put_att_text(ncid,varid,"units",3,"m/s")
      status = nf_def_var(ncid,"wmin",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"minimum vertical velocity     ")
      status = nf_put_att_text(ncid,varid,"units",3,"m/s")
    ENDIF
    IF(stat_u.eq.1)THEN
      status = nf_def_var(ncid,"umax",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"max E-W velocity              ")
      status = nf_put_att_text(ncid,varid,"units",3,"m/s")
      status = nf_def_var(ncid,"umin",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"min E-W velocity              ")
      status = nf_put_att_text(ncid,varid,"units",3,"m/s")
      status = nf_def_var(ncid,"sumax",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"max E-W velocity at lowest lvl")
      status = nf_put_att_text(ncid,varid,"units",3,"m/s")
      status = nf_def_var(ncid,"sumin",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"min E-W velocity at lowest lvl")
      status = nf_put_att_text(ncid,varid,"units",3,"m/s")
    ENDIF
    IF(stat_v.eq.1)THEN
      status = nf_def_var(ncid,"vmax",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"max N-S velocity              ")
      status = nf_put_att_text(ncid,varid,"units",3,"m/s")
      status = nf_def_var(ncid,"vmin",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"min N-S velocity              ")
      status = nf_put_att_text(ncid,varid,"units",3,"m/s")
      status = nf_def_var(ncid,"svmax",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"max N-S velocity at lowest lvl")
      status = nf_put_att_text(ncid,varid,"units",3,"m/s")
      status = nf_def_var(ncid,"svmin",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"min N-S velocity at lowest lvl")
      status = nf_put_att_text(ncid,varid,"units",3,"m/s")
    ENDIF
    IF(stat_rmw.eq.1)THEN
      status = nf_def_var(ncid,"rmw",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"radius of maximum V           ")
      status = nf_put_att_text(ncid,varid,"units",1,"m")
    ENDIF
    IF(stat_pipert.eq.1)THEN
      status = nf_def_var(ncid,"ppimax",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"max pi pert.                  ")
      status = nf_put_att_text(ncid,varid,"units",14,"nondimensional")
      status = nf_def_var(ncid,"ppimin",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"min pi pert.                  ")
      status = nf_put_att_text(ncid,varid,"units",14,"nondimensional")
    ENDIF
    IF(stat_prspert.eq.1)THEN
      status = nf_def_var(ncid,"ppmax",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"max pressure pert.            ")
      status = nf_put_att_text(ncid,varid,"units",2,"Pa")
      status = nf_def_var(ncid,"ppmin",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"min pressure pert.            ")
      status = nf_put_att_text(ncid,varid,"units",2,"Pa")
    ENDIF
    IF(stat_thpert.eq.1)THEN
      status = nf_def_var(ncid,"thpmax",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"max potential temp. pert.     ")
      status = nf_put_att_text(ncid,varid,"units",1,"K")
      status = nf_def_var(ncid,"thpmin",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"min potential temp. pert.     ")
      status = nf_put_att_text(ncid,varid,"units",1,"K")
      status = nf_def_var(ncid,"sthpmax",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"max pot temp pert lowest level")
      status = nf_put_att_text(ncid,varid,"units",1,"K")
      status = nf_def_var(ncid,"sthpmin",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"min pot temp pert lowest level")
      status = nf_put_att_text(ncid,varid,"units",1,"K")
    ENDIF
    IF(stat_q.eq.1)THEN
      do n=1,numq
        text1='max     '
        text2='max                           '
        write(text1(4:6),156) qname(n)
        write(text2(5:7),156) qname(n)
156     format(a3)
        status = nf_def_var(ncid,text1,nf_real,1,4,varid)
        status = nf_put_att_text(ncid,varid,"def",30,text2)
        status = nf_put_att_text(ncid,varid,"units",5,"kg/kg")
        text1='min     '
        text2='min                           '
        write(text1(4:6),156) qname(n)
        write(text2(5:7),156) qname(n)
        status = nf_def_var(ncid,text1,nf_real,1,4,varid)
        status = nf_put_att_text(ncid,varid,"def",30,text2)
        status = nf_put_att_text(ncid,varid,"units",5,"kg/kg")
      enddo
    ENDIF
    IF(stat_tke.eq.1)THEN
      status = nf_def_var(ncid,"tkemax",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"max tke                       ")
      status = nf_put_att_text(ncid,varid,"units",7,"m^2/s^2")
      status = nf_def_var(ncid,"tkemin",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"min tke                       ")
      status = nf_put_att_text(ncid,varid,"units",7,"m^2/s^2")
    ENDIF
    IF(stat_km.eq.1)THEN
      status = nf_def_var(ncid,"kmhmax",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"max kmh                       ")
      status = nf_put_att_text(ncid,varid,"units",5,"m^2/s")
      status = nf_def_var(ncid,"kmhmin",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"min kmh                       ")
      status = nf_put_att_text(ncid,varid,"units",5,"m^2/s")
      status = nf_def_var(ncid,"kmvmax",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"max kmv                       ")
      status = nf_put_att_text(ncid,varid,"units",5,"m^2/s")
      status = nf_def_var(ncid,"kmvmin",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"min kmv                       ")
      status = nf_put_att_text(ncid,varid,"units",5,"m^2/s")
    ENDIF
    IF(stat_kh.eq.1)THEN
      status = nf_def_var(ncid,"khhmax",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"max khh                       ")
      status = nf_put_att_text(ncid,varid,"units",5,"m^2/s")
      status = nf_def_var(ncid,"khhmin",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"min khh                       ")
      status = nf_put_att_text(ncid,varid,"units",5,"m^2/s")
      status = nf_def_var(ncid,"khvmax",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"max khv                       ")
      status = nf_put_att_text(ncid,varid,"units",5,"m^2/s")
      status = nf_def_var(ncid,"khvmin",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"min khv                       ")
      status = nf_put_att_text(ncid,varid,"units",5,"m^2/s")
    ENDIF
    IF(stat_div.eq.1)THEN
      status = nf_def_var(ncid,"divmax",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"max 3d divergence             ")
      status = nf_def_var(ncid,"divmin",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"min 3d divergence             ")
    ENDIF
    IF(stat_rh.eq.1)THEN
      status = nf_def_var(ncid,"rhmax",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"max relative humidity         ")
      status = nf_def_var(ncid,"rhmin",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"min relative humidity         ")
    ENDIF
    IF(stat_rhi.eq.1)THEN
      status = nf_def_var(ncid,"rhimax",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"max relative humidity wrt ice ")
      status = nf_def_var(ncid,"rhimin",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"min relative humidity wrt ice ")
    ENDIF
    IF(iptra.eq.1)then
      do n=1,npt
        text1='maxpt   '
        text2='max pt                        '
        write(text1(6:6),157) n
        write(text2(7:7),157) n
157     format(i1)
        status = nf_def_var(ncid,text1,nf_real,1,4,varid)
        status = nf_put_att_text(ncid,varid,"def",30,text2)
        text1='minpt   '
        text2='min pt                        '
        write(text1(6:6),157) n
        write(text2(7:7),157) n
        status = nf_def_var(ncid,text1,nf_real,1,4,varid)
        status = nf_put_att_text(ncid,varid,"def",30,text2)
      enddo
    endif
    IF(stat_the.eq.1)THEN
      status = nf_def_var(ncid,"themax",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"max theta-e below 10 km       ")
      status = nf_put_att_text(ncid,varid,"units",1,"K")
      status = nf_def_var(ncid,"themin",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"min theta-e below 10 km       ")
      status = nf_put_att_text(ncid,varid,"units",1,"K")
      status = nf_def_var(ncid,"sthemax",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"max theta-e at lowest level   ")
      status = nf_put_att_text(ncid,varid,"units",1,"K")
      status = nf_def_var(ncid,"sthemin",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"min theta-e at lowest level   ")
      status = nf_put_att_text(ncid,varid,"units",1,"K")
    ENDIF
    IF(stat_cloud.eq.1)THEN
      status = nf_def_var(ncid,"qctop",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"max cloud top height          ")
      status = nf_put_att_text(ncid,varid,"units",1,"m")
      status = nf_def_var(ncid,"qcbot",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"min cloud base height         ")
      status = nf_put_att_text(ncid,varid,"units",1,"m")
    ENDIF
    IF(stat_sfcprs.eq.1)THEN
      status = nf_def_var(ncid,"sprsmax",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"max pressure at lowest level  ")
      status = nf_put_att_text(ncid,varid,"units",2,"Pa")
      status = nf_def_var(ncid,"sprsmin",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"min pressure at lowest level  ")
      status = nf_put_att_text(ncid,varid,"units",2,"Pa")
    ENDIF
    IF(stat_wsp.eq.1)THEN
      status = nf_def_var(ncid,"wspmax",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"max wind speed                ")
      status = nf_put_att_text(ncid,varid,"units",3,"m/s")

      status = nf_def_var(ncid,"wspmin",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"min wind speed                ")
      status = nf_put_att_text(ncid,varid,"units",3,"m/s")

      status = nf_def_var(ncid,"swspmax",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"max wind speed at lowest level")
      status = nf_put_att_text(ncid,varid,"units",3,"m/s")

      status = nf_def_var(ncid,"swspmin",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"min wind speed at lowest level")
      status = nf_put_att_text(ncid,varid,"units",3,"m/s")

    IF(idrag.eq.1)THEN
      status = nf_def_var(ncid,"wsp10max",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"max 10 m wind speed           ")
      status = nf_put_att_text(ncid,varid,"units",3,"m/s")

      status = nf_def_var(ncid,"wsp10min",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"min 10 m wind speed           ")
      status = nf_put_att_text(ncid,varid,"units",3,"m/s")
    ENDIF
    ENDIF
    IF(stat_cfl.eq.1)THEN
    IF(adapt_dt.eq.1)THEN
      status = nf_def_var(ncid,"cflmax",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"max Courant number (average)  ")
      status = nf_put_att_text(ncid,varid,"units",14,"nondimensional")
    ELSE
      status = nf_def_var(ncid,"cflmax",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"max Courant number            ")
      status = nf_put_att_text(ncid,varid,"units",14,"nondimensional")
    ENDIF
      status = nf_def_var(ncid,"kshmax",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"max horiz K stability factor  ")
      status = nf_put_att_text(ncid,varid,"units",14,"nondimensional")
      status = nf_def_var(ncid,"ksvmax",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"max vert K stability factor   ")
      status = nf_put_att_text(ncid,varid,"units",14,"nondimensional")
    ENDIF
    IF(stat_vort.eq.1)THEN
      status = nf_def_var(ncid,"vortsfc",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"max vert. vort. at lowest lvl ")
      status = nf_put_att_text(ncid,varid,"units",3,"1/s")
      status = nf_def_var(ncid,"vort1km",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"max vert. vort. at z = 1 km   ")
      status = nf_put_att_text(ncid,varid,"units",3,"1/s")
      status = nf_def_var(ncid,"vort2km",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"max vert. vort. at z = 2 km   ")
      status = nf_put_att_text(ncid,varid,"units",3,"1/s")
      status = nf_def_var(ncid,"vort3km",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"max vert. vort. at z = 3 km   ")
      status = nf_put_att_text(ncid,varid,"units",3,"1/s")
      status = nf_def_var(ncid,"vort4km",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"max vert. vort. at z = 4 km   ")
      status = nf_put_att_text(ncid,varid,"units",3,"1/s")
      status = nf_def_var(ncid,"vort5km",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"max vert. vort. at z = 5 km   ")
      status = nf_put_att_text(ncid,varid,"units",3,"1/s")
    ENDIF
    IF(stat_tmass.eq.1)THEN
      status = nf_def_var(ncid,"tmass",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"total mass of (dry) air       ")
      status = nf_put_att_text(ncid,varid,"units",2,"kg")
    ENDIF
    IF(stat_tmois.eq.1)THEN
      status = nf_def_var(ncid,"tmois",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"total moisture                ")
      status = nf_put_att_text(ncid,varid,"units",2,"kg")
    ENDIF
    IF(stat_qmass.eq.1)THEN
      do n=1,numq
        IF( (n.eq.nqv) .or.                                 &
            (n.ge.nql1.and.n.le.nql2) .or.                  &
            (n.ge.nqs1.and.n.le.nqs2.and.iice.eq.1) )THEN
          text1='mass    '
          text2='total mass of                 '
          write(text1( 5: 7),156) qname(n)
          write(text2(15:17),156) qname(n)
          status = nf_def_var(ncid,text1,nf_real,1,4,varid)
          status = nf_put_att_text(ncid,varid,"def",30,text2)
          status = nf_put_att_text(ncid,varid,"units",2,"kg")
        ENDIF
      enddo
    ENDIF
    IF(stat_tenerg.eq.1)THEN
      status = nf_def_var(ncid,"ek",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"total kinetic energy          ")
      status = nf_def_var(ncid,"ei",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"total internal energy         ")
      status = nf_def_var(ncid,"ep",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"total potential energy        ")
      status = nf_def_var(ncid,"le",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"total latent energy           ")
      status = nf_def_var(ncid,"et",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"total energy                  ")
    ENDIF
    IF(stat_mo.eq.1)THEN
      status = nf_def_var(ncid,"tmu",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"total E-W momentum            ")
      status = nf_def_var(ncid,"tmv",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"total N-S momentum            ")
      status = nf_def_var(ncid,"tmw",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"total vertical momentum       ")
    ENDIF
    IF(stat_tmf.eq.1)THEN
      status = nf_def_var(ncid,"tmfu",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"total upward mass flux        ")
      status = nf_def_var(ncid,"tmfd",nf_real,1,4,varid)
      status = nf_put_att_text(ncid,varid,"def",30,"total downward mass flux      ")
    ENDIF
    IF(stat_pcn.eq.1)THEN
      do n=1,nbudget
        text1='        '
        text2='                              '
        write(text1(1:6),158) budname(n)
        write(text2(1:6),158) budname(n)
158     format(a6)
        status = nf_def_var(ncid,text1,nf_real,1,4,varid)
        status = nf_put_att_text(ncid,varid,"def",30,text2)
      enddo
    ENDIF
    IF(stat_qsrc.eq.1)THEN
      do n=1,numq
        text1='as      '
        text2='artificial source of          '
        write(text1( 3: 5),156) qname(n)
        write(text2(22:24),156) qname(n)
        status = nf_def_var(ncid,text1,nf_real,1,4,varid)
        status = nf_put_att_text(ncid,varid,"def",30,text2)
      enddo
      do n=1,numq
        text1='bs      '
        text2='bndry source/sink of          '
        write(text1( 3: 5),156) qname(n)
        write(text2(22:24),156) qname(n)
        status = nf_def_var(ncid,text1,nf_real,1,4,varid)
        status = nf_put_att_text(ncid,varid,"def",30,text2)
      enddo
    ENDIF

    status = nf_put_att_text(ncid, NF_GLOBAL, 'Conventions', 6, 'COARDS')

    status = nf_enddef(ncid)

    status = nf_put_var_real(ncid,1,0.0)
    status = nf_put_var_real(ncid,2,0.0)
    status = nf_put_var_real(ncid,3,0.0)

  ELSE

    ! open file:

    call disp_err( nf_open('cm1out_stats.nc',nf_write,ncid), .true. )

  ENDIF

    ! Write data:

    time_index = nrec

    status = nf_put_var1_real(ncid,4,time_index,rtime)

    DO n=1,nstat
      varid = 4 + n
      status = nf_put_var1_real(ncid,varid,time_index,rstat(n))
    ENDDO

    ! close file

    call disp_err( nf_close(ncid) , .true. )

    nrec = nrec + 1

    ! all done

      return
      end subroutine writestat_nc

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine disp_err( status , stop_on_error )
      implicit none

      integer, intent(in) :: status
      logical, intent(in) :: stop_on_error

      include 'netcdf.inc'

      IF( status.ne.nf_noerr )THEN
        IF( stop_on_error )THEN
          print *,'  netcdf status returned an error: ', status,' ... stopping program'
          call stopcm1
        ENDIF
      ENDIF

      return
      end subroutine disp_err

!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine writepdata_nc(prec,rtime,pdata)
      implicit none

      include 'input.incl'

      integer :: prec
      real :: rtime
      real, dimension(npvals,nparcels) :: pdata

      include 'netcdf.inc'

      integer :: ncid,status,dimid,varid,time_index,n,np

!-----------------------------------------------------------------------

  IF(prec.eq.1)THEN
    ! Definitions/descriptions:

    call disp_err( nf_create('cm1out_pdata.nc',nf_write,ncid), .true. )

    status = nf_def_dim(ncid,"xh",nparcels,dimid)
    status = nf_def_dim(ncid,"yh",1,dimid)
    status = nf_def_dim(ncid,"zh",1,dimid)
    status = nf_def_dim(ncid,"time",nf_unlimited,dimid)

    status = nf_def_var(ncid,"xh",nf_real,1,(/1/),varid)
    status = nf_put_att_text(ncid,varid,"def",51,"west-east location ... actually, really parcel info")
    status = nf_put_att_text(ncid,varid,"units",11,"degree_east")

    status = nf_def_var(ncid,"yh",nf_real,1,(/2/),varid)
    status = nf_put_att_text(ncid,varid,"def",20,"south-north location")
    status = nf_put_att_text(ncid,varid,"units",12,"degree_north")

    status = nf_def_var(ncid,"zh",nf_real,1,(/3/),varid)
    status = nf_put_att_text(ncid,varid,"def",6,"height")
    status = nf_put_att_text(ncid,varid,"units",1,"m")

    status = nf_def_var(ncid,"time",nf_real,1,(/4/),varid)
    status = nf_put_att_text(ncid,varid,"def",4,"time")
    status = nf_put_att_text(ncid,varid,"units",7,"seconds")

!------------------------

    status = nf_def_var(ncid,"x",nf_real,2,(/1,4/),varid)
    status = nf_put_att_text(ncid,varid,"def",30,"x                             ")
    status = nf_put_att_text(ncid,varid,"units",1,"m")

    status = nf_def_var(ncid,"y",nf_real,2,(/1,4/),varid)
    status = nf_put_att_text(ncid,varid,"def",30,"y                             ")
    status = nf_put_att_text(ncid,varid,"units",1,"m")

    status = nf_def_var(ncid,"z",nf_real,2,(/1,4/),varid)
    status = nf_put_att_text(ncid,varid,"def",30,"z                             ")
    status = nf_put_att_text(ncid,varid,"units",1,"m")

    status = nf_def_var(ncid,"qv",nf_real,2,(/1,4/),varid)
    status = nf_put_att_text(ncid,varid,"def",30,"water vapor mixing ratio      ")
    status = nf_put_att_text(ncid,varid,"units",5,"kg/kg")

    status = nf_def_var(ncid,"qc",nf_real,2,(/1,4/),varid)
    status = nf_put_att_text(ncid,varid,"def",30,"cloud water mixing ratio      ")
    status = nf_put_att_text(ncid,varid,"units",5,"kg/kg")

    status = nf_def_var(ncid,"qr",nf_real,2,(/1,4/),varid)
    status = nf_put_att_text(ncid,varid,"def",30,"rain water mixing ratio       ")
    status = nf_put_att_text(ncid,varid,"units",5,"kg/kg")

    status = nf_def_var(ncid,"nm",nf_real,2,(/1,4/),varid)
    status = nf_put_att_text(ncid,varid,"def",30,"squared Brunt-Vaisala frqncy  ")
    status = nf_put_att_text(ncid,varid,"units",3,"s-2")

    status = nf_def_var(ncid,"u",nf_real,2,(/1,4/),varid)
    status = nf_put_att_text(ncid,varid,"def",30,"u                             ")
    status = nf_put_att_text(ncid,varid,"units",3,"m/s")

    status = nf_def_var(ncid,"v",nf_real,2,(/1,4/),varid)
    status = nf_put_att_text(ncid,varid,"def",30,"v                             ")
    status = nf_put_att_text(ncid,varid,"units",3,"m/s")

    status = nf_def_var(ncid,"w",nf_real,2,(/1,4/),varid)
    status = nf_put_att_text(ncid,varid,"def",30,"w                             ")
    status = nf_put_att_text(ncid,varid,"units",3,"m/s")

    status = nf_def_var(ncid,"kh",nf_real,2,(/1,4/),varid)
    status = nf_put_att_text(ncid,varid,"def",30,"turb. coef. for scalar        ")
    status = nf_put_att_text(ncid,varid,"units",5,"m^2/s")

    status = nf_def_var(ncid,"the",nf_real,2,(/1,4/),varid)
    status = nf_put_att_text(ncid,varid,"def",30,"theta-e                       ")
    status = nf_put_att_text(ncid,varid,"units",1,"K")

    status = nf_def_var(ncid,"b",nf_real,2,(/1,4/),varid)
    status = nf_put_att_text(ncid,varid,"def",30,"buoyancy                      ")
    status = nf_put_att_text(ncid,varid,"units",5,"m/s^2")

    status = nf_def_var(ncid,"dpdz",nf_real,2,(/1,4/),varid)
    status = nf_put_att_text(ncid,varid,"def",30,"dpdz tendency                 ")
    status = nf_put_att_text(ncid,varid,"units",5,"m/s^2")

!------------------------

    status = nf_put_att_text(ncid, NF_GLOBAL, 'Conventions', 6, 'COARDS')

    status = nf_enddef(ncid)

  do np=1,nparcels
    status = nf_put_var1_real(ncid,1,np,float(np))
  enddo
    status = nf_put_var_real(ncid,2,0.0)
    status = nf_put_var_real(ncid,3,0.0)

!------------------------

  ELSE

    ! open file:

    call disp_err( nf_open('cm1out_pdata.nc',nf_write,ncid), .true. )

  ENDIF

      ! Write data:

      time_index = prec

      status = nf_put_var1_real(ncid,4,time_index,rtime)

      DO np=1,nparcels
      DO n=1,npvals - 3
        varid = 4 + n
        status = nf_put_var1_real(ncid,varid,(/np,time_index/),pdata(n,np))
      ENDDO
      ENDDO

      ! close file

      call disp_err( nf_close(ncid) , .true. )

      prec = prec + 1

      ! all done

      return
      end subroutine writepdata_nc
#endif
writeout_hdf5.F/1298670057  19071 8000  100644  180167    `
! parallel HDF5 output written by Leigh Orf <leigh.orf@cmich.edu>
!
! In namelist.input, you can choose which of the 2D and 3D variables are written.
!
! Three output options are available, set in namelist.input:
! output_format = 3 uses scale-offset lossy compression followed by gzip compression. (smallest files)
! output_format = 4 uses gzip compression (level 1) on floating point data and is lossless.
! output_format = 5 uses no compression whatsoever, just floating point (largest files)
!
! These compression options apply to 3D data. See comments in subroutine
! writefloat_hdf_unlimited for how to to add gzip compression to
! unlimited dimension arrays in parcel and stats hdf5 files. For more
! information on compression, please refer to the HDF5 user's guide.
!
!
! The modular nature of HDF5 makes it so that you do not need to worry
! about how the data was compressed when you read it - filters are
! activated automatically and your data appears as 32 bit floating point
! data regardless of the compression choice.
!
! Note that with the scaleoffset filter, you need to a scaling parameter
! which is related to absolute magnitude of your data. The values I have
! chosen work fine for me, but you may wish to tweak them. See hdf5
! docs.
!
! I have written this code to work with MPI only. If you wish to run
! with hdf5 output on a single core, you still need to compile with
! MPI and run with 1 MPI process.
!
! Each MPI rank is matched to one hdf5 file for history data. A
! directory is created which houses all of the hdf5 files at a given
! model dump time. Software has been developed to simplify dealing with
! this format where model domain is split amongst many files. Conversion
! code to create netcdf or vis5d format has also been created and is
! available. If you are interested in exploring additional compression
! options and/or conversion code contact Leigh Orf <leigh.orf@cmich.edu>
! or post to the cm1 CM1 google group.
!
! All hdf5 datasets now contain description and units attributes. New
! code has been added which writes both parcel (trajectory) data to hdf5
! format, as well as statistics data. Both are stored in a single file
! with an unlimited dimension in time, growing as the model progresses.
! This is similar to the netcdf code, which I used as a guide.
!
! Leigh Orf 1/11/11

!--------------------------------------------------------------------------------------------MARK


subroutine writeout_mult_hdf5(rtime,qname,sigma,sigmaf,xh,xf,uf,yh,yf,vf,mh,zh,mf,zf,    &
                pi0,prs0,rho0,th0,thv0,qv0,u0,v0,                        &
                zs,rain,sws,svs,sps,srs,sgs,sus,shs,thflux,qvflux,cdu,cdv,ce,dum1,dum2,dum3,dum4, &
                rho,prs,dbz,ua,dumu,va,dumv,wa,dumw,ppi,tha,        &
                qa,kmh,kmv,khh,khv,tkea,pta,num_soil_layers,   &
                lu_index,xland,mavail,tsk,tmn,tml,hml,huml,hvml,hfx,qfx,gsw,glw,tslb,   &
                radsw,rnflx,radswnet,radlwin,u10,v10,t2,q2,znt,ust,hpbl,zol,mol,br,  &
                dissten,thpten,qvpten,qcpten,qipten,upten,vpten,swten,lwten)
#ifdef HDFOUT
      use HDF5
      use orfiomod
#endif
#ifdef ORFSWATHS
      use orfswathsmod
#endif
      implicit none

      include 'input.incl'
      include 'constants.incl'
#ifdef MPI
      include 'mpif.h'
#endif



      real :: rtime
      character*3, dimension(maxq) :: qname
      real, dimension(kb:ke) :: sigma
      real, dimension(kb:ke+1) :: sigmaf
      real, dimension(ib:ie)   :: xh
      real, dimension(ib:ie+1) :: xf,uf
      real, dimension(jb:je)   :: yh
      real, dimension(jb:je+1) :: yf,vf
      real, dimension(ib:ie,jb:je,kb:ke) :: mh,zh,pi0,prs0,rho0,th0,thv0,qv0
      real, dimension(ib:ie,jb:je,kb:ke+1) :: mf,zf
      real, dimension(itb:ite,jtb:jte) :: zs
      real, dimension(ib:ie,jb:je,nrain) :: rain,sws,svs,sps,srs,sgs,sus,shs
      real, dimension(ib:ie,jb:je) :: thflux,qvflux,cdu,cdv,ce
      real, dimension(ib:ie,jb:je,kb:ke) :: dum1,dum2,dum3,dum4,rho,prs,dbz
      real, dimension(ib:ie+1,jb:je,kb:ke) :: u0,ua,dumu
      real, dimension(ib:ie,jb:je+1,kb:ke) :: v0,va,dumv
      real, dimension(ib:ie,jb:je,kb:ke+1) :: wa,dumw
      real, dimension(ib:ie,jb:je,kb:ke) :: ppi,tha
      real, dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: qa
      real, dimension(ibc:iec,jbc:jec,kbc:kec) :: kmh,kmv,khh,khv
      real, dimension(ibt:iet,jbt:jet,kbt:ket) :: tkea
      real, dimension(ibp:iep,jbp:jep,kbp:kep,npt) :: pta
      integer, intent(in) :: num_soil_layers
      integer, dimension(ibl:iel,jbl:jel), intent(in) :: lu_index
      real, dimension(ib:ie,jb:je), intent(in) :: tsk
      real, dimension(ibl:iel,jbl:jel), intent(in) :: xland,mavail,tmn,tml,hml,huml,hvml,hfx,qfx,gsw,glw
      real, dimension(ibl:iel,jbl:jel,num_soil_layers), intent(in) :: tslb
      real, dimension(ni,nj), intent(in) :: radsw,rnflx,radswnet,radlwin
      real, dimension(ibl:iel,jbl:jel), intent(in) :: u10,v10,t2,q2,znt,ust,hpbl,zol,mol,br
      real, dimension(ib:ie,jb:je,kb:ke), intent(in) :: dissten
      real, dimension(ibb:ieb,jbb:jeb,kbb:keb), intent(in) :: thpten,qvpten,qcpten,qipten,upten,vpten
      real, dimension(ibr:ier,jbr:jer,kbr:ker), intent(in) :: swten,lwten


#ifdef HDFOUT
! We don't need these, can use temp arrays that are passed to this routine
! Just use dum1(1:ni,1:nj,1:nk)
      real, dimension(ni,nj,nk) :: ds
      real, dimension(ni,nj) :: ds2
      real, dimension(1:nk) :: zhcol,u0col,v0col,th0col,pi0col,rho0col,pres0col,qv0col
      real, dimension(1:nk+1) :: zfcol
      real, dimension(1:ni) :: xfcol,xhcol !Note we will lose last point
      real, dimension(1:nj) :: yfcol,yhcol !Note we will lose last point

      integer i,j,k,n
      character(len=120)  description
      character(len=20)   units
      character(len=20)   varname
      character(len=160)  filename,filename_2d
      character(LEN=20) :: qvarname
      character(len=8) chid
      character(len=4) cid
      character(len=5) ctime

!     character(len=100) filedir
!     character(len=109) dircmd

      integer ierror
      integer(HID_T) :: file_id,file_2d_id,plist_id
      integer(HID_T) :: grid_group_id, mesh_group_id, basestate_group_id, twod_group_id, threed_group_id,threed_basestate_group_id
      integer(HID_T) :: twodfull_id,twodfull_mesh_id,twodfull_grid_id,twodfull_shear_id,twodfull_base_id;
      integer :: info
      character(LEN=4),  parameter :: grid_group_name = 'grid'
      character(LEN=4),  parameter :: mesh_group_name = 'mesh'
      character(LEN=9),  parameter :: basestate_group_name = 'basestate'
      character(LEN=12),  parameter :: threed_basestate_group_name = '3d_basestate'
      character(LEN=2),  parameter :: twod_group_name = '2d'
      character(LEN=6),  parameter :: twodfull_group_name = '2dfull'
      character(LEN=2),  parameter :: threed_group_name = '3d'
      character(LEN=5),  parameter :: shear_group_name = 'shear'
      integer sd_id, sds_id, status, dim_id, data_type
      integer ix,iy
      integer rank,tag
      integer itime,lt,flag
      integer source, dest
      integer, dimension(MPI_STATUS_SIZE) :: mpi_status

      real, dimension(ionumi) :: ioxfcol,ioxhcol,ibuf
      real, dimension(ionumj) :: ioyfcol,ioyhcol,jbuf
      ! ORF pass these to 1d write, pain in the ass
      integer(HSIZE_T), DIMENSION(1) :: dims,count
      integer(HSSIZE_T), DIMENSION(1) :: offset

! ORF for Lou's buoyancy calculation (at 1 km)
      integer ki10m,ki50m,ki1,ki2,ki3,ki4,ki5
      real, dimension(1:ni,1:nj) :: b,the,qt,thv
      real :: tx,cpm,qvs
      real :: rslf

      write(ctime,102)int(rtime)
      write(cid,103)ioid
102   format(i5.5)
103   format(i4.4)
#ifdef EATPOO
            if (len_trim(output_path) .eq. 0) then
                  if(myid.eq.0)then
                     write(outfile,*) 'empty output_path'
                     write(outfile,*) 'defaulting to current working directory'
                  endif
                  output_path='.'
            endif
            filedir = trim(output_path)//'/'//trim(output_basename)//'.'//ctime//'.cdir/'
            dircmd = 'mkdir -p '// trim(filedir)
            if (myid.eq.0) call system(dircmd)
            call MPI_BARRIER (mysubgroupcomm,ierr)
#endif
            filename = trim(filedir)//trim(output_basename)//'.'//ctime//'_'//cid//'.cm1hdf5'
            write(cid,103) 0
            filename_2d = trim(filedir)//trim(output_basename)//'.'//ctime//'_'//cid//'.2Dcm1hdf5'
            if(myid.eq.0)write(outfile,*) 'myid,filename=',ioid,'   ',trim(filename)
            if(myid.eq.0)call FFLUSH(outfile)

            call h5open_f (ierror)

            if (wr3d) then
                  CALL h5pcreate_f(H5P_FILE_ACCESS_F, plist_id, ierror)
                  info = MPI_INFO_NULL !WTF?
                  CALL h5pset_fapl_mpio_f(plist_id, mysubgroupcomm, info, ierror) !ORF iocomm != mysubgroupcomm
                  call h5fcreate_f(trim(filename),H5F_ACC_TRUNC_F,file_id,ierror,access_prp=plist_id)
                  CALL h5pclose_f(plist_id, ierror)

                  call h5gcreate_f(file_id,grid_group_name,grid_group_id,ierror)      
                  call h5gcreate_f(file_id,mesh_group_name,mesh_group_id,ierror)      
                  call h5gcreate_f(file_id,basestate_group_name,basestate_group_id,ierror)      
                  call h5gcreate_f(file_id,threed_basestate_group_name,threed_basestate_group_id,ierror)      
                  call h5gcreate_f(file_id,twod_group_name,twod_group_id,ierror)      
                  call h5gcreate_f(file_id,threed_group_name,threed_group_id,ierror)      
            endif
!Slice file
            if (wr2d) then
                  CALL h5pcreate_f(H5P_FILE_ACCESS_F, plist_id, ierror)
                  info = MPI_INFO_NULL !WTF?
                  CALL h5pset_fapl_mpio_f(plist_id, MPI_COMM_WORLD, info, ierror)
                  call h5fcreate_f(trim(filename_2d),H5F_ACC_TRUNC_F,file_2d_id,ierror,access_prp=plist_id)
                  CALL h5pclose_f(plist_id, ierror)

                  call h5gcreate_f(file_2d_id,twodfull_group_name,twodfull_id,ierror)      
                  call h5gcreate_f(file_2d_id,mesh_group_name,twodfull_mesh_id,ierror)      
                  call h5gcreate_f(file_2d_id,grid_group_name,twodfull_grid_id,ierror)      
                  call h5gcreate_f(file_2d_id,basestate_group_name,twodfull_base_id,ierror)      
                  call h5gcreate_f(file_2d_id,shear_group_name,twodfull_shear_id,ierror)      
            endif

! 3d and 2d writes are hopelessly intertwined; however this saves a bit
! on redundancy (and lines of code) and you have the option of writing
! one or the other (or both at the same time - but I think performance
! will suffer if you do that)

            if (wr3d) then
                  varname='time'
                  description='model time'
                  units='seconds'
                  call h5_write_float(file_id,varname,description,units,rtime,.false.)

                  varname='dx'
                  description='grid spacing in the x direction. If E/W grid stretching, this should be somehwat representative'
                  units='meters'
                  if(wr3d)call h5_write_float(mesh_group_id,varname,description,units,dx,.false.)

                  varname='dy'
                  description='grid spacing in the y direction. If N/S grid stretching, this should be somehwat representative'
                  units='meters'
                  call h5_write_float(mesh_group_id,varname,description,units,dy,.false.)

                  varname='nx'
                  description='number of gridpoints spanning the east/west direction of full the model domain'
                  units='index'
                  call h5_write_int  (grid_group_id,varname,description,units,nx,.false.)

                  varname='ny'
                  description='number of gridpoints spanning the north/south direction of full the model domain'
                  units='index'
                  call h5_write_int  (grid_group_id,varname,description,units,ny,.false.)

                  varname='nz'
                  description='number of gridpoints spanning the vertical extent of the full the model domain'
                  units='index'
                  call h5_write_int  (grid_group_id,varname,description,units,nz,.false.)

                  varname='x0'
                  description='index of westmost point of 3d field in this hdf5 file with respect to full model domain'
                  units='index'
                  call h5_write_int  (grid_group_id,varname,description,units,iox0,.false.)

                  varname='x1'
                  description='index of eastmost point of 3d field in this hdf5 file with respect to full model domain'
                  units='index'
                  call h5_write_int  (grid_group_id,varname,description,units,iox1,.false.)

                  varname='y0'
                  description='index of southmost point of 3d field in this hdf5 file with respect to full model domain'
                  units='index'
                  call h5_write_int  (grid_group_id,varname,description,units,ioy0,.false.)

                  varname='y1'
                  description='index of northmost point of 3d field in this hdf5 file with respect to full model domain'
                  units='index'
                  call h5_write_int  (grid_group_id,varname,description,units,ioy1,.false.)

                  varname='myi'
                  description='east/west index of hdf5 file in 2d decomposition. (1 < myi <= nodex)'
                  units='index'
                  call h5_write_int  (grid_group_id,varname,description,units,iomyi,.false.)

                  varname='myj'
                  description='north/south index of hdf5 file in 2d decomposition. (1 < myj <= nodej)'
                  units='index'
                  call h5_write_int  (grid_group_id,varname,description,units,iomyj,.false.)

                  varname='ni'
                  description='number of gridpoints in east/west direction in this hdf5 file for 2d and 3d data'
                  units='index'
                  call h5_write_int  (grid_group_id,varname,description,units,ionumi,.false.)

                  varname='nj'
                  description='number of gridpoints in north/south direction in this hdf5 file for 2d and 3d data'
                  units='index'
                  call h5_write_int  (grid_group_id,varname,description,units,ionumj,.false.)

                  varname='nodex'
                  description='number of hdf5 files spanning the full east/west extent of the model domain'
                  units='index'
                  call h5_write_int  (grid_group_id,varname,description,units,ionodex,.false.)

                  varname='nodey'
                  description='number of hdf5 files spanning the full north/south extent of the model domain'
                  units='index'
                  call h5_write_int  (grid_group_id,varname,description,units,ionodey,.false.)

            endif !if wr3d

            do k=1,nk
                zhcol(k)=zh(1,1,k)
                u0col(k) = u0(1,1,k)
                v0col(k) = v0(1,1,k)
                th0col(k) = th0(1,1,k)
                pi0col(k) = pi0(1,1,k)
                rho0col(k) = rho0(1,1,k)
                pres0col(k) = p00*(pi0(1,1,k))**cpdrd
                qv0col(k) = qv0(1,1,k)
            enddo

            do k=1,nk+1
                zfcol(k)=zf(1,1,k)
            enddo

! ORF 2/1/11
! The following are specifically written to 2D slice/swath files for shear study
! Look for ORFSWATHS below for additional 2D variables

! -----------------------------begin only 2D file stuff----------------------------------------

              i=1
              j=1
              k=1
            do while( zf(i,j,k).lt.10.0 )
              k = k + 1
            enddo
            ki10m=k
            k=1
            do while( zf(i,j,k).lt.50.0 )
              k = k + 1
            enddo
            ki50m=k
            k=1
            do while( zf(i,j,k).lt.1000.0 )
              k = k + 1
            enddo
            ki1=k
            k=1
            do while( zf(i,j,k).lt.2000.0 )
              k = k + 1
            enddo
            ki2=k
            k=1
            do while( zf(i,j,k).lt.3000.0 )
              k = k + 1
            enddo
            ki3=k
            k=1
            do while( zf(i,j,k).lt.4000.0 )
              k = k + 1
            enddo
            ki4=k
            k=1
            do while( zf(i,j,k).lt.5000.0 )
              k = k + 1
            enddo
            ki5=k

      if (wr2d) then

            varname='time'
            description='model time'
            units='seconds'
            call h5_write_float(file_2d_id,varname,description,units,rtime,.true.)

            varname='dx'
            description='grid spacing in the x direction. If E/W grid stretching, this should be somehwat representative'
            units='meters'
            call h5_write_float(twodfull_mesh_id,varname,description,units,dx,.true.)

            varname='dy'
            description='grid spacing in the y direction. If N/S grid stretching, this should be somehwat representative'
            units='meters'
            call h5_write_float(twodfull_mesh_id,varname,description,units,dy,.true.)

            varname='nx'
            description='number of gridpoints spanning the east/west direction of full the model domain'
            units='index'
            call h5_write_int  (twodfull_grid_id,varname,description,units,nx,.true.)

            varname='ny'
            description='number of gridpoints spanning the north/south direction of full the model domain'
            units='index'
            call h5_write_int  (twodfull_grid_id,varname,description,units,ny,.true.)

            varname='nz'
            description='number of gridpoints spanning the vertical extent of the full the model domain'
            units='index'
            call h5_write_int  (twodfull_grid_id,varname,description,units,nz,.true.)

            varname='sl1'
            description='shear in layer 1'
            units='s^{-1}'
            call h5_write_float(twodfull_shear_id,varname,description,units,var1,.true.)

            varname='sl2'
            description='shear in layer 2'
            units='s^{-1}'
            call h5_write_float(twodfull_shear_id,varname,description,units,var2,.true.)

            varname='dl1'
            description='depth of layar 1'
            units='m'
            call h5_write_float(twodfull_shear_id,varname,description,units,var3,.true.)

            varname='dl2'
            description='depth of layar 2'
            units='m'
            call h5_write_float(twodfull_shear_id,varname,description,units,var4,.true.)

            varname='angle'
            description='angle of hodograph L'
            units='degrees'
            call h5_write_float(twodfull_shear_id,varname,description,units,var5,.true.)

            varname='u0'
            description='U (E/W wind) base state, (i.e., from sounding)'
            units='m/s'
            dims(1)=nz;count(1)=nz;offset(1)=0
            call h5_write_1d_float(twodfull_base_id,varname,description,units,u0col,nz,dims,count,offset,rootonlyrank)

            varname='v0'
            description='V (N/S wind) base state, (i.e., from sounding)'
            units='m/s'
            dims(1)=nz;count(1)=nz;offset(1)=0
            call h5_write_1d_float(twodfull_base_id,varname,description,units,v0col,nz,dims,count,offset,rootonlyrank)

            varname='pi0'
            description='Exner base state, (i.e., from sounding)'
            units='dimensionless'
            dims(1)=nz;count(1)=nz;offset(1)=0
            call h5_write_1d_float(twodfull_base_id,varname,description,units,pi0col,nz,dims,count,offset,rootonlyrank)

            varname='pres0'
            description='Pressure base state, (i.e., from sounding)'
            units='dimensionless'
            dims(1)=nz;count(1)=nz;offset(1)=0
            call h5_write_1d_float(twodfull_base_id,varname,description,units,pres0col,nz,dims,count,offset,rootonlyrank)

            varname='th0'
            description='potential temperature base state, (i.e., from sounding)'
            units='K'
            dims(1)=nz;count(1)=nz;offset(1)=0
            call h5_write_1d_float(twodfull_base_id,varname,description,units,th0col,nz,dims,count,offset,rootonlyrank)

            varname='rh0'
            description='density base state, (i.e., from sounding)'
            units='kg/m^3'
            dims(1)=nz;count(1)=nz;offset(1)=0
            call h5_write_1d_float(twodfull_base_id,varname,description,units,rho0col,nz,dims,count,offset,rootonlyrank)

            varname='qv0'
            description='mixing ratio base state, (i.e., from sounding)'
            units='kg/kg'
            dims(1)=nz;count(1)=nz;offset(1)=0
            call h5_write_1d_float(twodfull_base_id,varname,description,units,qv0col,nz,dims,count,offset,rootonlyrank)

            varname='zh'
            description='height AGL of scalars'
            units='m'
            dims(1)=nz;count(1)=nz;offset(1)=0
            call h5_write_1d_float(twodfull_mesh_id,varname,description,units,zhcol,nz,dims,count,offset,rootonlyrank)

            varname='zf'
            description='height AGL of w (on staggered C grid)'
            units='m'
            dims(1)=nz+1;count(1)=nz+1;offset(1)=0
            call h5_write_1d_float(twodfull_mesh_id,varname,description,units,zfcol,nz+1,dims,count,offset,rootonlyrank)

            varname='yh'
            description='N/S location of scalar points (model uses Arakawa C grid)'
            units='meters'
            dims(1)=ny; count(1)=nj; offset(1)=myfulloffsetj
            call h5_write_1d_float(twodfull_mesh_id,varname,description,units,yh(1:nj),nj,dims,count,offset,y1drank)

            varname='yf'
            description='N/S location of V points (model uses Arakawa C grid)'
            units='meters'
!Last y point will be missing in 3d file
!but not in 2d file. We Gather to root and tack on last point
!2D file full mesh
            dims(1)=ny+1; count(1)=ny+1; offset(1)=0
            call h5_write_1d_float_uv(twodfull_mesh_id,varname,description,units,yf(1:nj),nj,dims,count,offset,y1dcomm,y1drank,(nodex)*(nodey-1))

            varname='xh'
            description='E/W location of scalar points (model uses Arakawa C grid)'
            units='meters'
            dims(1)=nx; count(1)=ni; offset(1)=myfulloffseti
            call h5_write_1d_float(twodfull_mesh_id,varname,description,units,xh(1:ni),ni,dims,count,offset,x1drank)

            varname='xf'
            description='E/W location of U points (model uses Arakawa C grid)'
            units='meters'
!Last x point will be missing in 3d file
!but not in 2d file. We Gather to root and tack on last point
!2D file full mesh
            dims(1)=nx+1; count(1)=nx+1; offset(1)=0
            call h5_write_1d_float_uv(twodfull_mesh_id,varname,description,units,xf(1:ni),ni,dims,count,offset,x1dcomm,x1drank,nodex-1)
      endif !if wr2d

! -----------------------------end only 2D file stuff----------------------------------------

! NOTE xf and yf for 2D slices below, need different routine


      if(wr3d) then
            varname='u0'
            description='U (E/W wind) base state, (i.e., from sounding)'
            units='m/s'
            dims(1)=nz;count(1)=nz;offset(1)=0

! ORF 2/22/11 FIX NUKE
! I'm pretty sure all ranks should NOT be writing these nz arrays (which are
! identical for all ranks) and
! 'mysubgrouprank' should be '0' - mask out everything else

! AH! Just use mcmrootrank insteady of mysubgrouprank!!!!
! We need rootonly rank but on EACH MCM

            call h5_write_1d_float(basestate_group_id,varname,description,units,u0col,nz,dims,count,offset,mcmrootrank)

            varname='v0'
            description='V (N/S wind) base state, (i.e., from sounding)'
            units='m/s'
            dims(1)=nz;count(1)=nz;offset(1)=0
            call h5_write_1d_float(basestate_group_id,varname,description,units,v0col,nz,dims,count,offset,mcmrootrank)

            varname='th0'
            description='Potential temperature base state, (i.e., from sounding)'
            units='K'
            dims(1)=nz;count(1)=nz;offset(1)=0
            call h5_write_1d_float(basestate_group_id,varname,description,units,th0col,nz,dims,count,offset,mcmrootrank)

            varname='pi0'
            description='Dimensionless pressure (Exner function) base state, (i.e., from sounding)'
            units='dimensionless'
            dims(1)=nz;count(1)=nz;offset(1)=0
            call h5_write_1d_float(basestate_group_id,varname,description,units,pi0col,nz,dims,count,offset,mcmrootrank)

            varname='pres0'
            description='Pressure base state, (i.e., from sounding)'
            units='Pa'
            dims(1)=nz;count(1)=nz;offset(1)=0
            call h5_write_1d_float(basestate_group_id,varname,description,units,pres0col,nz,dims,count,offset,mcmrootrank)

            varname='rh0'
            description='Density base state, (i.e., from sounding)'
            units='kg/m^3'
            dims(1)=nz;count(1)=nz;offset(1)=0
            call h5_write_1d_float(basestate_group_id,varname,description,units,rho0col,nz,dims,count,offset,mcmrootrank)

            varname='qv0'
            description='Water vapor base state, (i.e., from sounding)'
            units='kg/kg'
            dims(1)=nz;count(1)=nz;offset(1)=0
            call h5_write_1d_float(basestate_group_id,varname,description,units,qv0col,nz,dims,count,offset,mcmrootrank)

            varname='zh'
            description='Height above ground of scalar points (model uses Arakawa C grid)'
            units='meters'
            dims(1)=nz;count(1)=nz;offset(1)=0
            call h5_write_1d_float(mesh_group_id,varname,description,units,zhcol,nz,dims,count,offset,mcmrootrank)

            varname='zf'
            description='Height above ground of W points (model uses Arakawa C grid)'
            units='meters'
            dims(1)=nz+1;count(1)=nz+1;offset(1)=0
            call h5_write_1d_float(mesh_group_id,varname,description,units,zfcol,nz+1,dims,count,offset,mcmrootrank)

            varname='yh'
            description='N/S location of scalar points (model uses Arakawa C grid)'
            units='meters'
            dims(1)=ionumj; count(1)=nj; offset(1)=mygroupoffsetj
            call h5_write_1d_float(mesh_group_id,varname,description,units,yh(1:nj),nj,dims,count,offset,mylygrouprank)

            varname='yf'
            description='N/S location of V points (model uses Arakawa C grid)'
            units='meters'
            dims(1)=ionumj; count(1)=nj; offset(1)=mygroupoffsetj
!Last y point will be missing in 3d file
            call h5_write_1d_float(mesh_group_id,varname,description,units,yf(1:nj),nj,dims,count,offset,mylygrouprank)
!but not in 2d file. We Gather to root and tack on last point
!2D file full mesh

            varname='xh'
            description='E/W location of scalar points (model uses Arakawa C grid)'
            units='meters'
            dims(1)=ionumi; count(1)=ni; offset(1)=mygroupoffseti
            call h5_write_1d_float(mesh_group_id,varname,description,units,xh(1:ni),ni,dims,count,offset,mybxgrouprank)
!2D file full mesh

            varname='xf'
            description='E/W location of U points (model uses Arakawa C grid)'
            units='meters'
            dims(1)=ionumi; count(1)=ni; offset(1)=mygroupoffseti
!Last x point will be missing in 3d file
            call h5_write_1d_float(mesh_group_id,varname,description,units,xf(1:ni),ni,dims,count,offset,mybxgrouprank)
!but not in 2d file. We Gather to root and tack on last point
!2D file full mesh

      ! terrain

           if (output_zs.eq.1.and.terrain_flag) then
             do j=1,nj
             do i=1,ni
               ds2(i,j)=zs(i,j)
             enddo
             enddo

             varname='zs'
             description='terrain height'
             units='meters'
             call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)

           endif

           if (output_zh.eq.1.and.terrain_flag) then
             do k=1,nk
             do j=1,nj
             do i=1,ni
               ds(i,j,k)=zh(i,j,k)
             enddo
             enddo
             enddo

             varname='zh'
             description='height (above ground) of scalar grid points'
             units='meters'
             call h5_write_3d_float(threed_group_id,varname,description,units,ds,corexyztype,0,0,0)

           endif
                  
      ! ORF 1/11/11 Following netcdf example, allow option for output of 3D
      ! base state. 1D basestate variables in /basestate group are always
      ! written but are not useful for folks running with terrain who require
      ! the 3D basestate.

           if (output_basestate.eq.1) then

                do k=1,nk
                do j=1,nj
                do i=1,ni
                  ds(i,j,k)=pi0(i,j,k)
                enddo
                enddo
                enddo

                varname='pi0'
                description = '3D base state nondimensional pressure (Exner function)'
                units = 'dimensionless'
                call h5_write_3d_float(threed_basestate_group_id,varname,description,units,ds,corexyztype,0,0,0)

                do k=1,nk
                do j=1,nj
                do i=1,ni
                  ds(i,j,k)=th0(i,j,k)
                enddo
                enddo
                enddo

                varname='th0'
                description = '3D base state potential temperature'
                units = 'K'
                call h5_write_3d_float(threed_basestate_group_id,varname,description,units,ds,corexyztype,0,0,0)

                do k=1,nk
                do j=1,nj
                do i=1,ni
                  ds(i,j,k)=prs0(i,j,k)
                enddo
                enddo
                enddo

                varname='p0'
                description = '3D base state pressure'
                units = 'Pa'
                call h5_write_3d_float(threed_basestate_group_id,varname,description,units,ds,corexyztype,0,0,0)

                do k=1,nk
                do j=1,nj
                do i=1,ni
                  ds(i,j,k)=qv0(i,j,k)
                enddo
                enddo
                enddo

                varname='qv0'
                description = '3D base state water vapor mixing ratio'
                units = 'kg/kg'
                call h5_write_3d_float(threed_basestate_group_id,varname,description,units,ds,corexyztype,0,0,0)

                do k=1,nk
                do j=1,nj
                do i=1,ni+1
                  dumu(i,j,k)=u0(i,j,k)
                enddo
                enddo
                enddo

                varname='u0'
                description = '3D base state x component of velocity on native Arakawa C grid'
                units = 'm/s'
                call h5_write_3d_float(threed_basestate_group_id,varname,description,units,dumu(1:ni+1,1:nj,1:nk),corexyztype,1,0,0)

                do k=1,nk
                do j=1,nj+1
                do i=1,ni
                  dumv(i,j,k)=v0(i,j,k)
                enddo
                enddo
                enddo

                varname='v0'
                description = '3D base state y component of velocity on native Arakawa C grid'
                units = 'm/s'
                call h5_write_3d_float(threed_basestate_group_id,varname,description,units,dumv(1:ni,1:nj+1,1:nk),corexyztype,0,1,0)

            endif !output_basestate.eq.1
       endif !if wr3d

       if(output_rain.eq.1) then
           do j=1,nj
           do i=1,ni
             ds2(i,j)=rain(i,j,1)
           enddo
           enddo
           varname='sfcrain'
           description='accumulated surface rainfall'
           units='cm'
           if(wr3d)call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)
           if(wr2d)call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)
           if (nrain.eq.2) then
               do j=1,nj
               do i=1,ni
                 ds2(i,j)=rain(i,j,2)
               enddo
               enddo
               varname='sfcrain_trans'
               description='accumulated surface rainfall, translated with moving domain'
               units='cm'
               if(wr3d)call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)
               if(wr2d)call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)
           endif
       endif

      if(output_sws.eq.1) then
           do j=1,nj
           do i=1,ni
             ds2(i,j)=sws(i,j,1)
           enddo
           enddo
           varname='maxsws'
           description='maximum windspeed at lowest level'
           units='m/s'
           if(wr3d)call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)
           if(wr2d)call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)

           do j=1,nj
           do i=1,ni
             ds2(i,j)=svs(i,j,1)
           enddo
           enddo
           varname='maxsvs'
           description='maximum vertical vorticity at lowest level'
           units='s^{-1}'
           if(wr3d)call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)
           if(wr2d)call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)

           do j=1,nj
           do i=1,ni
             ds2(i,j)=sps(i,j,1)
           enddo
           enddo
           varname='minsps'
           description='minimum pressure at lowest level'
           units='Pa'
           if(wr3d)call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)
           if(wr2d)call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)

           do j=1,nj
           do i=1,ni
             ds2(i,j)=srs(i,j,1)
           enddo
           enddo
           varname='maxsrs'
           description='maximum surface rainwater mixing ratio'
           units='kg/kg'
           if(wr3d)call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)
           if(wr2d)call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)

           do j=1,nj
           do i=1,ni
             ds2(i,j)=sgs(i,j,1)
           enddo
           enddo
           varname='maxsgs'
           description='maximum surface graupel/hail mixing ratio'
           units='kg/kg'
           if(wr3d)call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)
           if(wr2d)call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)

           do j=1,nj
           do i=1,ni
             ds2(i,j)=sus(i,j,1)
           enddo
           enddo
           varname='maxsus'
           description='maximum updraft velocity'
           units='m/s'
           if(wr3d)call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)
           if(wr2d)call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)

           do j=1,nj
           do i=1,ni
             ds2(i,j)=sus(i,j,1)
           enddo
           enddo
           varname='maxshs'
           description='maximum integrated updraft helicity'
           units='m^2/s^2'
           if(wr3d)call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)
           if(wr2d)call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)


!ORF Here is where we write all the orfswaths stuff that I added
#ifdef ORFSWATHS

           if(wr2d) then
                do j=1,nj
                do i=1,ni
                  ds2(i,j)=orfswaths(i,j,1,1)
                enddo
                enddo

                varname='minthpert'
                description='minimum surface potential temperature perturbation'
                units='K'

                call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)

                do j=1,nj
                do i=1,ni
                  ds2(i,j)=orfswaths(i,j,1,2)
                enddo
                enddo

                varname='wmax1km'
                description='Maximum updraft at 1 km'
                units='m/s'

                call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)

                do j=1,nj
                do i=1,ni
                  ds2(i,j)=orfswaths(i,j,1,3)
                enddo
                enddo

                varname='wmin1km'
                description='Maximum downdraft at 1 km'
                units='m/s'

                call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)

                do j=1,nj
                do i=1,ni
                  ds2(i,j)=orfswaths(i,j,1,4)
                enddo
                enddo

                varname='zetamax1km'
                description='Maximum vertical vorticity (zeta) at 1 km'
                units='s^{-1}'

                call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)
            endif !if wr2d
#endif
      endif !output_sws.eq.1


      if (nrain.eq.2) then
         if(output_rain.eq.1) then
              do j=1,nj
              do i=1,ni
                ds2(i,j)=rain(i,j,2)
              enddo
              enddo
              varname='maxrain_trans'
              description='accumulated surface rainfall, translated with moving domain'
              units='cm'
              if(wr3d)call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)
              if(wr2d)call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)
          endif

          if(output_sws.eq.1) then
              do j=1,nj
              do i=1,ni
                ds2(i,j)=sws(i,j,2)
              enddo
              enddo
              varname='maxsws_trans'
              description='maximum windspeed at lowest level, translated with moving domain'
              units='m/s'
              if(wr3d)call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)
              if(wr2d)call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)

              do j=1,nj
              do i=1,ni
                ds2(i,j)=svs(i,j,2)
              enddo
              enddo
              varname='maxsvs_trans'
              description='maximum vertical vorticity at lowest level, translated with moving domain'
              units='s^{-1}'
              if(wr3d)call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)
              if(wr2d)call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)

              do j=1,nj
              do i=1,ni
                ds2(i,j)=sps(i,j,2)
              enddo
              enddo
              varname='maxsps_trans'
              description='minimum pressure at lowest level, translated with moving domain'
              units='Pa'
              if(wr3d)call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)
              if(wr2d)call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)

              do j=1,nj
              do i=1,ni
                ds2(i,j)=srs(i,j,2)
              enddo
              enddo
              varname='maxsrs_trans'
              description='maximum surface rainwater mixing ratio, translated with moving domain'
              units='kg/kg'
              if(wr3d)call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)
              if(wr2d)call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)

              do j=1,nj
              do i=1,ni
                ds2(i,j)=sgs(i,j,2)
              enddo
              enddo
              varname='maxsgs_trans'
              description='maximum surface graupel/hail mixing ratio, translated with moving domain'
              units='kg/kg'
              if(wr3d)call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)
              if(wr2d)call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)

              do j=1,nj
              do i=1,ni
                ds2(i,j)=sus(i,j,2)
              enddo
              enddo
              varname='maxsus_trans'
              description='maximum updraft velocity, translated with moving domain'
              units='m/s'
              if(wr3d)call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)
              if(wr2d)call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)

              do j=1,nj
              do i=1,ni
                ds2(i,j)=sus(i,j,2)
              enddo
              enddo
              varname='maxshs_trans'
              description='maximum integrated updraft helicity, translated with moving domain'
              units='m^2/s^2'
              if(wr3d)call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)
              if(wr2d)call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)

!ORF Here is where we write all the orfswaths stuff that I added
#ifdef ORFSWATHS

              if(wr2d) then
                   do j=1,nj
                   do i=1,ni
                     ds2(i,j)=orfswaths(i,j,2,1)
                   enddo
                   enddo
  
                   varname='minthpert_trans'
                   description='minimum surface potential temperature perturbation (translated)'
                   units='K'
  
                   call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)
  
                   do j=1,nj
                   do i=1,ni
                     ds2(i,j)=orfswaths(i,j,2,2)
                   enddo
                   enddo
  
                   varname='wmax1km_trans'
                   description='Maximum updraft at 1 km (translated)'
                   units='m/s'
  
                   call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)
  
                   do j=1,nj
                   do i=1,ni
                     ds2(i,j)=orfswaths(i,j,2,3)
                   enddo
                   enddo
  
                   varname='wmin1km_trans'
                   description='Maximum downdraft at 1 km (translated)'
                   units='m/s'
  
                   call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)
  
                   do j=1,nj
                   do i=1,ni
                     ds2(i,j)=orfswaths(i,j,2,4)
                   enddo
                   enddo
  
                   varname='zetamax1km_trans'
                   description='Maximum vertical vorticity (zeta) at 1 km (translated)'
                   units='s^{-1}'
  
                   call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)
              endif !if wr2d
#endif
           endif !output_sws.eq.1
      endif !nrain.eq.2

! Composite reflectivity

      if(output_dbz.eq.1.and.imoist.eq.1)then
          call calccref(dum1(ib,jb,1),dbz)
          do j=1,nj
          do i=1,ni
            ds2(i,j)=dum1(i,j,1)
          enddo
          enddo
          varname='cref'
          description='composite reflectivity'
          units='dbZ'
          if(wr3d)call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)
          if(wr2d)call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)
          varname="dbzsfc"
          description = 'surface reflectivity'
          units = 'dBZ'
          do j=1,nj
          do i=1,ni
            ds2(i,j)=dbz(i,j,1)
          enddo
          enddo
          if(wr2d)call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)

          varname="dbz1km"
          description = '1km reflectivity'
          units = 'dBZ'
          do j=1,nj
          do i=1,ni
            ds2(i,j)=dbz(i,j,ki1)
          enddo
          enddo
          if(wr2d)call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)
      endif

! Lou wants average buoyuancy below 1 km and temperature and sfc temp.

! Also theta-e at 1 km

!---------------- begin buoyancy calculation code stolen from parcel.F ------------------------!

        if(wr2d) then

              varname='ki1'
              description='1 km index'
              units='index'
              call h5_write_int(twodfull_shear_id,varname,description,units,ki1,.true.)

              b = 0.0

               IF(imoist.eq.1)THEN
           
             do k=1,ki1 
                 do j=1,nj
                 do i=1,ni
                   qt(i,j)=0.0
                 enddo
                 enddo
           
                 do j=1,nj
                 do i=1,ni
                   qt(i,j)=qt(i,j)+qa(i,j,k,nqv)
                 enddo
                 enddo
           
                 do n=nql1,nql2
                   do j=1,nj
                   do i=1,ni
                     qt(i,j)=qt(i,j)+qa(i,j,k,n)
                   enddo
                   enddo
                 enddo
           
                 do n=nqs1,nqs2
                   do j=1,nj
                   do i=1,ni
                     qt(i,j)=qt(i,j)+qa(i,j,k,n)
                   enddo
                   enddo
                 enddo
           
           
                 do j=1,nj
                 do i=1,ni
                   tx=(th0(i,j,k)+tha(i,j,k))*(pi0(i,j,k)+ppi(i,j,k))
                   cpm=cp+cpl*qa(i,j,k,nqv)
                   do n=nql1,nql2
                     cpm=cpm+cpl*qa(i,j,k,n)
                   enddo
                   qvs=rslf( prs(i,j,k) , tx )
                   the(i,j)=tx*((p00*(1.0+qa(i,j,k,nqv)*reps)      &
                                   /prs(i,j,k))**(rd/cpm))       &
                      *((qa(i,j,k,nqv)/qvs)**(-qa(i,j,k,nqv)*rv/cpm))    &
                      *exp((lv1-lv2*tx)*qa(i,j,k,nqv)/(cpm*tx))
                   thv(i,j)=(th0(i,j,k)+tha(i,j,k))*(1.0+reps*qa(i,j,k,nqv))/(1.0+qt(i,j))
                   b(i,j)=b(i,j)+g*( thv(i,j)/thv0(i,j,k) - 1.0 )
                 enddo
                 enddo

                 if (k.eq.1)then
                       varname='thetae_sfc'
                       description='Theta-e at surface'
                       units='K'
                       call h5_write_2d_float(twodfull_id,varname,description,units,the,corexytype,0,0,.true.)
                 endif
               enddo

                 b = b/float(ki1)

                 varname='buoy1km'
                 description='Average buoyancy below 1 km'
                 units='m/s^2'

                 call h5_write_2d_float(twodfull_id,varname,description,units,b,corexytype,0,0,.true.)

                 varname='thetae1km'
                 description='Theta-e at 1 km'
                 units='K'

                 call h5_write_2d_float(twodfull_id,varname,description,units,the,corexytype,0,0,.true.)

           endif !imoist.eq.1


      !----------------   end buoyancy calculation code stolen from parcel.F ------------------------!

      ! Temperature, in deg F:

                 do j=1,nj
                 do i=1,ni
                   ds2(i,j)=(((th0(i,j,1)+tha(i,j,1))*(pi0(i,j,1)+ppi(i,j,1)))-273.15)*(9./5.) + 32.0
                 enddo
                 enddo

                 varname='sfctempf'
                 description='Surface temperature in F'
                 units='degrees F'

                 call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)

      ! u, v at sfc, 1km

                 do j=1,nj
                 do i=1,ni
                   ds2(i,j)=0.5*(ua(i,j,1)+ua(i+1,j,1))
                 enddo
                 enddo

                 varname='uinterpsfc'
                 description='surface u wind (interpolated to scalar grid)'
                 units='m/s'
                 call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)

                 do j=1,nj
                 do i=1,ni
                   ds2(i,j)=0.5*(va(i,j,1)+va(i,j+1,1))
                 enddo
                 enddo

                 varname='vinterpsfc'
                 description='surface v wind (interpolated to scalar grid)'
                 units='m/s'
                 call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)

                 do j=1,nj
                 do i=1,ni
                   ds2(i,j)=0.5*(ua(i,j,ki1)+ua(i+1,j,ki1))
                 enddo
                 enddo

                 varname='uinterp1km'
                 description='1km u wind (interpolated to scalar grid)'
                 units='m/s'
                 call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)

                 do j=1,nj
                 do i=1,ni
                   ds2(i,j)=0.5*(va(i,j,ki1)+va(i,j+1,ki1))
                 enddo
                 enddo

                 varname='vinterp1km'
                 description='1km v wind (interpolated to scalar grid)'
                 units='m/s'
                 call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)

                 do j=1,nj
                 do i=1,ni
                   ds2(i,j)=tha(i,j,1)
                 enddo
                 enddo
                 varname='thpertsfc'
                 description = 'surface perturbation potential temperature'
                 units = 'K'
                 call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)

                 do j=1,nj
                 do i=1,ni
                   ds2(i,j)=wa(i,j,ki1)
                 enddo
                 enddo
                 varname='w1km'
                 description = 'w at 1 km'
                 units = 'm/s'
                 call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)

                 do j=1,nj
                 do i=1,ni
                   ds2(i,j)=wa(i,j,ki2)
                 enddo
                 enddo
                 varname='w2km'
                 description = 'w at 2 km'
                 units = 'm/s'
                 call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)

                 do j=1,nj
                 do i=1,ni
                   ds2(i,j)=wa(i,j,ki3)
                 enddo
                 enddo
                 varname='w3km'
                 description = 'w at 3 km'
                 units = 'm/s'
                 call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)

                 do j=1,nj
                 do i=1,ni
                   ds2(i,j)=wa(i,j,ki4)
                 enddo
                 enddo
                 varname='w4km'
                 description = 'w at 4 km'
                 units = 'm/s'
                 call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)

                 do j=1,nj
                 do i=1,ni
                   ds2(i,j)=wa(i,j,ki5)
                 enddo
                 enddo
                 varname='w5km'
                 description = 'w at 5 km'
                 units = 'm/s'
                 call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)
           endif !if wr2d


! Cold pool C and H (RKW)

      if(output_coldpool.eq.1) then
          call calccpch(zf,th0,qv0,dum1(ib,jb,1),dum1(ib,jb,2),tha,qa)
          do j=1,nj
          do i=1,ni
            ds2(i,j)=dum1(i,j,1)
          enddo
          enddo
          varname='cpc'
          description='cold pool intensity C'
          units='m/s'
          if(wr3d)call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)
          if(wr2d)call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=dum1(i,j,2)
          enddo
          enddo
          varname='cph'
          description='cold pool depth h'
          units='meters'
          if(wr3d)call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)
          if(wr2d)call h5_write_2d_float(twodfull_id,varname,description,units,ds2,corexytype,0,0,.true.)
      endif !output_coldpool.eq.1


! Surface fluxes
! I think only 3d from here on out ORF

      if(wr3d)then
      if(output_sfcflx.eq.1) then
          do j=1,nj
          do i=1,ni
            ds2(i,j)=thflux(i,j)
          enddo
          enddo
          varname='thflux'
          description='surface potential temperature flux'
          units='K m s^{-1}'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)
        
          do j=1,nj
          do i=1,ni
            ds2(i,j)=qvflux(i,j)
          enddo
          enddo

          varname='qvflux'
          description='surface water vapor flux'
          units='kg/kg m s^{-1}'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)

          do j=1,nj
            do i=1,ni
             ds2(i,j)=0.25*( (cdu(i,j)+cdu(i+1,j))   &
                           +(cdv(i,j)+cdv(i,j+1)) )
            enddo
          enddo

          varname='cd'
          description='cd' !ORF WTF IS THIS?
          units='nondimensional'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=ce(i,j)
          enddo
          enddo

          varname='ce'
          description='ce' !ORF WTF IS THIS?
          units='nondimensional'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=tsk(i,j)
          enddo
          enddo

          varname='tsk'
          description='soil/ocean temperature'
          units='K'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)

      endif !output_sfcflx.eq.1

      if(output_sfcparams.eq.1) then

          do j=1,nj
          do i=1,ni
            ds2(i,j)=xland(i,j)
          enddo
          enddo

          varname='xland'
          description='land/water flag (1=land, 2=water)'
          units='integer flag'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=lu_index(i,j)
          enddo
          enddo

          varname='lu'
          description='land usage index'
          units='integer flag'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=mavail(i,j)
          enddo
          enddo

          varname='mavail'
          description='surface moisture availability'
          units='integer flag'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)

      endif !output_sfcparams.eq.1

      if((output_sfcparams.eq.1).and.(sfcmodel.eq.2.or.oceanmodel.eq.2))then

          do j=1,nj
          do i=1,ni
            ds2(i,j)=tmn(i,j)
          enddo
          enddo
          varname='tmn'
          description='deep-layer soil temperature'
          units='K'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=hfx(i,j)
          enddo
          enddo
          varname='hfx'
          description='heat flux at surface'
          units='W/m^2'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=qfx(i,j)
          enddo
          enddo
          varname='qfx'
          description='surface moisture flux'
          units='W/m^2'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=gsw(i,j)
          enddo
          enddo
          varname='gsw'
          description='downward SW flux at surface'
          units='W/m^2'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=glw(i,j)
          enddo
          enddo
          varname='glw'
          description='downward LW flux at surface'
          units='W/m^2'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)
      endif

      if((output_sfcparams.eq.1).and.(sfcmodel.eq.2))then

          do j=1,nj
          do i=1,ni
            ds2(i,j)=tslb(i,j,1)
          enddo
          enddo
          varname='tslb1'
          description='soil temp, layer 1'
          units='K'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=tslb(i,j,2)
          enddo
          enddo
          varname='tslb2'
          description='soil temp, layer 2'
          units='K'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=tslb(i,j,3)
          enddo
          enddo
          varname='tslb3'
          description='soil temp, layer 3'
          units='K'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=tslb(i,j,4)
          enddo
          enddo
          varname='tslb4'
          description='soil temp, layer 4'
          units='K'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=tslb(i,j,5)
          enddo
          enddo
          varname='tslb5'
          description='soil temp, layer 5'
          units='K'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)
      endif

      if(output_sfcparams.eq.1.and.oceanmodel.eq.2)then

          do j=1,nj
          do i=1,ni
            ds2(i,j)=tml(i,j)
          enddo
          enddo
          varname='tml'
          description='ocean mixed layer temperature'
          units='K'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=hml(i,j)
          enddo
          enddo
          varname='hml'
          description='ocean mixed layer depth'
          units='meters'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=huml(i,j)
          enddo
          enddo
          varname='huml'
          description='ocean mixed layer u velocity'
          units='m/s'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=hvml(i,j)
          enddo
          enddo
          varname='hvml'
          description='ocean mixed layer v velocity'
          units='m/s'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)
      endif

      if(output_radten.eq.1)then

          do j=1,nj
          do i=1,ni
            ds2(i,j)=radsw(i,j)
          enddo
          enddo
          varname='radsw'
          description='solar radiation at surface'
          units='W/m^2'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=rnflx(i,j)
          enddo
          enddo
          varname='rnflx'
          description='net radiation absorbed by surface'
          units='W/m^2'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=radswnet(i,j)
          enddo
          enddo
          varname='radswnet'
          description='net solar radiation'
          units='W/m^2'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=radlwin(i,j)
          enddo
          enddo
          varname='radlwin'
          description='incoming longwave radiation'
          units='W/m^2'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)
      endif

      if(output_sfcdiags.eq.1)then

          do j=1,nj
          do i=1,ni
            ds2(i,j)=u10(i,j)
          enddo
          enddo
          varname='ul0'
          description='diagnostic 10m u wind'
          units='m/s'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=v10(i,j)
          enddo
          enddo
          varname='vl0'
          description='diagnostic 10m v wind'
          units='m/s'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=t2(i,j)
          enddo
          enddo
          varname='t2'
          description='diagnostic 2m temperature'
          units='K'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=q2(i,j)
          enddo
          enddo
          varname='q2'
          description='diagnostic 2m water vapor mixing ratio'
          units='kg/kg'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=znt(i,j)
          enddo
          enddo
          varname='znt'
          description='roughness length'
          units='m'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=ust(i,j)
          enddo
          enddo
          varname='ust'
          description='u* in similarity theory'
          units='m/s'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)

          if(ipbl.eq.1)then
                description='PBL height (from PBL scheme)'
          else
                description='rough estimate of PBL height'
          endif
          do j=1,nj
          do i=1,ni
            ds2(i,j)=hpbl(i,j)
          enddo
          enddo
          varname='hpbl'
          units='meters'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=zol(i,j)
          enddo
          enddo
          varname='zol'
          description='z/L (z over Monin-Obukhov length)'
          units='dimensionless'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=mol(i,j)
          enddo
          enddo
          varname='mol'
          description='T* (similarity theory)'
          units='K'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)

          do j=1,nj
          do i=1,ni
            ds2(i,j)=br(i,j)
          enddo
          enddo
          varname='br'
          description='bulk Richardson number in surface layer'
          units='dimensionless'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)
      endif

      if(output_th  .eq.1)then
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=th0(i,j,k)+tha(i,j,k)
          enddo
          enddo
          enddo
          varname='th'
          description = 'Potential temperature'
          units = 'K'
          call h5_write_3d_float(threed_group_id,varname,description,units,ds,corexyztype,0,0,0)
      endif
       if(output_u    .eq.1) then
           do k=1,nk
           do j=1,nj
           do i=1,ni+1
             dumu(i,j,k)=ua(i,j,k)
           enddo
           enddo
           enddo
           varname='u'
           description = 'velocity in x direction on native Arakawa C grid'
           units = 'm/s'
! xyztype not xyzu type because we have that overlap and only need the last
! yz plane and we take care of it in h5_write_3d_float with isu
           call h5_write_3d_float(threed_group_id,varname,description,units,dumu(1:ni+1,1:nj,1:nk),corexyztype,1,0,0)
       endif

      if(output_upert.eq.1)then
          do k=1,nk
          do j=1,nj
          do i=1,ni+1
            dumu(i,j,k)=ua(i,j,k)-u0(i,j,k)
          enddo
          enddo
          enddo
          varname='upert'
          description = 'perturbation velocity in x direction on native Arakawa C grid'
          units = 'm/s'
          call h5_write_3d_float(threed_group_id,varname,description,units,dumu(1:ni+1,1:nj,1:nk),corexyztype,1,0,0)
      endif
      if(output_uinterp.eq.1)then
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=0.5*(ua(i,j,k)+ua(i+1,j,k))
          enddo
          enddo
          enddo
          varname="uinterp"
          description = 'velocity in x-direction, interpolated to scalar points'
          units = 'm/s'
          call h5_write_3d_float(threed_group_id,varname,description,units,ds,corexyztype,0,0,0)
      endif

      if(output_v    .eq.1) then
          do k=1,nk
          do j=1,nj+1
          do i=1,ni
            dumv(i,j,k)=va(i,j,k)
          enddo
          enddo
          enddo
          varname='v'
          description = 'velocity in y direction on native Arakawa C grid'
          units = 'm/s'
! xyztype not xyzv type because we have that overlap and only need the last
! xz plane and we take care of it in h5_write_3d_float with isv
          call h5_write_3d_float(threed_group_id,varname,description,units,dumv(1:ni,1:nj+1,1:nk),corexyztype,0,1,0)
      endif

      if(output_vpert.eq.1)then
          do k=1,nk
          do j=1,nj+1
          do i=1,ni
            dumv(i,j,k)=va(i,j,k)-v0(i,j,k)
          enddo
          enddo
          enddo
          varname='vpert'
          description = 'perturbation velocity in y direction on native Arakawa C grid'
          units = 'm/s'
          call h5_write_3d_float(threed_group_id,varname,description,units,dumv(1:ni,1:nj+1,1:nk),corexyztype,0,1,0)
      endif

      if(output_vinterp.eq.1)then
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=0.5*(va(i,j,k)+va(i,j+1,k))
          enddo
          enddo
          enddo
          varname="vinterp"
          description = 'velocity in y-direction, interpolated to scalar points'
          units = 'm/s'
          call h5_write_3d_float(threed_group_id,varname,description,units,ds,corexyztype,0,0,0)
      endif

      if(output_w    .eq.1) then
          do k=1,nk+1
          do j=1,nj
          do i=1,ni
            dumw(i,j,k)=wa(i,j,k)
          enddo
          enddo
          enddo
          varname='w'
          description = 'velocity in z direction on native Arakawa C grid'
          units = 'm/s'

! NOTE! we can get rid of ds and just use George's temp array and index
! it accordingly

! we do use corexyzwtype because the we don't have vertical
! decomposition, just pass a bigger array and be done with it.
! isw is used in h5_write_3d_float
          call h5_write_3d_float(threed_group_id,varname,description,units,dumw(1:ni,1:nj,1:nk+1),corexyzwtype,0,0,1)
      endif

      if(output_winterp.eq.1)then
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=0.5*(wa(i,j,k)+wa(i,j,k+1))
          enddo
          enddo
          enddo
          varname='winterp'
          description = 'velocity in z direction, interpolated to scalar points'
          units = 'm/s'
          call h5_write_3d_float(threed_group_id,varname,description,units,ds,corexyztype,0,0,0)
      endif

      if(output_thpert .eq.1) then
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=tha(i,j,k)
          enddo
          enddo
          enddo
          varname='thpert'
          description = 'Perturbation potential temperature'
          units = 'K'
          call h5_write_3d_float(threed_group_id,varname,description,units,ds,corexyztype,0,0,0)
      endif

      if(output_prs    .eq.1) then
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=prs(i,j,k)
          enddo
          enddo
          enddo
          varname='p'
          description = 'Pressure'
          units = 'Pa'
          call h5_write_3d_float(threed_group_id,varname,description,units,ds,corexyztype,0,0,0)
      endif

      if(output_prspert.eq.1)then
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=prs(i,j,k)-p00*(pi0(i,j,k)**cpdrd)
          enddo
          enddo
          enddo
          varname="ppert"
          description = 'Perturbation pressure'
          units = 'Pa'
          call h5_write_3d_float(threed_group_id,varname,description,units,ds,corexyztype,0,0,0)
      endif
      if(output_pi.eq.1)then  
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=pi0(i,j,k)+ppi(i,j,k)
          enddo
          enddo
          enddo
          varname = "pi"
          description = 'Nondimensional pressure (Exner function)'
          units = 'dimensionless'
          call h5_write_3d_float(threed_group_id,varname,description,units,ds,corexyztype,0,0,0)
      endif
      if(output_pipert .eq.1) then
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=ppi(i,j,k)
          enddo
          enddo
          enddo
          varname='pipert'
          description = 'Nondimensional pressure (Exner function) perturbation'
          units = 'dimensionless'
          call h5_write_3d_float(threed_group_id,varname,description,units,ds,corexyztype,0,0,0)
      endif

      if(output_rho    .eq.1) then
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=rho(i,j,k)
          enddo
          enddo
          enddo
          varname = "rho"
          description = 'Density'
          units = 'kg/m^3'
          call h5_write_3d_float(threed_group_id,varname,description,units,ds,corexyztype,0,0,0)
      endif
      if(output_rhopert.eq.1)then
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=rho(i,j,k)-rho0(i,j,k)
          enddo
          enddo
          enddo
          varname="rhopert"
          description = 'Density perturbation'
          units = 'kg/m^3'
          call h5_write_3d_float(threed_group_id,varname,description,units,ds,corexyztype,0,0,0)
      endif
      if(iturb.eq.1)then
            if(output_tke.eq.1) then
                do k=1,nk
                do j=1,nj
                do i=1,ni
                  ds(i,j,k)=tkea(i,j,k)
                enddo
                enddo
                enddo
                varname="tke"
                description = 'Subgrid turbulence kinetic energy'
                units = 'J/kg'
                call h5_write_3d_float(threed_group_id,varname,description,units,ds,corexyztype,0,0,0)
           endif
      endif

      if(iturb.ge.1)then

          if(output_km  .eq.1) then
              do k=1,nk
              do j=1,nj
              do i=1,ni
                ds(i,j,k)=kmh(i,j,k)
              enddo
              enddo
              enddo

              varname='kmh'
              description = 'Eddy mixing coefficient for momentum in the horizontal direction'
              units = 'm^2/s'
              call h5_write_3d_float(threed_group_id,varname,description,units,ds,corexyztype,0,0,0)

              do k=1,nk
              do j=1,nj
              do i=1,ni
                ds(i,j,k)=kmv(i,j,k)
              enddo
              enddo
              enddo
              varname='kmv'
              description = 'Eddy mixing coefficient for momentum in the vertical direction'
              units = 'm^2/s'
              call h5_write_3d_float(threed_group_id,varname,description,units,ds,corexyztype,0,0,0)
          endif

         if(output_kh  .eq.1) then
           do k=1,nk
           do j=1,nj
           do i=1,ni
             ds(i,j,k)=khh(i,j,k)
           enddo
           enddo
           enddo
           varname='khh'
           description = 'Eddy mixing coefficient for scalars in the horizontal direction'
           units = 'm^2/s'
           call h5_write_3d_float(threed_group_id,varname,description,units,ds,corexyztype,0,0,0)

           do k=1,nk
           do j=1,nj
           do i=1,ni
             ds(i,j,k)=khv(i,j,k)
           enddo
           enddo
           enddo
           varname='khv'
           description = 'Eddy mixing coefficient for scalars in the vertical direction'
           units = 'm^2/s'
           call h5_write_3d_float(threed_group_id,varname,description,units,ds,corexyztype,0,0,0)
         endif
      endif !iturb .ge. 1

      if(imoist.eq.1)then
          if(output_qv .eq. 1)  then
                do k=1,nk
                do j=1,nj
                do i=1,ni
                  ds(i,j,k)=qa(i,j,k,nqv)
                enddo
                enddo
                enddo
                varname='qv'
                description = 'Water vapor mixing ratio'
                units = 'kg/kg'
                call h5_write_3d_float(threed_group_id,varname,description,units,ds,corexyztype,0,0,0)
          endif
          if(output_qvpert.eq.1)then
              do k=1,nk
              do j=1,nj
              do i=1,ni
                ds(i,j,k)=qa(i,j,k,nqv)-qv0(i,j,k)
              enddo
              enddo
              enddo
              varname="qvpert"
              description = 'Perturbation water vapor mixing ratio'
              units = 'kg/kg'
              call h5_write_3d_float(threed_group_id,varname,description,units,ds,corexyztype,0,0,0)
          endif

          if(output_q.eq.1)then
              do n=1,numq
                  if(n.ne.nqv)then
                      do k=1,nk
                      do j=1,nj
                      do i=1,ni
                        ds(i,j,k)=qa(i,j,k,n)
                      enddo
                      enddo
                      enddo
                      qvarname='                    '
                      write(qvarname(1:3),156) qname(n)
156                   Format(a3)
                      if(idm.eq.1.and.n.ge.nnc1.and.n.le.nnc2)then
                           description = 'Number concentration'
                           units = 'kg^{-1}'
                      else
                           description = 'Hydrometeor mixing ratio'
                           units = 'kg/kg'
                      endif
                      call h5_write_3d_float(threed_group_id,qvarname,description,units,ds,corexyztype,0,0,0)
                  endif
              enddo
          endif !output_q .eq.1
          if(output_dbz.eq.1) then
              do k=1,nk
              do j=1,nj
              do i=1,ni
                ds(i,j,k)=dbz(i,j,k)
              enddo
              enddo
              enddo
              varname="dbz"
              description = 'Reflectivity'
              units = 'dBZ'
              call h5_write_3d_float(threed_group_id,varname,description,units,ds,corexyztype,0,0,0)
          endif

      endif !imoist.eq.1



      if(iptra.eq.1)then
          do n=1,npt
            do k=1,nk
            do j=1,nj
            do i=1,ni
              ds(i,j,k)=pta(i,j,k,n)
            enddo
            enddo
            enddo

            chid = 'pt      '
            write(chid(3:4),111) n
111         format(i2.2)

            varname=chid
            description='mixing ratio of passive tracer'
            units='kg/kg'
            call h5_write_3d_float(threed_group_id,varname,description,units,ds,corexyztype,0,0,0)
          enddo
      endif


      if(output_pblten.eq.1)then
          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=thpten(i,j,k)
          enddo
          enddo
          enddo

          varname='thpten'
          description='pbl tendency: theta'
          units='Not sure, email leigh.orf@cmich.edu if you do know'
          call h5_write_3d_float(threed_group_id,varname,description,units,ds,corexyztype,0,0,0)

          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=qvpten(i,j,k)
          enddo
          enddo
          enddo

          varname='qvpten'
          description='pbl tendency: qv'
          units='Not sure, email leigh.orf@cmich.edu if you do know'
          call h5_write_3d_float(threed_group_id,varname,description,units,ds,corexyztype,0,0,0)

          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=qcpten(i,j,k)
          enddo
          enddo
          enddo

          varname='qcpten'
          description='pbl tendency: qc'
          units='Not sure, email leigh.orf@cmich.edu if you do know'
          call h5_write_3d_float(threed_group_id,varname,description,units,ds,corexyztype,0,0,0)

          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=qipten(i,j,k)
          enddo
          enddo
          enddo

          varname='qipten'
          description='pbl tendency: qi'
          units='Not sure, email leigh.orf@cmich.edu if you do know'
          call h5_write_3d_float(threed_group_id,varname,description,units,ds,corexyztype,0,0,0)

          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=upten(i,j,k)
          enddo
          enddo
          enddo

          varname='upten'
          description='pbl tendency: u'
          units='Not sure, email leigh.orf@cmich.edu if you do know'
          call h5_write_3d_float(threed_group_id,varname,description,units,ds,corexyztype,0,0,0)

          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=vpten(i,j,k)
          enddo
          enddo
          enddo

          varname='vpten'
          description='pbl tendency: v'
          units='Not sure, email leigh.orf@cmich.edu if you do know'
          call h5_write_3d_float(threed_group_id,varname,description,units,ds,corexyztype,0,0,0)

      endif !output_pblten.eq.1

      if(output_uh.eq.1) then

        ! get height AGL:
          if( terrain_flag )then
            do k=1,nk+1
            do j=1,nj
            do i=1,ni
              dum3(i,j,k) = zh(i,j,k)-zs(i,j)
              dumw(i,j,k) = zf(i,j,k)-zs(i,j)
            enddo
            enddo
            enddo
          else
            do k=1,nk+1
            do j=1,nj
            do i=1,ni
              dum3(i,j,k) = zh(i,j,k)
              dumw(i,j,k) = zf(i,j,k)
            enddo
            enddo
            enddo
          endif
          call calcuh(uf,vf,dum3,dumw,ua,va,wa,dum1(ib,jb,1),dum2)
          do j=1,nj
          do i=1,ni
            ds2(i,j)=dum1(i,j,1)
          enddo
          enddo

          varname='uh'
          description='integrated updraft helicity'
          units='m^2/s^2'
          call h5_write_2d_float(twod_group_id,varname,description,units,ds2,corexytype,0,0,.false.)

      endif!output_uh.eq.1
endif !wr3d

      if(output_vort.eq.1)then
          call calcvort(xh,xf,uf,vf,zh,mf,zf,ua,va,wa,dum1,dum2,dum3,dum4)

          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=dum1(i,j,k)
          enddo
          enddo
          enddo

          varname='xvort'
          description='horizontal vorticity (x), usually called xi'
          units='s^{-1}'
          if(wr3d)call h5_write_3d_float(threed_group_id,varname,description,units,ds,corexyztype,0,0,0)
          varname='xvortsfc'
          description='surface horizontal vorticity (x), usually called xi'
          units='s^{-1}'
          if(wr2d)call h5_write_2d_float(twodfull_id,varname,description,units,ds(1:ni,1:nj,1),corexytype,0,0,.true.)
          varname='xvort1km'
          description='1km horizontal vorticity (x), usually called xi'
          units='s^{-1}'
          if(wr2d)call h5_write_2d_float(twodfull_id,varname,description,units,ds(1:ni,1:nj,ki1),corexytype,0,0,.true.)

          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=dum2(i,j,k)
          enddo
          enddo
          enddo

          varname='yvort'
          description='horizontal vorticity (y), usually called eta'
          units='s^{-1}'
          if(wr3d)call h5_write_3d_float(threed_group_id,varname,description,units,ds,corexyztype,0,0,0)

          varname='yvortsfc'
          description='surface horizontal vorticity (y), usually called eta'
          units='s^{-1}'
          if(wr2d)call h5_write_2d_float(twodfull_id,varname,description,units,ds(1:ni,1:nj,1),corexytype,0,0,.true.)
          varname='yvort1km'
          description='1km horizontal vorticity (y), usually called eta'
          units='s^{-1}'
          if(wr2d)call h5_write_2d_float(twodfull_id,varname,description,units,ds(1:ni,1:nj,ki1),corexytype,0,0,.true.)

          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=dum3(i,j,k)
          enddo
          enddo
          enddo

          varname='zvort'
          description='vertical vorticity (zeta)'
          units='s^{-1}'
          if(wr3d)call h5_write_3d_float(threed_group_id,varname,description,units,ds,corexyztype,0,0,0)

          varname='zvortsfc'
          description='surface vertical vorticity (zeta)'
          units='s^{-1}'
          if(wr2d)call h5_write_2d_float(twodfull_id,varname,description,units,ds(1:ni,1:nj,1),corexytype,0,0,.true.)
          varname='zvort1km'
          description='1km vertical vorticity (zeta)'
          units='s^{-1}'
          if(wr2d)call h5_write_2d_float(twodfull_id,varname,description,units,ds(1:ni,1:nj,ki1),corexytype,0,0,.true.)

      endif !output_vort.eq.1

      if(output_dissten.eq.1) then

          do k=1,nk
          do j=1,nj
          do i=1,ni
            ds(i,j,k)=dissten(i,j,k)
          enddo
          enddo
          enddo

          varname='dissten'
          description='dissipative heating tendency'
          units='K/s'
          if(wr3d)call h5_write_3d_float(threed_group_id,varname,description,units,ds,corexyztype,0,0,0)

       endif


! close everything
            if(wr3d) then
                  call h5gclose_f(grid_group_id,ierror)
                  call h5gclose_f(mesh_group_id,ierror)
                  call h5gclose_f(basestate_group_id,ierror)
                  call h5gclose_f(threed_basestate_group_id,ierror)
                  call h5gclose_f(twod_group_id,ierror)
                  call h5gclose_f(threed_group_id,ierror)
                  call h5fclose_f(file_id,ierror)
            endif

            if(wr2d) then
                  call h5gclose_f(twodfull_id,ierror)
                  call h5gclose_f(twodfull_mesh_id,ierror)
                  call h5gclose_f(twodfull_grid_id,ierror)
                  call h5gclose_f(twodfull_shear_id,ierror)
                  call h5gclose_f(twodfull_base_id,ierror)
                  call h5fclose_f(file_2d_id,ierror)
            endif

            call h5close_f(ierror)

            if(myid.eq.0) then
                  if (wr3d) write(outfile,*) 'Done Writing Data to File: ',trim(filename_2d)
                  if (wr2d) write(outfile,*) 'Done Writing Data to File: ',trim(filename)
                  call FFLUSH(outfile)
            endif

!#ifdef EATPOO
!
!! begin block o' crap
!!     endif
!            call MPI_BARRIER(MPI_COMM_WORLD,ierror)
!            call h5gclose_f(grid_group_id,ierror)
!            call h5gclose_f(mesh_group_id,ierror)
!            call h5gclose_f(basestate_group_id,ierror)
!            call h5gclose_f(threed_basestate_group_id,ierror)
!            call h5gclose_f(twod_group_id,ierror)
!            call h5gclose_f(threed_group_id,ierror)
!            call h5fclose_f(file_id,ierror)
!            call h5close_f(ierror)
!            if (iodebug) print *, 'myid = ', myid, ' Made it past 1d writes and group closings'
!
!#endif
!EATPOO

      return
      end

!--------------------------------------------------------------------------------------------MARK

      subroutine h5_write_2d_float(file_id,varname,description,units,core2d,mcmtype,isu,isv,isslice)
      use HDF5
      use orfiomod
      implicit none
      include 'input.incl'
#ifdef MPI
      include 'mpif.h'
#endif

      character(LEN=20) :: varname
      character*20  units
      character*120  description
      integer(HSIZE_T), DIMENSION(2) :: dims,count
      integer(HSSIZE_T), DIMENSION(2) :: offset
      integer(HSIZE_T), DIMENSION(1) :: strdims
      integer :: arank = 1
      integer :: rank = 2
      integer(HSIZE_T), DIMENSION(1) :: adims = (/1/)
      integer(SIZE_T) :: stringlen
      integer(HID_T) :: file_id,dset_id,filespace_id,memspace_id,chunk_id,datatype_id,desctype_id,unitstype_id,desc_id,units_id,aspace_id,plist_id
      integer :: ierror,isu,isv,isw,mcmtype
      integer :: i,j,iix,iiy,ixcore,iycore,ioffset,info
      real, dimension(ni+isu,nj+isv) :: core2d
      logical :: isslice

      if (iodebug2) then
         call MPI_BARRIER(MPI_COMM_WORLD,ierror)
         print *,myid,' Writing 2D float: ',trim(varname)
         call FFLUSH(6)
         call MPI_BARRIER(MPI_COMM_WORLD,ierror)
      endif

            strdims(1)=1

            call h5screate_simple_f(arank,adims,aspace_id,ierror)
            call h5tcopy_f(H5T_NATIVE_CHARACTER,desctype_id,ierror)
            call h5tcopy_f(H5T_NATIVE_CHARACTER,unitstype_id,ierror)
            stringlen = len_trim(description)
            call h5tset_size_f(desctype_id,stringlen,ierror)
            stringlen = len_trim(units)
            call h5tset_size_f(unitstype_id,stringlen,ierror)

! ORF for now isslice only works when using pHDF5

      !handle filespace first
            if (.not. isslice) then
                  dims(1)  = ni*corex
                  dims(2)  = nj*corey
            else
                  dims(1) = nx
                  dims(2) = ny
            endif

            CALL h5screate_simple_f(rank, dims, filespace_id, ierror)
            call h5dcreate_f(file_id,trim(varname),H5T_NATIVE_REAL,filespace_id,dset_id,ierror)!removed chunk_id
            call h5sclose_f(filespace_id,ierror)

      !now memoryspace
            count(1) = ni
            count(2) = nj

            if (.not. isslice) then
                  offset(1) = mygroupi * ni
                  offset(2) = mygroupj * nj
            else
                  offset(1) = (myi-1) * ni
                  offset(2) = (myj-1) * nj
            endif

            call h5screate_simple_f(rank,count,memspace_id,ierror)
            CALL h5dget_space_f(dset_id, filespace_id, ierror)
            CALL h5sselect_hyperslab_f (filespace_id, H5S_SELECT_SET_F, offset, count, ierror)
            CALL h5pcreate_f(H5P_DATASET_XFER_F, plist_id, ierror)
            CALL h5pset_dxpl_mpio_f(plist_id, MPIO, ierror)
            CALL h5dwrite_f(dset_id, H5T_NATIVE_REAL, core2d, dims, ierror, &
                       file_space_id = filespace_id, mem_space_id = memspace_id, xfer_prp = plist_id)
!           CALL h5dwrite_f(dset_id, H5T_NATIVE_INTEGER, core2d, dims, ierror, &
!                      file_space_id = filespace_id, mem_space_id = memspace_id)
            call h5acreate_f(dset_id,"description",desctype_id,aspace_id,desc_id,ierror,H5P_DEFAULT_F,H5P_DEFAULT_F)
            call h5awrite_f(desc_id,desctype_id,description,strdims,ierror)
            call h5acreate_f(dset_id,"units",unitstype_id,aspace_id,units_id,ierror,H5P_DEFAULT_F,H5P_DEFAULT_F)
            call h5awrite_f(units_id,unitstype_id,units,strdims,ierror)

            call H5aclose_f (desc_id,ierror)
            call H5aclose_f (units_id,ierror)
            call H5sclose_f (aspace_id,ierror)
            call H5tclose_f (desctype_id,ierror)
            call H5tclose_f (unitstype_id,ierror)
            call h5dclose_f (dset_id,ierror)
            call h5pclose_f (plist_id,ierror)
            call h5sclose_f (memspace_id,ierror)

      return
      end

!--------------------------------------------------------------------------------------------MARK

      subroutine h5_write_3d_float(file_id,varname,description,units,core3d,mcmtype,isu,isv,isw)
      use HDF5
      use orfiomod
      implicit none
      include 'input.incl'
#ifdef MPI
      include 'mpif.h'
#endif

      character(LEN=20) :: varname
      character*20  units
      character*120  description
      integer(HSIZE_T), DIMENSION(3) :: dims,chunkdims,count,stride,block
      integer(HSSIZE_T), DIMENSION(3) :: offset
      integer(HSIZE_T), DIMENSION(1) :: strdims
      integer :: arank = 1
      integer(HSIZE_T), DIMENSION(1) :: adims = (/1/)
      integer(SIZE_T) :: stringlen
      integer(HID_T) :: file_id,dset_id,dspace_id,chunk_id,datatype_id,desctype_id,unitstype_id,desc_id,units_id,aspace_id
      integer(HID_T) :: localmax_id,localmin_id,globalmax_id,globalmin_id,maxmintype_id
      integer(HID_T) :: memspace_id,filespace_id,plist_id
      integer ::ierror,isu,isv,isw,mcmtype
      integer :: rank
      integer :: i,j,k,iix,iiy,ixcore,iycore,ioffset
      real, dimension(ni+isu,nj+isv,nk+isw) :: core3d
      real, dimension(ionumi,nk) :: lastxz
      real, dimension(ionumj,nk) :: lastyz
      real, dimension(ionumi*nk) :: vlast_source
      real, dimension(ionumj*nk) :: ulast_source
      real localmax,localmin,globalmax,globalmin
      integer source, dest, tag
      integer, dimension(MPI_STATUS_SIZE) :: mpi_status

! ORF isu, isv, isw are treated as booleans and as an integer to add that last
! point. Isrestart is more appropraitely a boolean only since it's only used for
! making decisions

      rank = 3

      if (iodebug2) call MPI_BARRIER(MPI_COMM_WORLD,ierror)
      if (iodebug2) print *,myid,' Writing 3D float ',trim(varname)
      if (iodebug2) call FFLUSH(6)
      if (iodebug2) call MPI_BARRIER(MPI_COMM_WORLD,ierror)


      dims(1)=ionumi 
      dims(2)=ionumj
      dims(3)=nk+isw
      
      chunkdims(1)=ni
      chunkdims(2)=nj
      chunkdims(3)=nk+isw

! Count is blocks, which are chunks
! Making chunkdims(3) nk because I think it needs to always divide evenly -
! in other words you need your block to line up right

      count(1)=1
      count(2)=1
      count(3)=1

      offset(1) = mygroupi * chunkdims(1)
      offset(2) = mygroupj * chunkdims(2)
      offset(3) = 0

      stride(1) = 1
      stride(2) = 1
      stride(3) = 1

      block(1) = chunkdims(1)
      block(2) = chunkdims(2)
      block(3) = chunkdims(3)

      strdims(1)=1

! ORF 2/21/11
! This is commented out because we are wanting to call this routine for
! only a subset of the full number of ranks in order to reduce hitting
! the filesystem too hard with tens of thousands of cores writing - and hence we
! can't do collective operations with MPI_COMM_WORLD

!     call maxmin_orf(ni,nj,nk,core3d(1:ni,1:nj,1:nk),globalmax,globalmin,MPI_COMM_WORLD)
!     call MPI_BCAST(globalmax,1,MPI_REAL,0,MPI_COMM_WORLD,ierror)
!     call MPI_BCAST(globalmin,1,MPI_REAL,0,MPI_COMM_WORLD,ierror)
!     call MPI_BARRIER(MPI_COMM_WORLD,ierror)
!     if(myid.eq.0)print*, varname," global max/min: ",fmax,fmin
!     call FFLUSH(6)

! ORF 2/21/11
! This however is OK becuase we are only getting the max/min for the
! file (communicator:mysubgroupcomm) in question

      call maxmin_orf(ni,nj,nk,core3d(1:ni,1:nj,1:nk),localmax,localmin,mysubgroupcomm)

!     call MPI_BARRIER(MPI_COMM_WORLD,ierror)
!     if(mysubgrouprank.eq.0)print*, varname, " local max/min: ",fmax,fmin
!     call FFLUSH(6)

      call h5screate_simple_f(arank,adims,aspace_id,ierror)
      call h5tcopy_f(H5T_NATIVE_CHARACTER,desctype_id,ierror)
      call h5tcopy_f(H5T_NATIVE_CHARACTER,unitstype_id,ierror)
      call h5tcopy_f(H5T_NATIVE_REAL,maxmintype_id,ierror)
      stringlen = len_trim(description)
      call h5tset_size_f(desctype_id,stringlen,ierror)
      stringlen = len_trim(units)
      call h5tset_size_f(unitstype_id,stringlen,ierror)
!Create filespace first, attach attributes
!forget about U and V crap for now
!The only consequence of this is the very last (East/North) point is lost for (U/V)
      call h5screate_simple_f(rank,dims,filespace_id,ierror)
      call h5screate_simple_f(rank,chunkdims,memspace_id,ierror)
      call h5pcreate_f(H5P_DATASET_CREATE_F,chunk_id,ierror)
      call h5pset_chunk_f(chunk_id,rank,chunkdims,ierror)
      call h5dcreate_f(file_id,trim(varname),H5T_NATIVE_REAL,filespace_id,dset_id,ierror,chunk_id)
      call h5sclose_f(filespace_id,ierror)
!     print *, 'myid = ',myid,' Working on ',trim(varname)
! description and units attributes
      call h5acreate_f(dset_id,"description",desctype_id,aspace_id,desc_id,ierror,H5P_DEFAULT_F,H5P_DEFAULT_F)
      call h5awrite_f(desc_id,desctype_id,description,strdims,ierror)
      call h5acreate_f(dset_id,"units",unitstype_id,aspace_id,units_id,ierror,H5P_DEFAULT_F,H5P_DEFAULT_F)
      call h5awrite_f(units_id,unitstype_id,units,strdims,ierror)
! max/min attributes
      call h5acreate_f(dset_id,"localmax",maxmintype_id,aspace_id,localmax_id,ierror,H5P_DEFAULT_F,H5P_DEFAULT_F)
      call h5awrite_f(localmax_id,maxmintype_id,localmax,strdims,ierror)
      call h5acreate_f(dset_id,"localmin",maxmintype_id,aspace_id,localmin_id,ierror,H5P_DEFAULT_F,H5P_DEFAULT_F)
      call h5awrite_f(localmin_id,maxmintype_id,localmin,strdims,ierror)
!     call h5acreate_f(dset_id,"globalmax",maxmintype_id,aspace_id,globalmax_id,ierror,H5P_DEFAULT_F,H5P_DEFAULT_F)
!     call h5awrite_f(globalmax_id,maxmintype_id,globalmax,strdims,ierror)
!     call h5acreate_f(dset_id,"globalmin",maxmintype_id,aspace_id,globalmin_id,ierror,H5P_DEFAULT_F,H5P_DEFAULT_F)
!     call h5awrite_f(globalmin_id,maxmintype_id,globalmin,strdims,ierror)
! Write 3D data
      call h5dget_space_f(dset_id, filespace_id, ierror)
      call h5sselect_hyperslab_f (filespace_id, H5S_SELECT_SET_F, offset, count, ierror,stride,block)
      call h5pcreate_f(H5P_DATASET_XFER_F, plist_id, ierror)
      call h5pset_dxpl_mpio_f(plist_id, MPIO, ierror)
      call h5dwrite_f(dset_id, H5T_NATIVE_REAL, core3d(1:ni,1:nj,1:nk+isw), dims, ierror, &
                 file_space_id = filespace_id, mem_space_id = memspace_id, xfer_prp = plist_id)
! Close everything

      call h5aclose_f (desc_id,ierror)
      call h5aclose_f (units_id,ierror)
      call h5sclose_f (aspace_id,ierror)
      call h5tclose_f (desctype_id,ierror)
      call h5tclose_f (unitstype_id,ierror)

      call h5tclose_f (maxmintype_id,ierror)
      call h5aclose_f (localmax_id,ierror)
      call h5aclose_f (localmin_id,ierror)
!     call h5aclose_f (globalmax_id,ierror)
!     call h5aclose_f (globalmin_id,ierror)

      call h5dclose_f (dset_id,ierror)
      call h5sclose_f (memspace_id,ierror)
      call h5sclose_f (filespace_id,ierror)
      call h5pclose_f (chunk_id,ierror)
      call h5pclose_f (plist_id,ierror)


!-------------------------------Write last U, V plane as separate dataset---------------------------------------------
! In order to keep things nice, just write the last yz (for u) or xz (for v)
! plane as a separate (2d) dataset.

!ORF  2/22/11
! Don't bother with this for restart files, just write overlapping data, we will
! never visualize restart files anyway

      if (isu .eq. 1 ) then
            rank=2
            varname=trim(varname)//"_yzlast"
            description='Easternmost yz plane of U to be tacked onto U array'
            units='m/s'
            call h5screate_simple_f(arank,adims,aspace_id,ierror)
            call h5tcopy_f(H5T_NATIVE_CHARACTER,desctype_id,ierror)
            call h5tcopy_f(H5T_NATIVE_CHARACTER,unitstype_id,ierror)
            stringlen = len_trim(description)
            call h5tset_size_f(desctype_id,stringlen,ierror)
            stringlen = len_trim(units)
            call h5tset_size_f(unitstype_id,stringlen,ierror)

      !handle filespace first
            dims(1)  = nj*corey
            dims(2)  = nk

            CALL h5screate_simple_f(rank, dims, filespace_id, ierror)
            call h5dcreate_f(file_id,trim(varname),H5T_NATIVE_REAL,filespace_id,dset_id,ierror)!removed chunk_id
            call h5sclose_f(filespace_id,ierror)

      !now memoryspace
            count(1) = nj
            count(2) = nk

            offset(1) = mygroupj * nj
            offset(2) = 0

            call h5screate_simple_f(rank,count,memspace_id,ierror)
            CALL h5dget_space_f(dset_id, filespace_id, ierror)
!           if (myrygrouprank .ne. MPI_UNDEFINED) then
            if (myi .eq. nodex) then
                  CALL h5sselect_hyperslab_f (filespace_id, H5S_SELECT_SET_F, offset, count, ierror)
            else
                  call h5sselect_none_f(filespace_id,ierror)
                  call h5sselect_none_f(memspace_id,ierror)
            endif

            CALL h5pcreate_f(H5P_DATASET_XFER_F, plist_id, ierror)
            CALL h5pset_dxpl_mpio_f(plist_id, MPIO, ierror)
            CALL h5dwrite_f(dset_id, H5T_NATIVE_REAL, core3d(ni+1,:,:), dims, ierror, &
                       file_space_id = filespace_id, mem_space_id = memspace_id, xfer_prp = plist_id)
            call h5acreate_f(dset_id,"description",desctype_id,aspace_id,desc_id,ierror,H5P_DEFAULT_F,H5P_DEFAULT_F)
            call h5awrite_f(desc_id,desctype_id,description,strdims,ierror)
            call h5acreate_f(dset_id,"units",unitstype_id,aspace_id,units_id,ierror,H5P_DEFAULT_F,H5P_DEFAULT_F)
            call h5awrite_f(units_id,unitstype_id,units,strdims,ierror)
      endif

      if (isv .eq. 1 ) then
            rank=2
            varname=trim(varname)//"_xzlast"
            description='Northernmost xz plane of V to be tacked onto V array'
            units='m/s'
            call h5screate_simple_f(arank,adims,aspace_id,ierror)
            call h5tcopy_f(H5T_NATIVE_CHARACTER,desctype_id,ierror)
            call h5tcopy_f(H5T_NATIVE_CHARACTER,unitstype_id,ierror)
            stringlen = len_trim(description)
            call h5tset_size_f(desctype_id,stringlen,ierror)
            stringlen = len_trim(units)
            call h5tset_size_f(unitstype_id,stringlen,ierror)

      !handle filespace first
            dims(1)  = ni*corex
            dims(2)  = nk

            CALL h5screate_simple_f(rank, dims, filespace_id, ierror)
            call h5dcreate_f(file_id,trim(varname),H5T_NATIVE_REAL,filespace_id,dset_id,ierror)
            call h5sclose_f(filespace_id,ierror)

      !now memoryspace
            count(1) = ni
            count(2) = nk

            offset(1) = mygroupi * ni
            offset(2) = 0

            call h5screate_simple_f(rank,count,memspace_id,ierror)
            CALL h5dget_space_f(dset_id, filespace_id, ierror)
!           if (mytxgrouprank .ne. MPI_UNDEFINED) then
            if (myj .eq. nodey) then
                  CALL h5sselect_hyperslab_f (filespace_id, H5S_SELECT_SET_F, offset, count, ierror)
            else
                  call h5sselect_none_f(filespace_id,ierror)
                  call h5sselect_none_f(memspace_id,ierror)
            endif

            CALL h5pcreate_f(H5P_DATASET_XFER_F, plist_id, ierror)
            CALL h5pset_dxpl_mpio_f(plist_id, MPIO, ierror)
            CALL h5dwrite_f(dset_id, H5T_NATIVE_REAL, core3d(:,nj+1,:), dims, ierror, &
                       file_space_id = filespace_id, mem_space_id = memspace_id, xfer_prp = plist_id)
            call h5acreate_f(dset_id,"description",desctype_id,aspace_id,desc_id,ierror,H5P_DEFAULT_F,H5P_DEFAULT_F)
            call h5awrite_f(desc_id,desctype_id,description,strdims,ierror)
            call h5acreate_f(dset_id,"units",unitstype_id,aspace_id,units_id,ierror,H5P_DEFAULT_F,H5P_DEFAULT_F)
            call h5awrite_f(units_id,unitstype_id,units,strdims,ierror)
      endif

      if ( isu.eq.1.or.isv.eq.1) then
            call H5aclose_f (desc_id,ierror)
            call H5aclose_f (units_id,ierror)
            call H5sclose_f (aspace_id,ierror)
            call H5tclose_f (desctype_id,ierror)
            call H5tclose_f (unitstype_id,ierror)
            call h5dclose_f (dset_id,ierror)
            call h5sclose_f (memspace_id,ierror)
            call h5sclose_f (filespace_id,ierror)
            call H5pclose_f (plist_id,ierror)
      endif

!-------------------------------END Write last U, V plane as separate !dataset---------------------------------------------

#ifdef ORFS_HEAD_ABOUT_TO_EXPLODE
      do i=1,toomanybeers
            call Orf_Drink_Beer(i)
      enddo
#endif
      return
      end
!--------------------------------------------------------------------------------------------MARK
      subroutine h5_write_float (file_id,varname,description,units,value,isslice)
      use HDF5
      use orfiomod
      implicit none
      include 'input.incl'
#ifdef MPI
      include 'mpif.h'
#endif
      character(LEN=20) :: varname
      character*120  description
      character*20  units

      integer(HSIZE_T), DIMENSION(1) :: strdims
      integer :: arank = 1
      integer(HSIZE_T), DIMENSION(1) :: adims = (/1/)
      integer(SIZE_T) :: stringlen

      real value
      integer rank,localiorank,ierror
      integer(HSIZE_T), DIMENSION(1) :: dims,count
      integer(HSSIZE_T), DIMENSION(1) :: offset
      integer(HID_T) :: file_id,dset_id,filespace_id,memspace_id,aspace_id,desc_id,desctype_id,unitstype_id,units_id
      integer(HID_T) :: plist_id
      logical :: isslice

      if (iodebug2) call MPI_BARRIER(MPI_COMM_WORLD,ierror)
      if (iodebug2) print *,myid,' Writing float: ',trim(varname)
      if (iodebug2) call FFLUSH(6)
      if (iodebug2) call MPI_BARRIER(MPI_COMM_WORLD,ierror)

      call h5screate_simple_f(arank,adims,aspace_id,ierror)
      call h5tcopy_f(H5T_NATIVE_CHARACTER,desctype_id,ierror)
      call h5tcopy_f(H5T_NATIVE_CHARACTER,unitstype_id,ierror)
      stringlen = len_trim(description)
      call h5tset_size_f(desctype_id,stringlen,ierror)
      stringlen = len_trim(units)
      call h5tset_size_f(unitstype_id,stringlen,ierror)

      ! filespace first
      rank=1
      strdims(1)=1
      dims(1)=1
      count(1)=1
      offset(1) = 0

      call h5screate_simple_f(rank,dims,filespace_id,ierror)
      call h5dcreate_f(file_id,trim(varname),H5T_NATIVE_REAL,filespace_id,dset_id,ierror)
      call h5sclose_f(filespace_id,ierror)

!           print *, 'Writing ',trim(varname)

      !memoryspace:
      call h5screate_simple_f(rank,count,memspace_id,ierror)
      call h5dget_space_f(dset_id,filespace_id,ierror)

      if(isslice) then
            localiorank = myid
      else
            localiorank = iorank
      endif

      if (localiorank.eq.0) then
            call h5sselect_hyperslab_f(filespace_id,H5S_SELECT_SET_F,offset,count,ierror)
      else
            call h5sselect_none_f(filespace_id,ierror)
            call h5sselect_none_f(memspace_id,ierror)
      endif
      CALL h5pcreate_f(H5P_DATASET_XFER_F, plist_id, ierror)
      CALL h5pset_dxpl_mpio_f(plist_id, MPIO, ierror)
      CALL h5dwrite_f(dset_id, H5T_NATIVE_REAL, value, dims, ierror, &
                 file_space_id = filespace_id, mem_space_id = memspace_id, xfer_prp = plist_id)
      call h5acreate_f(dset_id,"description",desctype_id,aspace_id,desc_id,ierror,H5P_DEFAULT_F,H5P_DEFAULT_F)
      call h5awrite_f(desc_id,desctype_id,trim(description),strdims,ierror)
      call h5acreate_f(dset_id,"units",unitstype_id,aspace_id,units_id,ierror,H5P_DEFAULT_F,H5P_DEFAULT_F)
      call h5awrite_f(units_id,unitstype_id,trim(units),strdims,ierror)


      call H5aclose_f (desc_id,ierror)
      call H5aclose_f (units_id,ierror)
      call H5sclose_f (aspace_id,ierror)
      call H5tclose_f (desctype_id,ierror)
      call H5tclose_f (unitstype_id,ierror)
      call h5dclose_f (dset_id,ierror)
      call h5sclose_f (filespace_id,ierror)
      call h5sclose_f (memspace_id,ierror)
      return
      end
!--------------------------------------------------------------------------------------------MARK
      subroutine h5_write_int (file_id,varname,description,units,value,isslice)
      use HDF5
      use orfiomod
      implicit none
      include 'input.incl'
#ifdef MPI
      include 'mpif.h'
#endif
      character(LEN=20) :: varname
      character*120  description
      character*20  units

      integer(HSIZE_T), DIMENSION(1) :: strdims
      integer :: arank = 1
      integer(HSIZE_T), DIMENSION(1) :: adims = (/1/)
      integer(SIZE_T) :: stringlen

      integer value
      integer rank,ierror,localiorank
      integer(HSIZE_T), DIMENSION(1) :: dims,count
      integer(HSSIZE_T), DIMENSION(1) :: offset
      integer(HID_T) :: file_id,dset_id,filespace_id,memspace_id,aspace_id,desc_id,desctype_id,unitstype_id,units_id
      integer(HID_T) :: plist_id
      logical :: isslice

      if (iodebug2) call MPI_BARRIER(MPI_COMM_WORLD,ierror)
      if (iodebug2) print *,myid,' Writing int: ',trim(varname)
      if (iodebug2) call FFLUSH(6)
      if (iodebug2) call MPI_BARRIER(MPI_COMM_WORLD,ierror)

      call h5screate_simple_f(arank,adims,aspace_id,ierror)
      call h5tcopy_f(H5T_NATIVE_CHARACTER,desctype_id,ierror)
      call h5tcopy_f(H5T_NATIVE_CHARACTER,unitstype_id,ierror)
      stringlen = len_trim(description)
      call h5tset_size_f(desctype_id,stringlen,ierror)
      stringlen = len_trim(units)
      call h5tset_size_f(unitstype_id,stringlen,ierror)

      ! filespace first
      rank=1
      strdims(1)=1
      dims(1)=1
      count(1)=1
      offset(1) = 0

      call h5screate_simple_f(rank,dims,filespace_id,ierror)
      call h5dcreate_f(file_id,trim(varname),H5T_NATIVE_INTEGER,filespace_id,dset_id,ierror)
      call h5sclose_f(filespace_id,ierror)

      !memoryspace:
      call h5screate_simple_f(rank,count,memspace_id,ierror)
      call h5dget_space_f(dset_id,filespace_id,ierror)
      if(isslice) then
            localiorank = myid
      else
            localiorank = iorank
      endif
      if (localiorank.eq.0) then
            call h5sselect_hyperslab_f(filespace_id,H5S_SELECT_SET_F,offset,count,ierror)
      else
            call h5sselect_none_f(filespace_id,ierror)
            call h5sselect_none_f(memspace_id,ierror)
      endif
      CALL h5pcreate_f(H5P_DATASET_XFER_F, plist_id, ierror)
      CALL h5pset_dxpl_mpio_f(plist_id, MPIO, ierror)
      CALL h5dwrite_f(dset_id, H5T_NATIVE_INTEGER, value, dims, ierror, &
                 file_space_id = filespace_id, mem_space_id = memspace_id, xfer_prp = plist_id)
      call h5acreate_f(dset_id,"description",desctype_id,aspace_id,desc_id,ierror,H5P_DEFAULT_F,H5P_DEFAULT_F)
      call h5awrite_f(desc_id,desctype_id,trim(description),strdims,ierror)
      call h5acreate_f(dset_id,"units",unitstype_id,aspace_id,units_id,ierror,H5P_DEFAULT_F,H5P_DEFAULT_F)
      call h5awrite_f(units_id,unitstype_id,trim(units),strdims,ierror)


      call H5aclose_f (desc_id,ierror)
      call H5aclose_f (units_id,ierror)
      call H5sclose_f (aspace_id,ierror)
      call H5tclose_f (desctype_id,ierror)
      call H5tclose_f (unitstype_id,ierror)
      call h5dclose_f (dset_id,ierror)
      call h5sclose_f (filespace_id,ierror)
      call h5sclose_f (memspace_id,ierror)
      return
      end

!--------------------------------------------------------------------------------------------MARK
! This routine is only for writing to the 2D file the FULL xf, yf arrays, each of which has
! that pesky extra point to deal with. 

! Note that we currently do NOT write the last xf,yf values in the 3D cm1hdf5 files

      subroutine h5_write_1d_float_uv (file_id,varname,description,units,local1darray,nlocal,dims,count,offset,onedcomm,onedrank,sourcerank)
      use HDF5
      use orfiomod
      implicit none
      include 'input.incl'
#ifdef MPI
      include 'mpif.h'
#endif
      character(LEN=20) :: varname
      character*120  description
      character*20  units

      integer(HSIZE_T), DIMENSION(1) :: strdims
      integer :: arank = 1
      integer(HSIZE_T), DIMENSION(1) :: adims = (/1/)
      integer(SIZE_T) :: stringlen

      integer :: nlocal
      real, dimension(nlocal) ::  local1darray
      real, dimension(:), allocatable :: vel
      real :: lastval
      integer rank,localrank,ierror,nglobal,tag,sourcerank,destrank,onedcomm,onedrank
      integer(HSIZE_T), DIMENSION(1) :: dims,count
      integer(HSSIZE_T), DIMENSION(1) :: offset
      integer(HID_T) :: file_id,dset_id,filespace_id,memspace_id,aspace_id,desc_id,desctype_id,unitstype_id,units_id
      integer(HID_T) :: plist_id
      integer status(MPI_STATUS_SIZE)

      if (iodebug2) call MPI_BARRIER(MPI_COMM_WORLD,ierror)
      if (iodebug2) print *,myid,' Writing 1d float: ',trim(varname)
      if (iodebug2) call FFLUSH(6)
      if (iodebug2) call MPI_BARRIER(MPI_COMM_WORLD,ierror)

      call h5screate_simple_f(arank,adims,aspace_id,ierror)
      call h5tcopy_f(H5T_NATIVE_CHARACTER,desctype_id,ierror)
      call h5tcopy_f(H5T_NATIVE_CHARACTER,unitstype_id,ierror)
      stringlen = len_trim(description)
      call h5tset_size_f(desctype_id,stringlen,ierror)
      stringlen = len_trim(units)
      call h5tset_size_f(unitstype_id,stringlen,ierror)

      ! filespace first
      rank=1
      strdims(1)=1
      nglobal=dims(1)
      allocate ( vel(nglobal))

      call h5screate_simple_f(rank,dims,filespace_id,ierror)
      call h5dcreate_f(file_id,trim(varname),H5T_NATIVE_REAL,filespace_id,dset_id,ierror)
      call h5sclose_f(filespace_id,ierror)

! Note that rank 0 (root) is a member of onedcomm which is either the southernmost or
! westernmost row/column

      if (onedrank .ne. MPI_UNDEFINED) call MPI_GATHER(local1darray,nlocal,MPI_REAL,vel,nlocal,MPI_REAL,0,onedcomm,ierror)

! sourcerank is either northwest for y or southeast for x (passed to routine)
! Dest rank is root

      destrank=0
      tag=1
      if (myid.eq.destrank) then
            call MPI_RECV(lastval,1,MPI_REAL,sourcerank,tag,MPI_COMM_WORLD,status,ierror)
      else if (myid.eq.sourcerank) then
            call MPI_SEND(local1darray(nlocal+1),1,MPI_REAL,destrank,tag,MPI_COMM_WORLD,ierror)
      endif

!FINALLY TACK THAT FUCKER ON

      if (myid.eq.0) vel(nglobal) = lastval

      !memoryspace:
      call h5screate_simple_f(rank,dims,memspace_id,ierror)
      call h5dget_space_f(dset_id,filespace_id,ierror)

      if (myid .eq. 0) then
            call h5sselect_hyperslab_f(filespace_id,H5S_SELECT_SET_F,offset,count,ierror)
      else
            call h5sselect_none_f(filespace_id,ierror)
            call h5sselect_none_f(memspace_id,ierror)
      endif
      CALL h5pcreate_f(H5P_DATASET_XFER_F, plist_id, ierror)
      CALL h5pset_dxpl_mpio_f(plist_id, MPIO, ierror)
      CALL h5dwrite_f(dset_id, H5T_NATIVE_REAL, vel, dims, ierror, &
                 file_space_id = filespace_id, mem_space_id = memspace_id, xfer_prp = plist_id)
      call h5acreate_f(dset_id,"description",desctype_id,aspace_id,desc_id,ierror,H5P_DEFAULT_F,H5P_DEFAULT_F)
      call h5awrite_f(desc_id,desctype_id,trim(description),strdims,ierror)
      call h5acreate_f(dset_id,"units",unitstype_id,aspace_id,units_id,ierror,H5P_DEFAULT_F,H5P_DEFAULT_F)
      call h5awrite_f(units_id,unitstype_id,trim(units),strdims,ierror)

      call H5aclose_f (desc_id,ierror)
      call H5aclose_f (units_id,ierror)
      call H5sclose_f (aspace_id,ierror)
      call H5tclose_f (desctype_id,ierror)
      call H5tclose_f (unitstype_id,ierror)
      call h5dclose_f (dset_id,ierror)
      call h5sclose_f (filespace_id,ierror)
      call h5sclose_f (memspace_id,ierror)
      return
      end

!--------------------------------------------------------------------------------------------MARK

      subroutine h5_write_1d_float (file_id,varname,description,units,local1darray,nlocal,dims,count,offset,localrank)
      use HDF5
      use orfiomod
      implicit none
      include 'input.incl'
#ifdef MPI
      include 'mpif.h'
#endif
      character(LEN=20) :: varname
      character*120  description
      character*20  units

      integer(HSIZE_T), DIMENSION(1) :: strdims
      integer :: arank = 1
      integer(HSIZE_T), DIMENSION(1) :: adims = (/1/)
      integer(SIZE_T) :: stringlen

      integer :: nlocal
      real, dimension(nlocal) ::  local1darray

      integer rank,localrank,ierror
      integer(HSIZE_T), DIMENSION(1) :: dims,count
      integer(HSSIZE_T), DIMENSION(1) :: offset
      integer(HID_T) :: file_id,dset_id,filespace_id,memspace_id,aspace_id,desc_id,desctype_id,unitstype_id,units_id
      integer(HID_T) :: plist_id

      if (iodebug2) call MPI_BARRIER(MPI_COMM_WORLD,ierror)
      if (iodebug2) print *,myid,' Writing 1d float: ',trim(varname)
      if (iodebug2) call FFLUSH(6)
      if (iodebug2) call MPI_BARRIER(MPI_COMM_WORLD,ierror)

      call h5screate_simple_f(arank,adims,aspace_id,ierror)
      call h5tcopy_f(H5T_NATIVE_CHARACTER,desctype_id,ierror)
      call h5tcopy_f(H5T_NATIVE_CHARACTER,unitstype_id,ierror)
      stringlen = len_trim(description)
      call h5tset_size_f(desctype_id,stringlen,ierror)
      stringlen = len_trim(units)
      call h5tset_size_f(unitstype_id,stringlen,ierror)

      ! filespace first
      rank=1
      strdims(1)=1

      call h5screate_simple_f(rank,dims,filespace_id,ierror)
      call h5dcreate_f(file_id,trim(varname),H5T_NATIVE_REAL,filespace_id,dset_id,ierror)
      call h5sclose_f(filespace_id,ierror)

      !memoryspace:
      call h5screate_simple_f(rank,count,memspace_id,ierror)
      call h5dget_space_f(dset_id,filespace_id,ierror)

! Everything hinges upon whether localrank, which is passed to
! this subroutine, is defined for a the current MPI rank (all
! ranks are calling this routine). I like setting up MPI groups
! and then essentially checking if we are in the group when making
! decisions about writing things - a leftover from when I was doing
! 1D MPI_Gathers, which udoubtedly pHDF5 is doing under the hood when
! set up for collective communication. So long as localrank is for a
! given MPI rank, the array passed to this routine, and its length, are
! written by the current MPI rank; if not, it's masked out as undefined.
! What is also crucial to making this work is the file_id that is
! passed, i.e., if it's the 2D slice file or the 3D MCM file (they are
! defined and initialized at the betinning of this file). This approch
! really cleans up a lot of crap that I had written here and makes this
! routine flexible (don't have to create separate 1d write routines),
! but it does require that you supply dims, count, offset from outside
! when calling this routine, which I have typically not required.
! Otherwise you have to pass booleans and make decisions in here and it
! gets messy. See param.F for all the different groups, ranks, etc. that
! are set up (you only need to do this once).
!
! Somewhat ironically, 2d and 3d writes are easier because they always
! require contribution from all ranks. In that case, I require the
! isslice boolean and can make decisions based upon that. Maybe I should
! change those to match this routine's API, I dunno.

      if (localrank .ne. MPI_UNDEFINED) then
            call h5sselect_hyperslab_f(filespace_id,H5S_SELECT_SET_F,offset,count,ierror)
      else
            call h5sselect_none_f(filespace_id,ierror)
            call h5sselect_none_f(memspace_id,ierror)
      endif
      CALL h5pcreate_f(H5P_DATASET_XFER_F, plist_id, ierror)
      CALL h5pset_dxpl_mpio_f(plist_id, MPIO, ierror)
      CALL h5dwrite_f(dset_id, H5T_NATIVE_REAL, local1darray, dims, ierror, &
                 file_space_id = filespace_id, mem_space_id = memspace_id, xfer_prp = plist_id)
      call h5acreate_f(dset_id,"description",desctype_id,aspace_id,desc_id,ierror,H5P_DEFAULT_F,H5P_DEFAULT_F)
      call h5awrite_f(desc_id,desctype_id,trim(description),strdims,ierror)
      call h5acreate_f(dset_id,"units",unitstype_id,aspace_id,units_id,ierror,H5P_DEFAULT_F,H5P_DEFAULT_F)
      call h5awrite_f(units_id,unitstype_id,trim(units),strdims,ierror)

      call H5aclose_f (desc_id,ierror)
      call H5aclose_f (units_id,ierror)
      call H5sclose_f (aspace_id,ierror)
      call H5tclose_f (desctype_id,ierror)
      call H5tclose_f (unitstype_id,ierror)
      call h5dclose_f (dset_id,ierror)
      call h5sclose_f (filespace_id,ierror)
      call h5sclose_f (memspace_id,ierror)
      return
      end
!--------------------------------------------------------------------------------------------MARK
      subroutine h5_write_1d_double (file_id,varname,description,units,local1darray,nlocal,dims,count,offset,localrank)
      use HDF5
      use orfiomod
      implicit none
      include 'input.incl'
#ifdef MPI
      include 'mpif.h'
#endif
      character(LEN=20) :: varname
      character*120  description
      character*20  units

      integer(HSIZE_T), DIMENSION(1) :: strdims
      integer :: arank = 1
      integer(HSIZE_T), DIMENSION(1) :: adims = (/1/)
      integer(SIZE_T) :: stringlen

      integer :: nlocal
      real*8, dimension(nlocal) ::  local1darray

      integer rank,localrank,ierror
      integer(HSIZE_T), DIMENSION(1) :: dims,count
      integer(HSSIZE_T), DIMENSION(1) :: offset
      integer(HID_T) :: file_id,dset_id,filespace_id,memspace_id,aspace_id,desc_id,desctype_id,unitstype_id,units_id
      integer(HID_T) :: plist_id

      if (iodebug2) call MPI_BARRIER(MPI_COMM_WORLD,ierror)
      if (iodebug2) print *,myid,' Writing 1d double: ',trim(varname)
      if (iodebug2) call FFLUSH(6)
      if (iodebug2) call MPI_BARRIER(MPI_COMM_WORLD,ierror)

      call h5screate_simple_f(arank,adims,aspace_id,ierror)
      call h5tcopy_f(H5T_NATIVE_CHARACTER,desctype_id,ierror)
      call h5tcopy_f(H5T_NATIVE_CHARACTER,unitstype_id,ierror)
      stringlen = len_trim(description)
      call h5tset_size_f(desctype_id,stringlen,ierror)
      stringlen = len_trim(units)
      call h5tset_size_f(unitstype_id,stringlen,ierror)

      ! filespace first
      rank=1
      strdims(1)=1

      call h5screate_simple_f(rank,dims,filespace_id,ierror)
      call h5dcreate_f(file_id,trim(varname),H5T_NATIVE_DOUBLE,filespace_id,dset_id,ierror)
      call h5sclose_f(filespace_id,ierror)

      !memoryspace:
      call h5screate_simple_f(rank,count,memspace_id,ierror)
      call h5dget_space_f(dset_id,filespace_id,ierror)

      if (localrank .ne. MPI_UNDEFINED) then
            call h5sselect_hyperslab_f(filespace_id,H5S_SELECT_SET_F,offset,count,ierror)
      else
            call h5sselect_none_f(filespace_id,ierror)
            call h5sselect_none_f(memspace_id,ierror)
      endif
      CALL h5pcreate_f(H5P_DATASET_XFER_F, plist_id, ierror)
      CALL h5pset_dxpl_mpio_f(plist_id, MPIO, ierror)
      CALL h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, local1darray, dims, ierror, &
                 file_space_id = filespace_id, mem_space_id = memspace_id, xfer_prp = plist_id)
      call h5acreate_f(dset_id,"description",desctype_id,aspace_id,desc_id,ierror,H5P_DEFAULT_F,H5P_DEFAULT_F)
      call h5awrite_f(desc_id,desctype_id,trim(description),strdims,ierror)
      call h5acreate_f(dset_id,"units",unitstype_id,aspace_id,units_id,ierror,H5P_DEFAULT_F,H5P_DEFAULT_F)
      call h5awrite_f(units_id,unitstype_id,trim(units),strdims,ierror)

      call H5aclose_f (desc_id,ierror)
      call H5aclose_f (units_id,ierror)
      call H5sclose_f (aspace_id,ierror)
      call H5tclose_f (desctype_id,ierror)
      call H5tclose_f (unitstype_id,ierror)
      call h5dclose_f (dset_id,ierror)
      call h5sclose_f (filespace_id,ierror)
      call h5sclose_f (memspace_id,ierror)
      return
      end
!--------------------------------------------------------------------------------------------MARK

! Fields along parcels are hardwired in parcel.F. If you add more fields, change
! here accordingly.

subroutine writepdata_hdf5(nrec,rtime,pdata)

      use HDF5
      implicit none
      include 'input.incl'

      character*160 filename
      integer :: nrec
      real :: rtime
      real, dimension(npvals,nparcels) :: pdata
      integer(SIZE_T) :: stringlen
      integer(HID_T) :: file_id,dset_id,dspace_id,chunk_id,datatype_id
      integer(HID_T) :: desctype_id,unitstype_id,desc_id,units_id,aspace_id
      integer(HID_T) :: parcel_group_id,memoryspace,filespace,time_id
      integer(HSIZE_T), dimension(2) :: maxdims,chunkdims,currentdims,singledims,offset
      integer(HSIZE_T), dimension(1) :: maxtimedims,timechunkdims,timecurrentdims,timesingledims,timeoffset
      integer(HID_T) :: timechunk_id,timememoryspace,timefilespace,timedset_id
      character(len=6), parameter :: parcel_group_name="parcel"
      character(len=120), parameter :: timedesc="model time"
      character(len=20), parameter :: timevar="time",timeunits="s"
      integer :: i,ierror
      integer :: rank,nvals

!     character, parameter :: varname(14) = (/character(len=20) :: &
      character(*), parameter :: varname(14) = (/  &
!     character(len=20), parameter :: varname(14) = (/character :: &
      'x', &
      'y', &
      'z', &
      'qv', &
      'qc', &
      'qr', &
      'nsq', &
      'u', &
      'v', &
      'w', &
      'kh', &
      'the', &
      'b', &
      'dpdz'/)

      character(*), parameter :: vardesc(14) = (/  &
      'x position of parcel', &
      'y position of parcel', &
      'z position of parcel', &
      'water vapor mixing ratio', &
      'cloud water mixing ratio', &
      'rain water mixing ratio', &
      'Brunt Vaisala frequency squared', &
      'u component of wind', &
      'v component of wind', &
      'w component of wind', &
      'turbulence coefficient for scalars', &
      'theta-e', &
      'buoyancy', &
      'dpdz tendency'/)

      character(*), parameter :: varunits(14) = (/  &
      'm','m','m', &
      'kg/kg','kg/kg','kg/kg', &
      'dimensionless', &
      'm/s','m/s','m/s', &
      'm^2/s','K', &
      'm/s^2', &
      'm/s^2'/)

      call h5open_f (ierror)

      maxdims(1) = nparcels
      maxdims(2) = H5S_UNLIMITED_F
      currentdims(1)=nparcels
      currentdims(2)=1
      singledims(1)=nparcels
      singledims(2)=1
      chunkdims(1) =nparcels
      chunkdims(2) = 1
      offset(1) = 0
      offset(2) = 0

      maxtimedims(1) = H5S_UNLIMITED_F
      timechunkdims(1) = 100
      timecurrentdims(1)=1
      timesingledims(1)=1
      timeoffset(1)=0

      timeoffset(1)=nrec-1
      timecurrentdims(1)=nrec
      offset(2) = nrec-1
      currentdims(2) = nrec

      filename = trim(output_basename)//'_pdata.hdf5'
      if(nrec.eq.1) then 
             call h5fcreate_f(trim(filename),H5F_ACC_TRUNC_F,file_id,ierror)
             call h5gcreate_f(file_id,parcel_group_name,parcel_group_id,ierror)      
      else
!            print *,'myid = ',myid,' nrec= ',nrec,' filename = ',trim(filename)
             call h5fopen_f(trim(filename),H5F_ACC_RDWR_F, file_id,ierror)
             call h5gopen_f(file_id,parcel_group_name,parcel_group_id,ierror)
      endif

      rank=1
      nvals=1
      call writefloat_hdf_unlimited(rank,nvals,nrec,parcel_group_id,timevar,timedesc,timeunits,time_id,timefilespace, &
            timememoryspace,timedset_id,timechunk_id,timechunkdims,maxtimedims,timecurrentdims,timesingledims,timeoffset,rtime)

      rank=2
      nvals=nparcels
      do i=1,14
            call writefloat_hdf_unlimited(rank,nvals,nrec,parcel_group_id,varname(i),vardesc(i), &
                  varunits(i),dspace_id,filespace,memoryspace,dset_id,chunk_id, &
                  chunkdims,maxdims,currentdims,singledims,offset,pdata(i,:))
            enddo

      nrec = nrec + 1
      call h5close_f (ierror)

      return
      end 


!--------------------------------------------------------------------------------------------MARK
! ORF 1/11/11
! Following routine works on data with an unlimited dimension,
! i.e., for creating and appending variables in parcel or stats hdf5 files

! Only one hdf file is written, model does a gather to root

subroutine writefloat_hdf_unlimited(rank,nvals,irec,file_id,varname,vardesc,varunits,dspace_id, &
      filespace,memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,floatval)

      use HDF5
      implicit none
      include 'input.incl'

      integer(HID_T) :: file_id,dset_id,dspace_id,chunk_id,datatype_id
      integer(HID_T) :: desctype_id,unitstype_id,desc_id,units_id,aspace_id
      integer(HID_T) :: parcel_group_id,memoryspace,filespace
      integer rank,nvals
      integer(HSIZE_T),dimension(rank) :: chunkdims,maxdims,currentdims,singledims,offset
      integer(HSIZE_T), DIMENSION(1) :: adims = (/1/)
      integer(HSIZE_T), DIMENSION(1) :: strdims = (/1/)
      real, dimension(nvals) :: floatval
      character(len=20) ::  varname
      character(len=120) :: vardesc
      character(len=20) :: varunits
      integer irec,ierror
      integer(SIZE_T) :: stringlen

!     print *, 'myid: ',myid,'irec: ',irec, varname
      if (irec.eq.1) then

            call h5screate_simple_f(rank, singledims, dspace_id, ierror, maxdims)
            call h5screate_simple_f(rank, singledims, memoryspace, ierror, singledims)
            call h5pcreate_f(H5P_DATASET_CREATE_F,chunk_id,ierror)
            call h5pset_chunk_f(chunk_id,rank,chunkdims,ierror)
! This is an example of how you would add gzip compression to unlimited dimension arrays for parcel and stats hdf5 files
!           if (output_format.eq.3.or.output_format.eq.4)call h5pset_deflate_f (chunk_id,1,ierror)

            call h5dcreate_f(file_id,trim(varname),H5T_NATIVE_REAL,dspace_id,dset_id,ierror,chunk_id)
            call h5dset_extent_f(dset_id,currentdims,ierror)
            call h5dget_space_f(dset_id,filespace,ierror)
            call h5sselect_hyperslab_f(filespace,H5S_SELECT_SET_F,offset,singledims,ierror)
            call h5dwrite_f(dset_id,H5T_NATIVE_REAL,floatval,singledims,ierror,memoryspace,filespace,H5P_DEFAULT_F)
            call h5sclose_f(memoryspace,ierror)
            call h5sclose_f(filespace,ierror)
            call h5sclose_f(dspace_id,ierror)
            call H5pclose_f(chunk_id,ierror)

            call h5tcopy_f(H5T_NATIVE_CHARACTER,desctype_id,ierror)
            stringlen = len_trim(vardesc)
            call h5tset_size_f(desctype_id,stringlen,ierror)
            call h5screate_simple_f(1,adims,aspace_id,ierror)
            call h5acreate_f(dset_id,"description",desctype_id,aspace_id,desc_id,ierror,H5P_DEFAULT_F,H5P_DEFAULT_F)
            call h5awrite_f(desc_id,desctype_id,vardesc,strdims,ierror)
            call H5aclose_f (desc_id,ierror)
            call H5sclose_f (aspace_id,ierror)
            call H5tclose_f (desctype_id,ierror)

            call h5tcopy_f(H5T_NATIVE_CHARACTER,desctype_id,ierror)
            stringlen = len_trim(varunits)
            call h5tset_size_f(desctype_id,stringlen,ierror)
            call h5screate_simple_f(1,adims,aspace_id,ierror)
            call h5acreate_f(dset_id,"units",desctype_id,aspace_id,desc_id,ierror,H5P_DEFAULT_F,H5P_DEFAULT_F)
            call h5awrite_f(desc_id,desctype_id,varunits,strdims,ierror)
            call H5aclose_f (desc_id,ierror)
            call H5sclose_f (aspace_id,ierror)
            call H5tclose_f (desctype_id,ierror)

            call h5dclose_f(dset_id,ierror)
      else
!           print *,'myid = ',myid,' irec= ',irec,' varname = ',varname
            call h5dopen_f(file_id,trim(varname),dset_id,ierror)
            call h5dset_extent_f(dset_id,currentdims,ierror)
            call h5dget_space_f(dset_id,filespace,ierror)
            call h5sselect_hyperslab_f(filespace,H5S_SELECT_SET_F,offset,singledims,ierror)
            call h5screate_simple_f(rank, singledims, memoryspace, ierror, singledims)
            call h5dwrite_f(dset_id,H5T_NATIVE_REAL,floatval,singledims,ierror,memoryspace,filespace,H5P_DEFAULT_F)
            call h5sclose_f(memoryspace,ierror)
            call h5sclose_f(filespace,ierror)
            call h5dclose_f(dset_id,ierror)
      endif
      return
end 


!--------------------------------------------------------------------------------------------MARK
! Only one hdf file is written, model does a gather to root, so we are only on
! rank 0 when in this routine
subroutine writestat_hdf5(nrec,rtime,nstat,rstat,qname,budname)

      use HDF5
      implicit none
      include 'input.incl'

      integer, intent(inout) :: nrec
      real,    intent(in)    :: rtime
      integer, intent(in)    :: nstat
      real, dimension(stat_out), intent(in) :: rstat
      character*3, dimension(maxq), intent(in) :: qname
      character*6, dimension(maxq), intent(in) :: budname

      character*160 filename
      integer(SIZE_T) :: stringlen
      integer(HID_T) :: file_id,dset_id,dspace_id,chunk_id,datatype_id
      integer(HID_T) :: desctype_id,unitstype_id,desc_id,units_id,aspace_id
      integer(HID_T) :: stats_group_id,memoryspace,filespace,var_id
      integer(HSIZE_T), dimension(1) :: maxdims,chunkdims,currentdims,singledims,offset
      character(len=6), parameter :: stats_group_name="stats"
      integer :: i,n,ierror
      integer :: rank,nvals
      character(len=20) :: varname
      character(len=20) :: units
      character(len=120)::  description
      character(len=8) :: text1
      character(len=30) :: text2
      integer :: stats_nrec

      call h5open_f (ierror)

      maxdims(1) = H5S_UNLIMITED_F
      chunkdims(1) = 100
      currentdims(1)=1
      singledims(1)=1
      offset(1)=0

      rank=1
      nvals=1

!     print *,'nrec = ',nrec
!     print *,'rtime = ',rtime

      filename = trim(output_basename)//'_stats.hdf5'
      if(nrec.eq.1) then 
             call h5fcreate_f(trim(filename),H5F_ACC_TRUNC_F,file_id,ierror)
             call h5gcreate_f(file_id,stats_group_name,stats_group_id,ierror)      
             call h5screate_simple_f(rank,singledims,filespace,ierror)
             call h5dcreate_f(file_id,'nrec',H5T_NATIVE_INTEGER,filespace,dset_id,ierror)
             stats_nrec = 0
      else
             call h5fopen_f(trim(filename),H5F_ACC_RDWR_F, file_id,ierror)
             call h5gopen_f(file_id,stats_group_name,stats_group_id,ierror)
             call h5dopen_f(file_id,'nrec',dset_id,ierror)
             call h5dread_f(dset_id,H5T_NATIVE_INTEGER,stats_nrec,singledims,ierror)
             call h5dclose_f(dset_id,ierror)
      endif

! ORF restarts need to be handled differently. We need to keep a record of where
! we left off in the stats file and only start writing after we catch up.
! It is highly likely that the stats file is not in sync with the restart file.
! stats_nrec is how many stats have been written to the stats file, is one less
! than regular nrec

      offset(1)=nrec-1
      currentdims(1)=nrec

      if ( (nrec-1) .eq. stats_nrec) then

      varname='time'
      description='model time'
      units='s'
      call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
            memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rtime)
 
      i=0
      if(adapt_dt.eq.1) then
            i=i+1
            varname='dt'
            description='average timestep (this simulation used adaptive timestepping)'
            units='s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if(stat_w.eq.1) then
            i=i+1
            varname='wmax'
            description='maximum vertical velocity'
            units='m/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='wmin'
            description='minimum vertical velocity'
            units='m/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if(stat_u.eq.1) then
            i=i+1
            varname='umax'
            description='maximum E/W wind speed'
            units='m/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='umin'
            description='minimum E/W wind speed'
            units='m/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='sumax'
            description='maximum surface E/W wind speed'
            units='m/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='sumin'
            description='minimum surface E/W wind speed'
            units='m/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if(stat_v.eq.1) then
            i=i+1
            varname='vmax'
            description='maximum N/S wind speed'
            units='m/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='vmin'
            description='minimum N/S wind speed'
            units='m/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='svmax'
            description='maximum surface N/S wind speed'
            units='m/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='svmin'
            description='minimum surface N/S wind speed'
            units='m/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if(stat_rmw.eq.1) then
            i=i+1
            varname='rmw'
            description='radius of maximum V'
            units='m'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if(stat_pipert.eq.1) then
            i=i+1
            varname='ppimax'
            description='maximum pi perturbation'
            units='dimensionless'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='ppimin'
            description='minimum pi perturbation'
            units='dimensionless'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif

      if(stat_prspert.eq.1) then
            i=i+1
            varname='ppmax'
            description='maximum pressure perturbation'
            units='Pa'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='ppmin'
            description='minimum pressure perturbation'
            units='Pa'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if(stat_thpert.eq.1) then
            i=i+1
            varname='thpmax'
            description='maximum potential temperature perturbation'
            units='K'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='thpmin'
            description='minimum potential temperature perturbation'
            units='K'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='sthpmax'
            description='maximum surface potential temperature perturbation'
            units='K'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='sthpmin'
            description='minimum surface potential temperature perturbation'
            units='K'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if(stat_q.eq.1) then
            do n=1,numq
                  text1='max     '
                  text2='max                           '
                  write(text1(4:6),156) qname(n)
                  write(text2(5:7),156) qname(n)
156 format(a3)
                  i=i+1
                  varname=text1
                  description=text2
                  units='kg/kg'
                  call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                        memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
 
                  text1='min     '
                  text2='min                           '
                  write(text1(4:6),156) qname(n)
                  write(text2(5:7),156) qname(n)
                  i=i+1
                  varname=text1
                  description=text2
                  units='kg/kg'
                  call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                        memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            enddo
      endif

      if(stat_tke.eq.1) then
            i=i+1
            varname='tkemax'
            description='maximum turbulent kinetic energy'
            units='m^2/s^2'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='tkemin'
            description='minimum turbulent kinetic energy'
            units='m^2/s^2'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if(stat_km.eq.1) then
            i=i+1
            varname='kmhmax'
            description='maximum horizontal eddy mixing coefficient for momentum'
            units='m^2/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='kmhmin'
            description='minimum horizontal eddy mixing coefficient for momentum'
            units='m^2/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='kmvmax'
            description='maximum vertical eddy mixing coefficient for momentum'
            units='m^2/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='kmvmin'
            description='minimum vertical eddy mixing coefficient for momentum'
            units='m^2/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if(stat_kh.eq.1) then
            i=i+1
            varname='khhmax'
            description='maximum horizontal eddy mixing coefficient for scalars'
            units='m^2/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='khhmin'
            description='minimum horizontal eddy mixing coefficient for scalars'
            units='m^2/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='khvmax'
            description='maximum vertical eddy mixing coefficient for scalars'
            units='m^2/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='khvmin'
            description='minimum vertical eddy mixing coefficient for scalars'
            units='m^2/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if(stat_div.eq.1) then
            i=i+1
            varname='divmax'
            description='maximum 3D divergence'
            units='s^{-1}'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='divmin'
            description='minimum 3D divergence'
            units='s^{-1}'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if(stat_rh.eq.1) then
            i=i+1
            varname='rhmax'
            description='maximum relative humidity'
            units='dimensionless'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='rhmin'
            description='minimum relative humidity'
            units='dimensionless'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if(stat_rhi.eq.1) then
            i=i+1
            varname='rhimax'
            description='maximum relative humidity wrt ice'
            units='dimensionless'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='rhimin'
            description='minimum relative humidity wrt ice'
            units='dimensionless'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if (iptra.eq.1) then
            do n=1,npt
                  text1='maxpt   '
                  text2='max pt                        '
                  write(text1(6:6),157) n
                  write(text2(7:7),157) n
157 format(i1)
                  i=i+1
                  varname=text1
                  description=text2
                  units='kg/kg'
                  call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                        memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
 
                  text1='minpt   '
                  text2='min pt                        '
                  write(text1(6:6),157) n
                  write(text2(7:7),157) n
                  i=i+1
                  varname=text1
                  description=text2
                  units='kg/kg'
                  call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                        memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            enddo
      endif
 
      if(stat_the.eq.1) then
            i=i+1
            varname='themax'
            description='maximum theta-e below 10 km'
            units='K'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='themin'
            description='minimum theta-e below 10 km'
            units='K'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='sthemax'
            description='maximum surface theta-e'
            units='K'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='sthemin'
            description='minimum surface theta-e'
            units='K'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if(stat_cloud.eq.1) then
            i=i+1
            varname='qctop'
            description='maximum cloud top height'
            units='m'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='qcbot'
            description='minimum cloud base height'
            units='m'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if(stat_sfcprs.eq.1) then
            i=i+1
            varname='sprsmax'
            description='maximum surface pressure'
            units='Pa'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='sprsmin'
            description='minumum surface pressure'
            units='Pa'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if(stat_wsp.eq.1) then
            i=i+1
            varname='wspmax'
            description='maximum wind speed'
            units='m/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='wspmin'
            description='minumum wind speed'
            units='m/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='swspmax'
            description='maximum surface wind speed'
            units='m/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='swspmin'
            description='minumum surface wind speed'
            units='m/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            if(idrag.eq.1)then
                  i=i+1
                  varname='wsp10max'
                  description='maximum 10 m wind speed'
                  units='m/s'
                  call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                        memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
                  i=i+1
                  varname='wsp10min'
                  description='minimum 10 m wind speed'
                  units='m/s'
                  call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                        memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            endif
      endif
 
      if(stat_cfl.eq.1) then
            if(adapt_dt.eq.1) then
                  i=i+1
                  varname='cflmax'
                  description='maximum Courant number (average - model ran with adaptive time stepping)'
                  units='dimensionless'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            else
                  i=i+1
                  varname='cflmax'
                  description='maximum Courant number'
                  units='dimensionless'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            endif
 
            i=i+1
            varname='kshmax'
            description='maximum horizontal K stability factor'
            units='dimensionless'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
 
            i=i+1
            varname='ksvmax'
            description='maximum vertical K stability factor'
            units='dimensionless'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if (stat_vort.eq.1) then
            i=i+1
            varname='vortsfc'
            description='maximum surface vertical vorticity'
            units='s^{-1}'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
 
            i=i+1
            varname='vort1km'
            description='maximum 1 km vertical vorticity'
            units='s^{-1}'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
 
            i=i+1
            varname='vort2km'
            description='maximum 2 km vertical vorticity'
            units='s^{-1}'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
 
            i=i+1
            varname='vort3km'
            description='maximum 3 km vertical vorticity'
            units='s^{-1}'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
 
            i=i+1
            varname='vort4km'
            description='maximum 4 km vertical vorticity'
            units='s^{-1}'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
 
            i=i+1
            varname='vort5km'
            description='maximum 5 km vertical vorticity'
            units='s^{-1}'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if(stat_tmass.eq.1) then
            i=i+1
            varname='tmass'
            description='total mass of dry air'
            units='kg'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
      if(stat_tmois.eq.1) then
            i=i+1
            varname='tmois'
            description='total mass of water vapor in air (doublecheck)'
            units='kg'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
! Note, tmois seems to be same as massqv 
      if(stat_qmass.eq.1)then
            do n=1,numq
                  if( (n.eq.nqv) .or.                                 &
                      (n.ge.nql1.and.n.le.nql2) .or.                  &
                      (n.ge.nqs1.and.n.le.nqs2.and.iice.eq.1) )then
                            text1='mass    '
                            text2='total mass of                 '
                            write(text1( 5: 7),156) qname(n)
                            write(text2(15:17),156) qname(n)
 
                            i=i+1
                            varname=text1
                            description=text2
                            units='kg'
                            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
                   endif
             enddo
       endif
 
      if(stat_tenerg.eq.1) then
            i=i+1
            varname='ek'
            description='total kinetic energy'
            units='J'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='ei'
            description='total internal energy'
            units='J'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='ep'
            description='total potential energy'
            units='J'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='le'
            description='total latent energy'
            units='J'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='et'
            description='total energy'
            units='J'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if(stat_mo.eq.1) then
            i=i+1
            varname='tmu'
            description='total E-W momentum '
            units='kg m/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='tmv'
            description='total N-S momentum '
            units='kg m/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='tmw'
            description='total vertical momentum '
            units='kg m/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
 
      if(stat_tmf.eq.1) then
            i=i+1
            varname='tmfu'
            description='total upward mass flux'
            units='kg/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            i=i+1
            varname='tmfd'
            description='total downward mass flux'
            units='kg/s'
            call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                  memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
      endif
      if(stat_pcn.eq.1)then
            do n=1,nbudget
                  text1='        '
                  text2='                              '
                  write(text1(1:6),158) budname(n)
                  write(text2(1:6),158) budname(n)
158 format(a6)
                  i=i+1
                  varname=text1
                  description=trim(text2)//' (microphysics water budget in qbudget array - try `grep qbudget solve.F`)'
                  units='kg'
                  call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                        memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            enddo
      endif
 
      IF(stat_qsrc.eq.1)THEN
            do n=1,numq
                  text1='as      '
                  text2='artificial source of          '
                  write(text1( 3: 5),156) qname(n)
                  write(text2(22:24),156) qname(n)
                  i=i+1
                  varname=text1
                  description=text2
                  units='kg'
                  call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                        memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            enddo
            do n=1,numq
                  text1='bs      '
                  text2='bndry source/sink of          '
                  write(text1( 3: 5),156) qname(n)
                  write(text2(22:24),156) qname(n)
                  i=i+1
                  varname=text1
                  description=text2
                  units='kg'
                  call writefloat_hdf_unlimited(rank,nvals,nrec,stats_group_id,varname,description,units,var_id,filespace, &
                        memoryspace,dset_id,chunk_id,chunkdims,maxdims,currentdims,singledims,offset,rstat(i))
            enddo
      endif

! Note: i should now equal stat_out (see procXXXXX.out file) or something is wrong
      if (i .ne. stat_out) then
            print *, 'Number of stats written in writestat_hdf5: ',i 
            print *, 'Number of stats caculated in param: ',stat_out
            print *, 'These two must be equal, something is wrong, likely in writestat_hdf5'
            call h5close_f (ierror)
            call stopcm1
      endif

!Now write nrec, only if we've gotten in here

      stats_nrec = nrec
      call h5dopen_f(file_id,'nrec',dset_id,ierror)
      call h5dwrite_f(dset_id,H5T_NATIVE_INTEGER,stats_nrec,singledims,ierror)
      call h5dclose_f(dset_id,ierror)
      endif ! stats_nrec .eq. nrec

! However we need  to increment nrec whether we are caught up or not otherwise
! we'll never catch up!

      nrec = nrec + 1

      call h5close_f (ierror)
#endif
! above endif matches #ifdef HDFOUT
      return
      end 

#ifdef HDF5RESTART
!--------------------------------------------------------------------------------------------MARK
! NOTE! This has not been fully tested yet, use at your own risk.
      subroutine write_restart_hdf5(nrec,prec,nwrite,nrst,         &
                               qbudget,asq,bsq,                          &
                               rain,sws,radbcw,radbce,radbcs,radbcn,     &
                               ua,va,wa,ppi,tha,qa,tkea,pta,pdata,rtime)
      use HDF5
      implicit none

      include 'input.incl'
      include 'constants.incl'

      real :: rtime
      integer nstep,nrec,prec,nwrite,nrst,itime
      real*8, dimension(nbudget) :: qbudget
      real*8, dimension(numq) :: asq,bsq
      real, dimension(ib:ie,jb:je,nrain) :: rain,sws
      real, dimension(jb:je,kb:ke) :: radbcw,radbce
      real, dimension(ib:ie,kb:ke) :: radbcs,radbcn
      real, dimension(ib:ie+1,jb:je,kb:ke) :: ua
      real, dimension(ib:ie,jb:je+1,kb:ke) :: va
      real, dimension(ib:ie,jb:je,kb:ke+1) :: wa
      real, dimension(ib:ie,jb:je,kb:ke) :: ppi,tha
      real, dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: qa
      real, dimension(ibt:iet,jbt:jet,kbt:ket) :: tkea
      real, dimension(ibp:iep,jbp:jep,kbp:kep,npt) :: pta
      real, dimension(npvals,nparcels) :: pdata

      character(len=160) filename
      character(len=120)  description
      character(len=20)   units
      character(len=20)   varname
      integer lt,flag,n
      character*5 ctime,crank
      character*4 cid
      integer ierror
      integer(HID_T) file_id,dspace_id,dset_id
      integer(HSIZE_T), dimension(4) :: dims,chunkdims
      character(LEN=7), parameter :: restart_group_name = 'restart'


            write(ctime,1102)int(rtime)
            write(cid,1103)ioid
      1102   format(i5.5)
      1103   format(i4.4)
            filedir = trim(output_path)//'/'//trim(output_basename)//'.'//ctime//'.rdir/'
            dircmd = 'mkdir -p '// trim(filedir)
            filename = trim(filedir)//trim(output_basename)//'.'//ctime//'_'//cid//'.restart_cm1hdf5'
            if (myid.eq.0) call system(dircmd)

            call h5pcreate_f(H5P_FILE_ACCESS_F, plist_id, ierror)
            info = MPI_INFO_NULL
            call h5pset_fapl_mpio_f(plist_id, mysubgroupcomm, info, ierror)
            call h5fcreate_f(trim(filename),H5F_ACC_TRUNC_F,file_id,ierror,access_prp=plist_id)
            call h5pclose_f(plist_id, ierror)

            if(myid.eq.0)then
                  write(outfile,*)
                  write(outfile,*) '  Writing to restart file:'
                  write(outfile,*) '  filename=',filename
                  write(outfile,*)
            endif

            varname='nstep'
            description='nstep'
            units='index'
            call h5_write_int  (file_id,varname,description,units,nx,.false.)

            varname='nrec'
            description='nrec'
            units='index'
            call h5_write_int  (file_id,varname,description,units,nx,.false.)

            varname='prec'
            description='prec'
            units='index'
            call h5_write_int  (file_id,varname,description,units,nx,.false.)

            varname='nwrite'
            description='nwrite'
            units='index'
            call h5_write_int  (file_id,varname,description,units,nx,.false.)

            varname='nrst'
            description='nrst'
            units='index'
            call h5_write_int  (file_id,varname,description,units,nx,.false.)

            varname='rtime'
            description='model time'
            units='s'
            call h5_write_float  (file_id,varname,description,units,nx,.false.)

            write(crank,1102)mysubgrouprank

            varname=trim('qbudget'//'_'//crank)
            description='qbudget'
            units='derp'
            dims(1)=nbudget;count(1)=nbudget;offset(1)=0
            call h5_write_1d_double(file_id,varname,description,units,qbudget,nbudget,dims,count,offset,mysubgrouprank)

            varname=trim('asq'//'_'//crank)
            description='asq'
            units='derp'
            dims(1)=numq;count(1)=numq;offset(1)=0
            call h5_write_1d_double(file_id,varname,description,units,qbudget,numq,dims,count,offset,mysubgrouprank)

            varname=trim('bsq'//'_'//crank)
            description='bsq'
            units='derp'
            dims(1)=numq;count(1)=numq;offset(1)=0
            call h5_write_1d_double(file_id,varname,description,units,qbudget,numq,dims,count,offset,mysubgrouprank)

            varname='rain'
            description='rain'
            units='derp'
! I am abandoning this code. It is too much of a hassle to cram restart
! files into parallel hdf5 files without creating new writetout routines
! because of all the different dimensions to deal with. I could go back
! to my old way (one file per mpi rank) but really what's the point,
! George already has his code working and restart files are only used
! for restarting, not analysis.

! Only caveat would be for very large simulations, only write 3000
! files or so at a time, and/or perhaps split them up into separate
! directories.

            call h5_write_3d_float(file_id,varname,description,units,rain,corexyztype,0,0,0)
      call h5_write_3d_float(group_id,  'rain                ',0,rain,ie-ib+1,je-jb+1,nrain,.false.)
      call h5_write_3d_float(group_id,  'sws                 ',0,sws,ie-ib+1,je-jb+1,nrain,.false.)
      call h5_write_3d_float(group_id,  'ua                  ',0,ua,ie+1-ib+1,je-jb+1,ke-kb+1,.false.)
      call h5_write_3d_float(group_id,  'va                  ',0,va,ie-ib+1,je+1-jb+1,ke-kb+1,.false.)
      call h5_write_3d_float(group_id,  'wa                  ',0,wa,ie-ib+1,je-jb+1,ke+1-kb+1,.false.)
      call h5_write_3d_float(group_id,  'ppi                 ',0,ppi,ie-ib+1,je-jb+1,ke-kb+1,.false.)
      call h5_write_3d_float(group_id,  'tha                 ',0,tha,ie-ib+1,je-jb+1,ke-kb+1,.false.)
      if(imoist.eq.1) call h5_write_4d_float(group_id,'qa                  ',0,qa,iem-ibm+1,jem-jbm+1,kem-kbm+1,numq,.false.)
      if(iturb.eq.1)  call h5_write_3d_float(group_id,'tkea                ',0,tkea,iet-ibt+1,jet-jbt+1,ket-kbt+1,.false.)
      if(iptra.eq.1)  call h5_write_4d_float(group_id,'pta                 ',0,pta,iep-ibp+1,jep-jbp+1,kep-kbp+1,npt,.false.)
      if(iprcl.eq.1)  call h5_write_2d_float(group_id,'pdata               ',pdata,npvals,nparcels)
      if(irbc.eq.4.and.ibw.eq.1) call h5_write_2d_float(group_id,'radbcw              ',radbcw,je-jb+1,ke-kb+1)
      if(irbc.eq.4.and.ibe.eq.1) call h5_write_2d_float(group_id,'radbce              ',radbce,je-jb+1,ke-kb+1)
      if(irbc.eq.4.and.ibs.eq.1) call h5_write_2d_float(group_id,'radbcs              ',radbcs,ie-ib+1,ke-kb+1)
      if(irbc.eq.4.and.ibn.eq.1) call h5_write_2d_float(group_id,'radbcn              ',radbcn,ie-ib+1,ke-kb+1)

      call h5close_f(ierror)

      return
      end

!--------------------------------------------------------------------------------------------MARK
! NOTE! This has not been fully tested yet, use at your own risk.

      subroutine read_restart_hdf5(nloop1,nrec,prec,nwrite,nrst,taptim,rsttim,   &
                              qbudget,asq,bsq,                              &
                              rain,sws,radbcw,radbce,radbcs,radbcn,         &
                              ua,va,wa,ppi,tha,qa,tkea,pta,pdata,rtime)
      use HDF5
      implicit none

      include 'input.incl'
      include 'constants.incl'

      integer nloop1,nrec,prec,nwrite,nrst,itime
      real*8 taptim,rsttim
      real*8, dimension(nbudget) :: qbudget
      real*8, dimension(numq) :: asq,bsq
      real, dimension(ib:ie,jb:je,nrain) :: rain,sws
      real, dimension(jb:je,kb:ke) :: radbcw,radbce
      real, dimension(ib:ie,kb:ke) :: radbcs,radbcn
      real, dimension(ib:ie+1,jb:je,kb:ke) :: ua
      real, dimension(ib:ie,jb:je+1,kb:ke) :: va
      real, dimension(ib:ie,jb:je,kb:ke+1) :: wa
      real, dimension(ib:ie,jb:je,kb:ke) :: ppi,tha
      real, dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: qa
      real, dimension(ibt:iet,jbt:jet,kbt:ket) :: tkea
      real, dimension(ibp:iep,jbp:jep,kbp:kep,npt) :: pta
      real, dimension(npvals,nparcels) :: pdata
      real rtime

      character*160 filename
      integer lt,flag,n
      character*5 ctime
      character*4 cid
      integer ierror
      integer(HID_T) file_id,group_id,dspace_id,dset_id
      integer(HSIZE_T), dimension(4) :: dims
      character(LEN=7), parameter :: restart_group_name = 'restart'

      call create_output_filename(mymcmid,filename,rstnum,'.cm1hdf5.restart     ')

      write(outfile,*)
      write(outfile,*) '  Reading from restart file!'
      write(outfile,*) '  filename=',filename
      write(outfile,*)

      call h5open_f(ierror)
      call h5fopen_f(filename,H5F_ACC_RDONLY_F,file_id,ierror)

      dims(1)=1

      call h5dopen_f(file_id,'/restart/nrec',dset_id,ierror)
      call h5dread_f(dset_id,H5T_NATIVE_INTEGER,nrec,dims,ierror)
      call h5dclose_f(dset_id,ierror)

      call h5dopen_f(file_id,'/restart/prec',dset_id,ierror)
      call h5dread_f(dset_id,H5T_NATIVE_INTEGER,prec,dims,ierror)
      call h5dclose_f(dset_id,ierror)

      call h5dopen_f(file_id,'/restart/nwrite',dset_id,ierror)
      call h5dread_f(dset_id,H5T_NATIVE_INTEGER,nwrite,dims,ierror)
      call h5dclose_f(dset_id,ierror)

      call h5dopen_f(file_id,'/restart/nrst',dset_id,ierror)
      call h5dread_f(dset_id,H5T_NATIVE_INTEGER,nrst,dims,ierror)
      call h5dclose_f(dset_id,ierror)

      call h5dopen_f(file_id,'/restart/rtime',dset_id,ierror)
      call h5dread_f(dset_id,H5T_NATIVE_REAL,rtime,dims,ierror)
      call h5dclose_f(dset_id,ierror)

      dims(1)=nbudget
      call h5dopen_f(file_id,'/restart/qbudget',dset_id,ierror)
      call h5dread_f(dset_id,H5T_NATIVE_DOUBLE,qbudget,dims,ierror)
      call h5dclose_f(dset_id,ierror)

      dims(1)=numq
      call h5dopen_f(file_id,'/restart/asq',dset_id,ierror)
      call h5dread_f(dset_id,H5T_NATIVE_DOUBLE,asq,dims,ierror)
      call h5dclose_f(dset_id,ierror)

      dims(1)=numq
      call h5dopen_f(file_id,'/restart/bsq',dset_id,ierror)
      call h5dread_f(dset_id,H5T_NATIVE_DOUBLE,bsq,dims,ierror)
      call h5dclose_f(dset_id,ierror)

      dims(1)=ie-ib+1
      dims(2)=je-jb+1
      dims(3)=nrain
      call h5dopen_f(file_id,'/restart/rain',dset_id,ierror)
      call h5dread_f(dset_id,H5T_NATIVE_REAL,rain,dims,ierror)
      call h5dclose_f(dset_id,ierror)

      dims(1)=ie-ib+1
      dims(2)=je-jb+1
      dims(3)=nrain
      call h5dopen_f(file_id,'/restart/sws',dset_id,ierror)
      call h5dread_f(dset_id,H5T_NATIVE_REAL,sws,dims,ierror)
      call h5dclose_f(dset_id,ierror)

      dims(1)=ie+1-ib+1
      dims(2)=je-jb+1
      dims(3)=ke-kb+1
      call h5dopen_f(file_id,'/restart/ua',dset_id,ierror)
      call h5dread_f(dset_id,H5T_NATIVE_REAL,ua,dims,ierror)
      call h5dclose_f(dset_id,ierror)

      dims(1)=ie-ib+1
      dims(2)=je+1-jb+1
      dims(3)=ke-kb+1
      call h5dopen_f(file_id,'/restart/va',dset_id,ierror)
      call h5dread_f(dset_id,H5T_NATIVE_REAL,va,dims,ierror)
      call h5dclose_f(dset_id,ierror)

      dims(1)=ie-ib+1
      dims(2)=je-jb+1
      dims(3)=ke+1-kb+1
      call h5dopen_f(file_id,'/restart/wa',dset_id,ierror)
      call h5dread_f(dset_id,H5T_NATIVE_REAL,wa,dims,ierror)
      call h5dclose_f(dset_id,ierror)

      dims(1)=ie-ib+1
      dims(2)=je-jb+1
      dims(3)=ke-kb+1
      call h5dopen_f(file_id,'/restart/ppi',dset_id,ierror)
      call h5dread_f(dset_id,H5T_NATIVE_REAL,ppi,dims,ierror)
      call h5dclose_f(dset_id,ierror)

      dims(1)=ie-ib+1
      dims(2)=je-jb+1
      dims(3)=ke-kb+1
      call h5dopen_f(file_id,'/restart/tha',dset_id,ierror)
      call h5dread_f(dset_id,H5T_NATIVE_REAL,tha,dims,ierror)
      call h5dclose_f(dset_id,ierror)

      if (imoist.eq.1) then
            dims(1)=iem-ibm+1
            dims(2)=jem-jbm+1
            dims(3)=kem-kbm+1
            dims(4)=numq
            call h5dopen_f(file_id,'/restart/qa',dset_id,ierror)
            call h5dread_f(dset_id,H5T_NATIVE_REAL,qa,dims,ierror)
            call h5dclose_f(dset_id,ierror)
      endif

      if (iturb.eq.1) then
            dims(1)=iet-ibt+1
            dims(2)=jet-jbt+1
            dims(3)=ket-kbt+1
            call h5dopen_f(file_id,'/restart/tkea',dset_id,ierror)
            call h5dread_f(dset_id,H5T_NATIVE_REAL,tkea,dims,ierror)
            call h5dclose_f(dset_id,ierror)
      endif

      if (iptra.eq.1) then
            dims(1)=iep-ibp+1
            dims(2)=jep-jbp+1
            dims(3)=kep-kbp+1
            dims(4)=npt
            call h5dopen_f(file_id,'/restart/pta',dset_id,ierror)
            call h5dread_f(dset_id,H5T_NATIVE_REAL,pta,dims,ierror)
            call h5dclose_f(dset_id,ierror)
      endif

      if (iprcl.eq.1) then
            dims(1)=npvals
            dims(2)=nparcels
            call h5dopen_f(file_id,'/restart/pdata',dset_id,ierror)
            call h5dread_f(dset_id,H5T_NATIVE_REAL,pdata,dims,ierror)
            call h5dclose_f(dset_id,ierror)
      endif

      if (irbc.eq.4.and.ibw.eq.1) then
            dims(1)=je-jb+1
            dims(2)=ke-kb+1
            call h5dopen_f(file_id,'/restart/radbcw',dset_id,ierror)
            call h5dread_f(dset_id,H5T_NATIVE_REAL,radbcw,dims,ierror)
            call h5dclose_f(dset_id,ierror)
      endif

      if (irbc.eq.4.and.ibe.eq.1) then
            dims(1)=je-jb+1
            dims(2)=ke-kb+1
            call h5dopen_f(file_id,'/restart/radbce',dset_id,ierror)
            call h5dread_f(dset_id,H5T_NATIVE_REAL,radbce,dims,ierror)
            call h5dclose_f(dset_id,ierror)
      endif

      if (irbc.eq.4.and.ibs.eq.1) then
            dims(1)=ie-ib+1
            dims(2)=ke-kb+1
            call h5dopen_f(file_id,'/restart/radbcs',dset_id,ierror)
            call h5dread_f(dset_id,H5T_NATIVE_REAL,radbcs,dims,ierror)
            call h5dclose_f(dset_id,ierror)
      endif

      if (irbc.eq.4.and.ibn.eq.1) then
            dims(1)=ie-ib+1
            dims(2)=ke-kb+1
            call h5dopen_f(file_id,'/restart/radbcn',dset_id,ierror)
            call h5dread_f(dset_id,H5T_NATIVE_REAL,radbcn,dims,ierror)
            call h5dclose_f(dset_id,ierror)
      endif

      call h5close_f (ierror)

      nloop1=nint(rtime/dtl)+1
      taptim=rtime+tapfrq
      rsttim=rtime+rstfrq
      prcltim=rtime+prclfrq
      nrec=nrec-stat_out

      write(outfile,*) nloop1,nrec,taptim,rsttim
      write(outfile,*)

      return
      end

#endif

!--------------------------------------------------------------------------------------------MARK


raddata3d.F/    1298670057  19071 8000  100644  206056    `
!
!##################################################################
!##################################################################
!######                                                      ######
!######                BLOCK DATA RADDATA                    ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######                University of Oklahoma                ######
!######                                                      ######
!##################################################################
!##################################################################
!
  BLOCK DATA raddata
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Initialize pre-calculated look-up tables used in radiation
!  computation.
!
!-----------------------------------------------------------------------
!
!  AUTHOR: Yuhe Liu
!  03/15/1996
!
!  Combined all files of look-up tables used in radiation computation
!  into this file. Different tables are identified by different
!  COMMON block names.
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

  INTEGER :: i, j, ip, iw
!
!-----------------------------------------------------------------------
!
!  The following DATA statements originally came from file
!  "h2o.tran3", which define pre-computed tables used for h2o (bands
!  1, 2, and 7 only) transmittance calculations.
!
!-----------------------------------------------------------------------
!
!  integer nx,no,nc,nh,nt
!  parameter (nx=26,no=21,nc=24,nh=31,nt=7)
!
!-----------------------------------------------------------------------
!
! h2o.tran3

  REAL :: h11(26,31,7),h12(26,31,7),h13(26,31,7)
  REAL :: h21(26,31,7),h22(26,31,7),h23(26,31,7)
  REAL :: h71(26,31,7),h72(26,31,7),h73(26,31,7)

  COMMON /radtab001/ h11,h12,h13,h21,h22,h23,h71,h72,h73

  DATA ((h11(ip,iw,1),iw=1,31),ip= 1, 1)/                               &
      0.6160E-04,  0.9815E-04,  0.1474E-03,  0.2092E-03,  0.2823E-03,   &
      0.3662E-03,  0.4615E-03,  0.5710E-03,  0.6998E-03,  0.8554E-03,   &
      0.1049E-02,  0.1295E-02,  0.1612E-02,  0.2021E-02,  0.2548E-02,   &
      0.3230E-02,  0.4123E-02,  0.5306E-02,  0.6887E-02,  0.9021E-02,   &
      0.1193E-01,  0.1590E-01,  0.2135E-01,  0.2885E-01,  0.3914E-01,   &
      0.5317E-01,  0.7223E-01,  0.9800E-01,  0.1326E+00,  0.1783E+00,   &
      0.2373E+00/
  DATA ((h12(ip,iw,1),iw=1,31),ip= 1, 1)/                               &
      -0.2021E-06, -0.3628E-06, -0.5891E-06, -0.8735E-06, -0.1204E-05,  &
      -0.1579E-05, -0.2002E-05, -0.2494E-05, -0.3093E-05, -0.3852E-05,  &
      -0.4835E-05, -0.6082E-05, -0.7591E-05, -0.9332E-05, -0.1128E-04,  &
      -0.1347E-04, -0.1596E-04, -0.1890E-04, -0.2241E-04, -0.2672E-04,  &
      -0.3208E-04, -0.3884E-04, -0.4747E-04, -0.5854E-04, -0.7272E-04,  &
      -0.9092E-04, -0.1146E-03, -0.1458E-03, -0.1877E-03, -0.2435E-03,  &
      -0.3159E-03/
  DATA ((h13(ip,iw,1),iw=1,31),ip= 1, 1)/                               &
      0.5907E-09,  0.8541E-09,  0.1095E-08,  0.1272E-08,  0.1297E-08,   &
      0.1105E-08,  0.6788E-09, -0.5585E-10, -0.1147E-08, -0.2746E-08,   &
      -0.5001E-08, -0.7715E-08, -0.1037E-07, -0.1227E-07, -0.1287E-07,  &
      -0.1175E-07, -0.8517E-08, -0.2920E-08,  0.4786E-08,  0.1407E-07,  &
      0.2476E-07,  0.3781E-07,  0.5633E-07,  0.8578E-07,  0.1322E-06,   &
      0.2013E-06,  0.3006E-06,  0.4409E-06,  0.6343E-06,  0.8896E-06,   &
      0.1216E-05/
  DATA ((h11(ip,iw,1),iw=1,31),ip= 2, 2)/                               &
      0.6166E-04,  0.9828E-04,  0.1477E-03,  0.2097E-03,  0.2833E-03,   &
      0.3680E-03,  0.4648E-03,  0.5768E-03,  0.7101E-03,  0.8736E-03,   &
      0.1080E-02,  0.1348E-02,  0.1700E-02,  0.2162E-02,  0.2767E-02,   &
      0.3563E-02,  0.4621E-02,  0.6039E-02,  0.7953E-02,  0.1056E-01,   &
      0.1412E-01,  0.1901E-01,  0.2574E-01,  0.3498E-01,  0.4763E-01,   &
      0.6484E-01,  0.8815E-01,  0.1196E+00,  0.1614E+00,  0.2157E+00,   &
      0.2844E+00/
  DATA ((h12(ip,iw,1),iw=1,31),ip= 2, 2)/                               &
      -0.2017E-06, -0.3620E-06, -0.5878E-06, -0.8713E-06, -0.1201E-05,  &
      -0.1572E-05, -0.1991E-05, -0.2476E-05, -0.3063E-05, -0.3808E-05,  &
      -0.4776E-05, -0.6011E-05, -0.7516E-05, -0.9272E-05, -0.1127E-04,  &
      -0.1355E-04, -0.1620E-04, -0.1936E-04, -0.2321E-04, -0.2797E-04,  &
      -0.3399E-04, -0.4171E-04, -0.5172E-04, -0.6471E-04, -0.8150E-04,  &
      -0.1034E-03, -0.1321E-03, -0.1705E-03, -0.2217E-03, -0.2889E-03,  &
      -0.3726E-03/
  DATA ((h13(ip,iw,1),iw=1,31),ip= 2, 2)/                               &
      0.5894E-09,  0.8519E-09,  0.1092E-08,  0.1267E-08,  0.1289E-08,   &
      0.1093E-08,  0.6601E-09, -0.7831E-10, -0.1167E-08, -0.2732E-08,   &
      -0.4864E-08, -0.7334E-08, -0.9581E-08, -0.1097E-07, -0.1094E-07,  &
      -0.8999E-08, -0.4669E-08,  0.2391E-08,  0.1215E-07,  0.2424E-07,  &
      0.3877E-07,  0.5711E-07,  0.8295E-07,  0.1218E-06,  0.1793E-06,   &
      0.2621E-06,  0.3812E-06,  0.5508E-06,  0.7824E-06,  0.1085E-05,   &
      0.1462E-05/
  DATA ((h11(ip,iw,1),iw=1,31),ip= 3, 3)/                               &
      0.6175E-04,  0.9849E-04,  0.1481E-03,  0.2106E-03,  0.2849E-03,   &
      0.3708E-03,  0.4698E-03,  0.5857E-03,  0.7257E-03,  0.9006E-03,   &
      0.1126E-02,  0.1425E-02,  0.1823E-02,  0.2353E-02,  0.3059E-02,   &
      0.4002E-02,  0.5270E-02,  0.6984E-02,  0.9316E-02,  0.1251E-01,   &
      0.1689E-01,  0.2292E-01,  0.3123E-01,  0.4262E-01,  0.5814E-01,   &
      0.7921E-01,  0.1077E+00,  0.1458E+00,  0.1957E+00,  0.2595E+00,   &
      0.3380E+00/
  DATA ((h12(ip,iw,1),iw=1,31),ip= 3, 3)/                               &
      -0.2011E-06, -0.3609E-06, -0.5859E-06, -0.8680E-06, -0.1195E-05,  &
      -0.1563E-05, -0.1975E-05, -0.2450E-05, -0.3024E-05, -0.3755E-05,  &
      -0.4711E-05, -0.5941E-05, -0.7455E-05, -0.9248E-05, -0.1132E-04,  &
      -0.1373E-04, -0.1659E-04, -0.2004E-04, -0.2431E-04, -0.2966E-04,  &
      -0.3653E-04, -0.4549E-04, -0.5724E-04, -0.7259E-04, -0.9265E-04,  &
      -0.1191E-03, -0.1543E-03, -0.2013E-03, -0.2633E-03, -0.3421E-03,  &
      -0.4350E-03/
  DATA ((h13(ip,iw,1),iw=1,31),ip= 3, 3)/                               &
      0.5872E-09,  0.8484E-09,  0.1087E-08,  0.1259E-08,  0.1279E-08,   &
      0.1077E-08,  0.6413E-09, -0.9334E-10, -0.1161E-08, -0.2644E-08,   &
      -0.4588E-08, -0.6709E-08, -0.8474E-08, -0.9263E-08, -0.8489E-08,  &
      -0.5553E-08,  0.1203E-09,  0.9035E-08,  0.2135E-07,  0.3689E-07,  &
      0.5610E-07,  0.8097E-07,  0.1155E-06,  0.1649E-06,  0.2350E-06,   &
      0.3353E-06,  0.4806E-06,  0.6858E-06,  0.9617E-06,  0.1315E-05,   &
      0.1741E-05/
  DATA ((h11(ip,iw,1),iw=1,31),ip= 4, 4)/                               &
      0.6189E-04,  0.9882E-04,  0.1488E-03,  0.2119E-03,  0.2873E-03,   &
      0.3752E-03,  0.4776E-03,  0.5993E-03,  0.7490E-03,  0.9403E-03,   &
      0.1192E-02,  0.1531E-02,  0.1990E-02,  0.2610E-02,  0.3446E-02,   &
      0.4576E-02,  0.6109E-02,  0.8196E-02,  0.1105E-01,  0.1498E-01,   &
      0.2039E-01,  0.2785E-01,  0.3809E-01,  0.5209E-01,  0.7112E-01,   &
      0.9688E-01,  0.1315E+00,  0.1773E+00,  0.2363E+00,  0.3100E+00,   &
      0.3976E+00/
  DATA ((h12(ip,iw,1),iw=1,31),ip= 4, 4)/                               &
      -0.2001E-06, -0.3592E-06, -0.5829E-06, -0.8631E-06, -0.1187E-05,  &
      -0.1549E-05, -0.1953E-05, -0.2415E-05, -0.2975E-05, -0.3694E-05,  &
      -0.4645E-05, -0.5882E-05, -0.7425E-05, -0.9279E-05, -0.1147E-04,  &
      -0.1406E-04, -0.1717E-04, -0.2100E-04, -0.2580E-04, -0.3191E-04,  &
      -0.3989E-04, -0.5042E-04, -0.6432E-04, -0.8261E-04, -0.1068E-03,  &
      -0.1389E-03, -0.1820E-03, -0.2391E-03, -0.3127E-03, -0.4021E-03,  &
      -0.5002E-03/
  DATA ((h13(ip,iw,1),iw=1,31),ip= 4, 4)/                               &
      0.5838E-09,  0.8426E-09,  0.1081E-08,  0.1249E-08,  0.1267E-08,   &
      0.1062E-08,  0.6313E-09, -0.8241E-10, -0.1094E-08, -0.2436E-08,   &
      -0.4100E-08, -0.5786E-08, -0.6992E-08, -0.7083E-08, -0.5405E-08,  &
      -0.1259E-08,  0.6099E-08,  0.1732E-07,  0.3276E-07,  0.5256E-07,  &
      0.7756E-07,  0.1103E-06,  0.1547E-06,  0.2159E-06,  0.3016E-06,   &
      0.4251E-06,  0.6033E-06,  0.8499E-06,  0.1175E-05,  0.1579E-05,   &
      0.2044E-05/
  DATA ((h11(ip,iw,1),iw=1,31),ip= 5, 5)/                               &
      0.6211E-04,  0.9932E-04,  0.1499E-03,  0.2140E-03,  0.2911E-03,   &
      0.3820E-03,  0.4895E-03,  0.6196E-03,  0.7834E-03,  0.9973E-03,   &
      0.1285E-02,  0.1678E-02,  0.2216E-02,  0.2951E-02,  0.3953E-02,   &
      0.5319E-02,  0.7186E-02,  0.9743E-02,  0.1326E-01,  0.1811E-01,   &
      0.2479E-01,  0.3400E-01,  0.4662E-01,  0.6379E-01,  0.8708E-01,   &
      0.1185E+00,  0.1603E+00,  0.2147E+00,  0.2835E+00,  0.3667E+00,   &
      0.4620E+00/
  DATA ((h12(ip,iw,1),iw=1,31),ip= 5, 5)/                               &
      -0.1987E-06, -0.3565E-06, -0.5784E-06, -0.8557E-06, -0.1175E-05,  &
      -0.1530E-05, -0.1923E-05, -0.2372E-05, -0.2919E-05, -0.3631E-05,  &
      -0.4587E-05, -0.5848E-05, -0.7442E-05, -0.9391E-05, -0.1173E-04,  &
      -0.1455E-04, -0.1801E-04, -0.2232E-04, -0.2779E-04, -0.3489E-04,  &
      -0.4428E-04, -0.5678E-04, -0.7333E-04, -0.9530E-04, -0.1246E-03,  &
      -0.1639E-03, -0.2164E-03, -0.2848E-03, -0.3697E-03, -0.4665E-03,  &
      -0.5646E-03/
  DATA ((h13(ip,iw,1),iw=1,31),ip= 5, 5)/                               &
      0.5785E-09,  0.8338E-09,  0.1071E-08,  0.1239E-08,  0.1256E-08,   &
      0.1057E-08,  0.6480E-09, -0.1793E-10, -0.9278E-09, -0.2051E-08,   &
      -0.3337E-08, -0.4514E-08, -0.5067E-08, -0.4328E-08, -0.1545E-08,  &
      0.4100E-08,  0.1354E-07,  0.2762E-07,  0.4690E-07,  0.7190E-07,   &
      0.1040E-06,  0.1459E-06,  0.2014E-06,  0.2764E-06,  0.3824E-06,   &
      0.5359E-06,  0.7532E-06,  0.1047E-05,  0.1424E-05,  0.1873E-05,   &
      0.2356E-05/
  DATA ((h11(ip,iw,1),iw=1,31),ip= 6, 6)/                               &
      0.6246E-04,  0.1001E-03,  0.1515E-03,  0.2171E-03,  0.2970E-03,   &
      0.3924E-03,  0.5072E-03,  0.6495E-03,  0.8329E-03,  0.1078E-02,   &
      0.1413E-02,  0.1876E-02,  0.2516E-02,  0.3399E-02,  0.4612E-02,   &
      0.6276E-02,  0.8562E-02,  0.1171E-01,  0.1605E-01,  0.2205E-01,   &
      0.3032E-01,  0.4167E-01,  0.5717E-01,  0.7821E-01,  0.1067E+00,   &
      0.1447E+00,  0.1948E+00,  0.2586E+00,  0.3372E+00,  0.4290E+00,   &
      0.5295E+00/
  DATA ((h12(ip,iw,1),iw=1,31),ip= 6, 6)/                               &
      -0.1964E-06, -0.3526E-06, -0.5717E-06, -0.8451E-06, -0.1158E-05,  &
      -0.1504E-05, -0.1886E-05, -0.2322E-05, -0.2861E-05, -0.3576E-05,  &
      -0.4552E-05, -0.5856E-05, -0.7529E-05, -0.9609E-05, -0.1216E-04,  &
      -0.1528E-04, -0.1916E-04, -0.2408E-04, -0.3043E-04, -0.3880E-04,  &
      -0.4997E-04, -0.6488E-04, -0.8474E-04, -0.1113E-03, -0.1471E-03,  &
      -0.1950E-03, -0.2583E-03, -0.3384E-03, -0.4326E-03, -0.5319E-03,  &
      -0.6244E-03/
  DATA ((h13(ip,iw,1),iw=1,31),ip= 6, 6)/                               &
      0.5713E-09,  0.8263E-09,  0.1060E-08,  0.1226E-08,  0.1252E-08,   &
      0.1076E-08,  0.7149E-09,  0.1379E-09, -0.6043E-09, -0.1417E-08,   &
      -0.2241E-08, -0.2830E-08, -0.2627E-08, -0.8950E-09,  0.3231E-08,  &
      0.1075E-07,  0.2278E-07,  0.4037E-07,  0.6439E-07,  0.9576E-07,   &
      0.1363E-06,  0.1886E-06,  0.2567E-06,  0.3494E-06,  0.4821E-06,   &
      0.6719E-06,  0.9343E-06,  0.1280E-05,  0.1705E-05,  0.2184E-05,   &
      0.2651E-05/
  DATA ((h11(ip,iw,1),iw=1,31),ip= 7, 7)/                               &
      0.6299E-04,  0.1013E-03,  0.1541E-03,  0.2220E-03,  0.3058E-03,   &
      0.4078E-03,  0.5334E-03,  0.6928E-03,  0.9032E-03,  0.1190E-02,   &
      0.1587E-02,  0.2140E-02,  0.2912E-02,  0.3982E-02,  0.5460E-02,   &
      0.7500E-02,  0.1031E-01,  0.1420E-01,  0.1958E-01,  0.2700E-01,   &
      0.3721E-01,  0.5118E-01,  0.7019E-01,  0.9593E-01,  0.1305E+00,   &
      0.1763E+00,  0.2354E+00,  0.3091E+00,  0.3969E+00,  0.4952E+00,   &
      0.5978E+00/
  DATA ((h12(ip,iw,1),iw=1,31),ip= 7, 7)/                               &
      -0.1932E-06, -0.3467E-06, -0.5623E-06, -0.8306E-06, -0.1136E-05,  &
      -0.1472E-05, -0.1842E-05, -0.2269E-05, -0.2807E-05, -0.3539E-05,  &
      -0.4553E-05, -0.5925E-05, -0.7710E-05, -0.9968E-05, -0.1278E-04,  &
      -0.1629E-04, -0.2073E-04, -0.2644E-04, -0.3392E-04, -0.4390E-04,  &
      -0.5727E-04, -0.7516E-04, -0.9916E-04, -0.1315E-03, -0.1752E-03,  &
      -0.2333E-03, -0.3082E-03, -0.3988E-03, -0.4982E-03, -0.5947E-03,  &
      -0.6764E-03/
  DATA ((h13(ip,iw,1),iw=1,31),ip= 7, 7)/                               &
      0.5612E-09,  0.8116E-09,  0.1048E-08,  0.1222E-08,  0.1270E-08,   &
      0.1141E-08,  0.8732E-09,  0.4336E-09, -0.6548E-10, -0.4774E-09,   &
      -0.7556E-09, -0.6577E-09,  0.4377E-09,  0.3359E-08,  0.9159E-08,  &
      0.1901E-07,  0.3422E-07,  0.5616E-07,  0.8598E-07,  0.1251E-06,   &
      0.1752E-06,  0.2392E-06,  0.3228E-06,  0.4389E-06,  0.6049E-06,   &
      0.8370E-06,  0.1150E-05,  0.1547E-05,  0.2012E-05,  0.2493E-05,   &
      0.2913E-05/
  DATA ((h11(ip,iw,1),iw=1,31),ip= 8, 8)/                               &
      0.6378E-04,  0.1032E-03,  0.1579E-03,  0.2293E-03,  0.3190E-03,   &
      0.4305E-03,  0.5712E-03,  0.7541E-03,  0.1001E-02,  0.1342E-02,   &
      0.1819E-02,  0.2489E-02,  0.3427E-02,  0.4734E-02,  0.6548E-02,   &
      0.9059E-02,  0.1254E-01,  0.1735E-01,  0.2401E-01,  0.3318E-01,   &
      0.4577E-01,  0.6292E-01,  0.8620E-01,  0.1176E+00,  0.1594E+00,   &
      0.2139E+00,  0.2827E+00,  0.3660E+00,  0.4614E+00,  0.5634E+00,   &
      0.6649E+00/
  DATA ((h12(ip,iw,1),iw=1,31),ip= 8, 8)/                               &
      -0.1885E-06, -0.3385E-06, -0.5493E-06, -0.8114E-06, -0.1109E-05,  &
      -0.1436E-05, -0.1796E-05, -0.2219E-05, -0.2770E-05, -0.3535E-05,  &
      -0.4609E-05, -0.6077E-05, -0.8016E-05, -0.1051E-04, -0.1367E-04,  &
      -0.1768E-04, -0.2283E-04, -0.2955E-04, -0.3849E-04, -0.5046E-04,  &
      -0.6653E-04, -0.8813E-04, -0.1173E-03, -0.1569E-03, -0.2100E-03,  &
      -0.2794E-03, -0.3656E-03, -0.4637E-03, -0.5629E-03, -0.6512E-03,  &
      -0.7167E-03/
  DATA ((h13(ip,iw,1),iw=1,31),ip= 8, 8)/                               &
      0.5477E-09,  0.8000E-09,  0.1039E-08,  0.1234E-08,  0.1331E-08,   &
      0.1295E-08,  0.1160E-08,  0.9178E-09,  0.7535E-09,  0.8301E-09,   &
      0.1184E-08,  0.2082E-08,  0.4253E-08,  0.8646E-08,  0.1650E-07,   &
      0.2920E-07,  0.4834E-07,  0.7564E-07,  0.1125E-06,  0.1606E-06,   &
      0.2216E-06,  0.2992E-06,  0.4031E-06,  0.5493E-06,  0.7549E-06,   &
      0.1035E-05,  0.1400E-05,  0.1843E-05,  0.2327E-05,  0.2774E-05,   &
      0.3143E-05/
  DATA ((h11(ip,iw,1),iw=1,31),ip= 9, 9)/                               &
      0.6495E-04,  0.1059E-03,  0.1635E-03,  0.2400E-03,  0.3381E-03,   &
      0.4631E-03,  0.6246E-03,  0.8394E-03,  0.1134E-02,  0.1546E-02,   &
      0.2126E-02,  0.2944E-02,  0.4093E-02,  0.5699E-02,  0.7934E-02,   &
      0.1104E-01,  0.1535E-01,  0.2131E-01,  0.2956E-01,  0.4089E-01,   &
      0.5636E-01,  0.7739E-01,  0.1058E+00,  0.1439E+00,  0.1939E+00,   &
      0.2578E+00,  0.3364E+00,  0.4283E+00,  0.5290E+00,  0.6314E+00,   &
      0.7292E+00/
  DATA ((h12(ip,iw,1),iw=1,31),ip= 9, 9)/                               &
      -0.1822E-06, -0.3274E-06, -0.5325E-06, -0.7881E-06, -0.1079E-05,  &
      -0.1398E-05, -0.1754E-05, -0.2184E-05, -0.2763E-05, -0.3581E-05,  &
      -0.4739E-05, -0.6341E-05, -0.8484E-05, -0.1128E-04, -0.1490E-04,  &
      -0.1955E-04, -0.2561E-04, -0.3364E-04, -0.4438E-04, -0.5881E-04,  &
      -0.7822E-04, -0.1045E-03, -0.1401E-03, -0.1884E-03, -0.2523E-03,  &
      -0.3335E-03, -0.4289E-03, -0.5296E-03, -0.6231E-03, -0.6980E-03,  &
      -0.7406E-03/
  DATA ((h13(ip,iw,1),iw=1,31),ip= 9, 9)/                               &
      0.5334E-09,  0.7859E-09,  0.1043E-08,  0.1279E-08,  0.1460E-08,   &
      0.1560E-08,  0.1618E-08,  0.1657E-08,  0.1912E-08,  0.2569E-08,   &
      0.3654E-08,  0.5509E-08,  0.8964E-08,  0.1518E-07,  0.2560E-07,   &
      0.4178E-07,  0.6574E-07,  0.9958E-07,  0.1449E-06,  0.2031E-06,   &
      0.2766E-06,  0.3718E-06,  0.5022E-06,  0.6849E-06,  0.9360E-06,   &
      0.1268E-05,  0.1683E-05,  0.2157E-05,  0.2625E-05,  0.3020E-05,   &
      0.3364E-05/
  DATA ((h11(ip,iw,1),iw=1,31),ip=10,10)/                               &
      0.6661E-04,  0.1098E-03,  0.1716E-03,  0.2554E-03,  0.3653E-03,   &
      0.5088E-03,  0.6986E-03,  0.9557E-03,  0.1313E-02,  0.1816E-02,   &
      0.2527E-02,  0.3532E-02,  0.4947E-02,  0.6929E-02,  0.9694E-02,   &
      0.1354E-01,  0.1888E-01,  0.2628E-01,  0.3647E-01,  0.5043E-01,   &
      0.6941E-01,  0.9514E-01,  0.1297E+00,  0.1755E+00,  0.2347E+00,   &
      0.3084E+00,  0.3962E+00,  0.4947E+00,  0.5974E+00,  0.6973E+00,   &
      0.7898E+00/
  DATA ((h12(ip,iw,1),iw=1,31),ip=10,10)/                               &
      -0.1742E-06, -0.3134E-06, -0.5121E-06, -0.7619E-06, -0.1048E-05,  &
      -0.1364E-05, -0.1725E-05, -0.2177E-05, -0.2801E-05, -0.3694E-05,  &
      -0.4969E-05, -0.6748E-05, -0.9161E-05, -0.1236E-04, -0.1655E-04,  &
      -0.2203E-04, -0.2927E-04, -0.3894E-04, -0.5192E-04, -0.6936E-04,  &
      -0.9294E-04, -0.1250E-03, -0.1686E-03, -0.2271E-03, -0.3027E-03,  &
      -0.3944E-03, -0.4951E-03, -0.5928E-03, -0.6755E-03, -0.7309E-03,  &
      -0.7417E-03/
  DATA ((h13(ip,iw,1),iw=1,31),ip=10,10)/                               &
      0.5179E-09,  0.7789E-09,  0.1071E-08,  0.1382E-08,  0.1690E-08,   &
      0.1979E-08,  0.2297E-08,  0.2704E-08,  0.3466E-08,  0.4794E-08,   &
      0.6746E-08,  0.9739E-08,  0.1481E-07,  0.2331E-07,  0.3679E-07,   &
      0.5726E-07,  0.8716E-07,  0.1289E-06,  0.1837E-06,  0.2534E-06,   &
      0.3424E-06,  0.4609E-06,  0.6245E-06,  0.8495E-06,  0.1151E-05,   &
      0.1536E-05,  0.1991E-05,  0.2468E-05,  0.2891E-05,  0.3245E-05,   &
      0.3580E-05/
  DATA ((h11(ip,iw,1),iw=1,31),ip=11,11)/                               &
      0.6888E-04,  0.1151E-03,  0.1828E-03,  0.2766E-03,  0.4028E-03,   &
      0.5713E-03,  0.7987E-03,  0.1111E-02,  0.1548E-02,  0.2167E-02,   &
      0.3044E-02,  0.4285E-02,  0.6035E-02,  0.8490E-02,  0.1192E-01,   &
      0.1670E-01,  0.2333E-01,  0.3249E-01,  0.4506E-01,  0.6220E-01,   &
      0.8546E-01,  0.1168E+00,  0.1587E+00,  0.2131E+00,  0.2820E+00,   &
      0.3653E+00,  0.4609E+00,  0.5630E+00,  0.6645E+00,  0.7599E+00,   &
      0.8458E+00/
  DATA ((h12(ip,iw,1),iw=1,31),ip=11,11)/                               &
      -0.1647E-06, -0.2974E-06, -0.4900E-06, -0.7358E-06, -0.1022E-05,  &
      -0.1344E-05, -0.1721E-05, -0.2212E-05, -0.2901E-05, -0.3896E-05,  &
      -0.5327E-05, -0.7342E-05, -0.1011E-04, -0.1382E-04, -0.1875E-04,  &
      -0.2530E-04, -0.3403E-04, -0.4573E-04, -0.6145E-04, -0.8264E-04,  &
      -0.1114E-03, -0.1507E-03, -0.2039E-03, -0.2737E-03, -0.3607E-03,  &
      -0.4599E-03, -0.5604E-03, -0.6497E-03, -0.7161E-03, -0.7443E-03,  &
      -0.7133E-03/
  DATA ((h13(ip,iw,1),iw=1,31),ip=11,11)/                               &
      0.5073E-09,  0.7906E-09,  0.1134E-08,  0.1560E-08,  0.2046E-08,   &
      0.2589E-08,  0.3254E-08,  0.4107E-08,  0.5481E-08,  0.7602E-08,   &
      0.1059E-07,  0.1501E-07,  0.2210E-07,  0.3334E-07,  0.5055E-07,   &
      0.7629E-07,  0.1134E-06,  0.1642E-06,  0.2298E-06,  0.3133E-06,   &
      0.4225E-06,  0.5709E-06,  0.7739E-06,  0.1047E-05,  0.1401E-05,   &
      0.1833E-05,  0.2308E-05,  0.2753E-05,  0.3125E-05,  0.3467E-05,   &
      0.3748E-05/
  DATA ((h11(ip,iw,1),iw=1,31),ip=12,12)/                               &
      0.7179E-04,  0.1221E-03,  0.1975E-03,  0.3049E-03,  0.4529E-03,   &
      0.6547E-03,  0.9312E-03,  0.1315E-02,  0.1855E-02,  0.2620E-02,   &
      0.3705E-02,  0.5243E-02,  0.7414E-02,  0.1046E-01,  0.1472E-01,   &
      0.2065E-01,  0.2888E-01,  0.4019E-01,  0.5566E-01,  0.7668E-01,   &
      0.1051E+00,  0.1432E+00,  0.1932E+00,  0.2571E+00,  0.3358E+00,   &
      0.4278E+00,  0.5285E+00,  0.6310E+00,  0.7289E+00,  0.8184E+00,   &
      0.8954E+00/
  DATA ((h12(ip,iw,1),iw=1,31),ip=12,12)/                               &
      -0.1548E-06, -0.2808E-06, -0.4683E-06, -0.7142E-06, -0.1008E-05,  &
      -0.1347E-05, -0.1758E-05, -0.2306E-05, -0.3083E-05, -0.4214E-05,  &
      -0.5851E-05, -0.8175E-05, -0.1140E-04, -0.1577E-04, -0.2166E-04,  &
      -0.2955E-04, -0.4014E-04, -0.5434E-04, -0.7343E-04, -0.9931E-04,  &
      -0.1346E-03, -0.1826E-03, -0.2467E-03, -0.3283E-03, -0.4246E-03,  &
      -0.5264E-03, -0.6211E-03, -0.6970E-03, -0.7402E-03, -0.7316E-03,  &
      -0.6486E-03/
  DATA ((h13(ip,iw,1),iw=1,31),ip=12,12)/                               &
      0.5078E-09,  0.8244E-09,  0.1255E-08,  0.1826E-08,  0.2550E-08,   &
      0.3438E-08,  0.4532E-08,  0.5949E-08,  0.8041E-08,  0.1110E-07,   &
      0.1534E-07,  0.2157E-07,  0.3116E-07,  0.4570E-07,  0.6747E-07,   &
      0.9961E-07,  0.1451E-06,  0.2061E-06,  0.2843E-06,  0.3855E-06,   &
      0.5213E-06,  0.7060E-06,  0.9544E-06,  0.1280E-05,  0.1684E-05,   &
      0.2148E-05,  0.2609E-05,  0.3002E-05,  0.3349E-05,  0.3670E-05,   &
      0.3780E-05/
  DATA ((h11(ip,iw,1),iw=1,31),ip=13,13)/                               &
      0.7529E-04,  0.1306E-03,  0.2160E-03,  0.3410E-03,  0.5175E-03,   &
      0.7626E-03,  0.1103E-02,  0.1577E-02,  0.2246E-02,  0.3196E-02,   &
      0.4544E-02,  0.6455E-02,  0.9152E-02,  0.1294E-01,  0.1823E-01,   &
      0.2560E-01,  0.3577E-01,  0.4971E-01,  0.6870E-01,  0.9443E-01,   &
      0.1290E+00,  0.1748E+00,  0.2340E+00,  0.3078E+00,  0.3956E+00,   &
      0.4942E+00,  0.5969E+00,  0.6970E+00,  0.7896E+00,  0.8714E+00,   &
      0.9364E+00/
  DATA ((h12(ip,iw,1),iw=1,31),ip=13,13)/                               &
      -0.1461E-06, -0.2663E-06, -0.4512E-06, -0.7027E-06, -0.1014E-05,  &
      -0.1387E-05, -0.1851E-05, -0.2478E-05, -0.3373E-05, -0.4682E-05,  &
      -0.6588E-05, -0.9311E-05, -0.1311E-04, -0.1834E-04, -0.2544E-04,  &
      -0.3502E-04, -0.4789E-04, -0.6515E-04, -0.8846E-04, -0.1202E-03,  &
      -0.1635E-03, -0.2217E-03, -0.2975E-03, -0.3897E-03, -0.4913E-03,  &
      -0.5902E-03, -0.6740E-03, -0.7302E-03, -0.7415E-03, -0.6858E-03,  &
      -0.5447E-03/
  DATA ((h13(ip,iw,1),iw=1,31),ip=13,13)/                               &
      0.5236E-09,  0.8873E-09,  0.1426E-08,  0.2193E-08,  0.3230E-08,   &
      0.4555E-08,  0.6200E-08,  0.8298E-08,  0.1126E-07,  0.1544E-07,   &
      0.2130E-07,  0.2978E-07,  0.4239E-07,  0.6096E-07,  0.8829E-07,   &
      0.1280E-06,  0.1830E-06,  0.2555E-06,  0.3493E-06,  0.4740E-06,   &
      0.6431E-06,  0.8701E-06,  0.1169E-05,  0.1547E-05,  0.1992E-05,   &
      0.2460E-05,  0.2877E-05,  0.3230E-05,  0.3569E-05,  0.3782E-05,   &
      0.3591E-05/
  DATA ((h11(ip,iw,1),iw=1,31),ip=14,14)/                               &
      0.7911E-04,  0.1403E-03,  0.2378E-03,  0.3847E-03,  0.5973E-03,   &
      0.8978E-03,  0.1319E-02,  0.1909E-02,  0.2741E-02,  0.3923E-02,   &
      0.5600E-02,  0.7977E-02,  0.1133E-01,  0.1604E-01,  0.2262E-01,   &
      0.3174E-01,  0.4429E-01,  0.6143E-01,  0.8469E-01,  0.1161E+00,   &
      0.1579E+00,  0.2124E+00,  0.2813E+00,  0.3647E+00,  0.4603E+00,   &
      0.5625E+00,  0.6641E+00,  0.7596E+00,  0.8456E+00,  0.9170E+00,   &
      0.9670E+00/
  DATA ((h12(ip,iw,1),iw=1,31),ip=14,14)/                               &
      -0.1402E-06, -0.2569E-06, -0.4428E-06, -0.7076E-06, -0.1051E-05,  &
      -0.1478E-05, -0.2019E-05, -0.2752E-05, -0.3802E-05, -0.5343E-05,  &
      -0.7594E-05, -0.1082E-04, -0.1536E-04, -0.2166E-04, -0.3028E-04,  &
      -0.4195E-04, -0.5761E-04, -0.7867E-04, -0.1072E-03, -0.1462E-03,  &
      -0.1990E-03, -0.2687E-03, -0.3559E-03, -0.4558E-03, -0.5572E-03,  &
      -0.6476E-03, -0.7150E-03, -0.7439E-03, -0.7133E-03, -0.6015E-03,  &
      -0.4089E-03/
  DATA ((h13(ip,iw,1),iw=1,31),ip=14,14)/                               &
      0.5531E-09,  0.9757E-09,  0.1644E-08,  0.2650E-08,  0.4074E-08,   &
      0.5957E-08,  0.8314E-08,  0.1128E-07,  0.1528E-07,  0.2087E-07,   &
      0.2874E-07,  0.4002E-07,  0.5631E-07,  0.7981E-07,  0.1139E-06,   &
      0.1621E-06,  0.2275E-06,  0.3136E-06,  0.4280E-06,  0.5829E-06,   &
      0.7917E-06,  0.1067E-05,  0.1419E-05,  0.1844E-05,  0.2310E-05,   &
      0.2747E-05,  0.3113E-05,  0.3455E-05,  0.3739E-05,  0.3715E-05,   &
      0.3125E-05/
  DATA ((h11(ip,iw,1),iw=1,31),ip=15,15)/                               &
      0.8292E-04,  0.1503E-03,  0.2614E-03,  0.4345E-03,  0.6915E-03,   &
      0.1061E-02,  0.1584E-02,  0.2320E-02,  0.3359E-02,  0.4831E-02,   &
      0.6920E-02,  0.9877E-02,  0.1405E-01,  0.1990E-01,  0.2805E-01,   &
      0.3933E-01,  0.5477E-01,  0.7579E-01,  0.1042E+00,  0.1423E+00,   &
      0.1924E+00,  0.2564E+00,  0.3351E+00,  0.4271E+00,  0.5280E+00,   &
      0.6306E+00,  0.7286E+00,  0.8182E+00,  0.8952E+00,  0.9530E+00,   &
      0.9864E+00/
  DATA ((h12(ip,iw,1),iw=1,31),ip=15,15)/                               &
      -0.1378E-06, -0.2542E-06, -0.4461E-06, -0.7333E-06, -0.1125E-05,  &
      -0.1630E-05, -0.2281E-05, -0.3159E-05, -0.4410E-05, -0.6246E-05,  &
      -0.8933E-05, -0.1280E-04, -0.1826E-04, -0.2589E-04, -0.3639E-04,  &
      -0.5059E-04, -0.6970E-04, -0.9552E-04, -0.1307E-03, -0.1784E-03,  &
      -0.2422E-03, -0.3237E-03, -0.4203E-03, -0.5227E-03, -0.6184E-03,  &
      -0.6953E-03, -0.7395E-03, -0.7315E-03, -0.6487E-03, -0.4799E-03,  &
      -0.2625E-03/
  DATA ((h13(ip,iw,1),iw=1,31),ip=15,15)/                               &
      0.5891E-09,  0.1074E-08,  0.1885E-08,  0.3167E-08,  0.5051E-08,   &
      0.7631E-08,  0.1092E-07,  0.1500E-07,  0.2032E-07,  0.2769E-07,   &
      0.3810E-07,  0.5279E-07,  0.7361E-07,  0.1032E-06,  0.1450E-06,   &
      0.2026E-06,  0.2798E-06,  0.3832E-06,  0.5242E-06,  0.7159E-06,   &
      0.9706E-06,  0.1299E-05,  0.1701E-05,  0.2159E-05,  0.2612E-05,   &
      0.2998E-05,  0.3341E-05,  0.3661E-05,  0.3775E-05,  0.3393E-05,   &
      0.2384E-05/
  DATA ((h11(ip,iw,1),iw=1,31),ip=16,16)/                               &
      0.8637E-04,  0.1598E-03,  0.2853E-03,  0.4876E-03,  0.7970E-03,   &
      0.1251E-02,  0.1901E-02,  0.2820E-02,  0.4118E-02,  0.5955E-02,   &
      0.8557E-02,  0.1224E-01,  0.1742E-01,  0.2467E-01,  0.3476E-01,   &
      0.4864E-01,  0.6759E-01,  0.9332E-01,  0.1280E+00,  0.1738E+00,   &
      0.2330E+00,  0.3069E+00,  0.3949E+00,  0.4935E+00,  0.5964E+00,   &
      0.6965E+00,  0.7893E+00,  0.8713E+00,  0.9363E+00,  0.9780E+00,   &
      0.9961E+00/
  DATA ((h12(ip,iw,1),iw=1,31),ip=16,16)/                               &
      -0.1383E-06, -0.2577E-06, -0.4608E-06, -0.7793E-06, -0.1237E-05,  &
      -0.1850E-05, -0.2652E-05, -0.3728E-05, -0.5244E-05, -0.7451E-05,  &
      -0.1067E-04, -0.1532E-04, -0.2193E-04, -0.3119E-04, -0.4395E-04,  &
      -0.6126E-04, -0.8466E-04, -0.1164E-03, -0.1596E-03, -0.2177E-03,  &
      -0.2933E-03, -0.3855E-03, -0.4874E-03, -0.5870E-03, -0.6718E-03,  &
      -0.7290E-03, -0.7411E-03, -0.6859E-03, -0.5450E-03, -0.3353E-03,  &
      -0.1363E-03/
  DATA ((h13(ip,iw,1),iw=1,31),ip=16,16)/                               &
      0.6217E-09,  0.1165E-08,  0.2116E-08,  0.3685E-08,  0.6101E-08,   &
      0.9523E-08,  0.1400E-07,  0.1959E-07,  0.2668E-07,  0.3629E-07,   &
      0.4982E-07,  0.6876E-07,  0.9523E-07,  0.1321E-06,  0.1825E-06,   &
      0.2505E-06,  0.3420E-06,  0.4677E-06,  0.6416E-06,  0.8760E-06,   &
      0.1183E-05,  0.1565E-05,  0.2010E-05,  0.2472E-05,  0.2882E-05,   &
      0.3229E-05,  0.3564E-05,  0.3777E-05,  0.3589E-05,  0.2786E-05,   &
      0.1487E-05/
  DATA ((h11(ip,iw,1),iw=1,31),ip=17,17)/                               &
      0.8925E-04,  0.1682E-03,  0.3074E-03,  0.5403E-03,  0.9085E-03,   &
      0.1463E-02,  0.2268E-02,  0.3416E-02,  0.5040E-02,  0.7333E-02,   &
      0.1057E-01,  0.1515E-01,  0.2157E-01,  0.3055E-01,  0.4297E-01,   &
      0.6001E-01,  0.8323E-01,  0.1146E+00,  0.1565E+00,  0.2111E+00,   &
      0.2801E+00,  0.3636E+00,  0.4594E+00,  0.5618E+00,  0.6636E+00,   &
      0.7592E+00,  0.8454E+00,  0.9169E+00,  0.9669E+00,  0.9923E+00,   &
      0.9995E+00/
  DATA ((h12(ip,iw,1),iw=1,31),ip=17,17)/                               &
      -0.1405E-06, -0.2649E-06, -0.4829E-06, -0.8398E-06, -0.1379E-05,  &
      -0.2132E-05, -0.3138E-05, -0.4487E-05, -0.6353E-05, -0.9026E-05,  &
      -0.1290E-04, -0.1851E-04, -0.2650E-04, -0.3772E-04, -0.5319E-04,  &
      -0.7431E-04, -0.1031E-03, -0.1422E-03, -0.1951E-03, -0.2648E-03,  &
      -0.3519E-03, -0.4518E-03, -0.5537E-03, -0.6449E-03, -0.7133E-03,  &
      -0.7432E-03, -0.7133E-03, -0.6018E-03, -0.4092E-03, -0.1951E-03,  &
      -0.5345E-04/
  DATA ((h13(ip,iw,1),iw=1,31),ip=17,17)/                               &
      0.6457E-09,  0.1235E-08,  0.2303E-08,  0.4149E-08,  0.7120E-08,   &
      0.1152E-07,  0.1749E-07,  0.2508E-07,  0.3462E-07,  0.4718E-07,   &
      0.6452E-07,  0.8874E-07,  0.1222E-06,  0.1675E-06,  0.2276E-06,   &
      0.3076E-06,  0.4174E-06,  0.5714E-06,  0.7837E-06,  0.1067E-05,   &
      0.1428E-05,  0.1859E-05,  0.2327E-05,  0.2760E-05,  0.3122E-05,   &
      0.3458E-05,  0.3739E-05,  0.3715E-05,  0.3126E-05,  0.1942E-05,   &
      0.6977E-06/
  DATA ((h11(ip,iw,1),iw=1,31),ip=18,18)/                               &
      0.9151E-04,  0.1750E-03,  0.3265E-03,  0.5891E-03,  0.1020E-02,   &
      0.1688E-02,  0.2679E-02,  0.4109E-02,  0.6138E-02,  0.9002E-02,   &
      0.1304E-01,  0.1871E-01,  0.2667E-01,  0.3773E-01,  0.5299E-01,   &
      0.7386E-01,  0.1022E+00,  0.1403E+00,  0.1905E+00,  0.2546E+00,   &
      0.3335E+00,  0.4258E+00,  0.5269E+00,  0.6297E+00,  0.7280E+00,   &
      0.8178E+00,  0.8950E+00,  0.9529E+00,  0.9864E+00,  0.9983E+00,   &
      0.1000E+01/
  DATA ((h12(ip,iw,1),iw=1,31),ip=18,18)/                               &
      -0.1431E-06, -0.2731E-06, -0.5072E-06, -0.9057E-06, -0.1537E-05,  &
      -0.2460E-05, -0.3733E-05, -0.5449E-05, -0.7786E-05, -0.1106E-04,  &
      -0.1574E-04, -0.2249E-04, -0.3212E-04, -0.4564E-04, -0.6438E-04,  &
      -0.9019E-04, -0.1256E-03, -0.1737E-03, -0.2378E-03, -0.3196E-03,  &
      -0.4163E-03, -0.5191E-03, -0.6154E-03, -0.6931E-03, -0.7384E-03,  &
      -0.7313E-03, -0.6492E-03, -0.4805E-03, -0.2629E-03, -0.8897E-04,  &
      -0.1432E-04/
  DATA ((h13(ip,iw,1),iw=1,31),ip=18,18)/                               &
      0.6607E-09,  0.1282E-08,  0.2441E-08,  0.4522E-08,  0.8027E-08,   &
      0.1348E-07,  0.2122E-07,  0.3139E-07,  0.4435E-07,  0.6095E-07,   &
      0.8319E-07,  0.1139E-06,  0.1557E-06,  0.2107E-06,  0.2819E-06,   &
      0.3773E-06,  0.5107E-06,  0.6982E-06,  0.9542E-06,  0.1290E-05,   &
      0.1703E-05,  0.2170E-05,  0.2628E-05,  0.3013E-05,  0.3352E-05,   &
      0.3669E-05,  0.3780E-05,  0.3397E-05,  0.2386E-05,  0.1062E-05,   &
      0.2216E-06/
  DATA ((h11(ip,iw,1),iw=1,31),ip=19,19)/                               &
      0.9320E-04,  0.1803E-03,  0.3422E-03,  0.6317E-03,  0.1124E-02,   &
      0.1915E-02,  0.3121E-02,  0.4890E-02,  0.7421E-02,  0.1100E-01,   &
      0.1602E-01,  0.2306E-01,  0.3288E-01,  0.4647E-01,  0.6515E-01,   &
      0.9066E-01,  0.1252E+00,  0.1710E+00,  0.2304E+00,  0.3045E+00,   &
      0.3928E+00,  0.4918E+00,  0.5951E+00,  0.6956E+00,  0.7887E+00,   &
      0.8709E+00,  0.9361E+00,  0.9780E+00,  0.9961E+00,  0.9999E+00,   &
      0.1000E+01/
  DATA ((h12(ip,iw,1),iw=1,31),ip=19,19)/                               &
      -0.1454E-06, -0.2805E-06, -0.5296E-06, -0.9685E-06, -0.1695E-05,  &
      -0.2812E-05, -0.4412E-05, -0.6606E-05, -0.9573E-05, -0.1363E-04,  &
      -0.1932E-04, -0.2743E-04, -0.3897E-04, -0.5520E-04, -0.7787E-04,  &
      -0.1094E-03, -0.1529E-03, -0.2117E-03, -0.2880E-03, -0.3809E-03,  &
      -0.4834E-03, -0.5836E-03, -0.6692E-03, -0.7275E-03, -0.7408E-03,  &
      -0.6865E-03, -0.5459E-03, -0.3360E-03, -0.1365E-03, -0.2935E-04,  &
      -0.2173E-05/
  DATA ((h13(ip,iw,1),iw=1,31),ip=19,19)/                               &
      0.6693E-09,  0.1312E-08,  0.2538E-08,  0.4802E-08,  0.8778E-08,   &
      0.1528E-07,  0.2501E-07,  0.3836E-07,  0.5578E-07,  0.7806E-07,   &
      0.1069E-06,  0.1456E-06,  0.1970E-06,  0.2631E-06,  0.3485E-06,   &
      0.4642E-06,  0.6268E-06,  0.8526E-06,  0.1157E-05,  0.1545E-05,   &
      0.2002E-05,  0.2478E-05,  0.2897E-05,  0.3245E-05,  0.3578E-05,   &
      0.3789E-05,  0.3598E-05,  0.2792E-05,  0.1489E-05,  0.4160E-06,   &
      0.3843E-07/
  DATA ((h11(ip,iw,1),iw=1,31),ip=20,20)/                               &
      0.9443E-04,  0.1843E-03,  0.3545E-03,  0.6669E-03,  0.1217E-02,   &
      0.2133E-02,  0.3577E-02,  0.5742E-02,  0.8880E-02,  0.1333E-01,   &
      0.1958E-01,  0.2830E-01,  0.4039E-01,  0.5705E-01,  0.7988E-01,   &
      0.1110E+00,  0.1526E+00,  0.2072E+00,  0.2764E+00,  0.3604E+00,   &
      0.4567E+00,  0.5597E+00,  0.6620E+00,  0.7581E+00,  0.8447E+00,   &
      0.9165E+00,  0.9668E+00,  0.9923E+00,  0.9995E+00,  0.1000E+01,   &
      0.1000E+01/
  DATA ((h12(ip,iw,1),iw=1,31),ip=20,20)/                               &
      -0.1472E-06, -0.2866E-06, -0.5485E-06, -0.1024E-05, -0.1842E-05,  &
      -0.3160E-05, -0.5136E-05, -0.7922E-05, -0.1171E-04, -0.1682E-04,  &
      -0.2381E-04, -0.3355E-04, -0.4729E-04, -0.6673E-04, -0.9417E-04,  &
      -0.1327E-03, -0.1858E-03, -0.2564E-03, -0.3449E-03, -0.4463E-03,  &
      -0.5495E-03, -0.6420E-03, -0.7116E-03, -0.7427E-03, -0.7139E-03,  &
      -0.6031E-03, -0.4104E-03, -0.1957E-03, -0.5358E-04, -0.6176E-05,  &
      -0.1347E-06/
  DATA ((h13(ip,iw,1),iw=1,31),ip=20,20)/                               &
      0.6750E-09,  0.1332E-08,  0.2602E-08,  0.5003E-08,  0.9367E-08,   &
      0.1684E-07,  0.2863E-07,  0.4566E-07,  0.6865E-07,  0.9861E-07,   &
      0.1368E-06,  0.1856E-06,  0.2479E-06,  0.3274E-06,  0.4315E-06,   &
      0.5739E-06,  0.7710E-06,  0.1040E-05,  0.1394E-05,  0.1829E-05,   &
      0.2309E-05,  0.2759E-05,  0.3131E-05,  0.3472E-05,  0.3755E-05,   &
      0.3730E-05,  0.3138E-05,  0.1948E-05,  0.6994E-06,  0.1022E-06,   &
      0.2459E-08/
  DATA ((h11(ip,iw,1),iw=1,31),ip=21,21)/                               &
      0.9530E-04,  0.1872E-03,  0.3638E-03,  0.6949E-03,  0.1295E-02,   &
      0.2330E-02,  0.4022E-02,  0.6633E-02,  0.1049E-01,  0.1601E-01,   &
      0.2378E-01,  0.3456E-01,  0.4941E-01,  0.6980E-01,  0.9765E-01,   &
      0.1353E+00,  0.1852E+00,  0.2494E+00,  0.3287E+00,  0.4216E+00,   &
      0.5234E+00,  0.6272E+00,  0.7261E+00,  0.8166E+00,  0.8943E+00,   &
      0.9526E+00,  0.9863E+00,  0.9983E+00,  0.1000E+01,  0.1000E+01,   &
      0.1000E+01/
  DATA ((h12(ip,iw,1),iw=1,31),ip=21,21)/                               &
      -0.1487E-06, -0.2912E-06, -0.5636E-06, -0.1069E-05, -0.1969E-05,  &
      -0.3483E-05, -0.5858E-05, -0.9334E-05, -0.1416E-04, -0.2067E-04,  &
      -0.2936E-04, -0.4113E-04, -0.5750E-04, -0.8072E-04, -0.1139E-03,  &
      -0.1606E-03, -0.2246E-03, -0.3076E-03, -0.4067E-03, -0.5121E-03,  &
      -0.6110E-03, -0.6909E-03, -0.7378E-03, -0.7321E-03, -0.6509E-03,  &
      -0.4825E-03, -0.2641E-03, -0.8936E-04, -0.1436E-04, -0.5966E-06,  &
      0.0000E+00/
  DATA ((h13(ip,iw,1),iw=1,31),ip=21,21)/                               &
      0.6777E-09,  0.1344E-08,  0.2643E-08,  0.5138E-08,  0.9798E-08,   &
      0.1809E-07,  0.3185E-07,  0.5285E-07,  0.8249E-07,  0.1222E-06,   &
      0.1730E-06,  0.2351E-06,  0.3111E-06,  0.4078E-06,  0.5366E-06,   &
      0.7117E-06,  0.9495E-06,  0.1266E-05,  0.1667E-05,  0.2132E-05,   &
      0.2600E-05,  0.3001E-05,  0.3354E-05,  0.3679E-05,  0.3796E-05,   &
      0.3414E-05,  0.2399E-05,  0.1067E-05,  0.2222E-06,  0.1075E-07,   &
      0.0000E+00/
  DATA ((h11(ip,iw,1),iw=1,31),ip=22,22)/                               &
      0.9589E-04,  0.1893E-03,  0.3706E-03,  0.7162E-03,  0.1357E-02,   &
      0.2500E-02,  0.4434E-02,  0.7523E-02,  0.1220E-01,  0.1900E-01,   &
      0.2860E-01,  0.4190E-01,  0.6015E-01,  0.8508E-01,  0.1189E+00,   &
      0.1643E+00,  0.2233E+00,  0.2976E+00,  0.3865E+00,  0.4865E+00,   &
      0.5909E+00,  0.6925E+00,  0.7866E+00,  0.8696E+00,  0.9355E+00,   &
      0.9778E+00,  0.9961E+00,  0.9999E+00,  0.1000E+01,  0.1000E+01,   &
      0.1000E+01/
  DATA ((h12(ip,iw,1),iw=1,31),ip=22,22)/                               &
      -0.1496E-06, -0.2947E-06, -0.5749E-06, -0.1105E-05, -0.2074E-05,  &
      -0.3763E-05, -0.6531E-05, -0.1076E-04, -0.1682E-04, -0.2509E-04,  &
      -0.3605E-04, -0.5049E-04, -0.7012E-04, -0.9787E-04, -0.1378E-03,  &
      -0.1939E-03, -0.2695E-03, -0.3641E-03, -0.4703E-03, -0.5750E-03,  &
      -0.6648E-03, -0.7264E-03, -0.7419E-03, -0.6889E-03, -0.5488E-03,  &
      -0.3382E-03, -0.1375E-03, -0.2951E-04, -0.2174E-05,  0.0000E+00,  &
      0.0000E+00/
  DATA ((h13(ip,iw,1),iw=1,31),ip=22,22)/                               &
      0.6798E-09,  0.1350E-08,  0.2667E-08,  0.5226E-08,  0.1010E-07,   &
      0.1903E-07,  0.3455E-07,  0.5951E-07,  0.9658E-07,  0.1479E-06,   &
      0.2146E-06,  0.2951E-06,  0.3903E-06,  0.5101E-06,  0.6693E-06,   &
      0.8830E-06,  0.1168E-05,  0.1532E-05,  0.1968E-05,  0.2435E-05,   &
      0.2859E-05,  0.3222E-05,  0.3572E-05,  0.3797E-05,  0.3615E-05,   &
      0.2811E-05,  0.1500E-05,  0.4185E-06,  0.3850E-07,  0.0000E+00,   &
      0.0000E+00/
  DATA ((h11(ip,iw,1),iw=1,31),ip=23,23)/                               &
      0.9629E-04,  0.1907E-03,  0.3755E-03,  0.7321E-03,  0.1406E-02,   &
      0.2639E-02,  0.4796E-02,  0.8368E-02,  0.1394E-01,  0.2221E-01,   &
      0.3400E-01,  0.5037E-01,  0.7279E-01,  0.1033E+00,  0.1442E+00,   &
      0.1983E+00,  0.2673E+00,  0.3516E+00,  0.4489E+00,  0.5533E+00,   &
      0.6572E+00,  0.7547E+00,  0.8425E+00,  0.9153E+00,  0.9663E+00,   &
      0.9922E+00,  0.9995E+00,  0.1000E+01,  0.1000E+01,  0.1000E+01,   &
      0.1000E+01/
  DATA ((h12(ip,iw,1),iw=1,31),ip=23,23)/                               &
      -0.1503E-06, -0.2971E-06, -0.5832E-06, -0.1131E-05, -0.2154E-05,  &
      -0.3992E-05, -0.7122E-05, -0.1211E-04, -0.1954E-04, -0.2995E-04,  &
      -0.4380E-04, -0.6183E-04, -0.8577E-04, -0.1191E-03, -0.1668E-03,  &
      -0.2333E-03, -0.3203E-03, -0.4237E-03, -0.5324E-03, -0.6318E-03,  &
      -0.7075E-03, -0.7429E-03, -0.7168E-03, -0.6071E-03, -0.4139E-03,  &
      -0.1976E-03, -0.5410E-04, -0.6215E-05, -0.1343E-06,  0.0000E+00,  &
      0.0000E+00/
  DATA ((h13(ip,iw,1),iw=1,31),ip=23,23)/                               &
      0.6809E-09,  0.1356E-08,  0.2683E-08,  0.5287E-08,  0.1030E-07,   &
      0.1971E-07,  0.3665E-07,  0.6528E-07,  0.1100E-06,  0.1744E-06,   &
      0.2599E-06,  0.3650E-06,  0.4887E-06,  0.6398E-06,  0.8358E-06,   &
      0.1095E-05,  0.1429E-05,  0.1836E-05,  0.2286E-05,  0.2716E-05,   &
      0.3088E-05,  0.3444E-05,  0.3748E-05,  0.3740E-05,  0.3157E-05,   &
      0.1966E-05,  0.7064E-06,  0.1030E-06,  0.2456E-08,  0.0000E+00,   &
      0.0000E+00/
  DATA ((h11(ip,iw,1),iw=1,31),ip=24,24)/                               &
      0.9655E-04,  0.1917E-03,  0.3789E-03,  0.7436E-03,  0.1442E-02,   &
      0.2748E-02,  0.5100E-02,  0.9128E-02,  0.1563E-01,  0.2553E-01,   &
      0.3987E-01,  0.5994E-01,  0.8746E-01,  0.1246E+00,  0.1739E+00,   &
      0.2376E+00,  0.3170E+00,  0.4107E+00,  0.5141E+00,  0.6198E+00,   &
      0.7208E+00,  0.8130E+00,  0.8923E+00,  0.9517E+00,  0.9860E+00,   &
      0.9983E+00,  0.1000E+01,  0.1000E+01,  0.1000E+01,  0.1000E+01,   &
      0.1000E+01/
  DATA ((h12(ip,iw,1),iw=1,31),ip=24,24)/                               &
      -0.1508E-06, -0.2989E-06, -0.5892E-06, -0.1151E-05, -0.2216E-05,  &
      -0.4175E-05, -0.7619E-05, -0.1333E-04, -0.2217E-04, -0.3497E-04,  &
      -0.5238E-04, -0.7513E-04, -0.1049E-03, -0.1455E-03, -0.2021E-03,  &
      -0.2790E-03, -0.3757E-03, -0.4839E-03, -0.5902E-03, -0.6794E-03,  &
      -0.7344E-03, -0.7341E-03, -0.6557E-03, -0.4874E-03, -0.2674E-03,  &
      -0.9059E-04, -0.1455E-04, -0.5986E-06,  0.0000E+00,  0.0000E+00,  &
      0.0000E+00/
  DATA ((h13(ip,iw,1),iw=1,31),ip=24,24)/                               &
      0.6812E-09,  0.1356E-08,  0.2693E-08,  0.5328E-08,  0.1045E-07,   &
      0.2021E-07,  0.3826E-07,  0.6994E-07,  0.1218E-06,  0.1997E-06,   &
      0.3069E-06,  0.4428E-06,  0.6064E-06,  0.8015E-06,  0.1043E-05,   &
      0.1351E-05,  0.1733E-05,  0.2168E-05,  0.2598E-05,  0.2968E-05,   &
      0.3316E-05,  0.3662E-05,  0.3801E-05,  0.3433E-05,  0.2422E-05,   &
      0.1081E-05,  0.2256E-06,  0.1082E-07,  0.0000E+00,  0.0000E+00,   &
      0.0000E+00/
  DATA ((h11(ip,iw,1),iw=1,31),ip=25,25)/                               &
      0.9672E-04,  0.1923E-03,  0.3813E-03,  0.7518E-03,  0.1469E-02,   &
      0.2832E-02,  0.5343E-02,  0.9779E-02,  0.1719E-01,  0.2882E-01,   &
      0.4606E-01,  0.7051E-01,  0.1042E+00,  0.1493E+00,  0.2081E+00,   &
      0.2824E+00,  0.3720E+00,  0.4736E+00,  0.5803E+00,  0.6844E+00,   &
      0.7810E+00,  0.8663E+00,  0.9339E+00,  0.9772E+00,  0.9960E+00,   &
      0.9999E+00,  0.1000E+01,  0.1000E+01,  0.1000E+01,  0.1000E+01,   &
      0.1000E+01/
  DATA ((h12(ip,iw,1),iw=1,31),ip=25,25)/                               &
      -0.1511E-06, -0.3001E-06, -0.5934E-06, -0.1166E-05, -0.2263E-05,  &
      -0.4319E-05, -0.8028E-05, -0.1438E-04, -0.2460E-04, -0.3991E-04,  &
      -0.6138E-04, -0.9005E-04, -0.1278E-03, -0.1778E-03, -0.2447E-03,  &
      -0.3313E-03, -0.4342E-03, -0.5424E-03, -0.6416E-03, -0.7146E-03,  &
      -0.7399E-03, -0.6932E-03, -0.5551E-03, -0.3432E-03, -0.1398E-03,  &
      -0.3010E-04, -0.2229E-05,  0.0000E+00,  0.0000E+00,  0.0000E+00,  &
      0.0000E+00/
  DATA ((h13(ip,iw,1),iw=1,31),ip=25,25)/                               &
      0.6815E-09,  0.1358E-08,  0.2698E-08,  0.5355E-08,  0.1054E-07,   &
      0.2056E-07,  0.3942E-07,  0.7349E-07,  0.1315E-06,  0.2226E-06,   &
      0.3537E-06,  0.5266E-06,  0.7407E-06,  0.9958E-06,  0.1296E-05,   &
      0.1657E-05,  0.2077E-05,  0.2512E-05,  0.2893E-05,  0.3216E-05,   &
      0.3562E-05,  0.3811E-05,  0.3644E-05,  0.2841E-05,  0.1524E-05,   &
      0.4276E-06,  0.3960E-07,  0.0000E+00,  0.0000E+00,  0.0000E+00,   &
      0.0000E+00/
  DATA ((h11(ip,iw,1),iw=1,31),ip=26,26)/                               &
      0.9682E-04,  0.1928E-03,  0.3829E-03,  0.7576E-03,  0.1489E-02,   &
      0.2894E-02,  0.5533E-02,  0.1031E-01,  0.1856E-01,  0.3195E-01,   &
      0.5237E-01,  0.8187E-01,  0.1227E+00,  0.1771E+00,  0.2468E+00,   &
      0.3321E+00,  0.4312E+00,  0.5384E+00,  0.6455E+00,  0.7463E+00,   &
      0.8372E+00,  0.9126E+00,  0.9652E+00,  0.9919E+00,  0.9994E+00,   &
      0.1000E+01,  0.1000E+01,  0.1000E+01,  0.1000E+01,  0.1000E+01,   &
      0.1000E+01/
  DATA ((h12(ip,iw,1),iw=1,31),ip=26,26)/                               &
      -0.1513E-06, -0.3009E-06, -0.5966E-06, -0.1176E-05, -0.2299E-05,  &
      -0.4430E-05, -0.8352E-05, -0.1526E-04, -0.2674E-04, -0.4454E-04,  &
      -0.7042E-04, -0.1062E-03, -0.1540E-03, -0.2163E-03, -0.2951E-03,  &
      -0.3899E-03, -0.4948E-03, -0.5983E-03, -0.6846E-03, -0.7332E-03,  &
      -0.7182E-03, -0.6142E-03, -0.4209E-03, -0.2014E-03, -0.5530E-04,  &
      -0.6418E-05, -0.1439E-06,  0.0000E+00,  0.0000E+00,  0.0000E+00,  &
      0.0000E+00/
  DATA ((h13(ip,iw,1),iw=1,31),ip=26,26)/                               &
      0.6817E-09,  0.1359E-08,  0.2702E-08,  0.5374E-08,  0.1061E-07,   &
      0.2079E-07,  0.4022E-07,  0.7610E-07,  0.1392E-06,  0.2428E-06,   &
      0.3992E-06,  0.6149E-06,  0.8893E-06,  0.1220E-05,  0.1599E-05,   &
      0.2015E-05,  0.2453E-05,  0.2853E-05,  0.3173E-05,  0.3488E-05,   &
      0.3792E-05,  0.3800E-05,  0.3210E-05,  0.2002E-05,  0.7234E-06,   &
      0.1068E-06,  0.2646E-08,  0.0000E+00,  0.0000E+00,  0.0000E+00,   &
      0.0000E+00/
  DATA ((h21(ip,iw,1),iw=1,31),ip= 1, 1)/                               &
      0.3920E-05,  0.7617E-05,  0.1455E-04,  0.2706E-04,  0.4855E-04,   &
      0.8315E-04,  0.1349E-03,  0.2063E-03,  0.2984E-03,  0.4109E-03,   &
      0.5422E-03,  0.6896E-03,  0.8537E-03,  0.1041E-02,  0.1262E-02,   &
      0.1534E-02,  0.1870E-02,  0.2286E-02,  0.2803E-02,  0.3444E-02,   &
      0.4242E-02,  0.5244E-02,  0.6511E-02,  0.8138E-02,  0.1027E-01,   &
      0.1312E-01,  0.1697E-01,  0.2222E-01,  0.2941E-01,  0.3923E-01,   &
      0.5258E-01/
  DATA ((h22(ip,iw,1),iw=1,31),ip= 1, 1)/                               &
      -0.5622E-07, -0.1071E-06, -0.1983E-06, -0.3533E-06, -0.5991E-06,  &
      -0.9592E-06, -0.1444E-05, -0.2049E-05, -0.2764E-05, -0.3577E-05,  &
      -0.4469E-05, -0.5467E-05, -0.6654E-05, -0.8137E-05, -0.1002E-04,  &
      -0.1237E-04, -0.1528E-04, -0.1884E-04, -0.2310E-04, -0.2809E-04,  &
      -0.3396E-04, -0.4098E-04, -0.4960E-04, -0.6058E-04, -0.7506E-04,  &
      -0.9451E-04, -0.1207E-03, -0.1558E-03, -0.2026E-03, -0.2648E-03,  &
      -0.3468E-03/
  DATA ((h23(ip,iw,1),iw=1,31),ip= 1, 1)/                               &
      -0.2195E-09, -0.4031E-09, -0.7043E-09, -0.1153E-08, -0.1737E-08,  &
      -0.2395E-08, -0.3020E-08, -0.3549E-08, -0.4034E-08, -0.4421E-08,  &
      -0.4736E-08, -0.5681E-08, -0.8289E-08, -0.1287E-07, -0.1873E-07,  &
      -0.2523E-07, -0.3223E-07, -0.3902E-07, -0.4409E-07, -0.4699E-07,  &
      -0.4782E-07, -0.4705E-07, -0.4657E-07, -0.4885E-07, -0.5550E-07,  &
      -0.6619E-07, -0.7656E-07, -0.8027E-07, -0.7261E-07, -0.4983E-07,  &
      -0.1101E-07/
  DATA ((h21(ip,iw,1),iw=1,31),ip= 2, 2)/                               &
      0.3920E-05,  0.7617E-05,  0.1455E-04,  0.2706E-04,  0.4856E-04,   &
      0.8318E-04,  0.1349E-03,  0.2065E-03,  0.2986E-03,  0.4114E-03,   &
      0.5431E-03,  0.6912E-03,  0.8566E-03,  0.1046E-02,  0.1272E-02,   &
      0.1552E-02,  0.1902E-02,  0.2342E-02,  0.2899E-02,  0.3605E-02,   &
      0.4501E-02,  0.5648E-02,  0.7129E-02,  0.9063E-02,  0.1163E-01,   &
      0.1509E-01,  0.1980E-01,  0.2626E-01,  0.3510E-01,  0.4717E-01,   &
      0.6351E-01/
  DATA ((h22(ip,iw,1),iw=1,31),ip= 2, 2)/                               &
      -0.5622E-07, -0.1071E-06, -0.1983E-06, -0.3534E-06, -0.5992E-06,  &
      -0.9594E-06, -0.1445E-05, -0.2050E-05, -0.2766E-05, -0.3580E-05,  &
      -0.4476E-05, -0.5479E-05, -0.6677E-05, -0.8179E-05, -0.1009E-04,  &
      -0.1251E-04, -0.1553E-04, -0.1928E-04, -0.2384E-04, -0.2930E-04,  &
      -0.3588E-04, -0.4393E-04, -0.5403E-04, -0.6714E-04, -0.8458E-04,  &
      -0.1082E-03, -0.1400E-03, -0.1829E-03, -0.2401E-03, -0.3157E-03,  &
      -0.4147E-03/
  DATA ((h23(ip,iw,1),iw=1,31),ip= 2, 2)/                               &
      -0.2195E-09, -0.4032E-09, -0.7046E-09, -0.1153E-08, -0.1738E-08,  &
      -0.2395E-08, -0.3021E-08, -0.3550E-08, -0.4035E-08, -0.4423E-08,  &
      -0.4740E-08, -0.5692E-08, -0.8314E-08, -0.1292E-07, -0.1882E-07,  &
      -0.2536E-07, -0.3242E-07, -0.3927E-07, -0.4449E-07, -0.4767E-07,  &
      -0.4889E-07, -0.4857E-07, -0.4860E-07, -0.5132E-07, -0.5847E-07,  &
      -0.6968E-07, -0.8037E-07, -0.8400E-07, -0.7521E-07, -0.4830E-07,  &
      -0.7562E-09/
  DATA ((h21(ip,iw,1),iw=1,31),ip= 3, 3)/                               &
      0.3920E-05,  0.7617E-05,  0.1455E-04,  0.2707E-04,  0.4858E-04,   &
      0.8322E-04,  0.1350E-03,  0.2066E-03,  0.2990E-03,  0.4122E-03,   &
      0.5444E-03,  0.6937E-03,  0.8611E-03,  0.1054E-02,  0.1287E-02,   &
      0.1579E-02,  0.1949E-02,  0.2424E-02,  0.3037E-02,  0.3829E-02,   &
      0.4854E-02,  0.6190E-02,  0.7942E-02,  0.1026E-01,  0.1338E-01,   &
      0.1761E-01,  0.2340E-01,  0.3134E-01,  0.4223E-01,  0.5703E-01,   &
      0.7694E-01/
  DATA ((h22(ip,iw,1),iw=1,31),ip= 3, 3)/                               &
      -0.5622E-07, -0.1071E-06, -0.1983E-06, -0.3535E-06, -0.5994E-06,  &
      -0.9599E-06, -0.1446E-05, -0.2052E-05, -0.2769E-05, -0.3586E-05,  &
      -0.4487E-05, -0.5499E-05, -0.6712E-05, -0.8244E-05, -0.1021E-04,  &
      -0.1272E-04, -0.1591E-04, -0.1992E-04, -0.2489E-04, -0.3097E-04,  &
      -0.3845E-04, -0.4782E-04, -0.5982E-04, -0.7558E-04, -0.9674E-04,  &
      -0.1254E-03, -0.1644E-03, -0.2167E-03, -0.2863E-03, -0.3777E-03,  &
      -0.4959E-03/
  DATA ((h23(ip,iw,1),iw=1,31),ip= 3, 3)/                               &
      -0.2196E-09, -0.4033E-09, -0.7048E-09, -0.1154E-08, -0.1739E-08,  &
      -0.2396E-08, -0.3022E-08, -0.3551E-08, -0.4036E-08, -0.4425E-08,  &
      -0.4746E-08, -0.5710E-08, -0.8354E-08, -0.1300E-07, -0.1894E-07,  &
      -0.2554E-07, -0.3265E-07, -0.3958E-07, -0.4502E-07, -0.4859E-07,  &
      -0.5030E-07, -0.5053E-07, -0.5104E-07, -0.5427E-07, -0.6204E-07,  &
      -0.7388E-07, -0.8477E-07, -0.8760E-07, -0.7545E-07, -0.4099E-07,  &
      0.2046E-07/
  DATA ((h21(ip,iw,1),iw=1,31),ip= 4, 4)/                               &
      0.3919E-05,  0.7618E-05,  0.1455E-04,  0.2708E-04,  0.4860E-04,   &
      0.8327E-04,  0.1352E-03,  0.2070E-03,  0.2997E-03,  0.4134E-03,   &
      0.5466E-03,  0.6976E-03,  0.8682E-03,  0.1067E-02,  0.1310E-02,   &
      0.1619E-02,  0.2020E-02,  0.2543E-02,  0.3232E-02,  0.4136E-02,   &
      0.5328E-02,  0.6906E-02,  0.9004E-02,  0.1182E-01,  0.1562E-01,   &
      0.2081E-01,  0.2794E-01,  0.3773E-01,  0.5111E-01,  0.6919E-01,   &
      0.9329E-01/
  DATA ((h22(ip,iw,1),iw=1,31),ip= 4, 4)/                               &
      -0.5623E-07, -0.1071E-06, -0.1984E-06, -0.3536E-06, -0.5997E-06,  &
      -0.9606E-06, -0.1447E-05, -0.2055E-05, -0.2775E-05, -0.3596E-05,  &
      -0.4504E-05, -0.5529E-05, -0.6768E-05, -0.8345E-05, -0.1039E-04,  &
      -0.1304E-04, -0.1645E-04, -0.2082E-04, -0.2633E-04, -0.3322E-04,  &
      -0.4187E-04, -0.5292E-04, -0.6730E-04, -0.8640E-04, -0.1122E-03,  &
      -0.1472E-03, -0.1948E-03, -0.2585E-03, -0.3428E-03, -0.4523E-03,  &
      -0.5915E-03/
  DATA ((h23(ip,iw,1),iw=1,31),ip= 4, 4)/                               &
      -0.2196E-09, -0.4034E-09, -0.7050E-09, -0.1154E-08, -0.1740E-08,  &
      -0.2398E-08, -0.3024E-08, -0.3552E-08, -0.4037E-08, -0.4428E-08,  &
      -0.4756E-08, -0.5741E-08, -0.8418E-08, -0.1310E-07, -0.1910E-07,  &
      -0.2575E-07, -0.3293E-07, -0.3998E-07, -0.4572E-07, -0.4980E-07,  &
      -0.5211E-07, -0.5287E-07, -0.5390E-07, -0.5782E-07, -0.6650E-07,  &
      -0.7892E-07, -0.8940E-07, -0.8980E-07, -0.7119E-07, -0.2452E-07,  &
      0.5823E-07/
  DATA ((h21(ip,iw,1),iw=1,31),ip= 5, 5)/                               &
      0.3919E-05,  0.7618E-05,  0.1455E-04,  0.2709E-04,  0.4863E-04,   &
      0.8337E-04,  0.1354E-03,  0.2075E-03,  0.3007E-03,  0.4152E-03,   &
      0.5500E-03,  0.7038E-03,  0.8793E-03,  0.1086E-02,  0.1345E-02,   &
      0.1680E-02,  0.2123E-02,  0.2712E-02,  0.3500E-02,  0.4552E-02,   &
      0.5958E-02,  0.7844E-02,  0.1038E-01,  0.1381E-01,  0.1847E-01,   &
      0.2487E-01,  0.3366E-01,  0.4572E-01,  0.6209E-01,  0.8406E-01,   &
      0.1130E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip= 5, 5)/                               &
      -0.5623E-07, -0.1071E-06, -0.1985E-06, -0.3538E-06, -0.6002E-06,  &
      -0.9618E-06, -0.1450E-05, -0.2059E-05, -0.2783E-05, -0.3611E-05,  &
      -0.4531E-05, -0.5577E-05, -0.6855E-05, -0.8499E-05, -0.1066E-04,  &
      -0.1351E-04, -0.1723E-04, -0.2207E-04, -0.2829E-04, -0.3621E-04,  &
      -0.4636E-04, -0.5954E-04, -0.7690E-04, -0.1002E-03, -0.1317E-03,  &
      -0.1746E-03, -0.2326E-03, -0.3099E-03, -0.4111E-03, -0.5407E-03,  &
      -0.7020E-03/
  DATA ((h23(ip,iw,1),iw=1,31),ip= 5, 5)/                               &
      -0.2197E-09, -0.4037E-09, -0.7054E-09, -0.1155E-08, -0.1741E-08,  &
      -0.2401E-08, -0.3027E-08, -0.3553E-08, -0.4039E-08, -0.4431E-08,  &
      -0.4775E-08, -0.5784E-08, -0.8506E-08, -0.1326E-07, -0.1931E-07,  &
      -0.2600E-07, -0.3324E-07, -0.4048E-07, -0.4666E-07, -0.5137E-07,  &
      -0.5428E-07, -0.5558E-07, -0.5730E-07, -0.6228E-07, -0.7197E-07,  &
      -0.8455E-07, -0.9347E-07, -0.8867E-07, -0.5945E-07,  0.5512E-08,  &
      0.1209E-06/
  DATA ((h21(ip,iw,1),iw=1,31),ip= 6, 6)/                               &
      0.3919E-05,  0.7619E-05,  0.1456E-04,  0.2710E-04,  0.4868E-04,   &
      0.8351E-04,  0.1357E-03,  0.2082E-03,  0.3022E-03,  0.4181E-03,   &
      0.5554E-03,  0.7134E-03,  0.8963E-03,  0.1117E-02,  0.1397E-02,   &
      0.1770E-02,  0.2270E-02,  0.2947E-02,  0.3865E-02,  0.5107E-02,   &
      0.6787E-02,  0.9062E-02,  0.1215E-01,  0.1634E-01,  0.2209E-01,   &
      0.2999E-01,  0.4083E-01,  0.5563E-01,  0.7559E-01,  0.1021E+00,   &
      0.1364E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip= 6, 6)/                               &
      -0.5624E-07, -0.1072E-06, -0.1986E-06, -0.3541E-06, -0.6010E-06,  &
      -0.9636E-06, -0.1453E-05, -0.2067E-05, -0.2796E-05, -0.3634E-05,  &
      -0.4572E-05, -0.5652E-05, -0.6987E-05, -0.8733E-05, -0.1107E-04,  &
      -0.1418E-04, -0.1832E-04, -0.2378E-04, -0.3092E-04, -0.4017E-04,  &
      -0.5221E-04, -0.6806E-04, -0.8916E-04, -0.1176E-03, -0.1562E-03,  &
      -0.2087E-03, -0.2793E-03, -0.3724E-03, -0.4928E-03, -0.6440E-03,  &
      -0.8270E-03/
  DATA ((h23(ip,iw,1),iw=1,31),ip= 6, 6)/                               &
      -0.2198E-09, -0.4040E-09, -0.7061E-09, -0.1156E-08, -0.1744E-08,  &
      -0.2405E-08, -0.3032E-08, -0.3556E-08, -0.4040E-08, -0.4444E-08,  &
      -0.4800E-08, -0.5848E-08, -0.8640E-08, -0.1346E-07, -0.1957E-07,  &
      -0.2627E-07, -0.3357E-07, -0.4114E-07, -0.4793E-07, -0.5330E-07,  &
      -0.5676E-07, -0.5873E-07, -0.6152E-07, -0.6783E-07, -0.7834E-07,  &
      -0.9023E-07, -0.9530E-07, -0.8162E-07, -0.3634E-07,  0.5638E-07,  &
      0.2189E-06/
  DATA ((h21(ip,iw,1),iw=1,31),ip= 7, 7)/                               &
      0.3919E-05,  0.7620E-05,  0.1457E-04,  0.2713E-04,  0.4877E-04,   &
      0.8374E-04,  0.1363E-03,  0.2095E-03,  0.3047E-03,  0.4227E-03,   &
      0.5637E-03,  0.7282E-03,  0.9224E-03,  0.1162E-02,  0.1475E-02,   &
      0.1898E-02,  0.2475E-02,  0.3267E-02,  0.4354E-02,  0.5839E-02,   &
      0.7866E-02,  0.1063E-01,  0.1440E-01,  0.1957E-01,  0.2666E-01,   &
      0.3641E-01,  0.4975E-01,  0.6784E-01,  0.9201E-01,  0.1236E+00,   &
      0.1639E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip= 7, 7)/                               &
      -0.5626E-07, -0.1072E-06, -0.1987E-06, -0.3545E-06, -0.6022E-06,  &
      -0.9665E-06, -0.1460E-05, -0.2078E-05, -0.2817E-05, -0.3671E-05,  &
      -0.4637E-05, -0.5767E-05, -0.7188E-05, -0.9080E-05, -0.1165E-04,  &
      -0.1513E-04, -0.1981E-04, -0.2609E-04, -0.3441E-04, -0.4534E-04,  &
      -0.5978E-04, -0.7897E-04, -0.1047E-03, -0.1396E-03, -0.1870E-03,  &
      -0.2510E-03, -0.3363E-03, -0.4475E-03, -0.5888E-03, -0.7621E-03,  &
      -0.9647E-03/
  DATA ((h23(ip,iw,1),iw=1,31),ip= 7, 7)/                               &
      -0.2200E-09, -0.4045E-09, -0.7071E-09, -0.1159E-08, -0.1748E-08,  &
      -0.2411E-08, -0.3040E-08, -0.3561E-08, -0.4046E-08, -0.4455E-08,  &
      -0.4839E-08, -0.5941E-08, -0.8815E-08, -0.1371E-07, -0.1983E-07,  &
      -0.2652E-07, -0.3400E-07, -0.4207E-07, -0.4955E-07, -0.5554E-07,  &
      -0.5966E-07, -0.6261E-07, -0.6688E-07, -0.7454E-07, -0.8521E-07,  &
      -0.9470E-07, -0.9275E-07, -0.6525E-07,  0.3686E-08,  0.1371E-06,  &
      0.3623E-06/
  DATA ((h21(ip,iw,1),iw=1,31),ip= 8, 8)/                               &
      0.3919E-05,  0.7622E-05,  0.1458E-04,  0.2717E-04,  0.4890E-04,   &
      0.8410E-04,  0.1372E-03,  0.2114E-03,  0.3085E-03,  0.4298E-03,   &
      0.5765E-03,  0.7508E-03,  0.9618E-03,  0.1229E-02,  0.1586E-02,   &
      0.2077E-02,  0.2757E-02,  0.3697E-02,  0.5000E-02,  0.6794E-02,   &
      0.9260E-02,  0.1264E-01,  0.1728E-01,  0.2365E-01,  0.3242E-01,   &
      0.4444E-01,  0.6080E-01,  0.8278E-01,  0.1118E+00,  0.1491E+00,   &
      0.1956E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip= 8, 8)/                               &
      -0.5628E-07, -0.1073E-06, -0.1990E-06, -0.3553E-06, -0.6042E-06,  &
      -0.9710E-06, -0.1469E-05, -0.2096E-05, -0.2849E-05, -0.3728E-05,  &
      -0.4738E-05, -0.5942E-05, -0.7490E-05, -0.9586E-05, -0.1247E-04,  &
      -0.1644E-04, -0.2184E-04, -0.2916E-04, -0.3898E-04, -0.5205E-04,  &
      -0.6948E-04, -0.9285E-04, -0.1244E-03, -0.1672E-03, -0.2251E-03,  &
      -0.3028E-03, -0.4051E-03, -0.5365E-03, -0.6998E-03, -0.8940E-03,  &
      -0.1112E-02/
  DATA ((h23(ip,iw,1),iw=1,31),ip= 8, 8)/                               &
      -0.2204E-09, -0.4052E-09, -0.7088E-09, -0.1162E-08, -0.1755E-08,  &
      -0.2422E-08, -0.3053E-08, -0.3572E-08, -0.4052E-08, -0.4474E-08,  &
      -0.4898E-08, -0.6082E-08, -0.9046E-08, -0.1400E-07, -0.2009E-07,  &
      -0.2683E-07, -0.3463E-07, -0.4334E-07, -0.5153E-07, -0.5811E-07,  &
      -0.6305E-07, -0.6749E-07, -0.7346E-07, -0.8208E-07, -0.9173E-07,  &
      -0.9603E-07, -0.8264E-07, -0.3505E-07,  0.6878E-07,  0.2586E-06,  &
      0.5530E-06/
  DATA ((h21(ip,iw,1),iw=1,31),ip= 9, 9)/                               &
      0.3919E-05,  0.7625E-05,  0.1459E-04,  0.2723E-04,  0.4910E-04,   &
      0.8465E-04,  0.1385E-03,  0.2143E-03,  0.3143E-03,  0.4407E-03,   &
      0.5960E-03,  0.7850E-03,  0.1020E-02,  0.1326E-02,  0.1744E-02,   &
      0.2324E-02,  0.3135E-02,  0.4267E-02,  0.5845E-02,  0.8031E-02,   &
      0.1105E-01,  0.1520E-01,  0.2093E-01,  0.2880E-01,  0.3962E-01,   &
      0.5440E-01,  0.7435E-01,  0.1009E+00,  0.1353E+00,  0.1787E+00,   &
      0.2317E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip= 9, 9)/                               &
      -0.5630E-07, -0.1074E-06, -0.1994E-06, -0.3564E-06, -0.6072E-06,  &
      -0.9779E-06, -0.1484E-05, -0.2124E-05, -0.2900E-05, -0.3817E-05,  &
      -0.4891E-05, -0.6205E-05, -0.7931E-05, -0.1031E-04, -0.1362E-04,  &
      -0.1821E-04, -0.2454E-04, -0.3320E-04, -0.4493E-04, -0.6068E-04,  &
      -0.8186E-04, -0.1104E-03, -0.1491E-03, -0.2016E-03, -0.2722E-03,  &
      -0.3658E-03, -0.4873E-03, -0.6404E-03, -0.8253E-03, -0.1037E-02,  &
      -0.1267E-02/
  DATA ((h23(ip,iw,1),iw=1,31),ip= 9, 9)/                               &
      -0.2207E-09, -0.4061E-09, -0.7117E-09, -0.1169E-08, -0.1767E-08,  &
      -0.2439E-08, -0.3074E-08, -0.3588E-08, -0.4062E-08, -0.4510E-08,  &
      -0.4983E-08, -0.6261E-08, -0.9324E-08, -0.1430E-07, -0.2036E-07,  &
      -0.2725E-07, -0.3561E-07, -0.4505E-07, -0.5384E-07, -0.6111E-07,  &
      -0.6731E-07, -0.7355E-07, -0.8112E-07, -0.8978E-07, -0.9616E-07,  &
      -0.9157E-07, -0.6114E-07,  0.1622E-07,  0.1694E-06,  0.4277E-06,  &
      0.7751E-06/
  DATA ((h21(ip,iw,1),iw=1,31),ip=10,10)/                               &
      0.3919E-05,  0.7629E-05,  0.1462E-04,  0.2733E-04,  0.4940E-04,   &
      0.8549E-04,  0.1406E-03,  0.2188E-03,  0.3232E-03,  0.4572E-03,   &
      0.6253E-03,  0.8354E-03,  0.1105E-02,  0.1464E-02,  0.1960E-02,   &
      0.2657E-02,  0.3637E-02,  0.5014E-02,  0.6942E-02,  0.9622E-02,   &
      0.1333E-01,  0.1846E-01,  0.2553E-01,  0.3526E-01,  0.4859E-01,   &
      0.6667E-01,  0.9084E-01,  0.1225E+00,  0.1629E+00,  0.2127E+00,   &
      0.2721E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip=10,10)/                               &
      -0.5636E-07, -0.1076E-06, -0.2000E-06, -0.3582E-06, -0.6119E-06,  &
      -0.9888E-06, -0.1507E-05, -0.2168E-05, -0.2978E-05, -0.3952E-05,  &
      -0.5122E-05, -0.6592E-05, -0.8565E-05, -0.1132E-04, -0.1518E-04,  &
      -0.2060E-04, -0.2811E-04, -0.3848E-04, -0.5261E-04, -0.7173E-04,  &
      -0.9758E-04, -0.1326E-03, -0.1801E-03, -0.2442E-03, -0.3296E-03,  &
      -0.4415E-03, -0.5840E-03, -0.7591E-03, -0.9636E-03, -0.1189E-02,  &
      -0.1427E-02/
  DATA ((h23(ip,iw,1),iw=1,31),ip=10,10)/                               &
      -0.2214E-09, -0.4080E-09, -0.7156E-09, -0.1178E-08, -0.1784E-08,  &
      -0.2466E-08, -0.3105E-08, -0.3617E-08, -0.4087E-08, -0.4563E-08,  &
      -0.5110E-08, -0.6492E-08, -0.9643E-08, -0.1461E-07, -0.2069E-07,  &
      -0.2796E-07, -0.3702E-07, -0.4717E-07, -0.5662E-07, -0.6484E-07,  &
      -0.7271E-07, -0.8079E-07, -0.8928E-07, -0.9634E-07, -0.9625E-07,  &
      -0.7776E-07, -0.2242E-07,  0.9745E-07,  0.3152E-06,  0.6388E-06,  &
      0.9992E-06/
  DATA ((h21(ip,iw,1),iw=1,31),ip=11,11)/                               &
      0.3919E-05,  0.7639E-05,  0.1466E-04,  0.2748E-04,  0.4986E-04,   &
      0.8675E-04,  0.1437E-03,  0.2255E-03,  0.3365E-03,  0.4816E-03,   &
      0.6682E-03,  0.9082E-03,  0.1224E-02,  0.1653E-02,  0.2253E-02,   &
      0.3099E-02,  0.4296E-02,  0.5984E-02,  0.8352E-02,  0.1165E-01,   &
      0.1623E-01,  0.2257E-01,  0.3132E-01,  0.4333E-01,  0.5968E-01,   &
      0.8166E-01,  0.1107E+00,  0.1481E+00,  0.1947E+00,  0.2509E+00,   &
      0.3170E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip=11,11)/                               &
      -0.5645E-07, -0.1079E-06, -0.2009E-06, -0.3610E-06, -0.6190E-06,  &
      -0.1005E-05, -0.1541E-05, -0.2235E-05, -0.3096E-05, -0.4155E-05,  &
      -0.5463E-05, -0.7150E-05, -0.9453E-05, -0.1269E-04, -0.1728E-04,  &
      -0.2375E-04, -0.3279E-04, -0.4531E-04, -0.6246E-04, -0.8579E-04,  &
      -0.1175E-03, -0.1604E-03, -0.2186E-03, -0.2964E-03, -0.3990E-03,  &
      -0.5311E-03, -0.6957E-03, -0.8916E-03, -0.1112E-02, -0.1346E-02,  &
      -0.1590E-02/
  DATA ((h23(ip,iw,1),iw=1,31),ip=11,11)/                               &
      -0.2225E-09, -0.4104E-09, -0.7217E-09, -0.1192E-08, -0.1811E-08,  &
      -0.2509E-08, -0.3155E-08, -0.3668E-08, -0.4138E-08, -0.4650E-08,  &
      -0.5296E-08, -0.6785E-08, -0.9991E-08, -0.1494E-07, -0.2122E-07,  &
      -0.2911E-07, -0.3895E-07, -0.4979E-07, -0.6002E-07, -0.6964E-07,  &
      -0.7935E-07, -0.8887E-07, -0.9699E-07, -0.9967E-07, -0.8883E-07,  &
      -0.4988E-07,  0.4156E-07,  0.2197E-06,  0.5081E-06,  0.8667E-06,  &
      0.1212E-05/
  DATA ((h21(ip,iw,1),iw=1,31),ip=12,12)/                               &
      0.3920E-05,  0.7649E-05,  0.1472E-04,  0.2768E-04,  0.5051E-04,   &
      0.8856E-04,  0.1481E-03,  0.2352E-03,  0.3557E-03,  0.5169E-03,   &
      0.7295E-03,  0.1010E-02,  0.1388E-02,  0.1909E-02,  0.2640E-02,   &
      0.3678E-02,  0.5151E-02,  0.7231E-02,  0.1015E-01,  0.1423E-01,   &
      0.1990E-01,  0.2775E-01,  0.3856E-01,  0.5333E-01,  0.7328E-01,   &
      0.9980E-01,  0.1343E+00,  0.1778E+00,  0.2308E+00,  0.2936E+00,   &
      0.3667E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip=12,12)/                               &
      -0.5658E-07, -0.1083E-06, -0.2023E-06, -0.3650E-06, -0.6295E-06,  &
      -0.1030E-05, -0.1593E-05, -0.2334E-05, -0.3273E-05, -0.4455E-05,  &
      -0.5955E-05, -0.7935E-05, -0.1067E-04, -0.1455E-04, -0.2007E-04,  &
      -0.2788E-04, -0.3885E-04, -0.5409E-04, -0.7503E-04, -0.1036E-03,  &
      -0.1425E-03, -0.1951E-03, -0.2660E-03, -0.3598E-03, -0.4817E-03,  &
      -0.6355E-03, -0.8218E-03, -0.1035E-02, -0.1267E-02, -0.1508E-02,  &
      -0.1755E-02/
  DATA ((h23(ip,iw,1),iw=1,31),ip=12,12)/                               &
      -0.2241E-09, -0.4142E-09, -0.7312E-09, -0.1214E-08, -0.1854E-08,  &
      -0.2578E-08, -0.3250E-08, -0.3765E-08, -0.4238E-08, -0.4809E-08,  &
      -0.5553E-08, -0.7132E-08, -0.1035E-07, -0.1538E-07, -0.2211E-07,  &
      -0.3079E-07, -0.4142E-07, -0.5303E-07, -0.6437E-07, -0.7566E-07,  &
      -0.8703E-07, -0.9700E-07, -0.1025E-06, -0.9718E-07, -0.6973E-07,  &
      -0.5265E-09,  0.1413E-06,  0.3895E-06,  0.7321E-06,  0.1085E-05,  &
      0.1449E-05/
  DATA ((h21(ip,iw,1),iw=1,31),ip=13,13)/                               &
      0.3920E-05,  0.7668E-05,  0.1480E-04,  0.2798E-04,  0.5143E-04,   &
      0.9106E-04,  0.1542E-03,  0.2488E-03,  0.3827E-03,  0.5661E-03,   &
      0.8143E-03,  0.1150E-02,  0.1608E-02,  0.2246E-02,  0.3147E-02,   &
      0.4428E-02,  0.6248E-02,  0.8823E-02,  0.1244E-01,  0.1750E-01,   &
      0.2452E-01,  0.3424E-01,  0.4756E-01,  0.6564E-01,  0.8981E-01,   &
      0.1215E+00,  0.1619E+00,  0.2118E+00,  0.2713E+00,  0.3409E+00,   &
      0.4215E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip=13,13)/                               &
      -0.5677E-07, -0.1090E-06, -0.2043E-06, -0.3709E-06, -0.6448E-06,  &
      -0.1066E-05, -0.1669E-05, -0.2480E-05, -0.3532E-05, -0.4887E-05,  &
      -0.6650E-05, -0.9017E-05, -0.1232E-04, -0.1701E-04, -0.2372E-04,  &
      -0.3325E-04, -0.4664E-04, -0.6528E-04, -0.9095E-04, -0.1260E-03,  &
      -0.1737E-03, -0.2381E-03, -0.3238E-03, -0.4359E-03, -0.5789E-03,  &
      -0.7549E-03, -0.9607E-03, -0.1188E-02, -0.1427E-02, -0.1674E-02,  &
      -0.1914E-02/
  DATA ((h23(ip,iw,1),iw=1,31),ip=13,13)/                               &
      -0.2262E-09, -0.4191E-09, -0.7441E-09, -0.1244E-08, -0.1916E-08,  &
      -0.2687E-08, -0.3407E-08, -0.3947E-08, -0.4432E-08, -0.5059E-08,  &
      -0.5896E-08, -0.7538E-08, -0.1079E-07, -0.1606E-07, -0.2346E-07,  &
      -0.3305E-07, -0.4459E-07, -0.5720E-07, -0.6999E-07, -0.8300E-07,  &
      -0.9536E-07, -0.1039E-06, -0.1036E-06, -0.8526E-07, -0.3316E-07,  &
      0.7909E-07,  0.2865E-06,  0.6013E-06,  0.9580E-06,  0.1303E-05,   &
      0.1792E-05/
  DATA ((h21(ip,iw,1),iw=1,31),ip=14,14)/                               &
      0.3923E-05,  0.7691E-05,  0.1491E-04,  0.2836E-04,  0.5261E-04,   &
      0.9432E-04,  0.1623E-03,  0.2667E-03,  0.4187E-03,  0.6323E-03,   &
      0.9278E-03,  0.1334E-02,  0.1897E-02,  0.2685E-02,  0.3800E-02,   &
      0.5388E-02,  0.7646E-02,  0.1084E-01,  0.1533E-01,  0.2160E-01,   &
      0.3031E-01,  0.4231E-01,  0.5866E-01,  0.8064E-01,  0.1097E+00,   &
      0.1471E+00,  0.1938E+00,  0.2501E+00,  0.3163E+00,  0.3932E+00,   &
      0.4810E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip=14,14)/                               &
      -0.5703E-07, -0.1098E-06, -0.2071E-06, -0.3788E-06, -0.6657E-06,  &
      -0.1116E-05, -0.1776E-05, -0.2687E-05, -0.3898E-05, -0.5493E-05,  &
      -0.7607E-05, -0.1048E-04, -0.1450E-04, -0.2024E-04, -0.2845E-04,  &
      -0.4014E-04, -0.5658E-04, -0.7947E-04, -0.1110E-03, -0.1541E-03,  &
      -0.2125E-03, -0.2907E-03, -0.3936E-03, -0.5261E-03, -0.6912E-03,  &
      -0.8880E-03, -0.1109E-02, -0.1346E-02, -0.1591E-02, -0.1837E-02,  &
      -0.2054E-02/
  DATA ((h23(ip,iw,1),iw=1,31),ip=14,14)/                               &
      -0.2288E-09, -0.4265E-09, -0.7627E-09, -0.1289E-08, -0.2011E-08,  &
      -0.2861E-08, -0.3673E-08, -0.4288E-08, -0.4812E-08, -0.5475E-08,  &
      -0.6365E-08, -0.8052E-08, -0.1142E-07, -0.1711E-07, -0.2533E-07,  &
      -0.3597E-07, -0.4862E-07, -0.6259E-07, -0.7708E-07, -0.9150E-07,  &
      -0.1035E-06, -0.1079E-06, -0.9742E-07, -0.5928E-07,  0.2892E-07,  &
      0.1998E-06,  0.4789E-06,  0.8298E-06,  0.1172E-05,  0.1583E-05,   &
      0.2329E-05/
  DATA ((h21(ip,iw,1),iw=1,31),ip=15,15)/                               &
      0.3928E-05,  0.7724E-05,  0.1504E-04,  0.2883E-04,  0.5403E-04,   &
      0.9826E-04,  0.1722E-03,  0.2891E-03,  0.4644E-03,  0.7172E-03,   &
      0.1074E-02,  0.1572E-02,  0.2267E-02,  0.3245E-02,  0.4632E-02,   &
      0.6606E-02,  0.9411E-02,  0.1338E-01,  0.1896E-01,  0.2674E-01,   &
      0.3751E-01,  0.5227E-01,  0.7222E-01,  0.9875E-01,  0.1332E+00,   &
      0.1768E+00,  0.2299E+00,  0.2927E+00,  0.3660E+00,  0.4504E+00,   &
      0.5444E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip=15,15)/                               &
      -0.5736E-07, -0.1109E-06, -0.2106E-06, -0.3890E-06, -0.6928E-06,  &
      -0.1181E-05, -0.1917E-05, -0.2965E-05, -0.4396E-05, -0.6315E-05,  &
      -0.8891E-05, -0.1242E-04, -0.1736E-04, -0.2442E-04, -0.3454E-04,  &
      -0.4892E-04, -0.6916E-04, -0.9735E-04, -0.1362E-03, -0.1891E-03,  &
      -0.2602E-03, -0.3545E-03, -0.4768E-03, -0.6310E-03, -0.8179E-03,  &
      -0.1032E-02, -0.1265E-02, -0.1508E-02, -0.1757E-02, -0.1989E-02,  &
      -0.2159E-02/
  DATA ((h23(ip,iw,1),iw=1,31),ip=15,15)/                               &
      -0.2321E-09, -0.4350E-09, -0.7861E-09, -0.1347E-08, -0.2144E-08,  &
      -0.3120E-08, -0.4107E-08, -0.4892E-08, -0.5511E-08, -0.6164E-08,  &
      -0.7054E-08, -0.8811E-08, -0.1240E-07, -0.1862E-07, -0.2773E-07,  &
      -0.3957E-07, -0.5371E-07, -0.6939E-07, -0.8564E-07, -0.1006E-06,  &
      -0.1100E-06, -0.1066E-06, -0.8018E-07, -0.1228E-07,  0.1263E-06,  &
      0.3678E-06,  0.7022E-06,  0.1049E-05,  0.1411E-05,  0.2015E-05,   &
      0.3099E-05/
  DATA ((h21(ip,iw,1),iw=1,31),ip=16,16)/                               &
      0.2064E-05,  0.4104E-05,  0.8141E-05,  0.1607E-04,  0.3145E-04,   &
      0.6080E-04,  0.1153E-03,  0.2129E-03,  0.3802E-03,  0.6538E-03,   &
      0.1078E-02,  0.1699E-02,  0.2576E-02,  0.3805E-02,  0.5540E-02,   &
      0.8004E-02,  0.1149E-01,  0.1640E-01,  0.2329E-01,  0.3290E-01,   &
      0.4622E-01,  0.6441E-01,  0.8888E-01,  0.1210E+00,  0.1622E+00,   &
      0.2132E+00,  0.2745E+00,  0.3470E+00,  0.4317E+00,  0.5286E+00,   &
      0.6335E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip=16,16)/                               &
      -0.3122E-07, -0.6175E-07, -0.1214E-06, -0.2361E-06, -0.4518E-06,  &
      -0.8438E-06, -0.1524E-05, -0.2643E-05, -0.4380E-05, -0.6922E-05,  &
      -0.1042E-04, -0.1504E-04, -0.2125E-04, -0.2987E-04, -0.4200E-04,  &
      -0.5923E-04, -0.8383E-04, -0.1186E-03, -0.1670E-03, -0.2328E-03,  &
      -0.3204E-03, -0.4347E-03, -0.5802E-03, -0.7595E-03, -0.9703E-03,  &
      -0.1205E-02, -0.1457E-02, -0.1720E-02, -0.1980E-02, -0.2191E-02,  &
      -0.2290E-02/
  DATA ((h23(ip,iw,1),iw=1,31),ip=16,16)/                               &
      -0.1376E-09, -0.2699E-09, -0.5220E-09, -0.9897E-09, -0.1819E-08,  &
      -0.3186E-08, -0.5224E-08, -0.7896E-08, -0.1090E-07, -0.1349E-07,  &
      -0.1443E-07, -0.1374E-07, -0.1386E-07, -0.1673E-07, -0.2237E-07,  &
      -0.3248E-07, -0.5050E-07, -0.7743E-07, -0.1097E-06, -0.1369E-06,  &
      -0.1463E-06, -0.1268E-06, -0.6424E-07,  0.5941E-07,  0.2742E-06,  &
      0.5924E-06,  0.9445E-06,  0.1286E-05,  0.1819E-05,  0.2867E-05,   &
      0.4527E-05/
  DATA ((h21(ip,iw,1),iw=1,31),ip=17,17)/                               &
      0.2452E-05,  0.4881E-05,  0.9693E-05,  0.1918E-04,  0.3768E-04,   &
      0.7322E-04,  0.1399E-03,  0.2607E-03,  0.4694E-03,  0.8102E-03,   &
      0.1334E-02,  0.2098E-02,  0.3180E-02,  0.4710E-02,  0.6879E-02,   &
      0.9952E-02,  0.1429E-01,  0.2038E-01,  0.2894E-01,  0.4085E-01,   &
      0.5722E-01,  0.7939E-01,  0.1088E+00,  0.1468E+00,  0.1945E+00,   &
      0.2524E+00,  0.3210E+00,  0.4017E+00,  0.4948E+00,  0.5978E+00,   &
      0.7040E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip=17,17)/                               &
      -0.3547E-07, -0.7029E-07, -0.1386E-06, -0.2709E-06, -0.5218E-06,  &
      -0.9840E-06, -0.1799E-05, -0.3156E-05, -0.5272E-05, -0.8357E-05,  &
      -0.1260E-04, -0.1827E-04, -0.2598E-04, -0.3667E-04, -0.5169E-04,  &
      -0.7312E-04, -0.1037E-03, -0.1467E-03, -0.2060E-03, -0.2857E-03,  &
      -0.3907E-03, -0.5257E-03, -0.6940E-03, -0.8954E-03, -0.1124E-02,  &
      -0.1371E-02, -0.1632E-02, -0.1897E-02, -0.2131E-02, -0.2275E-02,  &
      -0.2265E-02/
  DATA ((h23(ip,iw,1),iw=1,31),ip=17,17)/                               &
      -0.1482E-09, -0.2910E-09, -0.5667E-09, -0.1081E-08, -0.2005E-08,  &
      -0.3554E-08, -0.5902E-08, -0.8925E-08, -0.1209E-07, -0.1448E-07,  &
      -0.1536E-07, -0.1565E-07, -0.1763E-07, -0.2088E-07, -0.2564E-07,  &
      -0.3635E-07, -0.5791E-07, -0.8907E-07, -0.1213E-06, -0.1418E-06,  &
      -0.1397E-06, -0.1000E-06, -0.4427E-08,  0.1713E-06,  0.4536E-06,  &
      0.8086E-06,  0.1153E-05,  0.1588E-05,  0.2437E-05,  0.3905E-05,   &
      0.5874E-05/
  DATA ((h21(ip,iw,1),iw=1,31),ip=18,18)/                               &
      0.2878E-05,  0.5733E-05,  0.1140E-04,  0.2258E-04,  0.4446E-04,   &
      0.8668E-04,  0.1664E-03,  0.3120E-03,  0.5656E-03,  0.9812E-03,   &
      0.1621E-02,  0.2559E-02,  0.3902E-02,  0.5812E-02,  0.8522E-02,   &
      0.1235E-01,  0.1773E-01,  0.2530E-01,  0.3590E-01,  0.5058E-01,   &
      0.7059E-01,  0.9736E-01,  0.1323E+00,  0.1767E+00,  0.2312E+00,   &
      0.2962E+00,  0.3728E+00,  0.4619E+00,  0.5623E+00,  0.6685E+00,   &
      0.7716E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip=18,18)/                               &
      -0.4064E-07, -0.8066E-07, -0.1593E-06, -0.3124E-06, -0.6049E-06,  &
      -0.1148E-05, -0.2118E-05, -0.3751E-05, -0.6314E-05, -0.1006E-04,  &
      -0.1526E-04, -0.2232E-04, -0.3196E-04, -0.4525E-04, -0.6394E-04,  &
      -0.9058E-04, -0.1284E-03, -0.1812E-03, -0.2533E-03, -0.3493E-03,  &
      -0.4740E-03, -0.6315E-03, -0.8228E-03, -0.1044E-02, -0.1286E-02,  &
      -0.1544E-02, -0.1810E-02, -0.2061E-02, -0.2243E-02, -0.2291E-02,  &
      -0.2152E-02/
  DATA ((h23(ip,iw,1),iw=1,31),ip=18,18)/                               &
      -0.1630E-09, -0.3213E-09, -0.6266E-09, -0.1201E-08, -0.2248E-08,  &
      -0.4030E-08, -0.6770E-08, -0.1033E-07, -0.1392E-07, -0.1640E-07,  &
      -0.1768E-07, -0.1932E-07, -0.2229E-07, -0.2508E-07, -0.2940E-07,  &
      -0.4200E-07, -0.6717E-07, -0.1002E-06, -0.1286E-06, -0.1402E-06,  &
      -0.1216E-06, -0.5487E-07,  0.8418E-07,  0.3246E-06,  0.6610E-06,  &
      0.1013E-05,  0.1394E-05,  0.2073E-05,  0.3337E-05,  0.5175E-05,   &
      0.7255E-05/
  DATA ((h21(ip,iw,1),iw=1,31),ip=19,19)/                               &
      0.3282E-05,  0.6539E-05,  0.1300E-04,  0.2578E-04,  0.5085E-04,   &
      0.9936E-04,  0.1914E-03,  0.3608E-03,  0.6586E-03,  0.1153E-02,   &
      0.1924E-02,  0.3074E-02,  0.4742E-02,  0.7126E-02,  0.1051E-01,   &
      0.1526E-01,  0.2195E-01,  0.3133E-01,  0.4441E-01,  0.6238E-01,   &
      0.8664E-01,  0.1186E+00,  0.1597E+00,  0.2108E+00,  0.2723E+00,   &
      0.3450E+00,  0.4300E+00,  0.5272E+00,  0.6324E+00,  0.7378E+00,   &
      0.8330E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip=19,19)/                               &
      -0.4629E-07, -0.9195E-07, -0.1819E-06, -0.3572E-06, -0.6936E-06,  &
      -0.1323E-05, -0.2456E-05, -0.4385E-05, -0.7453E-05, -0.1200E-04,  &
      -0.1843E-04, -0.2731E-04, -0.3943E-04, -0.5606E-04, -0.7936E-04,  &
      -0.1123E-03, -0.1588E-03, -0.2231E-03, -0.3101E-03, -0.4247E-03,  &
      -0.5713E-03, -0.7522E-03, -0.9651E-03, -0.1202E-02, -0.1456E-02,  &
      -0.1721E-02, -0.1983E-02, -0.2196E-02, -0.2296E-02, -0.2224E-02,  &
      -0.1952E-02/
  DATA ((h23(ip,iw,1),iw=1,31),ip=19,19)/                               &
      -0.1827E-09, -0.3607E-09, -0.7057E-09, -0.1359E-08, -0.2552E-08,  &
      -0.4615E-08, -0.7854E-08, -0.1218E-07, -0.1670E-07, -0.2008E-07,  &
      -0.2241E-07, -0.2516E-07, -0.2796E-07, -0.3015E-07, -0.3506E-07,  &
      -0.4958E-07, -0.7627E-07, -0.1070E-06, -0.1289E-06, -0.1286E-06,  &
      -0.8843E-07,  0.1492E-07,  0.2118E-06,  0.5155E-06,  0.8665E-06,  &
      0.1220E-05,  0.1765E-05,  0.2825E-05,  0.4498E-05,  0.6563E-05,   &
      0.8422E-05/
  DATA ((h21(ip,iw,1),iw=1,31),ip=20,20)/                               &
      0.3608E-05,  0.7189E-05,  0.1430E-04,  0.2837E-04,  0.5601E-04,   &
      0.1097E-03,  0.2120E-03,  0.4017E-03,  0.7396E-03,  0.1311E-02,   &
      0.2226E-02,  0.3624E-02,  0.5685E-02,  0.8652E-02,  0.1286E-01,   &
      0.1878E-01,  0.2709E-01,  0.3868E-01,  0.5471E-01,  0.7654E-01,   &
      0.1057E+00,  0.1435E+00,  0.1912E+00,  0.2492E+00,  0.3181E+00,   &
      0.3990E+00,  0.4926E+00,  0.5960E+00,  0.7027E+00,  0.8027E+00,   &
      0.8852E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip=20,20)/                               &
      -0.5164E-07, -0.1026E-06, -0.2031E-06, -0.3994E-06, -0.7771E-06,  &
      -0.1488E-05, -0.2776E-05, -0.5001E-05, -0.8610E-05, -0.1411E-04,  &
      -0.2209E-04, -0.3328E-04, -0.4860E-04, -0.6954E-04, -0.9861E-04,  &
      -0.1393E-03, -0.1961E-03, -0.2738E-03, -0.3778E-03, -0.5132E-03,  &
      -0.6831E-03, -0.8868E-03, -0.1118E-02, -0.1368E-02, -0.1632E-02,  &
      -0.1899E-02, -0.2136E-02, -0.2282E-02, -0.2273E-02, -0.2067E-02,  &
      -0.1679E-02/
  DATA ((h23(ip,iw,1),iw=1,31),ip=20,20)/                               &
      -0.2058E-09, -0.4066E-09, -0.7967E-09, -0.1539E-08, -0.2904E-08,  &
      -0.5293E-08, -0.9116E-08, -0.1447E-07, -0.2058E-07, -0.2608E-07,  &
      -0.3053E-07, -0.3418E-07, -0.3619E-07, -0.3766E-07, -0.4313E-07,  &
      -0.5817E-07, -0.8299E-07, -0.1072E-06, -0.1195E-06, -0.1031E-06,  &
      -0.3275E-07,  0.1215E-06,  0.3835E-06,  0.7220E-06,  0.1062E-05,  &
      0.1504E-05,  0.2367E-05,  0.3854E-05,  0.5842E-05,  0.7875E-05,   &
      0.9082E-05/
  DATA ((h21(ip,iw,1),iw=1,31),ip=21,21)/                               &
      0.3827E-05,  0.7626E-05,  0.1518E-04,  0.3013E-04,  0.5955E-04,   &
      0.1169E-03,  0.2268E-03,  0.4325E-03,  0.8046E-03,  0.1449E-02,   &
      0.2512E-02,  0.4185E-02,  0.6707E-02,  0.1038E-01,  0.1561E-01,   &
      0.2298E-01,  0.3328E-01,  0.4754E-01,  0.6708E-01,  0.9340E-01,   &
      0.1280E+00,  0.1722E+00,  0.2267E+00,  0.2918E+00,  0.3688E+00,   &
      0.4584E+00,  0.5594E+00,  0.6662E+00,  0.7700E+00,  0.8597E+00,   &
      0.9266E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip=21,21)/                               &
      -0.5584E-07, -0.1110E-06, -0.2198E-06, -0.4329E-06, -0.8444E-06,  &
      -0.1623E-05, -0.3049E-05, -0.5551E-05, -0.9714E-05, -0.1627E-04,  &
      -0.2609E-04, -0.4015E-04, -0.5955E-04, -0.8603E-04, -0.1223E-03,  &
      -0.1724E-03, -0.2413E-03, -0.3346E-03, -0.4578E-03, -0.6155E-03,  &
      -0.8087E-03, -0.1033E-02, -0.1279E-02, -0.1540E-02, -0.1811E-02,  &
      -0.2065E-02, -0.2251E-02, -0.2301E-02, -0.2163E-02, -0.1828E-02,  &
      -0.1365E-02/
  DATA ((h23(ip,iw,1),iw=1,31),ip=21,21)/                               &
      -0.2274E-09, -0.4498E-09, -0.8814E-09, -0.1708E-08, -0.3247E-08,  &
      -0.5972E-08, -0.1045E-07, -0.1707E-07, -0.2545E-07, -0.3440E-07,  &
      -0.4259E-07, -0.4822E-07, -0.5004E-07, -0.5061E-07, -0.5485E-07,  &
      -0.6687E-07, -0.8483E-07, -0.9896E-07, -0.9646E-07, -0.5557E-07,  &
      0.5765E-07,  0.2752E-06,  0.5870E-06,  0.9188E-06,  0.1291E-05,   &
      0.1971E-05,  0.3251E-05,  0.5115E-05,  0.7221E-05,  0.8825E-05,   &
      0.9032E-05/
  DATA ((h21(ip,iw,1),iw=1,31),ip=22,22)/                               &
      0.3938E-05,  0.7849E-05,  0.1563E-04,  0.3105E-04,  0.6149E-04,   &
      0.1210E-03,  0.2361E-03,  0.4537E-03,  0.8543E-03,  0.1565E-02,   &
      0.2774E-02,  0.4739E-02,  0.7781E-02,  0.1229E-01,  0.1877E-01,   &
      0.2791E-01,  0.4064E-01,  0.5812E-01,  0.8180E-01,  0.1132E+00,   &
      0.1539E+00,  0.2047E+00,  0.2662E+00,  0.3391E+00,  0.4247E+00,   &
      0.5226E+00,  0.6287E+00,  0.7351E+00,  0.8311E+00,  0.9066E+00,   &
      0.9569E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip=22,22)/                               &
      -0.5833E-07, -0.1160E-06, -0.2300E-06, -0.4540E-06, -0.8885E-06,  &
      -0.1718E-05, -0.3256E-05, -0.6010E-05, -0.1072E-04, -0.1838E-04,  &
      -0.3026E-04, -0.4772E-04, -0.7223E-04, -0.1057E-03, -0.1512E-03,  &
      -0.2128E-03, -0.2961E-03, -0.4070E-03, -0.5514E-03, -0.7320E-03,  &
      -0.9467E-03, -0.1187E-02, -0.1446E-02, -0.1717E-02, -0.1985E-02,  &
      -0.2203E-02, -0.2307E-02, -0.2237E-02, -0.1965E-02, -0.1532E-02,  &
      -0.1044E-02/
  DATA ((h23(ip,iw,1),iw=1,31),ip=22,22)/                               &
      -0.2426E-09, -0.4805E-09, -0.9447E-09, -0.1841E-08, -0.3519E-08,  &
      -0.6565E-08, -0.1172E-07, -0.1979E-07, -0.3095E-07, -0.4443E-07,  &
      -0.5821E-07, -0.6868E-07, -0.7282E-07, -0.7208E-07, -0.7176E-07,  &
      -0.7562E-07, -0.8110E-07, -0.7934E-07, -0.5365E-07,  0.2483E-07,  &
      0.1959E-06,  0.4731E-06,  0.7954E-06,  0.1123E-05,  0.1652E-05,   &
      0.2711E-05,  0.4402E-05,  0.6498E-05,  0.8392E-05,  0.9154E-05,   &
      0.8261E-05/
  DATA ((h21(ip,iw,1),iw=1,31),ip=23,23)/                               &
      0.3973E-05,  0.7921E-05,  0.1578E-04,  0.3139E-04,  0.6229E-04,   &
      0.1231E-03,  0.2414E-03,  0.4680E-03,  0.8923E-03,  0.1663E-02,   &
      0.3011E-02,  0.5268E-02,  0.8869E-02,  0.1434E-01,  0.2230E-01,   &
      0.3359E-01,  0.4924E-01,  0.7057E-01,  0.9908E-01,  0.1363E+00,   &
      0.1834E+00,  0.2411E+00,  0.3100E+00,  0.3913E+00,  0.4856E+00,   &
      0.5901E+00,  0.6981E+00,  0.7994E+00,  0.8832E+00,  0.9424E+00,   &
      0.9773E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip=23,23)/                               &
      -0.5929E-07, -0.1180E-06, -0.2344E-06, -0.4638E-06, -0.9118E-06,  &
      -0.1775E-05, -0.3401E-05, -0.6375E-05, -0.1160E-04, -0.2039E-04,  &
      -0.3444E-04, -0.5575E-04, -0.8641E-04, -0.1287E-03, -0.1856E-03,  &
      -0.2615E-03, -0.3618E-03, -0.4928E-03, -0.6594E-03, -0.8621E-03,  &
      -0.1095E-02, -0.1349E-02, -0.1618E-02, -0.1894E-02, -0.2140E-02,  &
      -0.2293E-02, -0.2290E-02, -0.2085E-02, -0.1696E-02, -0.1212E-02,  &
      -0.7506E-03/
  DATA ((h23(ip,iw,1),iw=1,31),ip=23,23)/                               &
      -0.2496E-09, -0.4954E-09, -0.9780E-09, -0.1915E-08, -0.3697E-08,  &
      -0.6991E-08, -0.1279E-07, -0.2231E-07, -0.3653E-07, -0.5541E-07,  &
      -0.7688E-07, -0.9614E-07, -0.1069E-06, -0.1065E-06, -0.9866E-07,  &
      -0.8740E-07, -0.7192E-07, -0.4304E-07,  0.1982E-07,  0.1525E-06,  &
      0.3873E-06,  0.6947E-06,  0.1000E-05,  0.1409E-05,  0.2253E-05,   &
      0.3739E-05,  0.5744E-05,  0.7812E-05,  0.9067E-05,  0.8746E-05,   &
      0.6940E-05/
  DATA ((h21(ip,iw,1),iw=1,31),ip=24,24)/                               &
      0.3978E-05,  0.7933E-05,  0.1581E-04,  0.3149E-04,  0.6260E-04,   &
      0.1240E-03,  0.2445E-03,  0.4777E-03,  0.9213E-03,  0.1743E-02,   &
      0.3217E-02,  0.5756E-02,  0.9929E-02,  0.1644E-01,  0.2612E-01,   &
      0.3995E-01,  0.5910E-01,  0.8497E-01,  0.1190E+00,  0.1626E+00,   &
      0.2165E+00,  0.2813E+00,  0.3583E+00,  0.4485E+00,  0.5505E+00,   &
      0.6590E+00,  0.7646E+00,  0.8562E+00,  0.9245E+00,  0.9676E+00,   &
      0.9897E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip=24,24)/                               &
      -0.5950E-07, -0.1185E-06, -0.2358E-06, -0.4678E-06, -0.9235E-06,  &
      -0.1810E-05, -0.3503E-05, -0.6664E-05, -0.1236E-04, -0.2223E-04,  &
      -0.3849E-04, -0.6396E-04, -0.1017E-03, -0.1545E-03, -0.2257E-03,  &
      -0.3192E-03, -0.4399E-03, -0.5933E-03, -0.7824E-03, -0.1005E-02,  &
      -0.1251E-02, -0.1516E-02, -0.1794E-02, -0.2060E-02, -0.2257E-02,  &
      -0.2318E-02, -0.2186E-02, -0.1853E-02, -0.1386E-02, -0.9021E-03,  &
      -0.5050E-03/
  DATA ((h23(ip,iw,1),iw=1,31),ip=24,24)/                               &
      -0.2515E-09, -0.5001E-09, -0.9904E-09, -0.1951E-08, -0.3800E-08,  &
      -0.7288E-08, -0.1362E-07, -0.2452E-07, -0.4184E-07, -0.6663E-07,  &
      -0.9770E-07, -0.1299E-06, -0.1533E-06, -0.1584E-06, -0.1425E-06,  &
      -0.1093E-06, -0.5972E-07,  0.1426E-07,  0.1347E-06,  0.3364E-06,  &
      0.6209E-06,  0.9169E-06,  0.1243E-05,  0.1883E-05,  0.3145E-05,   &
      0.5011E-05,  0.7136E-05,  0.8785E-05,  0.9048E-05,  0.7686E-05,   &
      0.5368E-05/
  DATA ((h21(ip,iw,1),iw=1,31),ip=25,25)/                               &
      0.3978E-05,  0.7934E-05,  0.1582E-04,  0.3153E-04,  0.6275E-04,   &
      0.1246E-03,  0.2466E-03,  0.4847E-03,  0.9432E-03,  0.1808E-02,   &
      0.3392E-02,  0.6189E-02,  0.1092E-01,  0.1852E-01,  0.3009E-01,   &
      0.4683E-01,  0.7008E-01,  0.1012E+00,  0.1416E+00,  0.1920E+00,   &
      0.2531E+00,  0.3258E+00,  0.4115E+00,  0.5102E+00,  0.6180E+00,   &
      0.7267E+00,  0.8252E+00,  0.9030E+00,  0.9550E+00,  0.9838E+00,   &
      0.9965E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip=25,25)/                               &
      -0.5953E-07, -0.1187E-06, -0.2363E-06, -0.4697E-06, -0.9304E-06,  &
      -0.1833E-05, -0.3578E-05, -0.6889E-05, -0.1299E-04, -0.2384E-04,  &
      -0.4227E-04, -0.7201E-04, -0.1174E-03, -0.1825E-03, -0.2710E-03,  &
      -0.3861E-03, -0.5313E-03, -0.7095E-03, -0.9203E-03, -0.1158E-02,  &
      -0.1417E-02, -0.1691E-02, -0.1968E-02, -0.2200E-02, -0.2320E-02,  &
      -0.2263E-02, -0.1998E-02, -0.1563E-02, -0.1068E-02, -0.6300E-03,  &
      -0.3174E-03/
  DATA ((h23(ip,iw,1),iw=1,31),ip=25,25)/                               &
      -0.2520E-09, -0.5016E-09, -0.9963E-09, -0.1971E-08, -0.3867E-08,  &
      -0.7500E-08, -0.1427E-07, -0.2634E-07, -0.4656E-07, -0.7753E-07,  &
      -0.1196E-06, -0.1683E-06, -0.2113E-06, -0.2309E-06, -0.2119E-06,  &
      -0.1518E-06, -0.5200E-07,  0.9274E-07,  0.2973E-06,  0.5714E-06,  &
      0.8687E-06,  0.1152E-05,  0.1621E-05,  0.2634E-05,  0.4310E-05,   &
      0.6418E-05,  0.8347E-05,  0.9162E-05,  0.8319E-05,  0.6209E-05,   &
      0.3844E-05/
  DATA ((h21(ip,iw,1),iw=1,31),ip=26,26)/                               &
      0.3976E-05,  0.7932E-05,  0.1582E-04,  0.3154E-04,  0.6284E-04,   &
      0.1250E-03,  0.2479E-03,  0.4896E-03,  0.9592E-03,  0.1857E-02,   &
      0.3532E-02,  0.6558E-02,  0.1181E-01,  0.2048E-01,  0.3402E-01,   &
      0.5399E-01,  0.8188E-01,  0.1190E+00,  0.1664E+00,  0.2243E+00,   &
      0.2933E+00,  0.3747E+00,  0.4695E+00,  0.5755E+00,  0.6858E+00,   &
      0.7903E+00,  0.8773E+00,  0.9391E+00,  0.9758E+00,  0.9934E+00,   &
      0.9996E+00/
  DATA ((h22(ip,iw,1),iw=1,31),ip=26,26)/                               &
      -0.5954E-07, -0.1187E-06, -0.2366E-06, -0.4709E-06, -0.9349E-06,  &
      -0.1849E-05, -0.3632E-05, -0.7058E-05, -0.1350E-04, -0.2521E-04,  &
      -0.4564E-04, -0.7958E-04, -0.1329E-03, -0.2114E-03, -0.3200E-03,  &
      -0.4611E-03, -0.6353E-03, -0.8409E-03, -0.1072E-02, -0.1324E-02,  &
      -0.1592E-02, -0.1871E-02, -0.2127E-02, -0.2297E-02, -0.2312E-02,  &
      -0.2123E-02, -0.1738E-02, -0.1247E-02, -0.7744E-03, -0.4117E-03,  &
      -0.1850E-03/
  DATA ((h23(ip,iw,1),iw=1,31),ip=26,26)/                               &
      -0.2522E-09, -0.5025E-09, -0.9997E-09, -0.1983E-08, -0.3912E-08,  &
      -0.7650E-08, -0.1474E-07, -0.2777E-07, -0.5055E-07, -0.8745E-07,  &
      -0.1414E-06, -0.2095E-06, -0.2790E-06, -0.3241E-06, -0.3135E-06,  &
      -0.2269E-06, -0.5896E-07,  0.1875E-06,  0.4996E-06,  0.8299E-06,  &
      0.1115E-05,  0.1467E-05,  0.2236E-05,  0.3672E-05,  0.5668E-05,   &
      0.7772E-05,  0.9094E-05,  0.8827E-05,  0.7041E-05,  0.4638E-05,   &
      0.2539E-05/
  DATA ((h71(ip,iw,1),iw=1,31),ip= 1, 1)/                               &
      0.1342E-04,  0.2640E-04,  0.5137E-04,  0.9829E-04,  0.1832E-03,   &
      0.3284E-03,  0.5585E-03,  0.8907E-03,  0.1327E-02,  0.1856E-02,   &
      0.2461E-02,  0.3138E-02,  0.3898E-02,  0.4766E-02,  0.5783E-02,   &
      0.7007E-02,  0.8521E-02,  0.1041E-01,  0.1278E-01,  0.1570E-01,   &
      0.1928E-01,  0.2361E-01,  0.2884E-01,  0.3520E-01,  0.4305E-01,   &
      0.5286E-01,  0.6531E-01,  0.8127E-01,  0.1019E+00,  0.1287E+00,   &
      0.1632E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip= 1, 1)/                               &
      -0.5685E-08, -0.1331E-07, -0.3249E-07, -0.8137E-07, -0.2048E-06,  &
      -0.4973E-06, -0.1118E-05, -0.2246E-05, -0.3982E-05, -0.6290E-05,  &
      -0.9040E-05, -0.1215E-04, -0.1567E-04, -0.1970E-04, -0.2449E-04,  &
      -0.3046E-04, -0.3798E-04, -0.4725E-04, -0.5831E-04, -0.7123E-04,  &
      -0.8605E-04, -0.1028E-03, -0.1212E-03, -0.1413E-03, -0.1635E-03,  &
      -0.1884E-03, -0.2160E-03, -0.2461E-03, -0.2778E-03, -0.3098E-03,  &
      -0.3411E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip= 1, 1)/                               &
      0.2169E-10,  0.5237E-10,  0.1296E-09,  0.3204E-09,  0.7665E-09,   &
      0.1691E-08,  0.3222E-08,  0.5110E-08,  0.6779E-08,  0.7681E-08,   &
      0.7378E-08,  0.5836E-08,  0.3191E-08, -0.1491E-08, -0.1022E-07,   &
      -0.2359E-07, -0.3957E-07, -0.5553E-07, -0.6927E-07, -0.7849E-07,  &
      -0.8139E-07, -0.7853E-07, -0.7368E-07, -0.7220E-07, -0.7780E-07,  &
      -0.9091E-07, -0.1038E-06, -0.9929E-07, -0.5422E-07,  0.5379E-07,  &
      0.2350E-06/
  DATA ((h71(ip,iw,1),iw=1,31),ip= 2, 2)/                               &
      0.1342E-04,  0.2640E-04,  0.5137E-04,  0.9829E-04,  0.1832E-03,   &
      0.3284E-03,  0.5586E-03,  0.8908E-03,  0.1327E-02,  0.1856E-02,   &
      0.2462E-02,  0.3140E-02,  0.3902E-02,  0.4774E-02,  0.5797E-02,   &
      0.7033E-02,  0.8570E-02,  0.1050E-01,  0.1294E-01,  0.1599E-01,   &
      0.1979E-01,  0.2448E-01,  0.3024E-01,  0.3738E-01,  0.4633E-01,   &
      0.5766E-01,  0.7218E-01,  0.9096E-01,  0.1154E+00,  0.1471E+00,   &
      0.1880E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip= 2, 2)/                               &
      -0.5684E-08, -0.1331E-07, -0.3248E-07, -0.8133E-07, -0.2047E-06,  &
      -0.4971E-06, -0.1117E-05, -0.2245E-05, -0.3981E-05, -0.6287E-05,  &
      -0.9035E-05, -0.1215E-04, -0.1565E-04, -0.1967E-04, -0.2444E-04,  &
      -0.3036E-04, -0.3780E-04, -0.4694E-04, -0.5779E-04, -0.7042E-04,  &
      -0.8491E-04, -0.1013E-03, -0.1196E-03, -0.1399E-03, -0.1625E-03,  &
      -0.1879E-03, -0.2163E-03, -0.2474E-03, -0.2803E-03, -0.3140E-03,  &
      -0.3478E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip= 2, 2)/                               &
      0.2168E-10,  0.5242E-10,  0.1295E-09,  0.3201E-09,  0.7662E-09,   &
      0.1690E-08,  0.3220E-08,  0.5106E-08,  0.6776E-08,  0.7673E-08,   &
      0.7362E-08,  0.5808E-08,  0.3138E-08, -0.1595E-08, -0.1041E-07,   &
      -0.2390E-07, -0.4010E-07, -0.5636E-07, -0.7045E-07, -0.7972E-07,  &
      -0.8178E-07, -0.7677E-07, -0.6876E-07, -0.6381E-07, -0.6583E-07,  &
      -0.7486E-07, -0.8229E-07, -0.7017E-07, -0.1497E-07,  0.1051E-06,  &
      0.2990E-06/
  DATA ((h71(ip,iw,1),iw=1,31),ip= 3, 3)/                               &
      0.1342E-04,  0.2640E-04,  0.5137E-04,  0.9830E-04,  0.1832E-03,   &
      0.3285E-03,  0.5587E-03,  0.8911E-03,  0.1328E-02,  0.1857E-02,   &
      0.2465E-02,  0.3144E-02,  0.3909E-02,  0.4787E-02,  0.5820E-02,   &
      0.7075E-02,  0.8646E-02,  0.1064E-01,  0.1319E-01,  0.1643E-01,   &
      0.2053E-01,  0.2569E-01,  0.3215E-01,  0.4028E-01,  0.5059E-01,   &
      0.6380E-01,  0.8088E-01,  0.1031E+00,  0.1321E+00,  0.1698E+00,   &
      0.2179E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip= 3, 3)/                               &
      -0.5682E-08, -0.1330E-07, -0.3247E-07, -0.8129E-07, -0.2046E-06,  &
      -0.4968E-06, -0.1117E-05, -0.2244E-05, -0.3978E-05, -0.6283E-05,  &
      -0.9027E-05, -0.1213E-04, -0.1563E-04, -0.1963E-04, -0.2436E-04,  &
      -0.3021E-04, -0.3754E-04, -0.4649E-04, -0.5709E-04, -0.6940E-04,  &
      -0.8359E-04, -0.9986E-04, -0.1182E-03, -0.1388E-03, -0.1620E-03,  &
      -0.1882E-03, -0.2175E-03, -0.2498E-03, -0.2843E-03, -0.3203E-03,  &
      -0.3573E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip= 3, 3)/                               &
      0.2167E-10,  0.5238E-10,  0.1294E-09,  0.3198E-09,  0.7656E-09,   &
      0.1688E-08,  0.3217E-08,  0.5104E-08,  0.6767E-08,  0.7661E-08,   &
      0.7337E-08,  0.5764E-08,  0.3051E-08, -0.1752E-08, -0.1068E-07,   &
      -0.2436E-07, -0.4081E-07, -0.5740E-07, -0.7165E-07, -0.8046E-07,  &
      -0.8082E-07, -0.7289E-07, -0.6141E-07, -0.5294E-07, -0.5134E-07,  &
      -0.5552E-07, -0.5609E-07, -0.3464E-07,  0.3275E-07,  0.1669E-06,  &
      0.3745E-06/
  DATA ((h71(ip,iw,1),iw=1,31),ip= 4, 4)/                               &
      0.1342E-04,  0.2640E-04,  0.5138E-04,  0.9830E-04,  0.1832E-03,   &
      0.3286E-03,  0.5589E-03,  0.8915E-03,  0.1329E-02,  0.1859E-02,   &
      0.2468E-02,  0.3150E-02,  0.3920E-02,  0.4806E-02,  0.5855E-02,   &
      0.7140E-02,  0.8763E-02,  0.1085E-01,  0.1356E-01,  0.1707E-01,   &
      0.2158E-01,  0.2736E-01,  0.3471E-01,  0.4407E-01,  0.5608E-01,   &
      0.7161E-01,  0.9184E-01,  0.1183E+00,  0.1528E+00,  0.1973E+00,   &
      0.2537E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip= 4, 4)/                               &
      -0.5680E-08, -0.1329E-07, -0.3243E-07, -0.8121E-07, -0.2044E-06,  &
      -0.4963E-06, -0.1115E-05, -0.2242E-05, -0.3974E-05, -0.6276E-05,  &
      -0.9015E-05, -0.1211E-04, -0.1559E-04, -0.1956E-04, -0.2423E-04,  &
      -0.2999E-04, -0.3716E-04, -0.4588E-04, -0.5618E-04, -0.6818E-04,  &
      -0.8218E-04, -0.9847E-04, -0.1171E-03, -0.1382E-03, -0.1621E-03,  &
      -0.1892E-03, -0.2197E-03, -0.2535E-03, -0.2902E-03, -0.3293E-03,  &
      -0.3700E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip= 4, 4)/                               &
      0.2166E-10,  0.5229E-10,  0.1294E-09,  0.3193E-09,  0.7644E-09,   &
      0.1686E-08,  0.3213E-08,  0.5092E-08,  0.6753E-08,  0.7640E-08,   &
      0.7302E-08,  0.5696E-08,  0.2917E-08, -0.1984E-08, -0.1108E-07,   &
      -0.2497E-07, -0.4171E-07, -0.5849E-07, -0.7254E-07, -0.8017E-07,  &
      -0.7802E-07, -0.6662E-07, -0.5153E-07, -0.3961E-07, -0.3387E-07,  &
      -0.3219E-07, -0.2426E-07,  0.8700E-08,  0.9027E-07,  0.2400E-06,  &
      0.4623E-06/
  DATA ((h71(ip,iw,1),iw=1,31),ip= 5, 5)/                               &
      0.1342E-04,  0.2640E-04,  0.5138E-04,  0.9832E-04,  0.1833E-03,   &
      0.3287E-03,  0.5591E-03,  0.8922E-03,  0.1330E-02,  0.1862E-02,   &
      0.2473E-02,  0.3159E-02,  0.3937E-02,  0.4837E-02,  0.5911E-02,   &
      0.7240E-02,  0.8943E-02,  0.1117E-01,  0.1411E-01,  0.1798E-01,   &
      0.2304E-01,  0.2961E-01,  0.3807E-01,  0.4896E-01,  0.6308E-01,   &
      0.8148E-01,  0.1056E+00,  0.1371E+00,  0.1780E+00,  0.2303E+00,   &
      0.2958E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip= 5, 5)/                               &
      -0.5675E-08, -0.1328E-07, -0.3239E-07, -0.8110E-07, -0.2040E-06,  &
      -0.4954E-06, -0.1114E-05, -0.2238E-05, -0.3968E-05, -0.6265E-05,  &
      -0.8996E-05, -0.1208E-04, -0.1553E-04, -0.1945E-04, -0.2404E-04,  &
      -0.2966E-04, -0.3663E-04, -0.4508E-04, -0.5508E-04, -0.6686E-04,  &
      -0.8082E-04, -0.9732E-04, -0.1165E-03, -0.1382E-03, -0.1630E-03,  &
      -0.1913E-03, -0.2234E-03, -0.2593E-03, -0.2989E-03, -0.3417E-03,  &
      -0.3857E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip= 5, 5)/                               &
      0.2163E-10,  0.5209E-10,  0.1291E-09,  0.3186E-09,  0.7626E-09,   &
      0.1682E-08,  0.3203E-08,  0.5078E-08,  0.6730E-08,  0.7606E-08,   &
      0.7246E-08,  0.5592E-08,  0.2735E-08, -0.2325E-08, -0.1162E-07,   &
      -0.2576E-07, -0.4268E-07, -0.5938E-07, -0.7262E-07, -0.7827E-07,  &
      -0.7297E-07, -0.5786E-07, -0.3930E-07, -0.2373E-07, -0.1295E-07,  &
      -0.3728E-08,  0.1465E-07,  0.6114E-07,  0.1590E-06,  0.3257E-06,  &
      0.5622E-06/
  DATA ((h71(ip,iw,1),iw=1,31),ip= 6, 6)/                               &
      0.1342E-04,  0.2640E-04,  0.5139E-04,  0.9834E-04,  0.1833E-03,   &
      0.3288E-03,  0.5596E-03,  0.8932E-03,  0.1332E-02,  0.1866E-02,   &
      0.2481E-02,  0.3174E-02,  0.3963E-02,  0.4885E-02,  0.5997E-02,   &
      0.7394E-02,  0.9215E-02,  0.1164E-01,  0.1489E-01,  0.1924E-01,   &
      0.2501E-01,  0.3258E-01,  0.4243E-01,  0.5523E-01,  0.7195E-01,   &
      0.9387E-01,  0.1226E+00,  0.1601E+00,  0.2084E+00,  0.2695E+00,   &
      0.3446E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip= 6, 6)/                               &
      -0.5671E-08, -0.1326E-07, -0.3234E-07, -0.8091E-07, -0.2035E-06,  &
      -0.4941E-06, -0.1111E-05, -0.2232E-05, -0.3958E-05, -0.6247E-05,  &
      -0.8966E-05, -0.1202E-04, -0.1544E-04, -0.1929E-04, -0.2377E-04,  &
      -0.2921E-04, -0.3593E-04, -0.4409E-04, -0.5385E-04, -0.6555E-04,  &
      -0.7965E-04, -0.9656E-04, -0.1163E-03, -0.1390E-03, -0.1649E-03,  &
      -0.1947E-03, -0.2288E-03, -0.2675E-03, -0.3109E-03, -0.3575E-03,  &
      -0.4039E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip= 6, 6)/                               &
      0.2155E-10,  0.5188E-10,  0.1288E-09,  0.3175E-09,  0.7599E-09,   &
      0.1675E-08,  0.3190E-08,  0.5059E-08,  0.6699E-08,  0.7551E-08,   &
      0.7154E-08,  0.5435E-08,  0.2452E-08, -0.2802E-08, -0.1235E-07,   &
      -0.2668E-07, -0.4353E-07, -0.5962E-07, -0.7134E-07, -0.7435E-07,  &
      -0.6551E-07, -0.4676E-07, -0.2475E-07, -0.4876E-08,  0.1235E-07,  &
      0.3092E-07,  0.6192E-07,  0.1243E-06,  0.2400E-06,  0.4247E-06,   &
      0.6755E-06/
  DATA ((h71(ip,iw,1),iw=1,31),ip= 7, 7)/                               &
      0.1342E-04,  0.2640E-04,  0.5139E-04,  0.9837E-04,  0.1834E-03,   &
      0.3291E-03,  0.5603E-03,  0.8949E-03,  0.1336E-02,  0.1873E-02,   &
      0.2494E-02,  0.3198E-02,  0.4005E-02,  0.4960E-02,  0.6130E-02,   &
      0.7628E-02,  0.9618E-02,  0.1232E-01,  0.1599E-01,  0.2097E-01,   &
      0.2764E-01,  0.3646E-01,  0.4803E-01,  0.6319E-01,  0.8312E-01,   &
      0.1093E+00,  0.1436E+00,  0.1881E+00,  0.2448E+00,  0.3153E+00,   &
      0.4001E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip= 7, 7)/                               &
      -0.5665E-08, -0.1322E-07, -0.3224E-07, -0.8063E-07, -0.2027E-06,  &
      -0.4921E-06, -0.1106E-05, -0.2223E-05, -0.3942E-05, -0.6220E-05,  &
      -0.8920E-05, -0.1194E-04, -0.1530E-04, -0.1905E-04, -0.2337E-04,  &
      -0.2860E-04, -0.3505E-04, -0.4296E-04, -0.5259E-04, -0.6439E-04,  &
      -0.7884E-04, -0.9635E-04, -0.1170E-03, -0.1407E-03, -0.1681E-03,  &
      -0.1998E-03, -0.2366E-03, -0.2790E-03, -0.3265E-03, -0.3763E-03,  &
      -0.4235E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip= 7, 7)/                               &
      0.2157E-10,  0.5178E-10,  0.1283E-09,  0.3162E-09,  0.7558E-09,   &
      0.1665E-08,  0.3169E-08,  0.5027E-08,  0.6645E-08,  0.7472E-08,   &
      0.7017E-08,  0.5212E-08,  0.2059E-08, -0.3443E-08, -0.1321E-07,   &
      -0.2754E-07, -0.4389E-07, -0.5869E-07, -0.6825E-07, -0.6819E-07,  &
      -0.5570E-07, -0.3343E-07, -0.7592E-08,  0.1778E-07,  0.4322E-07,  &
      0.7330E-07,  0.1190E-06,  0.1993E-06,  0.3348E-06,  0.5376E-06,   &
      0.8030E-06/
  DATA ((h71(ip,iw,1),iw=1,31),ip= 8, 8)/                               &
      0.1342E-04,  0.2641E-04,  0.5141E-04,  0.9842E-04,  0.1836E-03,   &
      0.3295E-03,  0.5614E-03,  0.8975E-03,  0.1341E-02,  0.1884E-02,   &
      0.2514E-02,  0.3234E-02,  0.4071E-02,  0.5075E-02,  0.6332E-02,   &
      0.7976E-02,  0.1021E-01,  0.1328E-01,  0.1751E-01,  0.2329E-01,   &
      0.3109E-01,  0.4146E-01,  0.5517E-01,  0.7325E-01,  0.9710E-01,   &
      0.1284E+00,  0.1693E+00,  0.2217E+00,  0.2876E+00,  0.3679E+00,   &
      0.4616E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip= 8, 8)/                               &
      -0.5652E-08, -0.1318E-07, -0.3210E-07, -0.8018E-07, -0.2014E-06,  &
      -0.4888E-06, -0.1099E-05, -0.2210E-05, -0.3918E-05, -0.6179E-05,  &
      -0.8849E-05, -0.1182E-04, -0.1509E-04, -0.1871E-04, -0.2284E-04,  &
      -0.2782E-04, -0.3403E-04, -0.4177E-04, -0.5145E-04, -0.6354E-04,  &
      -0.7853E-04, -0.9681E-04, -0.1185E-03, -0.1437E-03, -0.1729E-03,  &
      -0.2072E-03, -0.2475E-03, -0.2942E-03, -0.3457E-03, -0.3973E-03,  &
      -0.4434E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip= 8, 8)/                               &
      0.2153E-10,  0.5151E-10,  0.1273E-09,  0.3136E-09,  0.7488E-09,   &
      0.1649E-08,  0.3142E-08,  0.4980E-08,  0.6559E-08,  0.7346E-08,   &
      0.6813E-08,  0.4884E-08,  0.1533E-08, -0.4209E-08, -0.1409E-07,   &
      -0.2801E-07, -0.4320E-07, -0.5614E-07, -0.6312E-07, -0.5976E-07,  &
      -0.4369E-07, -0.1775E-07,  0.1280E-07,  0.4534E-07,  0.8106E-07,  &
      0.1246E-06,  0.1874E-06,  0.2873E-06,  0.4433E-06,  0.6651E-06,   &
      0.9477E-06/
  DATA ((h71(ip,iw,1),iw=1,31),ip= 9, 9)/                               &
      0.1342E-04,  0.2641E-04,  0.5143E-04,  0.9849E-04,  0.1838E-03,   &
      0.3302E-03,  0.5631E-03,  0.9016E-03,  0.1350E-02,  0.1901E-02,   &
      0.2546E-02,  0.3292E-02,  0.4171E-02,  0.5250E-02,  0.6634E-02,   &
      0.8486E-02,  0.1104E-01,  0.1460E-01,  0.1955E-01,  0.2635E-01,   &
      0.3555E-01,  0.4786E-01,  0.6421E-01,  0.8588E-01,  0.1145E+00,   &
      0.1519E+00,  0.2003E+00,  0.2615E+00,  0.3372E+00,  0.4269E+00,   &
      0.5281E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip= 9, 9)/                               &
      -0.5629E-08, -0.1310E-07, -0.3186E-07, -0.7948E-07, -0.1995E-06,  &
      -0.4837E-06, -0.1088E-05, -0.2188E-05, -0.3880E-05, -0.6115E-05,  &
      -0.8743E-05, -0.1165E-04, -0.1480E-04, -0.1824E-04, -0.2216E-04,  &
      -0.2691E-04, -0.3293E-04, -0.4067E-04, -0.5057E-04, -0.6314E-04,  &
      -0.7885E-04, -0.9813E-04, -0.1212E-03, -0.1482E-03, -0.1799E-03,  &
      -0.2175E-03, -0.2622E-03, -0.3135E-03, -0.3678E-03, -0.4193E-03,  &
      -0.4627E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip= 9, 9)/                               &
      0.2121E-10,  0.5076E-10,  0.1257E-09,  0.3091E-09,  0.7379E-09,   &
      0.1623E-08,  0.3097E-08,  0.4904E-08,  0.6453E-08,  0.7168E-08,   &
      0.6534E-08,  0.4458E-08,  0.8932E-09, -0.5026E-08, -0.1469E-07,   &
      -0.2765E-07, -0.4103E-07, -0.5169E-07, -0.5585E-07, -0.4913E-07,  &
      -0.2954E-07,  0.6372E-09,  0.3738E-07,  0.7896E-07,  0.1272E-06,  &
      0.1867E-06,  0.2682E-06,  0.3895E-06,  0.5672E-06,  0.8091E-06,   &
      0.1114E-05/
  DATA ((h71(ip,iw,1),iw=1,31),ip=10,10)/                               &
      0.1343E-04,  0.2642E-04,  0.5147E-04,  0.9861E-04,  0.1842E-03,   &
      0.3312E-03,  0.5658E-03,  0.9080E-03,  0.1364E-02,  0.1928E-02,   &
      0.2595E-02,  0.3379E-02,  0.4325E-02,  0.5513E-02,  0.7077E-02,   &
      0.9215E-02,  0.1220E-01,  0.1640E-01,  0.2226E-01,  0.3032E-01,   &
      0.4127E-01,  0.5598E-01,  0.7559E-01,  0.1016E+00,  0.1359E+00,   &
      0.1804E+00,  0.2372E+00,  0.3081E+00,  0.3935E+00,  0.4916E+00,   &
      0.5975E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip=10,10)/                               &
      -0.5597E-08, -0.1300E-07, -0.3148E-07, -0.7838E-07, -0.1964E-06,  &
      -0.4759E-06, -0.1071E-05, -0.2155E-05, -0.3822E-05, -0.6019E-05,  &
      -0.8586E-05, -0.1139E-04, -0.1439E-04, -0.1764E-04, -0.2134E-04,  &
      -0.2591E-04, -0.3188E-04, -0.3978E-04, -0.5011E-04, -0.6334E-04,  &
      -0.7998E-04, -0.1006E-03, -0.1253E-03, -0.1547E-03, -0.1895E-03,  &
      -0.2315E-03, -0.2811E-03, -0.3363E-03, -0.3917E-03, -0.4413E-03,  &
      -0.4809E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip=10,10)/                               &
      0.2109E-10,  0.5017E-10,  0.1235E-09,  0.3021E-09,  0.7217E-09,   &
      0.1585E-08,  0.3028E-08,  0.4796E-08,  0.6285E-08,  0.6910E-08,   &
      0.6178E-08,  0.3945E-08,  0.2436E-09, -0.5632E-08, -0.1464E-07,   &
      -0.2596E-07, -0.3707E-07, -0.4527E-07, -0.4651E-07, -0.3644E-07,  &
      -0.1296E-07,  0.2250E-07,  0.6722E-07,  0.1202E-06,  0.1831E-06,  &
      0.2605E-06,  0.3627E-06,  0.5062E-06,  0.7064E-06,  0.9725E-06,   &
      0.1304E-05/
  DATA ((h71(ip,iw,1),iw=1,31),ip=11,11)/                               &
      0.1343E-04,  0.2644E-04,  0.5152E-04,  0.9878E-04,  0.1847E-03,   &
      0.3328E-03,  0.5701E-03,  0.9179E-03,  0.1385E-02,  0.1969E-02,   &
      0.2671E-02,  0.3513E-02,  0.4554E-02,  0.5900E-02,  0.7713E-02,   &
      0.1023E-01,  0.1379E-01,  0.1879E-01,  0.2578E-01,  0.3542E-01,   &
      0.4854E-01,  0.6622E-01,  0.8983E-01,  0.1211E+00,  0.1619E+00,   &
      0.2145E+00,  0.2807E+00,  0.3614E+00,  0.4559E+00,  0.5603E+00,   &
      0.6675E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip=11,11)/                               &
      -0.5538E-08, -0.1280E-07, -0.3089E-07, -0.7667E-07, -0.1917E-06,  &
      -0.4642E-06, -0.1045E-05, -0.2106E-05, -0.3736E-05, -0.5878E-05,  &
      -0.8363E-05, -0.1104E-04, -0.1387E-04, -0.1692E-04, -0.2044E-04,  &
      -0.2493E-04, -0.3101E-04, -0.3926E-04, -0.5020E-04, -0.6429E-04,  &
      -0.8213E-04, -0.1044E-03, -0.1314E-03, -0.1637E-03, -0.2027E-03,  &
      -0.2498E-03, -0.3042E-03, -0.3617E-03, -0.4163E-03, -0.4625E-03,  &
      -0.4969E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip=11,11)/                               &
      0.2067E-10,  0.4903E-10,  0.1200E-09,  0.2917E-09,  0.6965E-09,   &
      0.1532E-08,  0.2925E-08,  0.4632E-08,  0.6054E-08,  0.6590E-08,   &
      0.5746E-08,  0.3436E-08, -0.2251E-09, -0.5703E-08, -0.1344E-07,   &
      -0.2256E-07, -0.3120E-07, -0.3690E-07, -0.3520E-07, -0.2164E-07,  &
      0.6510E-08,  0.4895E-07,  0.1037E-06,  0.1702E-06,  0.2502E-06,   &
      0.3472E-06,  0.4710E-06,  0.6379E-06,  0.8633E-06,  0.1159E-05,   &
      0.1514E-05/
  DATA ((h71(ip,iw,1),iw=1,31),ip=12,12)/                               &
      0.1344E-04,  0.2647E-04,  0.5161E-04,  0.9906E-04,  0.1856E-03,   &
      0.3353E-03,  0.5765E-03,  0.9331E-03,  0.1417E-02,  0.2032E-02,   &
      0.2785E-02,  0.3712E-02,  0.4892E-02,  0.6456E-02,  0.8604E-02,   &
      0.1162E-01,  0.1590E-01,  0.2192E-01,  0.3033E-01,  0.4193E-01,   &
      0.5774E-01,  0.7906E-01,  0.1075E+00,  0.1449E+00,  0.1934E+00,   &
      0.2549E+00,  0.3309E+00,  0.4213E+00,  0.5232E+00,  0.6308E+00,   &
      0.7348E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip=12,12)/                               &
      -0.5476E-08, -0.1257E-07, -0.3008E-07, -0.7418E-07, -0.1848E-06,  &
      -0.4468E-06, -0.1006E-05, -0.2032E-05, -0.3611E-05, -0.5679E-05,  &
      -0.8058E-05, -0.1059E-04, -0.1324E-04, -0.1612E-04, -0.1956E-04,  &
      -0.2411E-04, -0.3046E-04, -0.3925E-04, -0.5098E-04, -0.6619E-04,  &
      -0.8562E-04, -0.1100E-03, -0.1399E-03, -0.1761E-03, -0.2202E-03,  &
      -0.2726E-03, -0.3306E-03, -0.3885E-03, -0.4404E-03, -0.4820E-03,  &
      -0.5082E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip=12,12)/                               &
      0.2041E-10,  0.4771E-10,  0.1149E-09,  0.2782E-09,  0.6614E-09,   &
      0.1451E-08,  0.2778E-08,  0.4401E-08,  0.5736E-08,  0.6189E-08,   &
      0.5315E-08,  0.3087E-08, -0.2518E-09, -0.4806E-08, -0.1071E-07,   &
      -0.1731E-07, -0.2346E-07, -0.2659E-07, -0.2184E-07, -0.4261E-08,  &
      0.2975E-07,  0.8112E-07,  0.1484E-06,  0.2308E-06,  0.3296E-06,   &
      0.4475E-06,  0.5942E-06,  0.7859E-06,  0.1041E-05,  0.1369E-05,   &
      0.1726E-05/
  DATA ((h71(ip,iw,1),iw=1,31),ip=13,13)/                               &
      0.1345E-04,  0.2650E-04,  0.5173E-04,  0.9947E-04,  0.1868E-03,   &
      0.3389E-03,  0.5861E-03,  0.9559E-03,  0.1466E-02,  0.2125E-02,   &
      0.2955E-02,  0.4004E-02,  0.5376E-02,  0.7235E-02,  0.9824E-02,   &
      0.1348E-01,  0.1866E-01,  0.2596E-01,  0.3613E-01,  0.5016E-01,   &
      0.6929E-01,  0.9504E-01,  0.1292E+00,  0.1738E+00,  0.2309E+00,   &
      0.3021E+00,  0.3880E+00,  0.4868E+00,  0.5936E+00,  0.7003E+00,   &
      0.7964E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip=13,13)/                               &
      -0.5362E-08, -0.1223E-07, -0.2895E-07, -0.7071E-07, -0.1748E-06,  &
      -0.4219E-06, -0.9516E-06, -0.1928E-05, -0.3436E-05, -0.5409E-05,  &
      -0.7666E-05, -0.1005E-04, -0.1254E-04, -0.1533E-04, -0.1880E-04,  &
      -0.2358E-04, -0.3038E-04, -0.3988E-04, -0.5264E-04, -0.6934E-04,  &
      -0.9083E-04, -0.1179E-03, -0.1515E-03, -0.1927E-03, -0.2424E-03,  &
      -0.2994E-03, -0.3591E-03, -0.4155E-03, -0.4634E-03, -0.4982E-03,  &
      -0.5096E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip=13,13)/                               &
      0.1976E-10,  0.4551E-10,  0.1086E-09,  0.2601E-09,  0.6126E-09,   &
      0.1345E-08,  0.2583E-08,  0.4112E-08,  0.5365E-08,  0.5796E-08,   &
      0.5031E-08,  0.3182E-08,  0.5970E-09, -0.2547E-08, -0.6172E-08,   &
      -0.1017E-07, -0.1388E-07, -0.1430E-07, -0.6118E-08,  0.1624E-07,  &
      0.5791E-07,  0.1205E-06,  0.2025E-06,  0.3032E-06,  0.4225E-06,   &
      0.5619E-06,  0.7322E-06,  0.9528E-06,  0.1243E-05,  0.1592E-05,   &
      0.1904E-05/
  DATA ((h71(ip,iw,1),iw=1,31),ip=14,14)/                               &
      0.1346E-04,  0.2655E-04,  0.5192E-04,  0.1001E-03,  0.1887E-03,   &
      0.3442E-03,  0.6001E-03,  0.9892E-03,  0.1536E-02,  0.2262E-02,   &
      0.3200E-02,  0.4420E-02,  0.6053E-02,  0.8300E-02,  0.1146E-01,   &
      0.1592E-01,  0.2224E-01,  0.3112E-01,  0.4348E-01,  0.6051E-01,   &
      0.8369E-01,  0.1147E+00,  0.1556E+00,  0.2084E+00,  0.2749E+00,   &
      0.3561E+00,  0.4511E+00,  0.5562E+00,  0.6644E+00,  0.7655E+00,   &
      0.8499E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip=14,14)/                               &
      -0.5210E-08, -0.1172E-07, -0.2731E-07, -0.6598E-07, -0.1615E-06,  &
      -0.3880E-06, -0.8769E-06, -0.1787E-05, -0.3204E-05, -0.5066E-05,  &
      -0.7197E-05, -0.9451E-05, -0.1185E-04, -0.1465E-04, -0.1831E-04,  &
      -0.2346E-04, -0.3088E-04, -0.4132E-04, -0.5545E-04, -0.7410E-04,  &
      -0.9820E-04, -0.1288E-03, -0.1670E-03, -0.2140E-03, -0.2692E-03,  &
      -0.3293E-03, -0.3886E-03, -0.4417E-03, -0.4840E-03, -0.5073E-03,  &
      -0.4944E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip=14,14)/                               &
      0.1880E-10,  0.4271E-10,  0.9966E-10,  0.2352E-09,  0.5497E-09,   &
      0.1205E-08,  0.2334E-08,  0.3765E-08,  0.4993E-08,  0.5532E-08,   &
      0.5148E-08,  0.4055E-08,  0.2650E-08,  0.1326E-08,  0.2019E-09,   &
      -0.1124E-08, -0.2234E-08,  0.2827E-09,  0.1247E-07,  0.4102E-07,  &
      0.9228E-07,  0.1682E-06,  0.2676E-06,  0.3885E-06,  0.5286E-06,   &
      0.6904E-06,  0.8871E-06,  0.1142E-05,  0.1466E-05,  0.1800E-05,   &
      0.2004E-05/
  DATA ((h71(ip,iw,1),iw=1,31),ip=15,15)/                               &
      0.1348E-04,  0.2663E-04,  0.5216E-04,  0.1009E-03,  0.1912E-03,   &
      0.3515E-03,  0.6196E-03,  0.1036E-02,  0.1637E-02,  0.2456E-02,   &
      0.3544E-02,  0.4996E-02,  0.6973E-02,  0.9722E-02,  0.1360E-01,   &
      0.1908E-01,  0.2681E-01,  0.3766E-01,  0.5272E-01,  0.7343E-01,   &
      0.1015E+00,  0.1388E+00,  0.1874E+00,  0.2492E+00,  0.3257E+00,   &
      0.4165E+00,  0.5191E+00,  0.6275E+00,  0.7324E+00,  0.8235E+00,   &
      0.8939E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip=15,15)/                               &
      -0.5045E-08, -0.1113E-07, -0.2540E-07, -0.6008E-07, -0.1449E-06,  &
      -0.3457E-06, -0.7826E-06, -0.1609E-05, -0.2920E-05, -0.4665E-05,  &
      -0.6691E-05, -0.8868E-05, -0.1127E-04, -0.1422E-04, -0.1820E-04,  &
      -0.2389E-04, -0.3213E-04, -0.4380E-04, -0.5975E-04, -0.8092E-04,  &
      -0.1083E-03, -0.1433E-03, -0.1873E-03, -0.2402E-03, -0.2997E-03,  &
      -0.3607E-03, -0.4178E-03, -0.4662E-03, -0.4994E-03, -0.5028E-03,  &
      -0.4563E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip=15,15)/                               &
      0.1804E-10,  0.3983E-10,  0.9045E-10,  0.2080E-09,  0.4786E-09,   &
      0.1046E-08,  0.2052E-08,  0.3413E-08,  0.4704E-08,  0.5565E-08,   &
      0.5887E-08,  0.5981E-08,  0.6202E-08,  0.6998E-08,  0.8493E-08,   &
      0.1002E-07,  0.1184E-07,  0.1780E-07,  0.3483E-07,  0.7122E-07,   &
      0.1341E-06,  0.2259E-06,  0.3446E-06,  0.4866E-06,  0.6486E-06,   &
      0.8343E-06,  0.1063E-05,  0.1356E-05,  0.1690E-05,  0.1951E-05,   &
      0.2005E-05/
  DATA ((h71(ip,iw,1),iw=1,31),ip=16,16)/                               &
      0.1351E-04,  0.2672E-04,  0.5247E-04,  0.1019E-03,  0.1944E-03,   &
      0.3609E-03,  0.6451E-03,  0.1098E-02,  0.1772E-02,  0.2718E-02,   &
      0.4009E-02,  0.5767E-02,  0.8190E-02,  0.1158E-01,  0.1636E-01,   &
      0.2311E-01,  0.3260E-01,  0.4586E-01,  0.6425E-01,  0.8940E-01,   &
      0.1232E+00,  0.1678E+00,  0.2251E+00,  0.2967E+00,  0.3831E+00,   &
      0.4825E+00,  0.5901E+00,  0.6976E+00,  0.7946E+00,  0.8725E+00,   &
      0.9285E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip=16,16)/                               &
      -0.4850E-08, -0.1045E-07, -0.2334E-07, -0.5367E-07, -0.1265E-06,  &
      -0.2980E-06, -0.6750E-06, -0.1406E-05, -0.2601E-05, -0.4239E-05,  &
      -0.6201E-05, -0.8389E-05, -0.1091E-04, -0.1413E-04, -0.1859E-04,  &
      -0.2500E-04, -0.3432E-04, -0.4761E-04, -0.6595E-04, -0.9030E-04,  &
      -0.1219E-03, -0.1624E-03, -0.2126E-03, -0.2708E-03, -0.3327E-03,  &
      -0.3926E-03, -0.4458E-03, -0.4871E-03, -0.5045E-03, -0.4777E-03,  &
      -0.3954E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip=16,16)/                               &
      0.1717E-10,  0.3723E-10,  0.8093E-10,  0.1817E-09,  0.4100E-09,   &
      0.8932E-09,  0.1791E-08,  0.3126E-08,  0.4634E-08,  0.6095E-08,   &
      0.7497E-08,  0.9170E-08,  0.1136E-07,  0.1453E-07,  0.1892E-07,   &
      0.2369E-07,  0.2909E-07,  0.3922E-07,  0.6232E-07,  0.1083E-06,   &
      0.1847E-06,  0.2943E-06,  0.4336E-06,  0.5970E-06,  0.7815E-06,   &
      0.9959E-06,  0.1263E-05,  0.1583E-05,  0.1880E-05,  0.2009E-05,   &
      0.1914E-05/
  DATA ((h71(ip,iw,1),iw=1,31),ip=17,17)/                               &
      0.1353E-04,  0.2681E-04,  0.5283E-04,  0.1031E-03,  0.1981E-03,   &
      0.3721E-03,  0.6761E-03,  0.1176E-02,  0.1943E-02,  0.3055E-02,   &
      0.4612E-02,  0.6766E-02,  0.9760E-02,  0.1396E-01,  0.1986E-01,   &
      0.2818E-01,  0.3984E-01,  0.5609E-01,  0.7850E-01,  0.1090E+00,   &
      0.1495E+00,  0.2023E+00,  0.2691E+00,  0.3508E+00,  0.4465E+00,   &
      0.5524E+00,  0.6613E+00,  0.7633E+00,  0.8485E+00,  0.9119E+00,   &
      0.9543E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip=17,17)/                               &
      -0.4673E-08, -0.9862E-08, -0.2135E-07, -0.4753E-07, -0.1087E-06,  &
      -0.2512E-06, -0.5671E-06, -0.1199E-05, -0.2281E-05, -0.3842E-05,  &
      -0.5804E-05, -0.8110E-05, -0.1088E-04, -0.1452E-04, -0.1961E-04,  &
      -0.2696E-04, -0.3768E-04, -0.5311E-04, -0.7444E-04, -0.1028E-03,  &
      -0.1397E-03, -0.1865E-03, -0.2427E-03, -0.3047E-03, -0.3667E-03,  &
      -0.4237E-03, -0.4712E-03, -0.5003E-03, -0.4921E-03, -0.4286E-03,  &
      -0.3188E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip=17,17)/                               &
      0.1653E-10,  0.3436E-10,  0.7431E-10,  0.1605E-09,  0.3548E-09,   &
      0.7723E-09,  0.1595E-08,  0.2966E-08,  0.4849E-08,  0.7169E-08,   &
      0.1003E-07,  0.1366E-07,  0.1825E-07,  0.2419E-07,  0.3186E-07,   &
      0.4068E-07,  0.5064E-07,  0.6618E-07,  0.9684E-07,  0.1536E-06,   &
      0.2450E-06,  0.3730E-06,  0.5328E-06,  0.7184E-06,  0.9291E-06,   &
      0.1180E-05,  0.1484E-05,  0.1798E-05,  0.1992E-05,  0.1968E-05,   &
      0.1736E-05/
  DATA ((h71(ip,iw,1),iw=1,31),ip=18,18)/                               &
      0.1356E-04,  0.2691E-04,  0.5318E-04,  0.1043E-03,  0.2020E-03,   &
      0.3841E-03,  0.7100E-03,  0.1263E-02,  0.2144E-02,  0.3464E-02,   &
      0.5359E-02,  0.8019E-02,  0.1174E-01,  0.1694E-01,  0.2426E-01,   &
      0.3451E-01,  0.4883E-01,  0.6870E-01,  0.9593E-01,  0.1326E+00,   &
      0.1809E+00,  0.2428E+00,  0.3196E+00,  0.4112E+00,  0.5147E+00,   &
      0.6239E+00,  0.7297E+00,  0.8217E+00,  0.8928E+00,  0.9421E+00,   &
      0.9726E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip=18,18)/                               &
      -0.4532E-08, -0.9395E-08, -0.1978E-07, -0.4272E-07, -0.9442E-07,  &
      -0.2124E-06, -0.4747E-06, -0.1017E-05, -0.2003E-05, -0.3524E-05,  &
      -0.5567E-05, -0.8108E-05, -0.1127E-04, -0.1547E-04, -0.2138E-04,  &
      -0.2996E-04, -0.4251E-04, -0.6059E-04, -0.8563E-04, -0.1190E-03,  &
      -0.1623E-03, -0.2156E-03, -0.2767E-03, -0.3403E-03, -0.4006E-03,  &
      -0.4530E-03, -0.4912E-03, -0.4995E-03, -0.4563E-03, -0.3592E-03,  &
      -0.2383E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip=18,18)/                               &
      0.1593E-10,  0.3276E-10,  0.6896E-10,  0.1476E-09,  0.3190E-09,   &
      0.6944E-09,  0.1474E-08,  0.2935E-08,  0.5300E-08,  0.8697E-08,   &
      0.1336E-07,  0.1946E-07,  0.2707E-07,  0.3637E-07,  0.4800E-07,   &
      0.6187E-07,  0.7806E-07,  0.1008E-06,  0.1404E-06,  0.2089E-06,   &
      0.3153E-06,  0.4613E-06,  0.6416E-06,  0.8506E-06,  0.1095E-05,   &
      0.1387E-05,  0.1708E-05,  0.1956E-05,  0.2003E-05,  0.1836E-05,   &
      0.1483E-05/
  DATA ((h71(ip,iw,1),iw=1,31),ip=19,19)/                               &
      0.1358E-04,  0.2700E-04,  0.5350E-04,  0.1054E-03,  0.2057E-03,   &
      0.3955E-03,  0.7434E-03,  0.1353E-02,  0.2361E-02,  0.3928E-02,   &
      0.6237E-02,  0.9531E-02,  0.1416E-01,  0.2063E-01,  0.2968E-01,   &
      0.4233E-01,  0.5990E-01,  0.8412E-01,  0.1170E+00,  0.1608E+00,   &
      0.2177E+00,  0.2894E+00,  0.3764E+00,  0.4768E+00,  0.5855E+00,   &
      0.6941E+00,  0.7921E+00,  0.8710E+00,  0.9276E+00,  0.9641E+00,   &
      0.9846E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip=19,19)/                               &
      -0.4448E-08, -0.9085E-08, -0.1877E-07, -0.3946E-07, -0.8472E-07,  &
      -0.1852E-06, -0.4074E-06, -0.8791E-06, -0.1789E-05, -0.3314E-05,  &
      -0.5521E-05, -0.8425E-05, -0.1215E-04, -0.1711E-04, -0.2407E-04,  &
      -0.3421E-04, -0.4905E-04, -0.7032E-04, -0.9985E-04, -0.1394E-03,  &
      -0.1897E-03, -0.2491E-03, -0.3132E-03, -0.3763E-03, -0.4332E-03,  &
      -0.4786E-03, -0.5005E-03, -0.4775E-03, -0.3970E-03, -0.2794E-03,  &
      -0.1652E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip=19,19)/                               &
      0.1566E-10,  0.3219E-10,  0.6635E-10,  0.1400E-09,  0.2999E-09,   &
      0.6513E-09,  0.1406E-08,  0.2953E-08,  0.5789E-08,  0.1037E-07,   &
      0.1709E-07,  0.2623E-07,  0.3777E-07,  0.5159E-07,  0.6823E-07,   &
      0.8864E-07,  0.1134E-06,  0.1461E-06,  0.1960E-06,  0.2761E-06,   &
      0.3962E-06,  0.5583E-06,  0.7580E-06,  0.9957E-06,  0.1282E-05,   &
      0.1607E-05,  0.1898E-05,  0.2020E-05,  0.1919E-05,  0.1623E-05,   &
      0.1171E-05/
  DATA ((h71(ip,iw,1),iw=1,31),ip=20,20)/                               &
      0.1360E-04,  0.2707E-04,  0.5375E-04,  0.1063E-03,  0.2087E-03,   &
      0.4052E-03,  0.7731E-03,  0.1437E-02,  0.2575E-02,  0.4414E-02,   &
      0.7212E-02,  0.1128E-01,  0.1704E-01,  0.2509E-01,  0.3631E-01,   &
      0.5188E-01,  0.7338E-01,  0.1028E+00,  0.1422E+00,  0.1940E+00,   &
      0.2603E+00,  0.3422E+00,  0.4387E+00,  0.5459E+00,  0.6563E+00,   &
      0.7597E+00,  0.8461E+00,  0.9105E+00,  0.9536E+00,  0.9791E+00,   &
      0.9920E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip=20,20)/                               &
      -0.4403E-08, -0.8896E-08, -0.1818E-07, -0.3751E-07, -0.7880E-07,  &
      -0.1683E-06, -0.3640E-06, -0.7852E-06, -0.1640E-05, -0.3191E-05,  &
      -0.5634E-05, -0.9046E-05, -0.1355E-04, -0.1953E-04, -0.2786E-04,  &
      -0.3995E-04, -0.5752E-04, -0.8256E-04, -0.1174E-03, -0.1638E-03,  &
      -0.2211E-03, -0.2854E-03, -0.3507E-03, -0.4116E-03, -0.4633E-03,  &
      -0.4966E-03, -0.4921E-03, -0.4309E-03, -0.3215E-03, -0.2016E-03,  &
      -0.1061E-03/
  DATA ((h73(ip,iw,1),iw=1,31),ip=20,20)/                               &
      0.1551E-10,  0.3147E-10,  0.6419E-10,  0.1356E-09,  0.2860E-09,   &
      0.6178E-09,  0.1353E-08,  0.2934E-08,  0.6095E-08,  0.1174E-07,   &
      0.2067E-07,  0.3346E-07,  0.5014E-07,  0.7024E-07,  0.9377E-07,   &
      0.1226E-06,  0.1592E-06,  0.2056E-06,  0.2678E-06,  0.3584E-06,   &
      0.4892E-06,  0.6651E-06,  0.8859E-06,  0.1160E-05,  0.1488E-05,   &
      0.1814E-05,  0.2010E-05,  0.1984E-05,  0.1748E-05,  0.1338E-05,   &
      0.8445E-06/
  DATA ((h71(ip,iw,1),iw=1,31),ip=21,21)/                               &
      0.1361E-04,  0.2711E-04,  0.5393E-04,  0.1070E-03,  0.2110E-03,   &
      0.4129E-03,  0.7973E-03,  0.1508E-02,  0.2769E-02,  0.4886E-02,   &
      0.8229E-02,  0.1322E-01,  0.2037E-01,  0.3038E-01,  0.4427E-01,   &
      0.6342E-01,  0.8963E-01,  0.1250E+00,  0.1720E+00,  0.2327E+00,   &
      0.3089E+00,  0.4007E+00,  0.5052E+00,  0.6163E+00,  0.7241E+00,   &
      0.8179E+00,  0.8905E+00,  0.9408E+00,  0.9720E+00,  0.9887E+00,   &
      0.9961E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip=21,21)/                               &
      -0.4379E-08, -0.8801E-08, -0.1782E-07, -0.3642E-07, -0.7536E-07,  &
      -0.1581E-06, -0.3366E-06, -0.7227E-06, -0.1532E-05, -0.3106E-05,  &
      -0.5810E-05, -0.9862E-05, -0.1540E-04, -0.2279E-04, -0.3292E-04,  &
      -0.4738E-04, -0.6817E-04, -0.9765E-04, -0.1384E-03, -0.1918E-03,  &
      -0.2551E-03, -0.3226E-03, -0.3876E-03, -0.4452E-03, -0.4883E-03,  &
      -0.5005E-03, -0.4598E-03, -0.3633E-03, -0.2416E-03, -0.1349E-03,  &
      -0.6278E-04/
  DATA ((h73(ip,iw,1),iw=1,31),ip=21,21)/                               &
      0.1542E-10,  0.3111E-10,  0.6345E-10,  0.1310E-09,  0.2742E-09,   &
      0.5902E-09,  0.1289E-08,  0.2826E-08,  0.6103E-08,  0.1250E-07,   &
      0.2355E-07,  0.4041E-07,  0.6347E-07,  0.9217E-07,  0.1256E-06,   &
      0.1658E-06,  0.2175E-06,  0.2824E-06,  0.3607E-06,  0.4614E-06,   &
      0.6004E-06,  0.7880E-06,  0.1034E-05,  0.1349E-05,  0.1698E-05,   &
      0.1965E-05,  0.2021E-05,  0.1857E-05,  0.1500E-05,  0.1015E-05,   &
      0.5467E-06/
  DATA ((h71(ip,iw,1),iw=1,31),ip=22,22)/                               &
      0.1362E-04,  0.2714E-04,  0.5405E-04,  0.1074E-03,  0.2127E-03,   &
      0.4187E-03,  0.8159E-03,  0.1565E-02,  0.2933E-02,  0.5314E-02,   &
      0.9222E-02,  0.1525E-01,  0.2406E-01,  0.3649E-01,  0.5367E-01,   &
      0.7717E-01,  0.1090E+00,  0.1514E+00,  0.2067E+00,  0.2770E+00,   &
      0.3633E+00,  0.4640E+00,  0.5742E+00,  0.6853E+00,  0.7859E+00,   &
      0.8670E+00,  0.9253E+00,  0.9629E+00,  0.9842E+00,  0.9942E+00,   &
      0.9983E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip=22,22)/                               &
      -0.4366E-08, -0.8749E-08, -0.1761E-07, -0.3578E-07, -0.7322E-07,  &
      -0.1517E-06, -0.3189E-06, -0.6785E-06, -0.1446E-05, -0.3014E-05,  &
      -0.5933E-05, -0.1069E-04, -0.1755E-04, -0.2683E-04, -0.3936E-04,  &
      -0.5675E-04, -0.8137E-04, -0.1160E-03, -0.1630E-03, -0.2223E-03,  &
      -0.2899E-03, -0.3589E-03, -0.4230E-03, -0.4755E-03, -0.5031E-03,  &
      -0.4834E-03, -0.4036E-03, -0.2849E-03, -0.1687E-03, -0.8356E-04,  &
      -0.3388E-04/
  DATA ((h73(ip,iw,1),iw=1,31),ip=22,22)/                               &
      0.1536E-10,  0.3086E-10,  0.6248E-10,  0.1288E-09,  0.2664E-09,   &
      0.5637E-09,  0.1222E-08,  0.2680E-08,  0.5899E-08,  0.1262E-07,   &
      0.2527E-07,  0.4621E-07,  0.7678E-07,  0.1165E-06,  0.1640E-06,   &
      0.2199E-06,  0.2904E-06,  0.3783E-06,  0.4787E-06,  0.5925E-06,   &
      0.7377E-06,  0.9389E-06,  0.1216E-05,  0.1560E-05,  0.1879E-05,   &
      0.2025E-05,  0.1940E-05,  0.1650E-05,  0.1194E-05,  0.6981E-06,   &
      0.3103E-06/
  DATA ((h71(ip,iw,1),iw=1,31),ip=23,23)/                               &
      0.1362E-04,  0.2716E-04,  0.5413E-04,  0.1077E-03,  0.2139E-03,   &
      0.4228E-03,  0.8295E-03,  0.1609E-02,  0.3063E-02,  0.5676E-02,   &
      0.1013E-01,  0.1726E-01,  0.2799E-01,  0.4332E-01,  0.6452E-01,   &
      0.9328E-01,  0.1317E+00,  0.1820E+00,  0.2467E+00,  0.3270E+00,   &
      0.4228E+00,  0.5308E+00,  0.6434E+00,  0.7499E+00,  0.8395E+00,   &
      0.9065E+00,  0.9515E+00,  0.9782E+00,  0.9916E+00,  0.9973E+00,   &
      0.9993E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip=23,23)/                               &
      -0.4359E-08, -0.8720E-08, -0.1749E-07, -0.3527E-07, -0.7175E-07,  &
      -0.1473E-06, -0.3062E-06, -0.6451E-06, -0.1372E-05, -0.2902E-05,  &
      -0.5936E-05, -0.1133E-04, -0.1971E-04, -0.3143E-04, -0.4715E-04,  &
      -0.6833E-04, -0.9759E-04, -0.1379E-03, -0.1907E-03, -0.2542E-03,  &
      -0.3239E-03, -0.3935E-03, -0.4559E-03, -0.4991E-03, -0.5009E-03,  &
      -0.4414E-03, -0.3306E-03, -0.2077E-03, -0.1093E-03, -0.4754E-04,  &
      -0.1642E-04/
  DATA ((h73(ip,iw,1),iw=1,31),ip=23,23)/                               &
      0.1531E-10,  0.3070E-10,  0.6184E-10,  0.1257E-09,  0.2578E-09,   &
      0.5451E-09,  0.1159E-08,  0.2526E-08,  0.5585E-08,  0.1225E-07,   &
      0.2576E-07,  0.5017E-07,  0.8855E-07,  0.1417E-06,  0.2078E-06,   &
      0.2858E-06,  0.3802E-06,  0.4946E-06,  0.6226E-06,  0.7572E-06,   &
      0.9137E-06,  0.1133E-05,  0.1438E-05,  0.1772E-05,  0.1994E-05,   &
      0.1994E-05,  0.1779E-05,  0.1375E-05,  0.8711E-06,  0.4273E-06,   &
      0.1539E-06/
  DATA ((h71(ip,iw,1),iw=1,31),ip=24,24)/                               &
      0.1362E-04,  0.2717E-04,  0.5417E-04,  0.1079E-03,  0.2146E-03,   &
      0.4256E-03,  0.8393E-03,  0.1641E-02,  0.3163E-02,  0.5968E-02,   &
      0.1092E-01,  0.1915E-01,  0.3195E-01,  0.5066E-01,  0.7669E-01,   &
      0.1117E+00,  0.1578E+00,  0.2173E+00,  0.2919E+00,  0.3824E+00,   &
      0.4867E+00,  0.5992E+00,  0.7100E+00,  0.8076E+00,  0.8838E+00,   &
      0.9370E+00,  0.9702E+00,  0.9880E+00,  0.9959E+00,  0.9988E+00,   &
      0.9998E+00/
  DATA ((h72(ip,iw,1),iw=1,31),ip=24,24)/                               &
      -0.4354E-08, -0.8703E-08, -0.1742E-07, -0.3499E-07, -0.7074E-07,  &
      -0.1441E-06, -0.2971E-06, -0.6195E-06, -0.1309E-05, -0.2780E-05,  &
      -0.5823E-05, -0.1165E-04, -0.2152E-04, -0.3616E-04, -0.5604E-04,  &
      -0.8230E-04, -0.1173E-03, -0.1635E-03, -0.2211E-03, -0.2868E-03,  &
      -0.3567E-03, -0.4260E-03, -0.4844E-03, -0.5097E-03, -0.4750E-03,  &
      -0.3779E-03, -0.2522E-03, -0.1409E-03, -0.6540E-04, -0.2449E-04,  &
      -0.6948E-05/
  DATA ((h73(ip,iw,1),iw=1,31),ip=24,24)/                               &
      0.1529E-10,  0.3060E-10,  0.6142E-10,  0.1241E-09,  0.2535E-09,   &
      0.5259E-09,  0.1107E-08,  0.2383E-08,  0.5243E-08,  0.1161E-07,   &
      0.2523E-07,  0.5188E-07,  0.9757E-07,  0.1657E-06,  0.2553E-06,   &
      0.3629E-06,  0.4878E-06,  0.6323E-06,  0.7923E-06,  0.9575E-06,   &
      0.1139E-05,  0.1381E-05,  0.1687E-05,  0.1952E-05,  0.2029E-05,   &
      0.1890E-05,  0.1552E-05,  0.1062E-05,  0.5728E-06,  0.2280E-06,   &
      0.6762E-07/
  DATA ((h71(ip,iw,1),iw=1,31),ip=25,25)/                               &
      0.1363E-04,  0.2718E-04,  0.5420E-04,  0.1080E-03,  0.2151E-03,   &
      0.4275E-03,  0.8461E-03,  0.1664E-02,  0.3237E-02,  0.6195E-02,   &
      0.1156E-01,  0.2080E-01,  0.3573E-01,  0.5818E-01,  0.8981E-01,   &
      0.1323E+00,  0.1874E+00,  0.2570E+00,  0.3423E+00,  0.4425E+00,   &
      0.5534E+00,  0.6669E+00,  0.7714E+00,  0.8568E+00,  0.9191E+00,   &
      0.9597E+00,  0.9828E+00,  0.9938E+00,  0.9981E+00,  0.9996E+00,   &
      0.1000E+01/
  DATA ((h72(ip,iw,1),iw=1,31),ip=25,25)/                               &
      -0.4352E-08, -0.8693E-08, -0.1738E-07, -0.3483E-07, -0.7006E-07,  &
      -0.1423E-06, -0.2905E-06, -0.6008E-06, -0.1258E-05, -0.2663E-05,  &
      -0.5638E-05, -0.1165E-04, -0.2270E-04, -0.4044E-04, -0.6554E-04,  &
      -0.9855E-04, -0.1407E-03, -0.1928E-03, -0.2534E-03, -0.3197E-03,  &
      -0.3890E-03, -0.4563E-03, -0.5040E-03, -0.4998E-03, -0.4249E-03,  &
      -0.3025E-03, -0.1794E-03, -0.8860E-04, -0.3575E-04, -0.1122E-04,  &
      -0.2506E-05/
  DATA ((h73(ip,iw,1),iw=1,31),ip=25,25)/                               &
      0.1527E-10,  0.3053E-10,  0.6115E-10,  0.1230E-09,  0.2492E-09,   &
      0.5149E-09,  0.1068E-08,  0.2268E-08,  0.4932E-08,  0.1089E-07,   &
      0.2408E-07,  0.5156E-07,  0.1028E-06,  0.1859E-06,  0.3028E-06,   &
      0.4476E-06,  0.6124E-06,  0.7932E-06,  0.9879E-06,  0.1194E-05,   &
      0.1417E-05,  0.1673E-05,  0.1929E-05,  0.2064E-05,  0.1997E-05,   &
      0.1725E-05,  0.1267E-05,  0.7464E-06,  0.3312E-06,  0.1066E-06,   &
      0.2718E-07/
  DATA ((h71(ip,iw,1),iw=1,31),ip=26,26)/                               &
      0.1363E-04,  0.2719E-04,  0.5422E-04,  0.1081E-03,  0.2154E-03,   &
      0.4287E-03,  0.8506E-03,  0.1680E-02,  0.3291E-02,  0.6364E-02,   &
      0.1206E-01,  0.2218E-01,  0.3912E-01,  0.6544E-01,  0.1033E+00,   &
      0.1544E+00,  0.2198E+00,  0.3008E+00,  0.3970E+00,  0.5060E+00,   &
      0.6209E+00,  0.7311E+00,  0.8254E+00,  0.8972E+00,  0.9462E+00,   &
      0.9757E+00,  0.9907E+00,  0.9970E+00,  0.9992E+00,  0.9999E+00,   &
      0.1000E+01/
  DATA ((h72(ip,iw,1),iw=1,31),ip=26,26)/                               &
      -0.4351E-08, -0.8688E-08, -0.1736E-07, -0.3473E-07, -0.6966E-07,  &
      -0.1405E-06, -0.2857E-06, -0.5867E-06, -0.1218E-05, -0.2563E-05,  &
      -0.5435E-05, -0.1144E-04, -0.2321E-04, -0.4379E-04, -0.7487E-04,  &
      -0.1163E-03, -0.1670E-03, -0.2250E-03, -0.2876E-03, -0.3535E-03,  &
      -0.4215E-03, -0.4826E-03, -0.5082E-03, -0.4649E-03, -0.3564E-03,  &
      -0.2264E-03, -0.1188E-03, -0.5128E-04, -0.1758E-04, -0.4431E-05,  &
      -0.7275E-06/
  DATA ((h73(ip,iw,1),iw=1,31),ip=26,26)/                               &
      0.1525E-10,  0.3048E-10,  0.6097E-10,  0.1223E-09,  0.2466E-09,   &
      0.5021E-09,  0.1032E-08,  0.2195E-08,  0.4688E-08,  0.1027E-07,   &
      0.2279E-07,  0.4999E-07,  0.1046E-06,  0.2009E-06,  0.3460E-06,   &
      0.5335E-06,  0.7478E-06,  0.9767E-06,  0.1216E-05,  0.1469E-05,   &
      0.1735E-05,  0.1977E-05,  0.2121E-05,  0.2103E-05,  0.1902E-05,   &
      0.1495E-05,  0.9541E-06,  0.4681E-06,  0.1672E-06,  0.4496E-07,   &
      0.9859E-08/
!
!-----------------------------------------------------------------------
!
!  The following DATA statements originally came from file
!  "co2.tran3", which define pre-computed tables used for co2 (band
!  3) transmittance calculations.
!
!-----------------------------------------------------------------------
!
! co2.tran3

  REAL :: c1(26,24,7),c2(26,24,7),c3(26,24,7)

  COMMON /radtab002/ c1,c2,c3

  DATA ((c1(ip,iw,1),iw=1,24),ip= 1, 1)/                                &
      0.1444E-03,  0.2378E-03,  0.3644E-03,  0.5245E-03,  0.7311E-03,   &
      0.1015E-02,  0.1416E-02,  0.1975E-02,  0.2715E-02,  0.3651E-02,   &
      0.4813E-02,  0.6264E-02,  0.8084E-02,  0.1037E-01,  0.1327E-01,   &
      0.1693E-01,  0.2155E-01,  0.2734E-01,  0.3453E-01,  0.4337E-01,   &
      0.5414E-01,  0.6726E-01,  0.8335E-01,  0.1032E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip= 1, 1)/                                &
      -0.2878E-06, -0.6295E-06, -0.1270E-05, -0.2323E-05, -0.3910E-05,  &
      -0.6235E-05, -0.9527E-05, -0.1391E-04, -0.1947E-04, -0.2652E-04,  &
      -0.3568E-04, -0.4777E-04, -0.6363E-04, -0.8414E-04, -0.1102E-03,  &
      -0.1425E-03, -0.1822E-03, -0.2301E-03, -0.2869E-03, -0.3534E-03,  &
      -0.4305E-03, -0.5188E-03, -0.6173E-03, -0.7229E-03/
  DATA ((c3(ip,iw,1),iw=1,24),ip= 1, 1)/                                &
      -0.2369E-09, -0.5453E-09, -0.1434E-08, -0.3513E-08, -0.7277E-08,  &
      -0.1283E-07, -0.1983E-07, -0.2838E-07, -0.4075E-07, -0.6115E-07,  &
      -0.9201E-07, -0.1325E-06, -0.1844E-06, -0.2534E-06, -0.3430E-06,  &
      -0.4550E-06, -0.5896E-06, -0.7434E-06, -0.9121E-06, -0.1096E-05,  &
      -0.1298E-05, -0.1508E-05, -0.1689E-05, -0.1773E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip= 2, 2)/                                &
      0.1444E-03,  0.2379E-03,  0.3646E-03,  0.5250E-03,  0.7320E-03,   &
      0.1016E-02,  0.1419E-02,  0.1981E-02,  0.2726E-02,  0.3669E-02,   &
      0.4847E-02,  0.6325E-02,  0.8193E-02,  0.1056E-01,  0.1358E-01,   &
      0.1742E-01,  0.2228E-01,  0.2843E-01,  0.3611E-01,  0.4561E-01,   &
      0.5730E-01,  0.7169E-01,  0.8952E-01,  0.1117E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip= 2, 2)/                                &
      -0.2875E-06, -0.6289E-06, -0.1269E-05, -0.2321E-05, -0.3907E-05,  &
      -0.6229E-05, -0.9516E-05, -0.1389E-04, -0.1944E-04, -0.2646E-04,  &
      -0.3559E-04, -0.4762E-04, -0.6340E-04, -0.8384E-04, -0.1098E-03,  &
      -0.1423E-03, -0.1824E-03, -0.2309E-03, -0.2887E-03, -0.3566E-03,  &
      -0.4355E-03, -0.5260E-03, -0.6274E-03, -0.7367E-03/
  DATA ((c3(ip,iw,1),iw=1,24),ip= 2, 2)/                                &
      -0.2382E-09, -0.5476E-09, -0.1437E-08, -0.3520E-08, -0.7291E-08,  &
      -0.1286E-07, -0.1989E-07, -0.2849E-07, -0.4093E-07, -0.6144E-07,  &
      -0.9241E-07, -0.1330E-06, -0.1852E-06, -0.2542E-06, -0.3435E-06,  &
      -0.4549E-06, -0.5891E-06, -0.7427E-06, -0.9114E-06, -0.1096E-05,  &
      -0.1298E-05, -0.1509E-05, -0.1689E-05, -0.1772E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip= 3, 3)/                                &
      0.1445E-03,  0.2381E-03,  0.3650E-03,  0.5258E-03,  0.7335E-03,   &
      0.1019E-02,  0.1424E-02,  0.1990E-02,  0.2742E-02,  0.3698E-02,   &
      0.4899E-02,  0.6418E-02,  0.8353E-02,  0.1083E-01,  0.1401E-01,   &
      0.1807E-01,  0.2326E-01,  0.2985E-01,  0.3814E-01,  0.4849E-01,   &
      0.6134E-01,  0.7733E-01,  0.9732E-01,  0.1223E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip= 3, 3)/                                &
      -0.2871E-06, -0.6279E-06, -0.1267E-05, -0.2318E-05, -0.3901E-05,  &
      -0.6219E-05, -0.9500E-05, -0.1386E-04, -0.1939E-04, -0.2639E-04,  &
      -0.3547E-04, -0.4743E-04, -0.6313E-04, -0.8354E-04, -0.1096E-03,  &
      -0.1425E-03, -0.1831E-03, -0.2325E-03, -0.2916E-03, -0.3613E-03,  &
      -0.4425E-03, -0.5361E-03, -0.6412E-03, -0.7550E-03/
  DATA ((c3(ip,iw,1),iw=1,24),ip= 3, 3)/                                &
      -0.2404E-09, -0.5516E-09, -0.1443E-08, -0.3531E-08, -0.7310E-08,  &
      -0.1290E-07, -0.1997E-07, -0.2865E-07, -0.4121E-07, -0.6185E-07,  &
      -0.9295E-07, -0.1337E-06, -0.1860E-06, -0.2549E-06, -0.3438E-06,  &
      -0.4547E-06, -0.5888E-06, -0.7424E-06, -0.9114E-06, -0.1097E-05,  &
      -0.1300E-05, -0.1511E-05, -0.1691E-05, -0.1771E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip= 4, 4)/                                &
      0.1446E-03,  0.2383E-03,  0.3656E-03,  0.5270E-03,  0.7358E-03,   &
      0.1023E-02,  0.1432E-02,  0.2003E-02,  0.2766E-02,  0.3743E-02,   &
      0.4979E-02,  0.6557E-02,  0.8587E-02,  0.1121E-01,  0.1459E-01,   &
      0.1895E-01,  0.2455E-01,  0.3170E-01,  0.4076E-01,  0.5217E-01,   &
      0.6649E-01,  0.8448E-01,  0.1071E+00,  0.1353E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip= 4, 4)/                                &
      -0.2865E-06, -0.6264E-06, -0.1264E-05, -0.2313E-05, -0.3892E-05,  &
      -0.6204E-05, -0.9474E-05, -0.1382E-04, -0.1932E-04, -0.2628E-04,  &
      -0.3530E-04, -0.4720E-04, -0.6286E-04, -0.8333E-04, -0.1097E-03,  &
      -0.1430E-03, -0.1845E-03, -0.2352E-03, -0.2960E-03, -0.3681E-03,  &
      -0.4523E-03, -0.5496E-03, -0.6595E-03, -0.7790E-03/
  DATA ((c3(ip,iw,1),iw=1,24),ip= 4, 4)/                                &
      -0.2433E-09, -0.5580E-09, -0.1454E-08, -0.3550E-08, -0.7345E-08,  &
      -0.1296E-07, -0.2010E-07, -0.2889E-07, -0.4159E-07, -0.6239E-07,  &
      -0.9360E-07, -0.1345E-06, -0.1867E-06, -0.2554E-06, -0.3439E-06,  &
      -0.4548E-06, -0.5890E-06, -0.7429E-06, -0.9127E-06, -0.1099E-05,  &
      -0.1304E-05, -0.1516E-05, -0.1693E-05, -0.1770E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip= 5, 5)/                                &
      0.1448E-03,  0.2387E-03,  0.3666E-03,  0.5290E-03,  0.7394E-03,   &
      0.1030E-02,  0.1444E-02,  0.2025E-02,  0.2805E-02,  0.3811E-02,   &
      0.5099E-02,  0.6761E-02,  0.8919E-02,  0.1173E-01,  0.1538E-01,   &
      0.2011E-01,  0.2622E-01,  0.3408E-01,  0.4412E-01,  0.5686E-01,   &
      0.7302E-01,  0.9346E-01,  0.1192E+00,  0.1512E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip= 5, 5)/                                &
      -0.2854E-06, -0.6241E-06, -0.1260E-05, -0.2305E-05, -0.3878E-05,  &
      -0.6181E-05, -0.9435E-05, -0.1375E-04, -0.1922E-04, -0.2613E-04,  &
      -0.3510E-04, -0.4696E-04, -0.6265E-04, -0.8334E-04, -0.1102E-03,  &
      -0.1443E-03, -0.1870E-03, -0.2393E-03, -0.3025E-03, -0.3775E-03,  &
      -0.4656E-03, -0.5678E-03, -0.6835E-03, -0.8098E-03/
  DATA ((c3(ip,iw,1),iw=1,24),ip= 5, 5)/                                &
      -0.2485E-09, -0.5672E-09, -0.1468E-08, -0.3577E-08, -0.7395E-08,  &
      -0.1306E-07, -0.2029E-07, -0.2923E-07, -0.4213E-07, -0.6307E-07,  &
      -0.9429E-07, -0.1351E-06, -0.1872E-06, -0.2557E-06, -0.3442E-06,  &
      -0.4553E-06, -0.5899E-06, -0.7447E-06, -0.9163E-06, -0.1105E-05,  &
      -0.1311E-05, -0.1522E-05, -0.1697E-05, -0.1766E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip= 6, 6)/                                &
      0.1450E-03,  0.2394E-03,  0.3680E-03,  0.5320E-03,  0.7452E-03,   &
      0.1040E-02,  0.1462E-02,  0.2058E-02,  0.2863E-02,  0.3914E-02,   &
      0.5275E-02,  0.7051E-02,  0.9378E-02,  0.1243E-01,  0.1641E-01,   &
      0.2162E-01,  0.2838E-01,  0.3713E-01,  0.4839E-01,  0.6282E-01,   &
      0.8125E-01,  0.1046E+00,  0.1340E+00,  0.1702E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip= 6, 6)/                                &
      -0.2837E-06, -0.6203E-06, -0.1252E-05, -0.2292E-05, -0.3857E-05,  &
      -0.6146E-05, -0.9377E-05, -0.1366E-04, -0.1909E-04, -0.2596E-04,  &
      -0.3489E-04, -0.4676E-04, -0.6263E-04, -0.8372E-04, -0.1113E-03,  &
      -0.1465E-03, -0.1908E-03, -0.2454E-03, -0.3115E-03, -0.3903E-03,  &
      -0.4833E-03, -0.5915E-03, -0.7144E-03, -0.8483E-03/
  DATA ((c3(ip,iw,1),iw=1,24),ip= 6, 6)/                                &
      -0.2557E-09, -0.5835E-09, -0.1495E-08, -0.3619E-08, -0.7472E-08,  &
      -0.1320E-07, -0.2055E-07, -0.2970E-07, -0.4281E-07, -0.6379E-07,  &
      -0.9492E-07, -0.1356E-06, -0.1876E-06, -0.2561E-06, -0.3451E-06,  &
      -0.4568E-06, -0.5924E-06, -0.7489E-06, -0.9229E-06, -0.1114E-05,  &
      -0.1321E-05, -0.1531E-05, -0.1700E-05, -0.1756E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip= 7, 7)/                                &
      0.1454E-03,  0.2404E-03,  0.3704E-03,  0.5368E-03,  0.7542E-03,   &
      0.1056E-02,  0.1491E-02,  0.2108E-02,  0.2951E-02,  0.4066E-02,   &
      0.5529E-02,  0.7457E-02,  0.1000E-01,  0.1336E-01,  0.1777E-01,   &
      0.2357E-01,  0.3115E-01,  0.4102E-01,  0.5382E-01,  0.7035E-01,   &
      0.9154E-01,  0.1184E+00,  0.1519E+00,  0.1926E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip= 7, 7)/                                &
      -0.2811E-06, -0.6147E-06, -0.1241E-05, -0.2272E-05, -0.3825E-05,  &
      -0.6093E-05, -0.9294E-05, -0.1354E-04, -0.1893E-04, -0.2577E-04,  &
      -0.3472E-04, -0.4672E-04, -0.6292E-04, -0.8464E-04, -0.1132E-03,  &
      -0.1500E-03, -0.1964E-03, -0.2539E-03, -0.3237E-03, -0.4074E-03,  &
      -0.5065E-03, -0.6222E-03, -0.7532E-03, -0.8955E-03/
  DATA ((c3(ip,iw,1),iw=1,24),ip= 7, 7)/                                &
      -0.2673E-09, -0.6022E-09, -0.1531E-08, -0.3682E-08, -0.7588E-08,  &
      -0.1342E-07, -0.2092E-07, -0.3030E-07, -0.4357E-07, -0.6448E-07,  &
      -0.9533E-07, -0.1359E-06, -0.1879E-06, -0.2570E-06, -0.3470E-06,  &
      -0.4598E-06, -0.5971E-06, -0.7563E-06, -0.9334E-06, -0.1127E-05,  &
      -0.1336E-05, -0.1543E-05, -0.1701E-05, -0.1738E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip= 8, 8)/                                &
      0.1460E-03,  0.2420E-03,  0.3740E-03,  0.5443E-03,  0.7681E-03,   &
      0.1081E-02,  0.1535E-02,  0.2184E-02,  0.3082E-02,  0.4286E-02,   &
      0.5885E-02,  0.8011E-02,  0.1083E-01,  0.1458E-01,  0.1954E-01,   &
      0.2608E-01,  0.3468E-01,  0.4595E-01,  0.6068E-01,  0.7979E-01,   &
      0.1043E+00,  0.1351E+00,  0.1731E+00,  0.2184E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip= 8, 8)/                                &
      -0.2770E-06, -0.6058E-06, -0.1224E-05, -0.2243E-05, -0.3777E-05,  &
      -0.6018E-05, -0.9181E-05, -0.1339E-04, -0.1876E-04, -0.2561E-04,  &
      -0.3467E-04, -0.4695E-04, -0.6370E-04, -0.8635E-04, -0.1163E-03,  &
      -0.1551E-03, -0.2043E-03, -0.2654E-03, -0.3400E-03, -0.4299E-03,  &
      -0.5366E-03, -0.6609E-03, -0.8010E-03, -0.9521E-03/
  DATA ((c3(ip,iw,1),iw=1,24),ip= 8, 8)/                                &
      -0.2845E-09, -0.6367E-09, -0.1591E-08, -0.3779E-08, -0.7752E-08,  &
      -0.1370E-07, -0.2140E-07, -0.3101E-07, -0.4437E-07, -0.6498E-07,  &
      -0.9551E-07, -0.1360E-06, -0.1887E-06, -0.2590E-06, -0.3503E-06,  &
      -0.4650E-06, -0.6052E-06, -0.7681E-06, -0.9488E-06, -0.1145E-05,  &
      -0.1354E-05, -0.1555E-05, -0.1698E-05, -0.1701E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip= 9, 9)/                                &
      0.1470E-03,  0.2444E-03,  0.3796E-03,  0.5557E-03,  0.7894E-03,   &
      0.1119E-02,  0.1600E-02,  0.2296E-02,  0.3271E-02,  0.4596E-02,   &
      0.6373E-02,  0.8752E-02,  0.1193E-01,  0.1617E-01,  0.2181E-01,   &
      0.2928E-01,  0.3916E-01,  0.5220E-01,  0.6930E-01,  0.9150E-01,   &
      0.1198E+00,  0.1551E+00,  0.1978E+00,  0.2475E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip= 9, 9)/                                &
      -0.2709E-06, -0.5925E-06, -0.1198E-05, -0.2199E-05, -0.3708E-05,  &
      -0.5913E-05, -0.9036E-05, -0.1322E-04, -0.1861E-04, -0.2556E-04,  &
      -0.3486E-04, -0.4760E-04, -0.6516E-04, -0.8909E-04, -0.1210E-03,  &
      -0.1624E-03, -0.2151E-03, -0.2808E-03, -0.3615E-03, -0.4590E-03,  &
      -0.5747E-03, -0.7088E-03, -0.8585E-03, -0.1018E-02/
  DATA ((c3(ip,iw,1),iw=1,24),ip= 9, 9)/                                &
      -0.3119E-09, -0.6873E-09, -0.1676E-08, -0.3915E-08, -0.7973E-08,  &
      -0.1407E-07, -0.2200E-07, -0.3179E-07, -0.4505E-07, -0.6522E-07,  &
      -0.9551E-07, -0.1364E-06, -0.1902E-06, -0.2622E-06, -0.3557E-06,  &
      -0.4735E-06, -0.6178E-06, -0.7853E-06, -0.9700E-06, -0.1169E-05,  &
      -0.1377E-05, -0.1567E-05, -0.1683E-05, -0.1631E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip=10,10)/                                &
      0.1484E-03,  0.2482E-03,  0.3882E-03,  0.5732E-03,  0.8217E-03,   &
      0.1176E-02,  0.1696E-02,  0.2457E-02,  0.3536E-02,  0.5021E-02,   &
      0.7028E-02,  0.9728E-02,  0.1336E-01,  0.1821E-01,  0.2470E-01,   &
      0.3334E-01,  0.4482E-01,  0.6004E-01,  0.8003E-01,  0.1059E+00,   &
      0.1385E+00,  0.1785E+00,  0.2259E+00,  0.2794E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip=10,10)/                                &
      -0.2620E-06, -0.5728E-06, -0.1161E-05, -0.2136E-05, -0.3612E-05,  &
      -0.5777E-05, -0.8867E-05, -0.1306E-04, -0.1854E-04, -0.2572E-04,  &
      -0.3543E-04, -0.4887E-04, -0.6756E-04, -0.9321E-04, -0.1275E-03,  &
      -0.1723E-03, -0.2295E-03, -0.3011E-03, -0.3894E-03, -0.4960E-03,  &
      -0.6220E-03, -0.7665E-03, -0.9259E-03, -0.1095E-02/
  DATA ((c3(ip,iw,1),iw=1,24),ip=10,10)/                                &
      -0.3497E-09, -0.7575E-09, -0.1791E-08, -0.4091E-08, -0.8254E-08,  &
      -0.1452E-07, -0.2265E-07, -0.3255E-07, -0.4557E-07, -0.6530E-07,  &
      -0.9557E-07, -0.1374E-06, -0.1930E-06, -0.2675E-06, -0.3644E-06,  &
      -0.4866E-06, -0.6362E-06, -0.8090E-06, -0.9981E-06, -0.1199E-05,  &
      -0.1402E-05, -0.1574E-05, -0.1643E-05, -0.1506E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip=11,11)/                                &
      0.1506E-03,  0.2538E-03,  0.4010E-03,  0.5992E-03,  0.8693E-03,   &
      0.1258E-02,  0.1834E-02,  0.2683E-02,  0.3901E-02,  0.5591E-02,   &
      0.7890E-02,  0.1100E-01,  0.1519E-01,  0.2082E-01,  0.2837E-01,   &
      0.3845E-01,  0.5192E-01,  0.6981E-01,  0.9323E-01,  0.1232E+00,   &
      0.1606E+00,  0.2055E+00,  0.2571E+00,  0.3133E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip=11,11)/                                &
      -0.2494E-06, -0.5450E-06, -0.1108E-05, -0.2049E-05, -0.3485E-05,  &
      -0.5612E-05, -0.8695E-05, -0.1296E-04, -0.1865E-04, -0.2620E-04,  &
      -0.3654E-04, -0.5099E-04, -0.7121E-04, -0.9909E-04, -0.1365E-03,  &
      -0.1855E-03, -0.2483E-03, -0.3274E-03, -0.4248E-03, -0.5421E-03,  &
      -0.6794E-03, -0.8346E-03, -0.1003E-02, -0.1181E-02/
  DATA ((c3(ip,iw,1),iw=1,24),ip=11,11)/                                &
      -0.3973E-09, -0.8499E-09, -0.1944E-08, -0.4319E-08, -0.8596E-08,  &
      -0.1501E-07, -0.2332E-07, -0.3326E-07, -0.4600E-07, -0.6541E-07,  &
      -0.9592E-07, -0.1392E-06, -0.1975E-06, -0.2757E-06, -0.3774E-06,  &
      -0.5057E-06, -0.6614E-06, -0.8401E-06, -0.1034E-05, -0.1235E-05,  &
      -0.1427E-05, -0.1565E-05, -0.1560E-05, -0.1310E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip=12,12)/                                &
      0.1537E-03,  0.2618E-03,  0.4196E-03,  0.6368E-03,  0.9377E-03,   &
      0.1374E-02,  0.2024E-02,  0.2990E-02,  0.4387E-02,  0.6339E-02,   &
      0.9008E-02,  0.1263E-01,  0.1752E-01,  0.2410E-01,  0.3296E-01,   &
      0.4485E-01,  0.6077E-01,  0.8185E-01,  0.1092E+00,  0.1439E+00,   &
      0.1861E+00,  0.2356E+00,  0.2906E+00,  0.3483E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip=12,12)/                                &
      -0.2326E-06, -0.5076E-06, -0.1037E-05, -0.1935E-05, -0.3329E-05,  &
      -0.5433E-05, -0.8553E-05, -0.1298E-04, -0.1902E-04, -0.2716E-04,  &
      -0.3840E-04, -0.5421E-04, -0.7643E-04, -0.1071E-03, -0.1485E-03,  &
      -0.2028E-03, -0.2727E-03, -0.3608E-03, -0.4689E-03, -0.5981E-03,  &
      -0.7471E-03, -0.9128E-03, -0.1091E-02, -0.1276E-02/
  DATA ((c3(ip,iw,1),iw=1,24),ip=12,12)/                                &
      -0.4576E-09, -0.9621E-09, -0.2122E-08, -0.4569E-08, -0.8941E-08,  &
      -0.1550E-07, -0.2398E-07, -0.3404E-07, -0.4663E-07, -0.6577E-07,  &
      -0.9677E-07, -0.1421E-06, -0.2042E-06, -0.2878E-06, -0.3962E-06,  &
      -0.5318E-06, -0.6946E-06, -0.8798E-06, -0.1078E-05, -0.1275E-05,  &
      -0.1445E-05, -0.1523E-05, -0.1413E-05, -0.1030E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip=13,13)/                                &
      0.1579E-03,  0.2729E-03,  0.4454E-03,  0.6893E-03,  0.1033E-02,   &
      0.1533E-02,  0.2280E-02,  0.3396E-02,  0.5018E-02,  0.7299E-02,   &
      0.1043E-01,  0.1468E-01,  0.2044E-01,  0.2820E-01,  0.3867E-01,   &
      0.5278E-01,  0.7166E-01,  0.9648E-01,  0.1283E+00,  0.1679E+00,   &
      0.2150E+00,  0.2685E+00,  0.3256E+00,  0.3836E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip=13,13)/                                &
      -0.2120E-06, -0.4613E-06, -0.9487E-06, -0.1798E-05, -0.3153E-05,  &
      -0.5260E-05, -0.8480E-05, -0.1319E-04, -0.1976E-04, -0.2876E-04,  &
      -0.4125E-04, -0.5885E-04, -0.8357E-04, -0.1178E-03, -0.1640E-03,  &
      -0.2250E-03, -0.3036E-03, -0.4023E-03, -0.5226E-03, -0.6643E-03,  &
      -0.8250E-03, -0.1001E-02, -0.1187E-02, -0.1378E-02/
  DATA ((c3(ip,iw,1),iw=1,24),ip=13,13)/                                &
      -0.5223E-09, -0.1082E-08, -0.2314E-08, -0.4826E-08, -0.9255E-08,  &
      -0.1596E-07, -0.2472E-07, -0.3507E-07, -0.4774E-07, -0.6677E-07,  &
      -0.9841E-07, -0.1466E-06, -0.2141E-06, -0.3049E-06, -0.4219E-06,  &
      -0.5662E-06, -0.7370E-06, -0.9290E-06, -0.1129E-05, -0.1315E-05,  &
      -0.1441E-05, -0.1427E-05, -0.1184E-05, -0.6731E-06/
  DATA ((c1(ip,iw,1),iw=1,24),ip=14,14)/                                &
      0.1634E-03,  0.2873E-03,  0.4793E-03,  0.7589E-03,  0.1159E-02,   &
      0.1742E-02,  0.2614E-02,  0.3916E-02,  0.5817E-02,  0.8503E-02,   &
      0.1220E-01,  0.1723E-01,  0.2403E-01,  0.3324E-01,  0.4572E-01,   &
      0.6253E-01,  0.8488E-01,  0.1140E+00,  0.1507E+00,  0.1952E+00,   &
      0.2468E+00,  0.3031E+00,  0.3612E+00,  0.4186E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip=14,14)/                                &
      -0.1896E-06, -0.4100E-06, -0.8500E-06, -0.1645E-05, -0.2972E-05,  &
      -0.5116E-05, -0.8508E-05, -0.1363E-04, -0.2097E-04, -0.3115E-04,  &
      -0.4531E-04, -0.6517E-04, -0.9298E-04, -0.1315E-03, -0.1837E-03,  &
      -0.2528E-03, -0.3417E-03, -0.4525E-03, -0.5860E-03, -0.7405E-03,  &
      -0.9123E-03, -0.1097E-02, -0.1290E-02, -0.1482E-02/
  DATA ((c3(ip,iw,1),iw=1,24),ip=14,14)/                                &
      -0.5738E-09, -0.1185E-08, -0.2465E-08, -0.5015E-08, -0.9502E-08,  &
      -0.1640E-07, -0.2567E-07, -0.3675E-07, -0.4990E-07, -0.6893E-07,  &
      -0.1014E-06, -0.1533E-06, -0.2278E-06, -0.3278E-06, -0.4553E-06,  &
      -0.6098E-06, -0.7899E-06, -0.9876E-06, -0.1184E-05, -0.1342E-05,  &
      -0.1393E-05, -0.1254E-05, -0.8703E-06, -0.2593E-06/
  DATA ((c1(ip,iw,1),iw=1,24),ip=15,15)/                                &
      0.1697E-03,  0.3043E-03,  0.5205E-03,  0.8458E-03,  0.1319E-02,   &
      0.2009E-02,  0.3034E-02,  0.4563E-02,  0.6800E-02,  0.9975E-02,   &
      0.1436E-01,  0.2033E-01,  0.2842E-01,  0.3941E-01,  0.5431E-01,   &
      0.7432E-01,  0.1007E+00,  0.1344E+00,  0.1762E+00,  0.2255E+00,   &
      0.2806E+00,  0.3385E+00,  0.3964E+00,  0.4532E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip=15,15)/                                &
      -0.1689E-06, -0.3610E-06, -0.7531E-06, -0.1495E-05, -0.2803E-05,  &
      -0.5013E-05, -0.8646E-05, -0.1433E-04, -0.2270E-04, -0.3446E-04,  &
      -0.5077E-04, -0.7342E-04, -0.1049E-03, -0.1486E-03, -0.2080E-03,  &
      -0.2866E-03, -0.3873E-03, -0.5115E-03, -0.6586E-03, -0.8256E-03,  &
      -0.1008E-02, -0.1201E-02, -0.1398E-02, -0.1583E-02/
  DATA ((c3(ip,iw,1),iw=1,24),ip=15,15)/                                &
      -0.6063E-09, -0.1245E-08, -0.2559E-08, -0.5110E-08, -0.9652E-08,  &
      -0.1685E-07, -0.2693E-07, -0.3933E-07, -0.5373E-07, -0.7330E-07,  &
      -0.1066E-06, -0.1625E-06, -0.2453E-06, -0.3564E-06, -0.4963E-06,  &
      -0.6636E-06, -0.8532E-06, -0.1054E-05, -0.1236E-05, -0.1339E-05,  &
      -0.1280E-05, -0.9947E-06, -0.4862E-06,  0.1889E-06/
  DATA ((c1(ip,iw,1),iw=1,24),ip=16,16)/                                &
      0.1763E-03,  0.3227E-03,  0.5664E-03,  0.9465E-03,  0.1511E-02,   &
      0.2335E-02,  0.3549E-02,  0.5348E-02,  0.7977E-02,  0.1172E-01,   &
      0.1692E-01,  0.2402E-01,  0.3369E-01,  0.4685E-01,  0.6465E-01,   &
      0.8835E-01,  0.1192E+00,  0.1579E+00,  0.2046E+00,  0.2579E+00,   &
      0.3153E+00,  0.3736E+00,  0.4308E+00,  0.4875E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip=16,16)/                                &
      -0.1533E-06, -0.3224E-06, -0.6725E-06, -0.1365E-05, -0.2657E-05,  &
      -0.4953E-05, -0.8878E-05, -0.1525E-04, -0.2490E-04, -0.3866E-04,  &
      -0.5766E-04, -0.8372E-04, -0.1197E-03, -0.1695E-03, -0.2372E-03,  &
      -0.3266E-03, -0.4401E-03, -0.5783E-03, -0.7390E-03, -0.9180E-03,  &
      -0.1110E-02, -0.1309E-02, -0.1503E-02, -0.1676E-02/
  DATA ((c3(ip,iw,1),iw=1,24),ip=16,16)/                                &
      -0.6109E-09, -0.1253E-08, -0.2555E-08, -0.5100E-08, -0.9703E-08,  &
      -0.1729E-07, -0.2846E-07, -0.4291E-07, -0.5988E-07, -0.8135E-07,  &
      -0.1158E-06, -0.1750E-06, -0.2657E-06, -0.3890E-06, -0.5438E-06,  &
      -0.7262E-06, -0.9256E-06, -0.1122E-05, -0.1269E-05, -0.1284E-05,  &
      -0.1086E-05, -0.6553E-06, -0.5588E-07,  0.6660E-06/
  DATA ((c1(ip,iw,1),iw=1,24),ip=17,17)/                                &
      0.1824E-03,  0.3403E-03,  0.6126E-03,  0.1054E-02,  0.1727E-02,   &
      0.2716E-02,  0.4160E-02,  0.6275E-02,  0.9353E-02,  0.1375E-01,   &
      0.1990E-01,  0.2837E-01,  0.3995E-01,  0.5571E-01,  0.7690E-01,   &
      0.1048E+00,  0.1404E+00,  0.1841E+00,  0.2353E+00,  0.2916E+00,   &
      0.3500E+00,  0.4078E+00,  0.4646E+00,  0.5215E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip=17,17)/                                &
      -0.1436E-06, -0.2978E-06, -0.6179E-06, -0.1270E-05, -0.2546E-05,  &
      -0.4927E-05, -0.9164E-05, -0.1628E-04, -0.2740E-04, -0.4353E-04,  &
      -0.6579E-04, -0.9606E-04, -0.1375E-03, -0.1943E-03, -0.2712E-03,  &
      -0.3722E-03, -0.4993E-03, -0.6515E-03, -0.8255E-03, -0.1016E-02,  &
      -0.1217E-02, -0.1417E-02, -0.1602E-02, -0.1757E-02/
  DATA ((c3(ip,iw,1),iw=1,24),ip=17,17)/                                &
      -0.6015E-09, -0.1225E-08, -0.2489E-08, -0.4978E-08, -0.9608E-08,  &
      -0.1756E-07, -0.2993E-07, -0.4715E-07, -0.6853E-07, -0.9454E-07,  &
      -0.1314E-06, -0.1920E-06, -0.2877E-06, -0.4222E-06, -0.5940E-06,  &
      -0.7936E-06, -0.1002E-05, -0.1181E-05, -0.1262E-05, -0.1156E-05,  &
      -0.8086E-06, -0.2604E-06,  0.4056E-06,  0.1164E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip=18,18)/                                &
      0.1875E-03,  0.3555E-03,  0.6547E-03,  0.1159E-02,  0.1954E-02,   &
      0.3140E-02,  0.4861E-02,  0.7345E-02,  0.1093E-01,  0.1606E-01,   &
      0.2330E-01,  0.3339E-01,  0.4729E-01,  0.6613E-01,  0.9118E-01,   &
      0.1236E+00,  0.1642E+00,  0.2127E+00,  0.2674E+00,  0.3254E+00,   &
      0.3836E+00,  0.4408E+00,  0.4978E+00,  0.5551E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip=18,18)/                                &
      -0.1390E-06, -0.2850E-06, -0.5878E-06, -0.1213E-05, -0.2477E-05,  &
      -0.4934E-05, -0.9466E-05, -0.1731E-04, -0.2990E-04, -0.4860E-04,  &
      -0.7471E-04, -0.1102E-03, -0.1582E-03, -0.2230E-03, -0.3098E-03,  &
      -0.4228E-03, -0.5632E-03, -0.7291E-03, -0.9158E-03, -0.1117E-02,  &
      -0.1323E-02, -0.1519E-02, -0.1689E-02, -0.1824E-02/
  DATA ((c3(ip,iw,1),iw=1,24),ip=18,18)/                                &
      -0.5875E-09, -0.1187E-08, -0.2392E-08, -0.4777E-08, -0.9321E-08,  &
      -0.1745E-07, -0.3091E-07, -0.5121E-07, -0.7879E-07, -0.1130E-06,  &
      -0.1555E-06, -0.2161E-06, -0.3110E-06, -0.4527E-06, -0.6400E-06,  &
      -0.8571E-06, -0.1069E-05, -0.1209E-05, -0.1193E-05, -0.9472E-06,  &
      -0.4712E-06,  0.1597E-06,  0.8892E-06,  0.1671E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip=19,19)/                                &
      0.1914E-03,  0.3677E-03,  0.6900E-03,  0.1252E-02,  0.2172E-02,   &
      0.3581E-02,  0.5632E-02,  0.8553E-02,  0.1271E-01,  0.1866E-01,   &
      0.2715E-01,  0.3914E-01,  0.5576E-01,  0.7817E-01,  0.1076E+00,   &
      0.1449E+00,  0.1903E+00,  0.2429E+00,  0.2999E+00,  0.3582E+00,   &
      0.4157E+00,  0.4727E+00,  0.5303E+00,  0.5878E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip=19,19)/                                &
      -0.1371E-06, -0.2799E-06, -0.5756E-06, -0.1190E-05, -0.2455E-05,  &
      -0.4982E-05, -0.9770E-05, -0.1824E-04, -0.3214E-04, -0.5332E-04,  &
      -0.8371E-04, -0.1255E-03, -0.1814E-03, -0.2555E-03, -0.3528E-03,  &
      -0.4774E-03, -0.6306E-03, -0.8095E-03, -0.1008E-02, -0.1218E-02,  &
      -0.1424E-02, -0.1610E-02, -0.1763E-02, -0.1875E-02/
  DATA ((c3(ip,iw,1),iw=1,24),ip=19,19)/                                &
      -0.5739E-09, -0.1144E-08, -0.2283E-08, -0.4524E-08, -0.8848E-08,  &
      -0.1686E-07, -0.3096E-07, -0.5411E-07, -0.8876E-07, -0.1343E-06,  &
      -0.1880E-06, -0.2511E-06, -0.3405E-06, -0.4800E-06, -0.6756E-06,  &
      -0.9041E-06, -0.1105E-05, -0.1184E-05, -0.1049E-05, -0.6701E-06,  &
      -0.1061E-06,  0.5899E-06,  0.1376E-05,  0.2160E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip=20,20)/                                &
      0.1942E-03,  0.3767E-03,  0.7173E-03,  0.1328E-02,  0.2364E-02,   &
      0.4005E-02,  0.6433E-02,  0.9873E-02,  0.1471E-01,  0.2160E-01,   &
      0.3150E-01,  0.4565E-01,  0.6537E-01,  0.9183E-01,  0.1260E+00,   &
      0.1683E+00,  0.2183E+00,  0.2738E+00,  0.3318E+00,  0.3894E+00,   &
      0.4463E+00,  0.5038E+00,  0.5619E+00,  0.6191E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip=20,20)/                                &
      -0.1368E-06, -0.2791E-06, -0.5744E-06, -0.1192E-05, -0.2475E-05,  &
      -0.5078E-05, -0.1008E-04, -0.1903E-04, -0.3392E-04, -0.5726E-04,  &
      -0.9202E-04, -0.1409E-03, -0.2063E-03, -0.2912E-03, -0.3997E-03,  &
      -0.5357E-03, -0.7004E-03, -0.8911E-03, -0.1100E-02, -0.1314E-02,  &
      -0.1514E-02, -0.1687E-02, -0.1822E-02, -0.1908E-02/
  DATA ((c3(ip,iw,1),iw=1,24),ip=20,20)/                                &
      -0.5617E-09, -0.1109E-08, -0.2184E-08, -0.4264E-08, -0.8251E-08,  &
      -0.1582E-07, -0.3000E-07, -0.5536E-07, -0.9656E-07, -0.1549E-06,  &
      -0.2254E-06, -0.2999E-06, -0.3855E-06, -0.5114E-06, -0.6982E-06,  &
      -0.9171E-06, -0.1082E-05, -0.1078E-05, -0.8280E-06, -0.3561E-06,  &
      0.2636E-06,  0.1015E-05,  0.1836E-05,  0.2588E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip=21,21)/                                &
      0.1962E-03,  0.3831E-03,  0.7370E-03,  0.1386E-02,  0.2520E-02,   &
      0.4379E-02,  0.7206E-02,  0.1125E-01,  0.1692E-01,  0.2493E-01,   &
      0.3644E-01,  0.5299E-01,  0.7611E-01,  0.1070E+00,  0.1463E+00,   &
      0.1936E+00,  0.2474E+00,  0.3046E+00,  0.3621E+00,  0.4188E+00,   &
      0.4758E+00,  0.5339E+00,  0.5921E+00,  0.6482E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip=21,21)/                                &
      -0.1371E-06, -0.2803E-06, -0.5786E-06, -0.1206E-05, -0.2522E-05,  &
      -0.5211E-05, -0.1040E-04, -0.1969E-04, -0.3522E-04, -0.6021E-04,  &
      -0.9890E-04, -0.1552E-03, -0.2312E-03, -0.3285E-03, -0.4496E-03,  &
      -0.5973E-03, -0.7728E-03, -0.9733E-03, -0.1188E-02, -0.1399E-02,  &
      -0.1590E-02, -0.1748E-02, -0.1862E-02, -0.1922E-02/
  DATA ((c3(ip,iw,1),iw=1,24),ip=21,21)/                                &
      -0.5521E-09, -0.1082E-08, -0.2100E-08, -0.4025E-08, -0.7661E-08,  &
      -0.1462E-07, -0.2837E-07, -0.5493E-07, -0.1013E-06, -0.1716E-06,  &
      -0.2627E-06, -0.3609E-06, -0.4548E-06, -0.5617E-06, -0.7128E-06,  &
      -0.8814E-06, -0.9684E-06, -0.8687E-06, -0.5417E-06, -0.3260E-07,  &
      0.6298E-06,  0.1417E-05,  0.2233E-05,  0.2884E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip=22,22)/                                &
      0.1974E-03,  0.3872E-03,  0.7505E-03,  0.1427E-02,  0.2638E-02,   &
      0.4682E-02,  0.7896E-02,  0.1261E-01,  0.1927E-01,  0.2865E-01,   &
      0.4207E-01,  0.6125E-01,  0.8802E-01,  0.1236E+00,  0.1681E+00,   &
      0.2201E+00,  0.2766E+00,  0.3342E+00,  0.3906E+00,  0.4468E+00,   &
      0.5043E+00,  0.5628E+00,  0.6204E+00,  0.6743E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip=22,22)/                                &
      -0.1377E-06, -0.2818E-06, -0.5836E-06, -0.1222E-05, -0.2570E-05,  &
      -0.5339E-05, -0.1069E-04, -0.2019E-04, -0.3606E-04, -0.6211E-04,  &
      -0.1038E-03, -0.1666E-03, -0.2537E-03, -0.3653E-03, -0.5012E-03,  &
      -0.6623E-03, -0.8484E-03, -0.1055E-02, -0.1268E-02, -0.1470E-02,  &
      -0.1649E-02, -0.1790E-02, -0.1882E-02, -0.1920E-02/
  DATA ((c3(ip,iw,1),iw=1,24),ip=22,22)/                                &
      -0.5464E-09, -0.1064E-08, -0.2050E-08, -0.3874E-08, -0.7265E-08,  &
      -0.1373E-07, -0.2688E-07, -0.5376E-07, -0.1035E-06, -0.1833E-06,  &
      -0.2955E-06, -0.4267E-06, -0.5474E-06, -0.6443E-06, -0.7332E-06,  &
      -0.7933E-06, -0.7465E-06, -0.5424E-06, -0.1941E-06,  0.3078E-06,  &
      0.9845E-06,  0.1771E-05,  0.2515E-05,  0.2962E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip=23,23)/                                &
      0.1981E-03,  0.3899E-03,  0.7594E-03,  0.1455E-02,  0.2722E-02,   &
      0.4913E-02,  0.8469E-02,  0.1387E-01,  0.2168E-01,  0.3275E-01,   &
      0.4842E-01,  0.7058E-01,  0.1012E+00,  0.1414E+00,  0.1908E+00,   &
      0.2467E+00,  0.3050E+00,  0.3620E+00,  0.4176E+00,  0.4739E+00,   &
      0.5318E+00,  0.5900E+00,  0.6460E+00,  0.6969E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip=23,23)/                                &
      -0.1374E-06, -0.2821E-06, -0.5849E-06, -0.1227E-05, -0.2587E-05,  &
      -0.5392E-05, -0.1082E-04, -0.2043E-04, -0.3640E-04, -0.6291E-04,  &
      -0.1064E-03, -0.1742E-03, -0.2713E-03, -0.3983E-03, -0.5523E-03,  &
      -0.7302E-03, -0.9280E-03, -0.1135E-02, -0.1338E-02, -0.1526E-02,  &
      -0.1690E-02, -0.1811E-02, -0.1880E-02, -0.1904E-02/
  DATA ((c3(ip,iw,1),iw=1,24),ip=23,23)/                                &
      -0.5505E-09, -0.1066E-08, -0.2044E-08, -0.3856E-08, -0.7199E-08,  &
      -0.1353E-07, -0.2638E-07, -0.5316E-07, -0.1044E-06, -0.1908E-06,  &
      -0.3207E-06, -0.4858E-06, -0.6471E-06, -0.7512E-06, -0.7676E-06,  &
      -0.6661E-06, -0.4252E-06, -0.1067E-06,  0.2334E-06,  0.6913E-06,  &
      0.1330E-05,  0.2055E-05,  0.2617E-05,  0.2760E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip=24,24)/                                &
      0.1986E-03,  0.3917E-03,  0.7654E-03,  0.1475E-02,  0.2782E-02,   &
      0.5086E-02,  0.8931E-02,  0.1497E-01,  0.2401E-01,  0.3707E-01,   &
      0.5549E-01,  0.8107E-01,  0.1157E+00,  0.1604E+00,  0.2138E+00,   &
      0.2723E+00,  0.3311E+00,  0.3877E+00,  0.4433E+00,  0.5001E+00,   &
      0.5580E+00,  0.6152E+00,  0.6683E+00,  0.7158E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip=24,24)/                                &
      -0.1372E-06, -0.2802E-06, -0.5797E-06, -0.1212E-05, -0.2549E-05,  &
      -0.5312E-05, -0.1068E-04, -0.2023E-04, -0.3609E-04, -0.6255E-04,  &
      -0.1068E-03, -0.1777E-03, -0.2830E-03, -0.4252E-03, -0.6004E-03,  &
      -0.8005E-03, -0.1011E-02, -0.1213E-02, -0.1399E-02, -0.1569E-02,  &
      -0.1712E-02, -0.1809E-02, -0.1858E-02, -0.1883E-02/
  DATA ((c3(ip,iw,1),iw=1,24),ip=24,24)/                                &
      -0.5589E-09, -0.1071E-08, -0.2083E-08, -0.3965E-08, -0.7465E-08,  &
      -0.1408E-07, -0.2720E-07, -0.5414E-07, -0.1061E-06, -0.1958E-06,  &
      -0.3365E-06, -0.5263E-06, -0.7236E-06, -0.8420E-06, -0.7920E-06,  &
      -0.5166E-06, -0.5606E-07,  0.4032E-06,  0.7697E-06,  0.1160E-05,  &
      0.1692E-05,  0.2251E-05,  0.2483E-05,  0.2295E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip=25,25)/                                &
      0.1990E-03,  0.3929E-03,  0.7699E-03,  0.1490E-02,  0.2829E-02,   &
      0.5226E-02,  0.9314E-02,  0.1593E-01,  0.2618E-01,  0.4144E-01,   &
      0.6312E-01,  0.9271E-01,  0.1317E+00,  0.1803E+00,  0.2364E+00,   &
      0.2956E+00,  0.3541E+00,  0.4111E+00,  0.4680E+00,  0.5255E+00,   &
      0.5829E+00,  0.6376E+00,  0.6869E+00,  0.7311E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip=25,25)/                                &
      -0.1366E-06, -0.2772E-06, -0.5687E-06, -0.1179E-05, -0.2458E-05,  &
      -0.5093E-05, -0.1024E-04, -0.1950E-04, -0.3503E-04, -0.6107E-04,  &
      -0.1053E-03, -0.1782E-03, -0.2902E-03, -0.4470E-03, -0.6455E-03,  &
      -0.8715E-03, -0.1095E-02, -0.1290E-02, -0.1458E-02, -0.1604E-02,  &
      -0.1716E-02, -0.1783E-02, -0.1821E-02, -0.1862E-02/
  DATA ((c3(ip,iw,1),iw=1,24),ip=25,25)/                                &
      -0.5574E-09, -0.1099E-08, -0.2136E-08, -0.4136E-08, -0.7893E-08,  &
      -0.1505E-07, -0.2894E-07, -0.5650E-07, -0.1084E-06, -0.1986E-06,  &
      -0.3416E-06, -0.5381E-06, -0.7439E-06, -0.8545E-06, -0.7482E-06,  &
      -0.3541E-06,  0.2762E-06,  0.9306E-06,  0.1416E-05,  0.1754E-05,  &
      0.2105E-05,  0.2343E-05,  0.2113E-05,  0.1689E-05/
  DATA ((c1(ip,iw,1),iw=1,24),ip=26,26)/                                &
      0.1993E-03,  0.3940E-03,  0.7739E-03,  0.1503E-02,  0.2871E-02,   &
      0.5350E-02,  0.9655E-02,  0.1679E-01,  0.2817E-01,  0.4563E-01,   &
      0.7094E-01,  0.1052E+00,  0.1488E+00,  0.2006E+00,  0.2575E+00,   &
      0.3155E+00,  0.3732E+00,  0.4317E+00,  0.4909E+00,  0.5496E+00,   &
      0.6058E+00,  0.6569E+00,  0.7019E+00,  0.7436E+00/
  DATA ((c2(ip,iw,1),iw=1,24),ip=26,26)/                                &
      -0.1351E-06, -0.2730E-06, -0.5547E-06, -0.1136E-05, -0.2337E-05,  &
      -0.4789E-05, -0.9589E-05, -0.1836E-04, -0.3337E-04, -0.5890E-04,  &
      -0.1031E-03, -0.1781E-03, -0.2974E-03, -0.4696E-03, -0.6912E-03,  &
      -0.9400E-03, -0.1174E-02, -0.1368E-02, -0.1521E-02, -0.1635E-02,  &
      -0.1706E-02, -0.1742E-02, -0.1779E-02, -0.1846E-02/
  DATA ((c3(ip,iw,1),iw=1,24),ip=26,26)/                                &
      -0.5597E-09, -0.1126E-08, -0.2190E-08, -0.4298E-08, -0.8333E-08,  &
      -0.1610E-07, -0.3092E-07, -0.5912E-07, -0.1108E-06, -0.1982E-06,  &
      -0.3334E-06, -0.5129E-06, -0.6865E-06, -0.7484E-06, -0.5999E-06,  &
      -0.1961E-06,  0.5028E-06,  0.1395E-05,  0.2125E-05,  0.2489E-05,  &
      0.2584E-05,  0.2312E-05,  0.1587E-05,  0.1122E-05/
!
!-----------------------------------------------------------------------
!
!  The following DATA statements originally came from file
!  "o3.tran3", which define pre-computed tables used for o3 (band5)
!  transmittance calculations.
!
!-----------------------------------------------------------------------
!
! o3.tran3

  REAL :: o1(26,21,7),o2(26,21,7),o3(26,21,7)

  COMMON /radtab003 /o1,o2,o3

  DATA ((o1(ip,iw,1),iw=1,21),ip= 1, 1)/                                &
      0.7117E-05,  0.1419E-04,  0.2828E-04,  0.5629E-04,  0.1117E-03,   &
      0.2207E-03,  0.4326E-03,  0.8367E-03,  0.1586E-02,  0.2911E-02,   &
      0.5106E-02,  0.8433E-02,  0.1302E-01,  0.1896E-01,  0.2658E-01,   &
      0.3657E-01,  0.4988E-01,  0.6765E-01,  0.9092E-01,  0.1204E+00,   &
      0.1559E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip= 1, 1)/                                &
      0.6531E-10,  0.5926E-10, -0.1646E-09, -0.1454E-08, -0.7376E-08,   &
      -0.2968E-07, -0.1071E-06, -0.3584E-06, -0.1125E-05, -0.3289E-05,  &
      -0.8760E-05, -0.2070E-04, -0.4259E-04, -0.7691E-04, -0.1264E-03,  &
      -0.1957E-03, -0.2895E-03, -0.4107E-03, -0.5588E-03, -0.7300E-03,  &
      -0.9199E-03/
  DATA ((o3(ip,iw,1),iw=1,21),ip= 1, 1)/                                &
      -0.2438E-10, -0.4826E-10, -0.9474E-10, -0.1828E-09, -0.3406E-09,  &
      -0.6223E-09, -0.1008E-08, -0.1412E-08, -0.1244E-08,  0.8485E-09,  &
      0.6343E-08,  0.1201E-07,  0.2838E-08, -0.4024E-07, -0.1257E-06,   &
      -0.2566E-06, -0.4298E-06, -0.6184E-06, -0.7657E-06, -0.8153E-06,  &
      -0.7552E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip= 2, 2)/                                &
      0.7117E-05,  0.1419E-04,  0.2828E-04,  0.5629E-04,  0.1117E-03,   &
      0.2207E-03,  0.4326E-03,  0.8367E-03,  0.1586E-02,  0.2912E-02,   &
      0.5107E-02,  0.8435E-02,  0.1303E-01,  0.1897E-01,  0.2660E-01,   &
      0.3660E-01,  0.4995E-01,  0.6777E-01,  0.9114E-01,  0.1207E+00,   &
      0.1566E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip= 2, 2)/                                &
      0.6193E-10,  0.5262E-10, -0.1774E-09, -0.1478E-08, -0.7416E-08,   &
      -0.2985E-07, -0.1071E-06, -0.3584E-06, -0.1124E-05, -0.3287E-05,  &
      -0.8753E-05, -0.2069E-04, -0.4256E-04, -0.7686E-04, -0.1264E-03,  &
      -0.1956E-03, -0.2893E-03, -0.4103E-03, -0.5580E-03, -0.7285E-03,  &
      -0.9171E-03/
  DATA ((o3(ip,iw,1),iw=1,21),ip= 2, 2)/                                &
      -0.2436E-10, -0.4822E-10, -0.9466E-10, -0.1827E-09, -0.3404E-09,  &
      -0.6220E-09, -0.1008E-08, -0.1414E-08, -0.1247E-08,  0.8360E-09,  &
      0.6312E-08,  0.1194E-07,  0.2753E-08, -0.4040E-07, -0.1260E-06,   &
      -0.2571E-06, -0.4307E-06, -0.6202E-06, -0.7687E-06, -0.8204E-06,  &
      -0.7636E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip= 3, 3)/                                &
      0.7117E-05,  0.1419E-04,  0.2828E-04,  0.5628E-04,  0.1117E-03,   &
      0.2207E-03,  0.4326E-03,  0.8367E-03,  0.1586E-02,  0.2912E-02,   &
      0.5109E-02,  0.8439E-02,  0.1303E-01,  0.1899E-01,  0.2664E-01,   &
      0.3666E-01,  0.5005E-01,  0.6795E-01,  0.9147E-01,  0.1213E+00,   &
      0.1576E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip= 3, 3)/                                &
      0.5658E-10,  0.4212E-10, -0.1977E-09, -0.1516E-08, -0.7481E-08,   &
      -0.2995E-07, -0.1072E-06, -0.3583E-06, -0.1123E-05, -0.3283E-05,  &
      -0.8744E-05, -0.2067E-04, -0.4252E-04, -0.7679E-04, -0.1262E-03,  &
      -0.1953E-03, -0.2889E-03, -0.4096E-03, -0.5567E-03, -0.7263E-03,  &
      -0.9130E-03/
  DATA ((o3(ip,iw,1),iw=1,21),ip= 3, 3)/                                &
      -0.2433E-10, -0.4815E-10, -0.9453E-10, -0.1825E-09, -0.3400E-09,  &
      -0.6215E-09, -0.1007E-08, -0.1415E-08, -0.1253E-08,  0.8143E-09,  &
      0.6269E-08,  0.1186E-07,  0.2604E-08, -0.4067E-07, -0.1264E-06,   &
      -0.2579E-06, -0.4321E-06, -0.6229E-06, -0.7732E-06, -0.8277E-06,  &
      -0.7752E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip= 4, 4)/                                &
      0.7116E-05,  0.1419E-04,  0.2828E-04,  0.5628E-04,  0.1117E-03,   &
      0.2207E-03,  0.4326E-03,  0.8368E-03,  0.1586E-02,  0.2913E-02,   &
      0.5111E-02,  0.8444E-02,  0.1305E-01,  0.1902E-01,  0.2669E-01,   &
      0.3676E-01,  0.5022E-01,  0.6825E-01,  0.9199E-01,  0.1222E+00,   &
      0.1591E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip= 4, 4)/                                &
      0.4814E-10,  0.2552E-10, -0.2298E-09, -0.1576E-08, -0.7579E-08,   &
      -0.3009E-07, -0.1074E-06, -0.3581E-06, -0.1122E-05, -0.3278E-05,  &
      -0.8729E-05, -0.2063E-04, -0.4245E-04, -0.7667E-04, -0.1260E-03,  &
      -0.1950E-03, -0.2883E-03, -0.4086E-03, -0.5549E-03, -0.7229E-03,  &
      -0.9071E-03/
  DATA ((o3(ip,iw,1),iw=1,21),ip= 4, 4)/                                &
      -0.2428E-10, -0.4805E-10, -0.9433E-10, -0.1821E-09, -0.3394E-09,  &
      -0.6206E-09, -0.1008E-08, -0.1416E-08, -0.1261E-08,  0.7860E-09,  &
      0.6188E-08,  0.1171E-07,  0.2389E-08, -0.4109E-07, -0.1271E-06,   &
      -0.2591E-06, -0.4344E-06, -0.6267E-06, -0.7797E-06, -0.8378E-06,  &
      -0.7901E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip= 5, 5)/                                &
      0.7116E-05,  0.1419E-04,  0.2827E-04,  0.5627E-04,  0.1117E-03,   &
      0.2207E-03,  0.4326E-03,  0.8368E-03,  0.1586E-02,  0.2914E-02,   &
      0.5114E-02,  0.8454E-02,  0.1307E-01,  0.1906E-01,  0.2677E-01,   &
      0.3690E-01,  0.5048E-01,  0.6872E-01,  0.9281E-01,  0.1236E+00,   &
      0.1615E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip= 5, 5)/                                &
      0.3482E-10, -0.6492E-12, -0.2805E-09, -0.1671E-08, -0.7740E-08,   &
      -0.3032E-07, -0.1076E-06, -0.3582E-06, -0.1120E-05, -0.3270E-05,  &
      -0.8704E-05, -0.2058E-04, -0.4235E-04, -0.7649E-04, -0.1257E-03,  &
      -0.1945E-03, -0.2874E-03, -0.4070E-03, -0.5521E-03, -0.7181E-03,  &
      -0.8990E-03/
  DATA ((o3(ip,iw,1),iw=1,21),ip= 5, 5)/                                &
      -0.2419E-10, -0.4788E-10, -0.9401E-10, -0.1815E-09, -0.3385E-09,  &
      -0.6192E-09, -0.1006E-08, -0.1417E-08, -0.1273E-08,  0.7404E-09,  &
      0.6068E-08,  0.1148E-07,  0.2021E-08, -0.4165E-07, -0.1281E-06,   &
      -0.2609E-06, -0.4375E-06, -0.6323E-06, -0.7887E-06, -0.8508E-06,  &
      -0.8067E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip= 6, 6)/                                &
      0.7114E-05,  0.1419E-04,  0.2827E-04,  0.5627E-04,  0.1117E-03,   &
      0.2207E-03,  0.4325E-03,  0.8369E-03,  0.1587E-02,  0.2916E-02,   &
      0.5120E-02,  0.8468E-02,  0.1310E-01,  0.1913E-01,  0.2690E-01,   &
      0.3714E-01,  0.5090E-01,  0.6944E-01,  0.9407E-01,  0.1258E+00,   &
      0.1651E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip= 6, 6)/                                &
      0.1388E-10, -0.4180E-10, -0.3601E-09, -0.1820E-08, -0.7993E-08,   &
      -0.3068E-07, -0.1081E-06, -0.3580E-06, -0.1117E-05, -0.3257E-05,  &
      -0.8667E-05, -0.2049E-04, -0.4218E-04, -0.7620E-04, -0.1253E-03,  &
      -0.1937E-03, -0.2860E-03, -0.4047E-03, -0.5481E-03, -0.7115E-03,  &
      -0.8885E-03/
  DATA ((o3(ip,iw,1),iw=1,21),ip= 6, 6)/                                &
      -0.2406E-10, -0.4762E-10, -0.9351E-10, -0.1806E-09, -0.3370E-09,  &
      -0.6170E-09, -0.1004E-08, -0.1417E-08, -0.1297E-08,  0.6738E-09,  &
      0.5895E-08,  0.1113E-07,  0.1466E-08, -0.4265E-07, -0.1298E-06,   &
      -0.2636E-06, -0.4423E-06, -0.6402E-06, -0.8005E-06, -0.8658E-06,  &
      -0.8222E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip= 7, 7)/                                &
      0.7113E-05,  0.1418E-04,  0.2826E-04,  0.5625E-04,  0.1117E-03,   &
      0.2206E-03,  0.4325E-03,  0.8371E-03,  0.1588E-02,  0.2918E-02,   &
      0.5128E-02,  0.8491E-02,  0.1315E-01,  0.1923E-01,  0.2710E-01,   &
      0.3750E-01,  0.5154E-01,  0.7056E-01,  0.9600E-01,  0.1290E+00,   &
      0.1703E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip= 7, 7)/                                &
      -0.1889E-10, -0.1062E-09, -0.4847E-09, -0.2053E-08, -0.8389E-08,  &
      -0.3140E-07, -0.1089E-06, -0.3577E-06, -0.1112E-05, -0.3236E-05,  &
      -0.8607E-05, -0.2035E-04, -0.4192E-04, -0.7576E-04, -0.1245E-03,  &
      -0.1925E-03, -0.2840E-03, -0.4013E-03, -0.5427E-03, -0.7029E-03,  &
      -0.8756E-03/
  DATA ((o3(ip,iw,1),iw=1,21),ip= 7, 7)/                                &
      -0.2385E-10, -0.4722E-10, -0.9273E-10, -0.1791E-09, -0.3348E-09,  &
      -0.6121E-09, -0.9974E-09, -0.1422E-08, -0.1326E-08,  0.5603E-09,  &
      0.5604E-08,  0.1061E-07,  0.6106E-09, -0.4398E-07, -0.1321E-06,   &
      -0.2676E-06, -0.4490E-06, -0.6507E-06, -0.8145E-06, -0.8801E-06,  &
      -0.8311E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip= 8, 8)/                                &
      0.7110E-05,  0.1418E-04,  0.2825E-04,  0.5623E-04,  0.1116E-03,   &
      0.2206E-03,  0.4325E-03,  0.8373E-03,  0.1589E-02,  0.2923E-02,   &
      0.5141E-02,  0.8526E-02,  0.1324E-01,  0.1940E-01,  0.2741E-01,   &
      0.3807E-01,  0.5253E-01,  0.7227E-01,  0.9889E-01,  0.1338E+00,   &
      0.1777E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip= 8, 8)/                                &
      -0.6983E-10, -0.2063E-09, -0.6785E-09, -0.2416E-08, -0.9000E-08,  &
      -0.3243E-07, -0.1100E-06, -0.3574E-06, -0.1104E-05, -0.3205E-05,  &
      -0.8516E-05, -0.2014E-04, -0.4151E-04, -0.7508E-04, -0.1234E-03,  &
      -0.1907E-03, -0.2811E-03, -0.3966E-03, -0.5355E-03, -0.6924E-03,  &
      -0.8613E-03/
  DATA ((o3(ip,iw,1),iw=1,21),ip= 8, 8)/                                &
      -0.2353E-10, -0.4659E-10, -0.9153E-10, -0.1769E-09, -0.3313E-09,  &
      -0.6054E-09, -0.9899E-09, -0.1430E-08, -0.1375E-08,  0.3874E-09,  &
      0.5171E-08,  0.9807E-08, -0.7345E-09, -0.4604E-07, -0.1356E-06,   &
      -0.2731E-06, -0.4577E-06, -0.6632E-06, -0.8284E-06, -0.8894E-06,  &
      -0.8267E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip= 9, 9)/                                &
      0.7105E-05,  0.1417E-04,  0.2823E-04,  0.5620E-04,  0.1116E-03,   &
      0.2205E-03,  0.4325E-03,  0.8376E-03,  0.1591E-02,  0.2929E-02,   &
      0.5162E-02,  0.8581E-02,  0.1336E-01,  0.1966E-01,  0.2790E-01,   &
      0.3894E-01,  0.5404E-01,  0.7484E-01,  0.1031E+00,  0.1405E+00,   &
      0.1880E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip= 9, 9)/                                &
      -0.1481E-09, -0.3601E-09, -0.9762E-09, -0.2973E-08, -0.1014E-07,  &
      -0.3421E-07, -0.1121E-06, -0.3569E-06, -0.1092E-05, -0.3156E-05,  &
      -0.8375E-05, -0.1981E-04, -0.4090E-04, -0.7405E-04, -0.1218E-03,  &
      -0.1881E-03, -0.2770E-03, -0.3906E-03, -0.5269E-03, -0.6810E-03,  &
      -0.8471E-03/
  DATA ((o3(ip,iw,1),iw=1,21),ip= 9, 9)/                                &
      -0.2304E-10, -0.4564E-10, -0.8969E-10, -0.1735E-09, -0.3224E-09,  &
      -0.5933E-09, -0.9756E-09, -0.1428E-08, -0.1446E-08,  0.1156E-09,  &
      0.4499E-08,  0.8469E-08, -0.2720E-08, -0.4904E-07, -0.1401E-06,   &
      -0.2801E-06, -0.4681E-06, -0.6761E-06, -0.8387E-06, -0.8879E-06,  &
      -0.8040E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip=10,10)/                                &
      0.7098E-05,  0.1415E-04,  0.2821E-04,  0.5615E-04,  0.1115E-03,   &
      0.2204E-03,  0.4325E-03,  0.8382E-03,  0.1593E-02,  0.2940E-02,   &
      0.5194E-02,  0.8666E-02,  0.1356E-01,  0.2006E-01,  0.2865E-01,   &
      0.4026E-01,  0.5631E-01,  0.7863E-01,  0.1093E+00,  0.1500E+00,   &
      0.2017E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip=10,10)/                                &
      -0.2661E-09, -0.5923E-09, -0.1426E-08, -0.3816E-08, -0.1159E-07,  &
      -0.3654E-07, -0.1143E-06, -0.3559E-06, -0.1074E-05, -0.3083E-05,  &
      -0.8159E-05, -0.1932E-04, -0.3998E-04, -0.7253E-04, -0.1194E-03,  &
      -0.1845E-03, -0.2718E-03, -0.3833E-03, -0.5176E-03, -0.6701E-03,  &
      -0.8354E-03/
  DATA ((o3(ip,iw,1),iw=1,21),ip=10,10)/                                &
      -0.2232E-10, -0.4421E-10, -0.8695E-10, -0.1684E-09, -0.3141E-09,  &
      -0.5765E-09, -0.9606E-09, -0.1434E-08, -0.1551E-08, -0.2663E-09,  &
      0.3515E-08,  0.6549E-08, -0.5479E-08, -0.5312E-07, -0.1460E-06,   &
      -0.2883E-06, -0.4787E-06, -0.6863E-06, -0.8399E-06, -0.8703E-06,  &
      -0.7602E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip=11,11)/                                &
      0.7088E-05,  0.1413E-04,  0.2817E-04,  0.5608E-04,  0.1114E-03,   &
      0.2203E-03,  0.4325E-03,  0.8390E-03,  0.1598E-02,  0.2955E-02,   &
      0.5242E-02,  0.8796E-02,  0.1386E-01,  0.2067E-01,  0.2978E-01,   &
      0.4224E-01,  0.5964E-01,  0.8406E-01,  0.1178E+00,  0.1627E+00,   &
      0.2197E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip=11,11)/                                &
      -0.4394E-09, -0.9330E-09, -0.2086E-08, -0.5054E-08, -0.1373E-07,  &
      -0.3971E-07, -0.1178E-06, -0.3546E-06, -0.1049E-05, -0.2976E-05,  &
      -0.7847E-05, -0.1860E-04, -0.3864E-04, -0.7038E-04, -0.1162E-03,  &
      -0.1798E-03, -0.2654E-03, -0.3754E-03, -0.5091E-03, -0.6621E-03,  &
      -0.8286E-03/
  DATA ((o3(ip,iw,1),iw=1,21),ip=11,11)/                                &
      -0.2127E-10, -0.4216E-10, -0.8300E-10, -0.1611E-09, -0.3019E-09,  &
      -0.5597E-09, -0.9431E-09, -0.1450E-08, -0.1694E-08, -0.7913E-09,  &
      0.2144E-08,  0.3990E-08, -0.9282E-08, -0.5810E-07, -0.1525E-06,   &
      -0.2965E-06, -0.4869E-06, -0.6894E-06, -0.8281E-06, -0.8350E-06,  &
      -0.6956E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip=12,12)/                                &
      0.7073E-05,  0.1411E-04,  0.2811E-04,  0.5598E-04,  0.1112E-03,   &
      0.2201E-03,  0.4324E-03,  0.8401E-03,  0.1604E-02,  0.2978E-02,   &
      0.5313E-02,  0.8987E-02,  0.1431E-01,  0.2158E-01,  0.3145E-01,   &
      0.4512E-01,  0.6440E-01,  0.9161E-01,  0.1293E+00,  0.1793E+00,   &
      0.2426E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip=12,12)/                                &
      -0.6829E-09, -0.1412E-08, -0.3014E-08, -0.6799E-08, -0.1675E-07,  &
      -0.4450E-07, -0.1235E-06, -0.3538E-06, -0.1014E-05, -0.2827E-05,  &
      -0.7407E-05, -0.1759E-04, -0.3676E-04, -0.6744E-04, -0.1120E-03,  &
      -0.1742E-03, -0.2585E-03, -0.3683E-03, -0.5034E-03, -0.6594E-03,  &
      -0.8290E-03/
  DATA ((o3(ip,iw,1),iw=1,21),ip=12,12)/                                &
      -0.1985E-10, -0.3937E-10, -0.7761E-10, -0.1511E-09, -0.2855E-09,  &
      -0.5313E-09, -0.9251E-09, -0.1470E-08, -0.1898E-08, -0.1519E-08,  &
      0.2914E-09,  0.5675E-09, -0.1405E-07, -0.6359E-07, -0.1584E-06,   &
      -0.3020E-06, -0.4893E-06, -0.6821E-06, -0.8021E-06, -0.7834E-06,  &
      -0.6105E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip=13,13)/                                &
      0.7053E-05,  0.1407E-04,  0.2804E-04,  0.5584E-04,  0.1110E-03,   &
      0.2198E-03,  0.4324E-03,  0.8420E-03,  0.1613E-02,  0.3011E-02,   &
      0.5416E-02,  0.9263E-02,  0.1495E-01,  0.2289E-01,  0.3384E-01,   &
      0.4918E-01,  0.7096E-01,  0.1018E+00,  0.1442E+00,  0.2004E+00,   &
      0.2708E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip=13,13)/                                &
      -0.1004E-08, -0.2043E-08, -0.4239E-08, -0.9104E-08, -0.2075E-07,  &
      -0.5096E-07, -0.1307E-06, -0.3520E-06, -0.9671E-06, -0.2630E-05,  &
      -0.6825E-05, -0.1624E-04, -0.3429E-04, -0.6369E-04, -0.1069E-03,  &
      -0.1680E-03, -0.2520E-03, -0.3635E-03, -0.5029E-03, -0.6647E-03,  &
      -0.8390E-03/
  DATA ((o3(ip,iw,1),iw=1,21),ip=13,13)/                                &
      -0.1807E-10, -0.3587E-10, -0.7085E-10, -0.1385E-09, -0.2648E-09,  &
      -0.4958E-09, -0.8900E-09, -0.1473E-08, -0.2112E-08, -0.2399E-08,  &
      -0.2002E-08, -0.3646E-08, -0.1931E-07, -0.6852E-07, -0.1618E-06,  &
      -0.3021E-06, -0.4828E-06, -0.6634E-06, -0.7643E-06, -0.7177E-06,  &
      -0.5054E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip=14,14)/                                &
      0.7029E-05,  0.1402E-04,  0.2795E-04,  0.5567E-04,  0.1107E-03,   &
      0.2195E-03,  0.4326E-03,  0.8447E-03,  0.1625E-02,  0.3056E-02,   &
      0.5554E-02,  0.9638E-02,  0.1584E-01,  0.2470E-01,  0.3713E-01,   &
      0.5470E-01,  0.7969E-01,  0.1149E+00,  0.1631E+00,  0.2263E+00,   &
      0.3045E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip=14,14)/                                &
      -0.1387E-08, -0.2798E-08, -0.5706E-08, -0.1187E-07, -0.2564E-07,  &
      -0.5866E-07, -0.1398E-06, -0.3516E-06, -0.9148E-06, -0.2398E-05,  &
      -0.6122E-05, -0.1459E-04, -0.3125E-04, -0.5923E-04, -0.1013E-03,  &
      -0.1620E-03, -0.2473E-03, -0.3631E-03, -0.5098E-03, -0.6800E-03,  &
      -0.8603E-03/
  DATA ((o3(ip,iw,1),iw=1,21),ip=14,14)/                                &
      -0.1610E-10, -0.3200E-10, -0.6337E-10, -0.1245E-09, -0.2408E-09,  &
      -0.4533E-09, -0.8405E-09, -0.1464E-08, -0.2337E-08, -0.3341E-08,  &
      -0.4467E-08, -0.8154E-08, -0.2436E-07, -0.7128E-07, -0.1604E-06,  &
      -0.2945E-06, -0.4666E-06, -0.6357E-06, -0.7187E-06, -0.6419E-06,  &
      -0.3795E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip=15,15)/                                &
      0.7003E-05,  0.1397E-04,  0.2785E-04,  0.5550E-04,  0.1104E-03,   &
      0.2192E-03,  0.4329E-03,  0.8481E-03,  0.1641E-02,  0.3112E-02,   &
      0.5729E-02,  0.1012E-01,  0.1698E-01,  0.2708E-01,  0.4146E-01,   &
      0.6189E-01,  0.9085E-01,  0.1313E+00,  0.1862E+00,  0.2571E+00,   &
      0.3433E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip=15,15)/                                &
      -0.1788E-08, -0.3588E-08, -0.7244E-08, -0.1479E-07, -0.3083E-07,  &
      -0.6671E-07, -0.1497E-06, -0.3519E-06, -0.8607E-06, -0.2154E-05,  &
      -0.5364E-05, -0.1276E-04, -0.2785E-04, -0.5435E-04, -0.9573E-04,  &
      -0.1570E-03, -0.2455E-03, -0.3682E-03, -0.5253E-03, -0.7065E-03,  &
      -0.8938E-03/
  DATA ((o3(ip,iw,1),iw=1,21),ip=15,15)/                                &
      -0.1429E-10, -0.2843E-10, -0.5645E-10, -0.1115E-09, -0.2181E-09,  &
      -0.4200E-09, -0.7916E-09, -0.1460E-08, -0.2542E-08, -0.4168E-08,  &
      -0.6703E-08, -0.1215E-07, -0.2821E-07, -0.7073E-07, -0.1530E-06,  &
      -0.2791E-06, -0.4426E-06, -0.6027E-06, -0.6707E-06, -0.5591E-06,  &
      -0.2328E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip=16,16)/                                &
      0.6981E-05,  0.1393E-04,  0.2777E-04,  0.5535E-04,  0.1102E-03,   &
      0.2190E-03,  0.4336E-03,  0.8527E-03,  0.1660E-02,  0.3177E-02,   &
      0.5930E-02,  0.1068E-01,  0.1836E-01,  0.3000E-01,  0.4686E-01,   &
      0.7083E-01,  0.1046E+00,  0.1511E+00,  0.2134E+00,  0.2924E+00,   &
      0.3861E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip=16,16)/                                &
      -0.2141E-08, -0.4286E-08, -0.8603E-08, -0.1737E-07, -0.3548E-07,  &
      -0.7410E-07, -0.1590E-06, -0.3537E-06, -0.8142E-06, -0.1935E-05,  &
      -0.4658E-05, -0.1099E-04, -0.2444E-04, -0.4948E-04, -0.9067E-04,  &
      -0.1538E-03, -0.2474E-03, -0.3793E-03, -0.5495E-03, -0.7439E-03,  &
      -0.9383E-03/
  DATA ((o3(ip,iw,1),iw=1,21),ip=16,16)/                                &
      -0.1295E-10, -0.2581E-10, -0.5136E-10, -0.1019E-09, -0.2011E-09,  &
      -0.3916E-09, -0.7585E-09, -0.1439E-08, -0.2648E-08, -0.4747E-08,  &
      -0.8301E-08, -0.1499E-07, -0.3024E-07, -0.6702E-07, -0.1399E-06,  &
      -0.2564E-06, -0.4117E-06, -0.5669E-06, -0.6239E-06, -0.4748E-06,  &
      -0.7013E-07/
  DATA ((o1(ip,iw,1),iw=1,21),ip=17,17)/                                &
      0.6967E-05,  0.1390E-04,  0.2772E-04,  0.5527E-04,  0.1101E-03,   &
      0.2191E-03,  0.4346E-03,  0.8579E-03,  0.1679E-02,  0.3244E-02,   &
      0.6139E-02,  0.1127E-01,  0.1986E-01,  0.3330E-01,  0.5315E-01,   &
      0.8139E-01,  0.1207E+00,  0.1741E+00,  0.2442E+00,  0.3311E+00,   &
      0.4312E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip=17,17)/                                &
      -0.2400E-08, -0.4796E-08, -0.9599E-08, -0.1927E-07, -0.3892E-07,  &
      -0.7954E-07, -0.1661E-06, -0.3540E-06, -0.7780E-06, -0.1763E-05,  &
      -0.4092E-05, -0.9512E-05, -0.2142E-04, -0.4502E-04, -0.8640E-04,  &
      -0.1525E-03, -0.2526E-03, -0.3955E-03, -0.5805E-03, -0.7897E-03,  &
      -0.9899E-03/
  DATA ((o3(ip,iw,1),iw=1,21),ip=17,17)/                                &
      -0.1220E-10, -0.2432E-10, -0.4845E-10, -0.9640E-10, -0.1912E-09,  &
      -0.3771E-09, -0.7392E-09, -0.1420E-08, -0.2702E-08, -0.5049E-08,  &
      -0.9214E-08, -0.1659E-07, -0.3101E-07, -0.6162E-07, -0.1235E-06,  &
      -0.2287E-06, -0.3755E-06, -0.5274E-06, -0.5790E-06, -0.3947E-06,  &
      0.1003E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip=18,18)/                                &
      0.6963E-05,  0.1389E-04,  0.2771E-04,  0.5526E-04,  0.1101E-03,   &
      0.2193E-03,  0.4359E-03,  0.8629E-03,  0.1698E-02,  0.3305E-02,   &
      0.6331E-02,  0.1183E-01,  0.2133E-01,  0.3671E-01,  0.5996E-01,   &
      0.9320E-01,  0.1389E+00,  0.1999E+00,  0.2778E+00,  0.3717E+00,   &
      0.4761E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip=18,18)/                                &
      -0.2557E-08, -0.5106E-08, -0.1020E-07, -0.2043E-07, -0.4103E-07,  &
      -0.8293E-07, -0.1697E-06, -0.3531E-06, -0.7531E-06, -0.1645E-05,  &
      -0.3690E-05, -0.8411E-05, -0.1902E-04, -0.4118E-04, -0.8276E-04,  &
      -0.1525E-03, -0.2601E-03, -0.4147E-03, -0.6149E-03, -0.8384E-03,  &
      -0.1042E-02/
  DATA ((o3(ip,iw,1),iw=1,21),ip=18,18)/                                &
      -0.1189E-10, -0.2372E-10, -0.4729E-10, -0.9421E-10, -0.1873E-09,  &
      -0.3713E-09, -0.7317E-09, -0.1437E-08, -0.2764E-08, -0.5243E-08,  &
      -0.9691E-08, -0.1751E-07, -0.3122E-07, -0.5693E-07, -0.1076E-06,  &
      -0.1981E-06, -0.3324E-06, -0.4785E-06, -0.5280E-06, -0.3174E-06,  &
      0.2672E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip=19,19)/                                &
      0.6963E-05,  0.1389E-04,  0.2771E-04,  0.5528E-04,  0.1102E-03,   &
      0.2196E-03,  0.4370E-03,  0.8672E-03,  0.1712E-02,  0.3355E-02,   &
      0.6488E-02,  0.1230E-01,  0.2262E-01,  0.3989E-01,  0.6677E-01,   &
      0.1056E+00,  0.1586E+00,  0.2276E+00,  0.3131E+00,  0.4124E+00,   &
      0.5188E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip=19,19)/                                &
      -0.2630E-08, -0.5249E-08, -0.1048E-07, -0.2096E-07, -0.4198E-07,  &
      -0.8440E-07, -0.1710E-06, -0.3513E-06, -0.7326E-06, -0.1562E-05,  &
      -0.3416E-05, -0.7637E-05, -0.1719E-04, -0.3795E-04, -0.7926E-04,  &
      -0.1524E-03, -0.2680E-03, -0.4344E-03, -0.6486E-03, -0.8838E-03,  &
      -0.1089E-02/
  DATA ((o3(ip,iw,1),iw=1,21),ip=19,19)/                                &
      -0.1188E-10, -0.2369E-10, -0.4725E-10, -0.9417E-10, -0.1875E-09,  &
      -0.3725E-09, -0.7365E-09, -0.1445E-08, -0.2814E-08, -0.5384E-08,  &
      -0.1008E-07, -0.1816E-07, -0.3179E-07, -0.5453E-07, -0.9500E-07,  &
      -0.1679E-06, -0.2819E-06, -0.4109E-06, -0.4555E-06, -0.2283E-06,  &
      0.4283E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip=20,20)/                                &
      0.6963E-05,  0.1389E-04,  0.2772E-04,  0.5529E-04,  0.1103E-03,   &
      0.2198E-03,  0.4377E-03,  0.8701E-03,  0.1723E-02,  0.3391E-02,   &
      0.6606E-02,  0.1266E-01,  0.2366E-01,  0.4262E-01,  0.7304E-01,   &
      0.1179E+00,  0.1789E+00,  0.2563E+00,  0.3487E+00,  0.4516E+00,   &
      0.5572E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip=20,20)/                                &
      -0.2651E-08, -0.5291E-08, -0.1056E-07, -0.2110E-07, -0.4221E-07,  &
      -0.8462E-07, -0.1705E-06, -0.3466E-06, -0.7155E-06, -0.1501E-05,  &
      -0.3223E-05, -0.7079E-05, -0.1581E-04, -0.3517E-04, -0.7553E-04,  &
      -0.1510E-03, -0.2746E-03, -0.4528E-03, -0.6789E-03, -0.9214E-03,  &
      -0.1124E-02/
  DATA ((o3(ip,iw,1),iw=1,21),ip=20,20)/                                &
      -0.1193E-10, -0.2380E-10, -0.4748E-10, -0.9465E-10, -0.1886E-09,  &
      -0.3751E-09, -0.7436E-09, -0.1466E-08, -0.2872E-08, -0.5508E-08,  &
      -0.1038E-07, -0.1891E-07, -0.3279E-07, -0.5420E-07, -0.8711E-07,  &
      -0.1403E-06, -0.2248E-06, -0.3221E-06, -0.3459E-06, -0.1066E-06,  &
      0.5938E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip=21,21)/                                &
      0.6964E-05,  0.1389E-04,  0.2772E-04,  0.5530E-04,  0.1103E-03,   &
      0.2199E-03,  0.4382E-03,  0.8719E-03,  0.1730E-02,  0.3416E-02,   &
      0.6690E-02,  0.1293E-01,  0.2445E-01,  0.4479E-01,  0.7837E-01,   &
      0.1291E+00,  0.1985E+00,  0.2846E+00,  0.3831E+00,  0.4875E+00,   &
      0.5902E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip=21,21)/                                &
      -0.2654E-08, -0.5296E-08, -0.1057E-07, -0.2111E-07, -0.4219E-07,  &
      -0.8445E-07, -0.1696E-06, -0.3428E-06, -0.7013E-06, -0.1458E-05,  &
      -0.3084E-05, -0.6678E-05, -0.1476E-04, -0.3284E-04, -0.7173E-04,  &
      -0.1481E-03, -0.2786E-03, -0.4688E-03, -0.7052E-03, -0.9506E-03,  &
      -0.1148E-02/
  DATA ((o3(ip,iw,1),iw=1,21),ip=21,21)/                                &
      -0.1195E-10, -0.2384E-10, -0.4755E-10, -0.9482E-10, -0.1890E-09,  &
      -0.3761E-09, -0.7469E-09, -0.1476E-08, -0.2892E-08, -0.5603E-08,  &
      -0.1060E-07, -0.1942E-07, -0.3393E-07, -0.5508E-07, -0.8290E-07,  &
      -0.1182E-06, -0.1657E-06, -0.2170E-06, -0.1997E-06,  0.6227E-07,  &
      0.7847E-06/
  DATA ((o1(ip,iw,1),iw=1,21),ip=22,22)/                                &
      0.6964E-05,  0.1389E-04,  0.2772E-04,  0.5530E-04,  0.1103E-03,   &
      0.2200E-03,  0.4385E-03,  0.8731E-03,  0.1735E-02,  0.3433E-02,   &
      0.6748E-02,  0.1311E-01,  0.2502E-01,  0.4642E-01,  0.8258E-01,   &
      0.1385E+00,  0.2160E+00,  0.3107E+00,  0.4146E+00,  0.5188E+00,   &
      0.6171E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip=22,22)/                                &
      -0.2653E-08, -0.5295E-08, -0.1057E-07, -0.2110E-07, -0.4215E-07,  &
      -0.8430E-07, -0.1690E-06, -0.3403E-06, -0.6919E-06, -0.1427E-05,  &
      -0.2991E-05, -0.6399E-05, -0.1398E-04, -0.3099E-04, -0.6824E-04,  &
      -0.1441E-03, -0.2795E-03, -0.4814E-03, -0.7282E-03, -0.9739E-03,  &
      -0.1163E-02/
  DATA ((o3(ip,iw,1),iw=1,21),ip=22,22)/                                &
      -0.1195E-10, -0.2384E-10, -0.4756E-10, -0.9485E-10, -0.1891E-09,  &
      -0.3765E-09, -0.7483E-09, -0.1481E-08, -0.2908E-08, -0.5660E-08,  &
      -0.1075E-07, -0.1980E-07, -0.3472E-07, -0.5626E-07, -0.8149E-07,  &
      -0.1027E-06, -0.1136E-06, -0.1071E-06, -0.2991E-07,  0.2743E-06,  &
      0.1017E-05/
  DATA ((o1(ip,iw,1),iw=1,21),ip=23,23)/                                &
      0.6964E-05,  0.1389E-04,  0.2772E-04,  0.5530E-04,  0.1103E-03,   &
      0.2200E-03,  0.4387E-03,  0.8738E-03,  0.1738E-02,  0.3445E-02,   &
      0.6786E-02,  0.1324E-01,  0.2541E-01,  0.4757E-01,  0.8567E-01,   &
      0.1459E+00,  0.2303E+00,  0.3331E+00,  0.4415E+00,  0.5444E+00,   &
      0.6377E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip=23,23)/                                &
      -0.2653E-08, -0.5294E-08, -0.1057E-07, -0.2109E-07, -0.4212E-07,  &
      -0.8420E-07, -0.1686E-06, -0.3388E-06, -0.6858E-06, -0.1406E-05,  &
      -0.2928E-05, -0.6206E-05, -0.1344E-04, -0.2961E-04, -0.6533E-04,  &
      -0.1399E-03, -0.2780E-03, -0.4904E-03, -0.7488E-03, -0.9953E-03,  &
      -0.1175E-02/
  DATA ((o3(ip,iw,1),iw=1,21),ip=23,23)/                                &
      -0.1195E-10, -0.2384E-10, -0.4756E-10, -0.9485E-10, -0.1891E-09,  &
      -0.3767E-09, -0.7492E-09, -0.1485E-08, -0.2924E-08, -0.5671E-08,  &
      -0.1084E-07, -0.2009E-07, -0.3549E-07, -0.5773E-07, -0.8208E-07,  &
      -0.9394E-07, -0.7270E-07, -0.3947E-08,  0.1456E-06,  0.5083E-06,  &
      0.1270E-05/
  DATA ((o1(ip,iw,1),iw=1,21),ip=24,24)/                                &
      0.6964E-05,  0.1389E-04,  0.2772E-04,  0.5531E-04,  0.1103E-03,   &
      0.2201E-03,  0.4388E-03,  0.8743E-03,  0.1740E-02,  0.3452E-02,   &
      0.6811E-02,  0.1332E-01,  0.2567E-01,  0.4835E-01,  0.8782E-01,   &
      0.1511E+00,  0.2412E+00,  0.3507E+00,  0.4627E+00,  0.5638E+00,   &
      0.6526E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip=24,24)/                                &
      -0.2653E-08, -0.5294E-08, -0.1056E-07, -0.2109E-07, -0.4210E-07,  &
      -0.8413E-07, -0.1684E-06, -0.3379E-06, -0.6820E-06, -0.1393E-05,  &
      -0.2889E-05, -0.6080E-05, -0.1307E-04, -0.2861E-04, -0.6310E-04,  &
      -0.1363E-03, -0.2758E-03, -0.4969E-03, -0.7681E-03, -0.1017E-02,  &
      -0.1186E-02/
  DATA ((o3(ip,iw,1),iw=1,21),ip=24,24)/                                &
      -0.1195E-10, -0.2384E-10, -0.4756E-10, -0.9485E-10, -0.1891E-09,  &
      -0.3768E-09, -0.7497E-09, -0.1487E-08, -0.2933E-08, -0.5710E-08,  &
      -0.1089E-07, -0.2037E-07, -0.3616E-07, -0.5907E-07, -0.8351E-07,  &
      -0.8925E-07, -0.4122E-07,  0.8779E-07,  0.3143E-06,  0.7281E-06,  &
      0.1500E-05/
  DATA ((o1(ip,iw,1),iw=1,21),ip=25,25)/                                &
      0.6964E-05,  0.1389E-04,  0.2772E-04,  0.5531E-04,  0.1103E-03,   &
      0.2201E-03,  0.4388E-03,  0.8745E-03,  0.1741E-02,  0.3456E-02,   &
      0.6827E-02,  0.1337E-01,  0.2584E-01,  0.4885E-01,  0.8924E-01,   &
      0.1547E+00,  0.2488E+00,  0.3632E+00,  0.4779E+00,  0.5771E+00,   &
      0.6627E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip=25,25)/                                &
      -0.2653E-08, -0.5293E-08, -0.1056E-07, -0.2108E-07, -0.4209E-07,  &
      -0.8409E-07, -0.1682E-06, -0.3373E-06, -0.6797E-06, -0.1383E-05,  &
      -0.2862E-05, -0.5993E-05, -0.1283E-04, -0.2795E-04, -0.6158E-04,  &
      -0.1338E-03, -0.2743E-03, -0.5030E-03, -0.7863E-03, -0.1038E-02,  &
      -0.1196E-02/
  DATA ((o3(ip,iw,1),iw=1,21),ip=25,25)/                                &
      -0.1195E-10, -0.2383E-10, -0.4755E-10, -0.9484E-10, -0.1891E-09,  &
      -0.3768E-09, -0.7499E-09, -0.1489E-08, -0.2939E-08, -0.5741E-08,  &
      -0.1100E-07, -0.2066E-07, -0.3660E-07, -0.6002E-07, -0.8431E-07,  &
      -0.8556E-07, -0.1674E-07,  0.1638E-06,  0.4525E-06,  0.8949E-06,  &
      0.1669E-05/
  DATA ((o1(ip,iw,1),iw=1,21),ip=26,26)/                                &
      0.6964E-05,  0.1389E-04,  0.2772E-04,  0.5531E-04,  0.1103E-03,   &
      0.2201E-03,  0.4389E-03,  0.8747E-03,  0.1741E-02,  0.3458E-02,   &
      0.6836E-02,  0.1340E-01,  0.2594E-01,  0.4916E-01,  0.9011E-01,   &
      0.1569E+00,  0.2536E+00,  0.3714E+00,  0.4877E+00,  0.5856E+00,   &
      0.6695E+00/
  DATA ((o2(ip,iw,1),iw=1,21),ip=26,26)/                                &
      -0.2652E-08, -0.5292E-08, -0.1056E-07, -0.2108E-07, -0.4208E-07,  &
      -0.8406E-07, -0.1681E-06, -0.3369E-06, -0.6784E-06, -0.1378E-05,  &
      -0.2843E-05, -0.5944E-05, -0.1269E-04, -0.2759E-04, -0.6078E-04,  &
      -0.1326E-03, -0.2742E-03, -0.5088E-03, -0.8013E-03, -0.1054E-02,  &
      -0.1202E-02/
  DATA ((o3(ip,iw,1),iw=1,21),ip=26,26)/                                &
      -0.1194E-10, -0.2383E-10, -0.4754E-10, -0.9482E-10, -0.1891E-09,  &
      -0.3768E-09, -0.7499E-09, -0.1489E-08, -0.2941E-08, -0.5752E-08,  &
      -0.1104E-07, -0.2069E-07, -0.3661E-07, -0.6012E-07, -0.8399E-07,  &
      -0.8183E-07,  0.1930E-08,  0.2167E-06,  0.5434E-06,  0.9990E-06,  &
      0.1787E-05/
!
!-----------------------------------------------------------------------
!
!  The following DATA statements originally came from file
!  "cai.dat", which define pre-computed tables cai
!
!-----------------------------------------------------------------------
!
!  integer   nm,nt,na
!  parameter (nm=11,nt=9,na=11)

  REAL :: caib(11,9,11),caif(9,11)

  COMMON /radtab004/ caib,caif

  DATA ((caib(1,i,j),j=1,11),i=1,9)/                                    &
      0.,0.084,0.170,0.258,0.349,0.442,0.540,0.643,0.752,0.870,1.,      &
      0.,0.076,0.153,0.233,0.315,0.401,0.492,0.589,0.698,0.826,1.,      &
      0.,0.069,0.139,0.210,0.283,0.359,0.438,0.523,0.619,0.741,1.,      &
      0.,0.065,0.130,0.196,0.263,0.332,0.403,0.478,0.561,0.671,1.,      &
      0.,0.062,0.126,0.189,0.253,0.318,0.385,0.454,0.533,0.681,1.,      &
      0.,0.062,0.123,0.185,0.248,0.311,0.375,0.444,0.539,0.738,1.,      &
      0.,0.061,0.122,0.183,0.244,0.307,0.370,0.444,0.577,0.752,1.,      &
      0.,0.060,0.121,0.182,0.243,0.304,0.368,0.457,0.574,0.732,1.,      &
      0.,0.060,0.120,0.181,0.242,0.302,0.367,0.451,0.551,0.690,1./
  DATA ((caib(2,i,j),j=1,11),i=1,9)/                                    &
      0.,0.094,0.190,0.286,0.384,0.482,0.583,0.684,0.788,0.893,1.,      &
      0.,0.090,0.180,0.274,0.368,0.466,0.566,0.668,0.774,0.885,1.,      &
      0.,0.082,0.167,0.254,0.343,0.436,0.533,0.636,0.746,0.866,1.,      &
      0.,0.074,0.151,0.229,0.310,0.395,0.485,0.582,0.692,0.822,1.,      &
      0.,0.068,0.138,0.209,0.282,0.358,0.439,0.527,0.630,0.769,1.,      &
      0.,0.065,0.130,0.197,0.265,0.336,0.410,0.493,0.599,0.766,1.,      &
      0.,0.063,0.126,0.190,0.256,0.323,0.394,0.480,0.604,0.772,1.,      &
      0.,0.062,0.124,0.186,0.249,0.314,0.385,0.475,0.594,0.749,1.,      &
      0.,0.061,0.122,0.183,0.245,0.309,0.378,0.462,0.564,0.704,1./
  DATA ((caib(3,i,j),j=1,11),i=1,9)/                                    &
      0.,0.097,0.194,0.292,0.392,0.491,0.591,0.692,0.794,0.897,1.,      &
      0.,0.094,0.189,0.286,0.383,0.482,0.582,0.684,0.788,0.893,1.,      &
      0.,0.090,0.180,0.274,0.368,0.466,0.566,0.668,0.775,0.885,1.,      &
      0.,0.083,0.167,0.254,0.344,0.438,0.535,0.638,0.748,0.868,1.,      &
      0.,0.075,0.152,0.232,0.314,0.400,0.492,0.592,0.703,0.835,1.,      &
      0.,0.069,0.140,0.212,0.288,0.366,0.451,0.546,0.659,0.805,1.,      &
      0.,0.066,0.132,0.200,0.270,0.344,0.424,0.518,0.638,0.794,1.,      &
      0.,0.063,0.127,0.192,0.259,0.329,0.406,0.499,0.616,0.769,1.,      &
      0.,0.062,0.124,0.187,0.251,0.318,0.391,0.477,0.580,0.721,1./
  DATA ((caib(4,i,j),j=1,11),i=1,9)/                                    &
      0.,0.098,0.196,0.295,0.394,0.494,0.594,0.695,0.796,0.898,1.,      &
      0.,0.096,0.193,0.290,0.389,0.488,0.589,0.690,0.792,0.896,1.,      &
      0.,0.093,0.187,0.282,0.379,0.478,0.578,0.680,0.784,0.891,1.,      &
      0.,0.087,0.176,0.268,0.362,0.458,0.557,0.661,0.768,0.881,1.,      &
      0.,0.080,0.163,0.248,0.336,0.428,0.524,0.628,0.739,0.862,1.,      &
      0.,0.074,0.149,0.226,0.308,0.393,0.485,0.586,0.700,0.835,1.,      &
      0.,0.068,0.138,0.210,0.285,0.365,0.452,0.550,0.668,0.814,1.,      &
      0.,0.065,0.131,0.199,0.269,0.344,0.426,0.522,0.638,0.786,1.,      &
      0.,0.063,0.126,0.191,0.257,0.327,0.404,0.491,0.596,0.737,1./
  DATA ((caib(5,i,j),j=1,11),i=1,9)/                                    &
      0.,0.098,0.197,0.296,0.396,0.496,0.596,0.696,0.797,0.898,1.,      &
      0.,0.097,0.195,0.293,0.392,0.492,0.592,0.693,0.794,0.897,1.,      &
      0.,0.095,0.190,0.287,0.385,0.484,0.584,0.686,0.789,0.894,1.,      &
      0.,0.090,0.182,0.276,0.372,0.470,0.570,0.672,0.778,0.887,1.,      &
      0.,0.084,0.171,0.259,0.351,0.446,0.545,0.649,0.758,0.875,1.,      &
      0.,0.077,0.157,0.239,0.325,0.415,0.511,0.614,0.728,0.855,1.,      &
      0.,0.071,0.145,0.220,0.300,0.384,0.476,0.578,0.694,0.832,1.,      &
      0.,0.067,0.135,0.206,0.280,0.358,0.444,0.542,0.658,0.802,1.,      &
      0.,0.064,0.129,0.195,0.264,0.337,0.416,0.504,0.610,0.751,1./
  DATA ((caib(6,i,j),j=1,11),i=1,9)/                                    &
      0.,0.099,0.198,0.298,0.397,0.497,0.597,0.698,0.798,0.899,1.,      &
      0.,0.098,0.196,0.295,0.394,0.494,0.594,0.695,0.796,0.898,1.,      &
      0.,0.096,0.193,0.290,0.389,0.488,0.588,0.690,0.792,0.896,1.,      &
      0.,0.093,0.187,0.282,0.379,0.478,0.578,0.680,0.784,0.891,1.,      &
      0.,0.088,0.177,0.268,0.362,0.460,0.559,0.663,0.770,0.882,1.,      &
      0.,0.081,0.164,0.250,0.340,0.433,0.531,0.636,0.747,0.868,1.,      &
      0.,0.074,0.151,0.231,0.314,0.402,0.497,0.600,0.716,0.846,1.,      &
      0.,0.069,0.140,0.214,0.291,0.372,0.462,0.561,0.675,0.815,1.,      &
      0.,0.065,0.132,0.200,0.271,0.346,0.427,0.517,0.624,0.764,1./
  DATA ((caib(7,i,j),j=1,11),i=1,9)/                                    &
      0.,0.099,0.199,0.298,0.398,0.498,0.598,0.698,0.798,0.899,1.,      &
      0.,0.098,0.197,0.296,0.396,0.496,0.596,0.696,0.797,0.898,1.,      &
      0.,0.097,0.195,0.293,0.392,0.492,0.592,0.693,0.794,0.897,1.,      &
      0.,0.094,0.190,0.287,0.384,0.484,0.584,0.686,0.789,0.894,1.,      &
      0.,0.090,0.182,0.276,0.372,0.470,0.570,0.673,0.779,0.888,1.,      &
      0.,0.084,0.171,0.260,0.353,0.448,0.548,0.652,0.761,0.877,1.,      &
      0.,0.078,0.158,0.241,0.328,0.419,0.516,0.620,0.733,0.858,1.,      &
      0.,0.072,0.145,0.222,0.302,0.386,0.478,0.578,0.692,0.827,1.,      &
      0.,0.067,0.135,0.206,0.278,0.355,0.438,0.530,0.637,0.775,1./
  DATA ((caib(8,i,j),j=1,11),i=1,9)/                                    &
      0.,0.100,0.199,0.299,0.399,0.498,0.599,0.699,0.799,0.900,1.,      &
      0.,0.099,0.198,0.298,0.397,0.497,0.597,0.698,0.798,0.899,1.,      &
      0.,0.098,0.196,0.295,0.395,0.494,0.594,0.695,0.796,0.898,1.,      &
      0.,0.096,0.193,0.291,0.390,0.489,0.589,0.690,0.793,0.896,1.,      &
      0.,0.093,0.188,0.283,0.380,0.479,0.579,0.682,0.786,0.892,1.,      &
      0.,0.088,0.178,0.270,0.365,0.462,0.562,0.665,0.772,0.884,1.,      &
      0.,0.082,0.165,0.252,0.341,0.434,0.532,0.636,0.747,0.867,1.,      &
      0.,0.074,0.151,0.230,0.313,0.400,0.492,0.593,0.706,0.837,1.,      &
      0.,0.069,0.139,0.211,0.286,0.364,0.448,0.541,0.649,0.786,1./
  DATA ((caib(9,i,j),j=1,11),i=1,9)/                                    &
      0.,0.100,0.200,0.299,0.399,0.499,0.599,0.700,0.800,0.900,1.,      &
      0.,0.100,0.199,0.299,0.399,0.498,0.599,0.699,0.799,0.900,1.,      &
      0.,0.099,0.198,0.298,0.397,0.497,0.597,0.698,0.798,0.899,1.,      &
      0.,0.098,0.196,0.295,0.394,0.494,0.594,0.695,0.796,0.898,1.,      &
      0.,0.096,0.192,0.290,0.388,0.487,0.588,0.689,0.791,0.895,1.,      &
      0.,0.092,0.185,0.280,0.376,0.474,0.574,0.676,0.781,0.889,1.,      &
      0.,0.086,0.173,0.262,0.354,0.449,0.547,0.650,0.759,0.875,1.,      &
      0.,0.078,0.157,0.239,0.324,0.412,0.506,0.607,0.719,0.846,1.,      &
      0.,0.071,0.143,0.217,0.293,0.373,0.459,0.552,0.660,0.796,1./
  DATA ((caib(10,i,j),j=1,11),i=1,9)/                                   &
      0.,0.100,0.200,0.300,0.400,0.500,0.600,0.700,0.800,0.900,1.,      &
      0.,0.100,0.200,0.300,0.400,0.500,0.600,0.700,0.800,0.900,1.,      &
      0.,0.100,0.200,0.300,0.400,0.500,0.600,0.700,0.800,0.900,1.,      &
      0.,0.100,0.200,0.299,0.399,0.499,0.599,0.699,0.799,0.900,1.,      &
      0.,0.099,0.198,0.297,0.396,0.496,0.595,0.696,0.796,0.898,1.,      &
      0.,0.096,0.192,0.289,0.387,0.485,0.585,0.686,0.788,0.893,1.,      &
      0.,0.090,0.181,0.273,0.366,0.462,0.560,0.662,0.769,0.881,1.,      &
      0.,0.082,0.164,0.248,0.335,0.424,0.519,0.620,0.730,0.854,1.,      &
      0.,0.073,0.147,0.223,0.301,0.382,0.468,0.563,0.671,0.805,1./
  DATA ((caib(11,i,j),j=1,11),i=1,9)/                                   &
      0.,0.100,0.200,0.300,0.400,0.500,0.600,0.700,0.800,0.900,1.,      &
      0.,0.100,0.200,0.300,0.400,0.500,0.600,0.700,0.800,0.900,1.,      &
      0.,0.100,0.200,0.300,0.400,0.500,0.600,0.700,0.800,0.900,1.,      &
      0.,0.100,0.200,0.300,0.400,0.500,0.600,0.700,0.800,0.900,1.,      &
      0.,0.100,0.200,0.300,0.400,0.500,0.600,0.700,0.800,0.900,1.,      &
      0.,0.100,0.200,0.299,0.398,0.496,0.595,0.695,0.795,0.897,1.,      &
      0.,0.096,0.190,0.284,0.378,0.474,0.572,0.674,0.778,0.886,1.,      &
      0.,0.086,0.171,0.257,0.345,0.436,0.531,0.632,0.740,0.861,1.,      &
      0.,0.076,0.152,0.229,0.308,0.390,0.478,0.573,0.681,0.813,1./
!
  DATA ((caif(i,j),j=1,11),i=1,9)/                                      &
      0.,0.099,0.198,0.298,0.397,0.497,0.597,0.698,0.798,0.899,1.,      &
      0.,0.098,0.196,0.295,0.395,0.495,0.595,0.695,0.796,0.898,1.,      &
      0.,0.096,0.193,0.291,0.390,0.489,0.589,0.690,0.793,0.896,1.,      &
      0.,0.093,0.187,0.283,0.380,0.479,0.580,0.681,0.786,0.892,1.,      &
      0.,0.087,0.177,0.268,0.363,0.460,0.561,0.665,0.772,0.884,1.,      &
      0.,0.079,0.160,0.246,0.335,0.430,0.529,0.635,0.747,0.869,1.,      &
      0.,0.068,0.141,0.217,0.298,0.385,0.481,0.586,0.704,0.840,1.,      &
      0.,0.059,0.120,0.185,0.256,0.333,0.419,0.518,0.637,0.789,1.,      &
      0.,0.051,0.104,0.160,0.219,0.284,0.357,0.443,0.551,0.707,1./
!
!-----------------------------------------------------------------------
!
!  The following DATA statements originally came from file
!  "cah.dat", which define pre-computed tables used for co2.
!
!-----------------------------------------------------------------------
!
  REAL :: cah(22,19)

  COMMON /radtab005/ cah

  DATA ((cah(i,j),i=1,22),j= 1, 5)/                                     &
      0.9923, 0.9922, 0.9921, 0.9920, 0.9916, 0.9910, 0.9899, 0.9882,   &
      0.9856, 0.9818, 0.9761, 0.9678, 0.9558, 0.9395, 0.9188, 0.8945,   &
      0.8675, 0.8376, 0.8029, 0.7621, 0.7154, 0.6647, 0.9876, 0.9876,   &
      0.9875, 0.9873, 0.9870, 0.9864, 0.9854, 0.9837, 0.9811, 0.9773,   &
      0.9718, 0.9636, 0.9518, 0.9358, 0.9153, 0.8913, 0.8647, 0.8350,   &
      0.8005, 0.7599, 0.7133, 0.6627, 0.9808, 0.9807, 0.9806, 0.9805,   &
      0.9802, 0.9796, 0.9786, 0.9769, 0.9744, 0.9707, 0.9653, 0.9573,   &
      0.9459, 0.9302, 0.9102, 0.8866, 0.8604, 0.8311, 0.7969, 0.7565,   &
      0.7101, 0.6596, 0.9708, 0.9708, 0.9707, 0.9705, 0.9702, 0.9697,   &
      0.9687, 0.9671, 0.9647, 0.9612, 0.9560, 0.9483, 0.9372, 0.9221,   &
      0.9027, 0.8798, 0.8542, 0.8253, 0.7916, 0.7515, 0.7054, 0.6551,   &
      0.9568, 0.9568, 0.9567, 0.9565, 0.9562, 0.9557, 0.9548, 0.9533,   &
      0.9510, 0.9477, 0.9428, 0.9355, 0.9250, 0.9106, 0.8921, 0.8700,   &
      0.8452, 0.8171, 0.7839, 0.7443, 0.6986, 0.6486/

  DATA ((cah(i,j),i=1,22),j= 6,10)/                                     &
      0.9377, 0.9377, 0.9376, 0.9375, 0.9372, 0.9367, 0.9359, 0.9345,   &
      0.9324, 0.9294, 0.9248, 0.9181, 0.9083, 0.8948, 0.8774, 0.8565,   &
      0.8328, 0.8055, 0.7731, 0.7342, 0.6890, 0.6395, 0.9126, 0.9126,   &
      0.9125, 0.9124, 0.9121, 0.9117, 0.9110, 0.9098, 0.9079, 0.9052,   &
      0.9012, 0.8951, 0.8862, 0.8739, 0.8579, 0.8385, 0.8161, 0.7900,   &
      0.7585, 0.7205, 0.6760, 0.6270, 0.8809, 0.8809, 0.8808, 0.8807,   &
      0.8805, 0.8802, 0.8796, 0.8786, 0.8770, 0.8747, 0.8712, 0.8659,   &
      0.8582, 0.8473, 0.8329, 0.8153, 0.7945, 0.7697, 0.7394, 0.7024,   &
      0.6588, 0.6105, 0.8427, 0.8427, 0.8427, 0.8426, 0.8424, 0.8422,   &
      0.8417, 0.8409, 0.8397, 0.8378, 0.8350, 0.8306, 0.8241, 0.8148,   &
      0.8023, 0.7866, 0.7676, 0.7444, 0.7154, 0.6796, 0.6370, 0.5897,   &
      0.7990, 0.7990, 0.7990, 0.7989, 0.7988, 0.7987, 0.7983, 0.7978,   &
      0.7969, 0.7955, 0.7933, 0.7899, 0.7846, 0.7769, 0.7664, 0.7528,   &
      0.7357, 0.7141, 0.6866, 0.6520, 0.6108, 0.5646/

  DATA ((cah(i,j),i=1,22),j=11,15)/                                     &
      0.7515, 0.7515, 0.7515, 0.7515, 0.7514, 0.7513, 0.7511, 0.7507,   &
      0.7501, 0.7491, 0.7476, 0.7450, 0.7409, 0.7347, 0.7261, 0.7144,   &
      0.6992, 0.6793, 0.6533, 0.6203, 0.5805, 0.5357, 0.7020, 0.7020,   &
      0.7020, 0.7019, 0.7019, 0.7018, 0.7017, 0.7015, 0.7011, 0.7005,   &
      0.6993, 0.6974, 0.6943, 0.6894, 0.6823, 0.6723, 0.6588, 0.6406,   &
      0.6161, 0.5847, 0.5466, 0.5034, 0.6518, 0.6518, 0.6518, 0.6518,   &
      0.6518, 0.6517, 0.6517, 0.6515, 0.6513, 0.6508, 0.6500, 0.6485,   &
      0.6459, 0.6419, 0.6359, 0.6273, 0.6151, 0.5983, 0.5755, 0.5458,   &
      0.5095, 0.4681, 0.6017, 0.6017, 0.6017, 0.6017, 0.6016, 0.6016,   &
      0.6016, 0.6015, 0.6013, 0.6009, 0.6002, 0.5989, 0.5967, 0.5932,   &
      0.5879, 0.5801, 0.5691, 0.5535, 0.5322, 0.5043, 0.4700, 0.4308,   &
      0.5518, 0.5518, 0.5518, 0.5518, 0.5518, 0.5518, 0.5517, 0.5516,   &
      0.5514, 0.5511, 0.5505, 0.5493, 0.5473, 0.5441, 0.5393, 0.5322,   &
      0.5220, 0.5076, 0.4878, 0.4617, 0.4297, 0.3929/

  DATA ((cah(i,j),i=1,22),j=16,19)/                                     &
      0.5031, 0.5031, 0.5031, 0.5031, 0.5031, 0.5030, 0.5030, 0.5029,   &
      0.5028, 0.5025, 0.5019, 0.5008, 0.4990, 0.4960, 0.4916, 0.4850,   &
      0.4757, 0.4624, 0.4441, 0.4201, 0.3904, 0.3564, 0.4565, 0.4565,   &
      0.4565, 0.4564, 0.4564, 0.4564, 0.4564, 0.4563, 0.4562, 0.4559,   &
      0.4553, 0.4544, 0.4527, 0.4500, 0.4460, 0.4400, 0.4315, 0.4194,   &
      0.4028, 0.3809, 0.3538, 0.3227, 0.4122, 0.4122, 0.4122, 0.4122,   &
      0.4122, 0.4122, 0.4122, 0.4121, 0.4120, 0.4117, 0.4112, 0.4104,   &
      0.4089, 0.4065, 0.4029, 0.3976, 0.3900, 0.3792, 0.3643, 0.3447,   &
      0.3203, 0.2923, 0.3696, 0.3696, 0.3696, 0.3696, 0.3696, 0.3696,   &
      0.3695, 0.3695, 0.3694, 0.3691, 0.3687, 0.3680, 0.3667, 0.3647,   &
      0.3615, 0.3570, 0.3504, 0.3409, 0.3279, 0.3106, 0.2892, 0.2642/
!
!-----------------------------------------------------------------------
!
!  End of RADDATA
!
!-----------------------------------------------------------------------
!

END BLOCK DATA raddata
radlib3d.F/     1298670057  19071 8000  100644  25359     `
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE COEFF                      ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE coeff(n,x,f,w,iop,INT,wk)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Formatted it in accordance with the ARPS coding standard.
!
!-----------------------------------------------------------------------
!
!
!-----------------------------------------------------------------------
!
!  Variable declarations
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

  INTEGER :: n
  INTEGER :: iop(2)

  REAL :: x(n),f(n),w(n),wk(n,4)

  INTEGER :: i
  INTEGER :: i1,i2, ii,ii1, in,INT
  INTEGER :: j0,j1,j2,j3,j4
  INTEGER :: jm,mk
  INTEGER :: ml,nn

  REAL :: a12,a13,a14,a23,a24,a34, b2,y2
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
  ii(i)=(i-1)*INT+1
  j0=1
  DO i=2,n
    jm=j0
    j0=j0+INT
    wk(i,1)=x(i)-x(i-1)
    wk(i,2)=(f(j0)-f(jm))/wk(i,1)
    wk(i,3)=wk(i,1)/6.
    wk(i,1)=wk(i,1)/3.
  END DO
  nn=n
  mk=iop(1)
  ml=iop(2)
!  GO TO (102,103,104,105) ,mk
!  obsolescent feature correction by WYH
  SELECT CASE (mk)
  CASE (1)
    GO TO 102
  CASE (2)
    GO TO 103
  CASE (3)
    GO TO 104
  CASE (4)
    GO TO 105
  CASE DEFAULT
!   Do nothing
  END SELECT
! end of correction by wyh.

  102 CONTINUE
  wk(2,2)=wk(3,2)-wk(2,2)-wk(2,3)*w(1)
  wk(2,3)=0.
  wk(2,1)=wk(2,1)+wk(3,1)
  i1=2
  nn=nn-1
  GO TO 106
  103 CONTINUE
  wk(1,2)=wk(2,2)-w(1)
  wk(2,2)=wk(3,2)-wk(2,2)
  wk(1,3)=0.
  wk(1,1)=wk(2,1)
  wk(2,1)=wk(2,1)+wk(3,1)
  i1=1
  GO TO 106
  104 CONTINUE
  y2=wk(2,2)
  b2=wk(2,1)
  wk(2,2)=wk(3,2)-wk(2,2)
  wk(2,1)=wk(3,1)+wk(2,1)
  i1=2
  nn=nn-1
  GO TO 106
  105 CONTINUE
  a12=x(1)-x(2)
  a13=x(1)-x(3)
  a14=x(1)-x(4)
  a23=x(2)-x(3)
  a24=x(2)-x(4)
  a34=x(3)-x(4)
  j1=1
  j2=j1+INT
  j3=j2+INT
  j4=j3+INT
  w(1)=(1./a12+1./a13+1./a14)*f(j1)-                                    &
       a13*a14/(a12*a23*a24)*f(j2)+a12*a14/(a13*a23*a34)*f(j3)-         &
       a12*a13/(a14*a24*a34)*f(j4)
  GO TO 103
  106 CONTINUE
  i2=n-2
  DO i=3,i2
    wk(i,2)=wk(i+1,2)-wk(i,2)
    wk(i,1)=wk(i+1,1)+wk(i,1)
  END DO
  in=ii(n)
!  GO TO (108,109,110,111) ,ml
!  obsolescent feature correction by WYH
  SELECT CASE (ml)
  CASE (1)
    GO TO 108
  CASE (2)
    GO TO 109
  CASE (3)
    GO TO 110
  CASE (4)
    GO TO 111
  CASE DEFAULT
!   Do nothing
  END SELECT
! end of correction by WYH

  108 CONTINUE
  wk(n-1,2)=wk(n,2)-wk(n-1,2)-wk(n,3)*w(in)
  wk(n,3)=0.
  wk(n-1,1)=wk(n-1,1)+wk(n,1)
  nn=nn-1
  GO TO 112
  109 CONTINUE
  wk(n-1,2)=wk(n,2)-wk(n-1,2)
  wk(n,2)=-wk(n,2)+w(in)
  wk(n-1,1)=wk(n-1,1)+wk(n,1)
  wk(1,4)=0.
  GO TO 112
  110 CONTINUE
  wk(n-1,2)=wk(n,2)-wk(n-1,2)
  wk(n,2)=y2-wk(n,2)
  wk(n-1,1)=wk(n-1,1)+wk(n,1)
  wk(n,1)=wk(n,1)+b2
  wk(1,4)=wk(2,3)
  GO TO 112
  111 CONTINUE
  a12=x(n)-x(n-1)
  a13=x(n)-x(n-2)
  a14=x(n)-x(n-3)
  a23=x(n-1)-x(n-2)
  a24=x(n-1)-x(n-3)
  a34=x(n-2)-x(n-3)
  j1=in
  j2=j1-INT
  j3=j2-INT
  j4=j3-INT
  w(in)=(1./a12+1./a13+1./a14)*f(j1)-                                   &
        a13*a14/(a12*a23*a24)*f(j2)+a12*a14/(a13*a23*a34)*f(j3)-        &
        a12*a13/(a14*a24*a34)*f(j4)
  GO TO 109
  112 CONTINUE
  ii1=ii(i1)
  CALL trip (nn,wk(i1,3),wk(i1,1),wk(i1+1,3),wk(i1,2),w(ii1),INT)
!  GO TO (114,114,113,114) ,mk
!  obsolescent feature correction by WYH
  SELECT CASE (mk)
  CASE (1,2,4)
    GO TO 114
  CASE (3)
    GO TO 113
  CASE DEFAULT
!   Do nothing
  END SELECT
! end of correction by wyh

  113 CONTINUE
  w(1)=w(in)
  114 CONTINUE

  RETURN
END SUBROUTINE coeff
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE TERP1                      ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE terp1(n,x,f,w,y,INT,tab,itab)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Formatted it in accordance with the ARPS coding standard.
!
!-----------------------------------------------------------------------
!
!fpp$ expand (search)
!fpp$ expand (interp)
!!dir$ inline always interp, search
!*$*  inline routine (interp, search)
!
!-----------------------------------------------------------------------
!
!  Variable declarations
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

  INTEGER :: n
  INTEGER :: INT
  INTEGER :: itab(3)

  REAL :: x(n),f(n),w(n),tab(3)

  INTEGER :: i
  REAL :: y
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
  CALL search (y,x,n,i)
  CALL interp (n,x,f,w,y,i,INT,tab,itab)

  RETURN
END SUBROUTINE terp1
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE TRIP                       ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE trip(n,a,b,c,y,z,INT)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Formatted it in accordance with the ARPS coding standard.
!
!-----------------------------------------------------------------------
!
!  Variable declarations
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

  INTEGER :: n

  REAL :: a(n),b(n),c(n),y(n),z(n)

  INTEGER :: INT

  INTEGER :: ii, ik, in, inm
  INTEGER :: i,j,k
  INTEGER :: nm1, nm2

  REAL :: bn, yn, v, den
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
  ii(i)=(i-1)*INT+1
  bn=b(n)
  yn=y(n)
  v=c(n)
  y(1)=y(1)/b(1)
  a(1)=a(1)/b(1)
  b(1)=c(1)/b(1)
  nm2=n-2
  DO j=2,nm2
    den=b(j)-a(j)*b(j-1)
    b(j)=c(j)/den
    y(j)=(y(j)-a(j)*y(j-1))/den
    a(j)=-a(j)*a(j-1)/den
    bn=bn-v*a(j-1)
    yn=yn-v*y(j-1)
    v=-v*b(j-1)
  END DO
  den=b(n-1)-a(n-1)*b(n-2)
  b(n-1)=(c(n-1)-a(n-1)*a(n-2))/den
  y(n-1)=(y(n-1)-a(n-1)*y(n-2))/den
  bn=bn-v*a(n-2)
  yn=yn-v*y(n-2)
  v=a(n)-v*b(n-2)
  nm1=n-1
  in=ii(n)
  inm=ii(nm1)
  z(in)=(yn-v*y(nm1))/(bn-v*b(nm1))
  z(inm)=y(nm1)-b(nm1)*z(in)
  DO j=2,nm1
    k=n-j
    ik=ii(k)
    z(ik)=y(k)-b(k)*z(ik+INT)-a(k)*z(in)
  END DO

  RETURN
END SUBROUTINE trip
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE SEARCH                     ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE search(xbar,x,n,i)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Formatted it in accordance with the ARPS coding standard.
!
!-----------------------------------------------------------------------
!
!  Variable declarations
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

  INTEGER :: i,n

  REAL :: x(n)
  REAL :: xbar

  INTEGER :: k,m,nm1

  REAL :: b
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
  b = .69314718

  IF(xbar > x(2)) GO TO 101
  i=1
  RETURN

  101 CONTINUE
  IF(xbar < x(n-1)) GO TO 102
  i=n-1
  RETURN

  102 CONTINUE
  m=INT((ALOG(FLOAT(n)))/b)
  i=2**m
  IF(i >= n) i=i/2
  k=i
  nm1=n-1
  103 CONTINUE
  k=k/2
  IF(xbar >= x(i)) GO TO 104
  i=i-k
  GO TO 103
  104 CONTINUE
  IF(xbar <= x(i+1)) RETURN
  i=MIN0(i+k,nm1)
  GO TO 103

END SUBROUTINE search
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE INTERP                     ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE interp(n,x,f,w,y,i,INT,tab,itab)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Formatted it in accordance with the ARPS coding standard.
!
!-----------------------------------------------------------------------
!
!  Variable declarations
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

  INTEGER :: n
  INTEGER :: i, i0, ii, INT, ip

  INTEGER :: itab(3)
  REAL :: x(n),f(n),w(n),tab(3)
  REAL :: a,b,c, fl0,flk,flp, y
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
  ii(i)=(i-1)*INT+1
  flk=x(i+1)-x(i)
  flp=x(i+1)-y
  fl0=y-x(i)
  i0=ii(i)
  ip=i0+INT
  IF(itab(1) /= 1) GO TO 102
  a=(w(i0)*flp**3+w(ip)*fl0**3)/(6.*flk)
  b=(f(ip)/flk-w(ip)*flk/6.)*fl0
  c=(f(i0)/flk-w(i0)*flk/6.)*flp
  tab(1)=a+b+c
  102 IF(itab(2) /= 1) GO TO 104
  a=(w(ip)*fl0**2-w(i0)*flp**2)/(2.*flk)
  b=(f(ip)-f(i0))/flk
  c=(w(i0)-w(ip))*flk/6.
  tab(2)=a+b+c
  104 IF(itab(3) /= 1) GO TO 106
  tab(3)=(w(i0)*flp+w(ip)*fl0)/flk

  106 RETURN
END SUBROUTINE interp
!
!##################################################################
!##################################################################
!######                                                      ######
!######                FUNCTION EXPMN                        ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

  FUNCTION expmn(fin)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Calculate exponential for arguments in the range 0> fin > -10.
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Adopted the original code and formatted it in accordance with the
!  ARPS coding standard.
!
!-----------------------------------------------------------------------
!
!  ORIGINAL COMMENTS:
!
!**************************************************************************
! compute exponential for arguments in the range 0> fin > -10.
!
!-----------------------------------------------------------------------
!
!  Variable declarations
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

  REAL :: one, expmin
  PARAMETER (one=1.0, expmin=-10.0)

  REAL :: e1,e2,e3,e4
  PARAMETER (e1=1.0,        e2=-2.507213E-1)
  PARAMETER (e3=2.92732E-2, e4=-3.827800E-3)

  REAL :: fin, tmp
  REAL :: expmn
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
  tmp = MAX( fin, expmin )
  expmn = ((e4*tmp + e3)*tmp+e2)*tmp+e1
  expmn = expmn * expmn
  expmn = one / (expmn * expmn)

  RETURN
  END FUNCTION expmn
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE DELEDD                     ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE deledd(tau,ssc,g0,csm,rr,tt,td)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Calculate the bulk scattering properties of a single layer using
!  delta-eddington approximation.
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Formatted it in accordance with the ARPS coding standard.
!
!-----------------------------------------------------------------------
!
!  ORIGINAL COMMENTS:
!
!*********************************************************************
!
!-----uses the delta-eddington approximation to compute the
!  bulk scattering properties of a single layer
!  coded following King and Harshvardhan (JAS, 1986)
!
!  inputs:
!
!  tau: the effective optical thickness
!  ssc: the effective single scattering albedo
!  g0:  the effective asymmetry factor
!  csm: the effective secant of the zenith angle
!
!  outputs:
!
!  rr: the layer reflection of the direct beam
!  tt: the layer diffuse transmission of the direct beam
!  td: the layer direct transmission of the direct beam
!
!*********************************************************************
!fpp$ expand (expmn)
!!dir$ inline always expmn
!*$*  inline routine (expmn)
!*********************************************************************
!
!-----------------------------------------------------------------------
!
!  Variable Declarations.
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

  REAL :: zero,one,two,three,four,fourth,seven,thresh
  PARAMETER (one =1., three=3.)
  PARAMETER (two =2., seven=7.)
  PARAMETER (four=4., fourth=.25)
  PARAMETER (zero=0., thresh=1.e-8)

!-----input parameters
  REAL :: tau,ssc,g0,csm

!-----output parameters
  REAL :: rr,tt,td

!-----temporary parameters

  REAL :: zth,ff,xx,taup,sscp,gp,gm1,gm2,gm3,akk,alf1,alf2,             &
       all,bll,st7,st8,cll,dll,fll,ell,st1,st2,st3,st4

  REAL, EXTERNAL :: expmn

!---------------------------------------------------------------------
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
  zth = one / csm

!  delta-eddington scaling of single scattering albedo,
!  optical thickness, and asymmetry factor,
!  K & H eqs(27-29)

  ff  = g0*g0
  xx  = one-ff*ssc
  taup= tau*xx
  sscp= ssc*(one-ff)/xx
  gp  = g0/(one+g0)

!  gamma1, gamma2, and gamma3. see table 2 and eq(26) K & H
!  ssc and gp are the d-s single scattering
!  albedo and asymmetry factor.

  xx  =  three*gp
  gm1 =  (seven - sscp*(four+xx))*fourth
  gm2 = -(one   - sscp*(four-xx))*fourth

!  akk is k as defined in eq(25) of K & H

  akk = SQRT((gm1+gm2)*(gm1-gm2))

  xx  = akk * zth
  st7 = one - xx
  st8 = one + xx
  st3 = st7 * st8

  IF (ABS(st3) < thresh) THEN
    zth = zth + 0.001
    xx  = akk * zth
    st7 = one - xx
    st8 = one + xx
    st3 = st7 * st8
  END IF

!  extinction of the direct beam transmission

!wdt
  !td  = EXP(-taup/zth)
  td  = expmn(-taup/zth)  ! faster, but less accurate for long integrations

!  alf1 and alf2 are alpha1 and alpha2 from eqs (23) & (24) of K & H

  gm3  = (two - zth*three*gp)*fourth
  xx   = gm1 - gm2
  alf1 = gm1 - gm3 * xx
  alf2 = gm2 + gm3 * xx

!  all is last term in eq(21) of K & H
!  bll is last term in eq(22) of K & H

  xx  = akk * two
  all = (gm3 - alf2 * zth    )*xx*td
  bll = (one - gm3 + alf1*zth)*xx

  xx  = akk * gm3
  cll = (alf2 + xx) * st7
  dll = (alf2 - xx) * st8

  xx  = akk * (one-gm3)
  fll = (alf1 + xx) * st8
  ell = (alf1 - xx) * st7

!wdt
  !st2 = EXP(-akk*taup)
  st2 = expmn(-akk*taup)  ! faster, but less accurate for long integrations
  st4 = st2 * st2

  st1 =  sscp / ((akk+gm1 + (akk-gm1)*st4) * st3)

!  rr is r-hat of eq(21) of K & H
!  tt is diffuse part of t-hat of eq(22) of K & H

  rr =   ( cll-dll*st4    -all*st2)*st1
  tt = - ((fll-ell*st4)*td-bll*st2)*st1

  rr = MAX(rr,zero)
  tt = MAX(tt,zero)

  RETURN
END SUBROUTINE deledd
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE SAGPOL                     ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE sagpol(tau,ssc,g0,rll,tll)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Calculate transmittance and reflectance of diffuse radiation.
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Formatted it in accordance with the ARPS coding standard.
!
!-----------------------------------------------------------------------
!
!  ORIGINAL COMMENTS:
!
!*********************************************************************
!-----transmittance (tll) and reflectance (rll) of diffuse radiation
!  follows Sagan and Pollock (JGR, 1967).
!  also, eq.(31) of Lacis and Hansen (JAS, 1974).
!
!-----input parameters:
!
!   tau: the effective optical thickness
!   ssc: the effective single scattering albedo
!   g0:  the effective asymmetry factor
!
!-----output parameters:
!
!   rll: the layer reflection of diffuse radiation
!   tll: the layer transmission of diffuse radiation
!
!*********************************************************************
!fpp$ expand (expmn)
!!dir$ inline always expmn
!*$*  inline routine (expmn)
!
!-----------------------------------------------------------------------
!
!  Variable Declarations.
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

  REAL :: one,three,four
  PARAMETER (one=1., three=3., four=4.)

!-----output parameters:

  REAL :: tau,ssc,g0

!-----output parameters:

  REAL :: rll,tll

!-----temporary arrays

  REAL :: xx,uuu,ttt,emt,up1,um1,st1

!-----function

  REAL :: expmn
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
  xx  = one-ssc*g0
  uuu = SQRT( xx/(one-ssc))
  ttt = SQRT( xx*(one-ssc)*three )*tau
  emt = expmn(-ttt)
  up1 = uuu + one
  um1 = uuu - one
  xx  = um1*emt
  st1 = one / ((up1+xx) * (up1-xx))
  rll = up1*um1*(one-emt*emt)*st1
  tll = uuu*four*emt         *st1

  RETURN
END SUBROUTINE sagpol

irrad3d.F/      1298670057  19071 8000  100644  58575     `
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE IRRAD                      ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE irrad(idim,jdim,m,n,np,                                      &
           taucl,ccld,pl,ta,wa,oa,co2,ts,                               &
           high,radlwin,flx,flc,dfdts,st4,                              &
           fclr,dbs,trant,th2o,tcon,tco2,                               &
           pa,dt,sh2o,swpre,swtem,sco3,scopre,scotem,                   &
           dh2o,dcont,dco2,do3,flxu,flxd,clr,blayer,                    &
           h2oexp,conexp,co2exp)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Calculate IR fluxes due to water vapor, co2, and o3. Clouds in
!  different layers are assumed randomly overlapped.
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Adopted the original code and formatted it in accordance with the
!  ARPS coding standard.
!
!-----------------------------------------------------------------------
!
!  ORIGINAL COMMENTS:
!
!******************** CLIRAD IR1  Date: Oct. 17, 1994 ****************
!*********************************************************************
!
! This routine computes ir fluxes due to water vapor, co2, and o3.
!   Clouds in different layers are assumed randomly overlapped.
!
! This is a vectorized code.  It computes fluxes simultaneously for
!   (m x n) soundings, which is a subset of (m x ndim) soundings.
!   In a global climate model, m and ndim correspond to the numbers of
!   grid boxes in the zonal and meridional directions, respectively.
!
! Detailed description of the radiation routine is given in
!   Chou and Suarez (1994).
!
! There are two options for computing cooling rate profiles.
!
!   if high = .true., transmission functions in the co2, o3, and the
!   three water vapor bands with strong absorption are computed using
!   table look-up.  cooling rates are computed accurately from the
!   surface up to 0.01 mb.
!   if high = .false., transmission functions are computed using the
!   k-distribution method with linear pressure scaling.  cooling rates
!   are not calculated accurately for pressures less than 20 mb.
!   the computation is faster with high=.false. than with high=.true.
!
! The IR spectrum is divided into eight bands:
!
!   bnad     wavenumber (/cm)   absorber         method
!
!    1           0 - 340           h2o            K/T
!    2         340 - 540           h2o            K/T
!    3         540 - 800       h2o,cont,co2       K,S,K/T
!    4         800 - 980       h2o,cont           K,S
!    5         980 - 1100      h2o,cont,o3        K,S,T
!    6        1100 - 1380      h2o,cont           K,S
!    7        1380 - 1900          h2o            K/T
!    8        1900 - 3000          h2o            K
!
! Note : "h2o" for h2o line absorption
!     "cont" for h2o continuum absorption
!     "K" for k-distribution method
!     "S" for one-parameter temperature scaling
!     "T" for table look-up
!
! The 15 micrometer region (540-800/cm) is further divided into
!   3 sub-bands :
!
!   subbnad   wavenumber (/cm)
!
!    1          540 - 620
!    2          620 - 720
!    3          720 - 800
!
!---- Input parameters                               units    size
!
!   number of soundings in zonal direction (m)        n/d      1
!   number of soundings in meridional direction (n)   n/d      1
!   maximum number of soundings in
!              meridional direction (ndim)         n/d      1
!   number of atmospheric layers (np)                 n/d      1
!   cloud optical thickness (taucl)                   n/d     m*ndim*np
!   cloud cover (ccld)                              fraction  m*ndim*np
!   level pressure (pl)                               mb      m*ndim*(np+1)
!   layer temperature (ta)                            k       m*ndim*np
!   layer specific humidity (wa)                      g/g     m*ndim*np
!   layer ozone mixing ratio by mass (oa)             g/g     m*ndim*np
!   surface temperature (ts)                          k       m*ndim
!   co2 mixing ratio by volumn (co2)                  pppv     1
!   high                                                       1
!
! pre-computed tables used in table look-up for transmittance calculations:
!
!   c1 , c2, c3: for co2 (band 3)
!   o1 , o2, o3: for  o3 (band 5)
!   h11,h12,h13: for h2o (band 1)
!   h21,h22,h23: for h2o (band 2)
!   h71,h72,h73: for h2o (band 7)
!
!---- output parameters
!
!   net downward flux, all-sky   (flx)             w/m**2     m*ndim*(np+1)
!   net downward flux, clear-sky (flc)             w/m**2     m*ndim*(np+1)
!   sensitivity of net downward flux
!    to surface temperature (dfdts)             w/m**2/k   m*ndim*(np+1)
!   emission by the surface (st4)                  w/m**2     m*ndim
!
! Notes:
!
!   (1)  Water vapor continuum absorption is included in 540-1380 /cm.
!   (2)  Scattering by clouds is not included.
!   (3)  Clouds are assumed "gray" bodies.
!   (4)  The diffuse cloud transmission is computed to be exp(-1.66*taucl).
!   (5)  If there are no clouds, flx=flc.
!   (6)  plevel(1) is the pressure at the top of the model atmosphere, and
!     plevel(np+1) is the surface pressure.
!
!    ARPS note: pl was replaced by pa at scalar points (layers)
!
!   (7)  Downward flux is positive, and upward flux is negative.
!   (8)  dfdts is always negative because upward flux is defined as negative.
!   (9)  For questions and coding errors, please contact with Ming-Dah Chou,
!     Code 913, NASA/Goddard Space Flight Center, Greenbelt, MD 20771.
!     Phone: 301-286-4012, Fax: 301-286-1759,
!     e-mail: chou@climate.gsfc.nasa.gov
!
!-----parameters defining the size of the pre-computed tables for transmittance
!  calculations using table look-up.
!
!  "nx" is the number of intervals in pressure
!  "no" is the number of intervals in o3 amount
!  "nc" is the number of intervals in co2 amount
!  "nh" is the number of intervals in h2o amount
!  "nt" is the number of copies to be made from the pre-computed
!       transmittance tables to reduce "memory-bank conflict"
!       in parallel machines and, hence, enhancing the speed of
!       computations using table look-up.
!       If such advantage does not exist, "nt" can be set to 1.
!***************************************************************************
!
!fpp$ expand (expmn)
!!dir$ inline always expmn
!*$*  inline routine (expmn)
!
!-----------------------------------------------------------------------
!

!
!-----------------------------------------------------------------------
!
!  Variable Declarations.
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE
  INTEGER :: idim,jdim

!!!  INTEGER :: nx,no,nc,nh,nt,m,n,np
  INTEGER :: m,n,np
  INTEGER :: i,j,k,ip,iw,it,ib,ik,iq,isb,k1,k2
!!!  PARAMETER (nx=26,no=21,nc=24,nh=31,nt=7)

!---- input parameters ------

  REAL :: taucl(idim,jdim,np)
  REAL :: ccld(idim,jdim,np)
  REAL :: pl(idim,jdim,np+1)
  REAL :: ta(idim,jdim,np)
  REAL :: wa(idim,jdim,np)
  REAL :: oa(idim,jdim,np)
  REAL :: ts(idim,jdim)
  REAL :: co2

  LOGICAL :: high

!---- output parameters ------

  REAL :: radlwin(idim,jdim) 
  REAL :: flx(idim,jdim,np+1)
  REAL :: flc(idim,jdim,np+1)
  REAL :: dfdts(idim,jdim,np+1)
  REAL :: st4(idim,jdim)
!
!-----------------------------------------------------------------------
!
!  Temporary arrays
!
!-----------------------------------------------------------------------
!
  REAL :: fclr(m,n)
  REAL :: dbs(m,n)
  REAL :: trant(m,n)
  REAL :: th2o(m,n,6)
  REAL :: tcon(m,n,3)
  REAL :: tco2(m,n,6,2)

  REAL :: pa(m,n,np)
  REAL :: dt(m,n,np)
  REAL :: sh2o(m,n,np+1)
  REAL :: swpre(m,n,np+1)
  REAL :: swtem(m,n,np+1)
  REAL :: sco3(m,n,np+1)
  REAL :: scopre(m,n,np+1)
  REAL :: scotem(m,n,np+1)
  REAL :: dh2o(m,n,np)
  REAL :: dcont(m,n,np)
  REAL :: dco2(m,n,np)
  REAL :: do3(m,n,np)
  REAL :: flxu(m,n,np+1)
  REAL :: flxd(m,n,np+1)
  REAL :: clr(m,n,0:np+1)
  REAL :: blayer(m,n,0:np+1)

  REAL :: h2oexp(m,n,np,6)
  REAL :: conexp(m,n,np,3)

  REAL :: co2exp(m,n,np,6,2)
!
!-----------------------------------------------------------------------
!
!  Misc. local variables
!
!-----------------------------------------------------------------------
!
  LOGICAL :: oznbnd
  LOGICAL :: co2bnd
  LOGICAL :: h2otbl
  LOGICAL :: conbnd

!!!  REAL :: c1 (nx,nc,nt),c2 (nx,nc,nt),c3 (nx,nc,nt)
!!!  REAL :: o1 (nx,no,nt),o2 (nx,no,nt),o3 (nx,no,nt)
!!!  REAL :: h11(nx,nh,nt),h12(nx,nh,nt),h13(nx,nh,nt)
!!!  REAL :: h21(nx,nh,nt),h22(nx,nh,nt),h23(nx,nh,nt)
!!!  REAL :: h71(nx,nh,nt),h72(nx,nh,nt),h73(nx,nh,nt)
  include 'irrad.incl'

  REAL :: xx, w1,p1,dwe,dpe

!---- static data -----

  REAL :: cb(5,8)

!-----the following coefficients (table 2 of chou and suarez, 1995)
!  are for computing spectrally integtrated planck fluxes of
!  the 8 bands using eq. (22)

  DATA cb/                                                              &
      -2.6844E-1,-8.8994E-2, 1.5676E-3,-2.9349E-6, 2.2233E-9,           &
      3.7315E+1,-7.4758E-1, 4.6151E-3,-6.3260E-6, 3.5647E-9,            &
      3.7187E+1,-3.9085E-1,-6.1072E-4, 1.4534E-5,-1.6863E-8,            &
      -4.1928E+1, 1.0027E+0,-8.5789E-3, 2.9199E-5,-2.5654E-8,           &
      -4.9163E+1, 9.8457E-1,-7.0968E-3, 2.0478E-5,-1.5514E-8,           &
      -1.0345E+2, 1.8636E+0,-1.1753E-2, 2.7864E-5,-1.1998E-8,           &
      -6.9233E+0,-1.5878E-1, 3.9160E-3,-2.4496E-5, 4.9301E-8,           &
      1.1483E+2,-2.2376E+0, 1.6394E-2,-5.3672E-5, 6.6456E-8/

!-----copy tables to enhance the speed of co2 (band 3), o3 (band5),
!  and h2o (bands 1, 2, and 7 only) transmission calculations
!  using table look-up.

!!!  LOGICAL :: first
!!!  SAVE first
!!!  DATA first /.true./
!
!-----------------------------------------------------------------------
!
!  Functions:
!
!-----------------------------------------------------------------------
!
  REAL :: expmn
!
!-----------------------------------------------------------------------
!
!  Include files:
!
!-----------------------------------------------------------------------
!
!  include "h2o.tran3"
!  include "co2.tran3"
!  include "o3.tran3"

!!!  COMMON /radtab001/ h11,h12,h13,h21,h22,h23,h71,h72,h73
!!!  COMMON /radtab002/ c1,c2,c3
!!!  COMMON /radtab003/ o1,o2,o3
!
!-----------------------------------------------------------------------
!
!  Save variables:
!
!-----------------------------------------------------------------------
!
!  save c1,c2,c3,o1,o2,o3
!  save h11,h12,h13,h21,h22,h23,h71,h72,h73
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!----- moved this section of code to new initrad subroutine -----!

!-----compute layer pressure (pa) and layer temperature minus 250K (dt)

  DO k=1,np
    DO j=1,n
      DO i=1,m
        dt(i,j,k)=ta(i,j,k)-250.0
!!!     GHB, 101129:  pa is now given directly through radtrans3d
!!!        pa(i,j,k)=0.5*(pl(i,j,k)+pl(i,j,k+1))
!!!        print *,'  old,new,error:',k,0.5*(pl(i,j,k)+pl(i,j,k+1)),pa(i,j,k),   &
!!!                                     0.5*(pl(i,j,k)+pl(i,j,k+1))-pa(i,j,k)
      END DO
    END DO
  END DO

!-----compute layer absorber amount

!  dh2o : water vapor amount (g/cm**2)
!  dcont: scaled water vapor amount for continuum absorption (g/cm**2)
!  dco2 : co2 amount (cm-atm)stp
!  do3  : o3 amount (cm-atm)stp
!  the factor 1.02 is equal to 1000/980
!  factors 789 and 476 are for unit conversion
!  the factor 0.001618 is equal to 1.02/(.622*1013.25)
!  the factor 6.081 is equal to 1800/296

  DO k=1,np
    DO j=1,n
      DO i=1,m
        dh2o(i,j,k) = 1.02*wa(i,j,k)*(pl(i,j,k+1)-pl(i,j,k))+1.e-10
        dco2(i,j,k) = 789.*co2*(pl(i,j,k+1)-pl(i,j,k))+1.e-10
        do3 (i,j,k) = 476.0*oa(i,j,k)*(pl(i,j,k+1)-pl(i,j,k))+1.e-10

!-----compute scaled water vapor amount for h2o continuum absorption
!  following eq. (43).

        xx=pa(i,j,k)*0.001618*wa(i,j,k)*wa(i,j,k)                       &
            *(pl(i,j,k+1)-pl(i,j,k))
        dcont(i,j,k) = xx*expmn(1800./ta(i,j,k)-6.081)+1.e-10

!-----compute effective cloud-free fraction, clr, for each layer.
!  the cloud diffuse transmittance is approximated by using a
!  diffusivity factor of 1.66.

        clr(i,j,k)=1.0-(ccld(i,j,k)*(1.-expmn(-1.66*taucl(i,j,k))))

      END DO
    END DO
  END DO

!-----compute column-integrated h2o amoumt, h2o-weighted pressure
!  and temperature.  it follows eqs. (37) and (38).

  IF (high) THEN

    CALL column(m,n,np,pa,dt,dh2o,sh2o,swpre,swtem)

  END IF

!-----the surface (with an index np+1) is treated as a layer filled with
!  black clouds.

  DO j=1,n
    DO i=1,m
      clr(i,j,0)    = 1.0
      clr(i,j,np+1) = 0.0
      st4(i,j)      = 0.0
    END DO
  END DO

!-----initialize fluxes

  DO k=1,np+1
    DO j=1,n
      DO i=1,m
        flx(i,j,k)  = 0.0
        flc(i,j,k)  = 0.0
        dfdts(i,j,k)= 0.0
        flxu(i,j,k) = 0.0
        flxd(i,j,k) = 0.0
      END DO
    END DO
  END DO

!-----integration over spectral bands

  DO ib=1,8

!-----if h2otbl, compute h2o (line) transmittance using table look-up.
!  if conbnd, compute h2o (continuum) transmittance in bands 3, 4, 5 and 6.
!  if co2bnd, compute co2 transmittance in band 3.
!  if oznbnd, compute  o3 transmittance in band 5.

    h2otbl=high.AND.(ib == 1.OR.ib == 2.OR.ib == 7)
    conbnd=ib >= 3.AND.ib <= 6
    co2bnd=ib == 3
    oznbnd=ib == 5

!-----blayer is the spectrally integrated planck flux of the mean layer
!  temperature derived from eq. (22)
!  the fitting for the planck flux is valid in the range 160-345 K.

    DO k=1,np
      DO j=1,n
        DO i=1,m
          blayer(i,j,k)=ta(i,j,k)*(ta(i,j,k)*(ta(i,j,k)                 &
                       *(ta(i,j,k)*cb(5,ib)+cb(4,ib))+cb(3,ib))         &
                       +cb(2,ib))+cb(1,ib)
        END DO
      END DO
    END DO

!-----the earth's surface, with an index "np+1", is treated as a layer

    DO j=1,n
      DO i=1,m
        blayer(i,j,0)   = 0.0
        blayer(i,j,np+1)=ts(i,j)*(ts(i,j)*(ts(i,j)                      &
                        *(ts(i,j)*cb(5,ib)+cb(4,ib))+cb(3,ib))          &
                        +cb(2,ib))+cb(1,ib)

!-----dbs is the derivative of the surface planck flux with respect to
!  surface temperature (eq. 59).

        dbs(i,j)=ts(i,j)*(ts(i,j)*(ts(i,j)                              &
                *4.*cb(5,ib)+3.*cb(4,ib))+2.*cb(3,ib))+cb(2,ib)

      END DO
    END DO

!-----compute column-integrated absorber amoumt, absorber-weighted
!  pressure and temperature for co2 (band 3) and o3 (band 5).
!  it follows eqs. (37) and (38).

!-----this is in the band loop to save storage

    IF( high .AND. co2bnd) THEN

      CALL column(m,n,np,pa,dt,dco2,sco3,scopre,scotem)

    END IF

    IF(oznbnd) THEN

      CALL column(m,n,np,pa,dt,do3,sco3,scopre,scotem)

    END IF

!-----compute the exponential terms (eq. 32) at each layer for
!  water vapor line absorption when k-distribution is used

    IF( .NOT. h2otbl) THEN

      CALL h2oexps(ib,m,n,np,dh2o,pa,dt,h2oexp)

    END IF

!-----compute the exponential terms (eq. 46) at each layer for
!  water vapor continuum absorption

    IF( conbnd) THEN

      CALL conexps(ib,m,n,np,dcont,conexp)

    END IF


!-----compute the  exponential terms (eq. 32) at each layer for
!  co2 absorption

    IF( .NOT.high .AND. co2bnd) THEN

      CALL co2exps(m,n,np,dco2,pa,dt,co2exp)

    END IF

!-----compute transmittances for regions between levels k1 and k2
!  and update the fluxes at the two levels.

    DO k1=1,np

!-----initialize fclr, th2o, tcon, and tco2

      DO j=1,n
        DO i=1,m
          fclr(i,j)=1.0
        END DO
      END DO

!-----for h2o line absorption

      IF(.NOT. h2otbl) THEN
        DO ik=1,6
          DO j=1,n
            DO i=1,m
              th2o(i,j,ik)=1.0
            END DO
          END DO
        END DO
      END IF

!-----for h2o continuum absorption

      IF (conbnd) THEN
        DO iq=1,3
          DO j=1,n
            DO i=1,m
              tcon(i,j,iq)=1.0
            END DO
          END DO
        END DO
      END IF

!-----for co2 absorption when using k-distribution method.
!  band 3 is divided into 3 sub-bands, but sub-bands 3a and 3c
!  are combined in computing the co2 transmittance.

      IF (.NOT. high .AND. co2bnd) THEN
        DO isb=1,2
          DO ik=1,6
            DO j=1,n
              DO i=1,m
                tco2(i,j,ik,isb)=1.0
              END DO
            END DO
          END DO
        END DO
      END IF

!-----loop over the bottom level of the region (k2)

      DO k2=k1+1,np+1

        DO j=1,n
          DO i=1,m
            trant(i,j)=1.0
          END DO
        END DO

        IF(h2otbl) THEN

          w1=-8.0
          p1=-2.0
          dwe=0.3
          dpe=0.2

!-----compute water vapor transmittance using table look-up

          IF (ib == 1 ) THEN

            CALL tablup(k1,k2,m,n,np,nx,nh,nt,sh2o,swpre,swtem,         &
                        w1,p1,dwe,dpe,h11,h12,h13,trant)

          END IF
          IF (ib == 2 ) THEN

            CALL tablup(k1,k2,m,n,np,nx,nh,nt,sh2o,swpre,swtem,         &
                        w1,p1,dwe,dpe,h21,h22,h23,trant)

          END IF
          IF (ib == 7 ) THEN

            CALL tablup(k1,k2,m,n,np,nx,nh,nt,sh2o,swpre,swtem,         &
                        w1,p1,dwe,dpe,h71,h72,h73,trant)

          END IF

        ELSE

!-----compute water vapor transmittance using k-distribution.

          CALL wvkdis(ib,m,n,np,k2-1,h2oexp,conexp,th2o,tcon,trant)

        END IF

        IF(co2bnd) THEN

          IF( high ) THEN

!-----compute co2 transmittance using table look-up method

            w1=-4.0
            p1=-2.0
            dwe=0.3
            dpe=0.2

            CALL tablup(k1,k2,m,n,np,nx,nc,nt,sco3,scopre,scotem,       &
                        w1,p1,dwe,dpe,c1,c2,c3,trant)

          ELSE

!-----compute co2 transmittance using k-distribution method

            CALL co2kdis(m,n,np,k2-1,co2exp,tco2,trant)

          END IF

        END IF

!-----compute o3 transmittance using table look-up

        IF (oznbnd) THEN

          w1=-6.0
          p1=-2.0
          dwe=0.3
          dpe=0.2

          CALL tablup(k1,k2,m,n,np,nx,no,nt,sco3,scopre,scotem,         &
                      w1,p1,dwe,dpe,o1,o2,o3,trant)

        END IF

!-----fclr is the clear line-of-sight between levels k1 and k2.
!  in computing fclr, clouds are assumed randomly overlapped
!  using eq. (10).

        DO j=1,n
          DO i=1,m
            fclr(i,j) = fclr(i,j)*clr(i,j,k2-1)
          END DO
        END DO

!-----compute upward and downward fluxes


!-----add "boundary" terms to the net downward flux.
!  these are the first terms on the right-hand-side of
!  eqs. (56a) and (56b).
!  downward fluxes are positive.

        IF (k2 == k1+1) THEN
          DO j=1,n
            DO i=1,m
              flc(i,j,k1)=flc(i,j,k1)-blayer(i,j,k1)
              flc(i,j,k2)=flc(i,j,k2)+blayer(i,j,k1)
            END DO
          END DO
        END IF

!-----add flux components involving the four layers above and below
!  the levels k1 and k2.  it follows eqs. (56a) and (56b).

        DO j=1,n
          DO i=1,m
            xx=trant(i,j)*(blayer(i,j,k2-1)-blayer(i,j,k2))
            flc(i,j,k1) =flc(i,j,k1)+xx
            xx=trant(i,j)*(blayer(i,j,k1-1)-blayer(i,j,k1))
            flc(i,j,k2) =flc(i,j,k2)+xx
          END DO
        END DO

!-----compute upward and downward fluxes for all-sky situation

        IF (k2 == k1+1) THEN
          DO j=1,n
            DO i=1,m
              flxu(i,j,k1)=flxu(i,j,k1)-blayer(i,j,k1)
              flxd(i,j,k2)=flxd(i,j,k2)+blayer(i,j,k1)
            END DO
          END DO
        END IF

        DO j=1,n
          DO i=1,m
            xx=trant(i,j)*(blayer(i,j,k2-1)-blayer(i,j,k2))
            flxu(i,j,k1) =flxu(i,j,k1)+xx*fclr(i,j)
            xx=trant(i,j)*(blayer(i,j,k1-1)-blayer(i,j,k1))
            flxd(i,j,k2) =flxd(i,j,k2)+xx*fclr(i,j)
          END DO
        END DO


      END DO

!-----compute the partial derivative of fluxes with respect to
!  surface temperature (eq. 59).

      DO j=1,n
        DO i=1,m
          dfdts(i,j,k1) =dfdts(i,j,k1)-dbs(i,j)*trant(i,j)*fclr(i,j)
        END DO
      END DO

    END DO

!-----add contribution from the surface to the flux terms at the surface.

    DO j=1,n
      DO i=1,m
        dfdts(i,j,np+1) =dfdts(i,j,np+1)-dbs(i,j)
      END DO
    END DO

    DO j=1,n
      DO i=1,m
        flc(i,j,np+1)=flc(i,j,np+1)-blayer(i,j,np+1)
        flxu(i,j,np+1)=flxu(i,j,np+1)-blayer(i,j,np+1)
        st4(i,j)=st4(i,j)-blayer(i,j,np+1)
      END DO
    END DO


!  write(7,3211) ib, flxd(1,1,52),flxu(1,1,52)
!  write(7,3211) ib, flxd(1,1,np+1),flxu(1,1,np+1)
!    3211 FORMAT ('ib, fluxd, fluxu=', i3,2F12.3)

  END DO

  DO k=1,np+1
    DO j=1,n
      DO i=1,m
        flx(i,j,k)=flxd(i,j,k)+flxu(i,j,k)
        radlwin(i,j) = flxd(i,j,np+1) 
      END DO
    END DO
  END DO

  RETURN
END SUBROUTINE irrad
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE H2OEXPS                    ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE h2oexps(ib,m,n,np,dh2o,pa,dt,h2oexp)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Calculate exponentials for water vapor line absorption in
!  individual layers.
!
!-----------------------------------------------------------------------
!
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION:
!
!  03/11/1996 (Yuhe Liu)
!  Formatted code to ARPS standard format
!
!-----------------------------------------------------------------------
!
!  ORIGINAL COMMENTS:
!
!   compute exponentials for water vapor line absorption
!   in individual layers.
!
!---- input parameters
!  spectral band (ib)
!  number of grid intervals in zonal direction (m)
!  number of grid intervals in meridional direction (n)
!  number of layers (np)
!  layer water vapor amount for line absorption (dh2o)
!  layer pressure (pa)
!  layer temperature minus 250K (dt)
!
!---- output parameters
!  6 exponentials for each layer  (h2oexp)
!
!**********************************************************************
!
!fpp$ expand (expmn)
!!dir$ inline always expmn
!*$*  inline routine (expmn)
!
!-----------------------------------------------------------------------
!
!  Variable declarations
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE
  INTEGER :: ib,m,n,np

!---- input parameters ------

  REAL :: dh2o(m,n,np)
  REAL :: pa(m,n,np)
  REAL :: dt(m,n,np)

!---- output parameters -----

  REAL :: h2oexp(m,n,np,6)

!---- static data -----

  INTEGER :: mw(8)

  REAL :: xkw(8)
  REAL :: aw(8)
  REAL :: bw(8)

!---- temporary arrays -----

  REAL :: xh

!---- local misc. variables

  INTEGER :: i,j,k,ik

!-----xkw  are the absorption coefficients for the first
!  k-distribution function due to water vapor line absorption
!  (tables 4 and 7).  units are cm**2/g

  DATA xkw / 29.55  , 4.167E-1, 1.328E-2, 5.250E-4,                     &
              5.25E-4, 2.340E-3, 1.320E-0, 5.250E-4/

!-----mw are the ratios between neighboring absorption coefficients
!  for water vapor line absorption (tables 4 and 7).

  DATA mw /6,6,8,6,6,8,6,16/

!-----aw and bw (table 3) are the coefficients for temperature scaling
!  in eq. (25).

  DATA aw/ 0.0021, 0.0140, 0.0167, 0.0302,                              &
           0.0307, 0.0154, 0.0008, 0.0096/
  DATA bw/ -1.01E-5, 5.57E-5, 8.54E-5, 2.96E-4,                         &
            2.86E-4, 7.53E-5,-3.52E-6, 1.64E-5/

!-----expmn is an external function

  REAL :: expmn
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!

!**********************************************************************
!    note that the 3 sub-bands in band 3 use the same set of xkw, aw,
!    and bw.  therefore, h2oexp for these sub-bands are identical.
!**********************************************************************

  DO k=1,np
    DO j=1,n
      DO i=1,m

!-----xh is   the scaled water vapor amount for line absorption
!  computed from (27).

        xh = dh2o(i,j,k)*(pa(i,j,k)*0.002)                              &
            * ( 1.+(aw(ib)+bw(ib)* dt(i,j,k))*dt(i,j,k) )

!-----h2oexp is the water vapor transmittance of the layer (k2-1)
!  due to line absorption

        h2oexp(i,j,k,1) = expmn(-xh*xkw(ib))

      END DO
    END DO
  END DO

  DO ik=2,6

    IF(mw(ib) == 6) THEN

      DO k=1,np
        DO j=1,n
          DO i=1,m
            xh = h2oexp(i,j,k,ik-1)*h2oexp(i,j,k,ik-1)
            h2oexp(i,j,k,ik) = xh*xh*xh
          END DO
        END DO
      END DO

    ELSE IF(mw(ib) == 8) THEN

      DO k=1,np
        DO j=1,n
          DO i=1,m
            xh = h2oexp(i,j,k,ik-1)*h2oexp(i,j,k,ik-1)
            xh = xh*xh
            h2oexp(i,j,k,ik) = xh*xh
          END DO
        END DO
      END DO

    ELSE

      DO k=1,np
        DO j=1,n
          DO i=1,m
            xh = h2oexp(i,j,k,ik-1)*h2oexp(i,j,k,ik-1)
            xh = xh*xh
            xh = xh*xh
            h2oexp(i,j,k,ik) = xh*xh
          END DO
        END DO
      END DO

    END IF
  END DO

  RETURN
END SUBROUTINE h2oexps
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE CONEXPS                    ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE conexps(ib,m,n,np,dcont,conexp)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Calculate exponentials for continuum absorption in individual
!  layers.
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Adopted the original code and formatted it in accordance with the
!  ARPS coding standard.
!
!-----------------------------------------------------------------------
!
!  ORIGINAL COMMENTS:
!
!**********************************************************************
!   compute exponentials for continuum absorption in individual layers.
!
!---- input parameters
!  spectral band (ib)
!  number of grid intervals in zonal direction (m)
!  number of grid intervals in meridional direction (n)
!  number of layers (np)
!  layer scaled water vapor amount for continuum absorption (dcont)
!
!---- output parameters
!  1 or 3 exponentials for each layer (conexp)
!
!**********************************************************************
!
!fpp$ expand (expmn)
!!dir$ inline always expmn
!*$*  inline routine (expmn)
!
!-----------------------------------------------------------------------
!
!  Variable Declarations.
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE
  INTEGER :: ib,m,n,np,i,j,k,iq

!---- input parameters ------

  REAL :: dcont(m,n,np)

!---- updated parameters -----

  REAL :: conexp(m,n,np,3)

!---- static data -----

  INTEGER :: NE(8)
  REAL :: xke(8)


!-----xke are the absorption coefficients for the first
!  k-distribution function due to water vapor continuum absorption
!  (table 6).  units are cm**2/g

  DATA xke /  0.00,   0.00,   27.40,   15.8,                            &
              9.40,   7.75,     0.0,    0.0/


!-----ne is the number of terms in computing water vapor
!  continuum transmittance (Table 6).
!  band 3 is divided into 3 sub-bands.

  DATA NE /0,0,3,1,1,1,0,0/
!
!-----------------------------------------------------------------------
!
!  Functions:
!
!-----------------------------------------------------------------------
!

!-----expmn is an external function
  REAL :: expmn
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
  DO k=1,np
    DO j=1,n
      DO i=1,m
        conexp(i,j,k,1) = expmn(-dcont(i,j,k)*xke(ib))
      END DO
    END DO
  END DO

  IF (ib == 3) THEN

!-----the absorption coefficients for sub-bands 3b (iq=2) and 3a (iq=3)
!  are, respectively, double and quadruple that for sub-band 3c (iq=1)
!  (table 6).

    DO iq=2,3
      DO k=1,np
        DO j=1,n
          DO i=1,m
            conexp(i,j,k,iq) = conexp(i,j,k,iq-1) *conexp(i,j,k,iq-1)
          END DO
        END DO
      END DO
    END DO

  END IF

  RETURN
END SUBROUTINE conexps
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE CO2EXPS                    ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE co2exps(m,n,np,dco2,pa,dt,co2exp)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Calculate co2 exponentials for individual layers.
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Adopted the original code and formatted it in accordance with the
!  ARPS coding standard.
!
!-----------------------------------------------------------------------
!
!  ORIGINAL COMMENTS:
!
!
!**********************************************************************
!   compute co2 exponentials for individual layers.
!
!---- input parameters
!  number of grid intervals in zonal direction (m)
!  number of grid intervals in meridional direction (n)
!  number of layers (np)
!  layer co2 amount (dco2)
!  layer pressure (pa)
!  layer temperature minus 250K (dt)
!
!---- output parameters
!  6 exponentials for each layer (co2exp)
!**********************************************************************
!
!fpp$ expand (expmn)
!!dir$ inline always expmn
!*$*  inline routine (expmn)
!
!-----------------------------------------------------------------------
!
!  Variable Declarations.
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE
  INTEGER :: m,n,np,i,j,k

!---- input parameters -----

  REAL :: dco2(m,n,np)
  REAL :: pa(m,n,np)
  REAL :: dt(m,n,np)

!---- output parameters -----

  REAL :: co2exp(m,n,np,6,2)

!---- static data -----

  REAL :: xkc(2),ac(2),bc(2),pm(2),prc(2)

!---- temporary arrays -----

  REAL :: xc

!-----xkc is the absorption coefficients for the
!  first k-distribution function due to co2 (table 7).
!  units are 1/(cm-atm)stp.

  DATA xkc/2.656E-5,2.656E-3/

!-----parameters (table 3) for computing the scaled co2 amount
!  using (27).

  DATA prc/  300.0,   30.0/
  DATA pm /    0.5,   0.85/
  DATA ac / 0.0182, 0.0042/
  DATA bc /1.07E-4,2.00E-5/
!
!-----------------------------------------------------------------------
!
!  Functions:
!
!-----------------------------------------------------------------------
!

!-----function expmn

  REAL :: expmn
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
  DO k=1,np
    DO j=1,n
      DO i=1,m

!-----compute the scaled co2 amount from eq. (27) for band-wings
!  (sub-bands 3a and 3c).

        xc = dco2(i,j,k)*(pa(i,j,k)/prc(1))**pm(1)                      &
                *(1.+(ac(1)+bc(1)*dt(i,j,k))*dt(i,j,k))

!-----six exponential by powers of 8 (table 7).

        co2exp(i,j,k,1,1)=expmn(-xc*xkc(1))

        xc=co2exp(i,j,k,1,1)*co2exp(i,j,k,1,1)
        xc=xc*xc
        co2exp(i,j,k,2,1)=xc*xc

        xc=co2exp(i,j,k,2,1)*co2exp(i,j,k,2,1)
        xc=xc*xc
        co2exp(i,j,k,3,1)=xc*xc

        xc=co2exp(i,j,k,3,1)*co2exp(i,j,k,3,1)
        xc=xc*xc
        co2exp(i,j,k,4,1)=xc*xc

        xc=co2exp(i,j,k,4,1)*co2exp(i,j,k,4,1)
        xc=xc*xc
        co2exp(i,j,k,5,1)=xc*xc

        xc=co2exp(i,j,k,5,1)*co2exp(i,j,k,5,1)
        xc=xc*xc
        co2exp(i,j,k,6,1)=xc*xc

!-----compute the scaled co2 amount from eq. (27) for band-center
!  region (sub-band 3b).

        xc = dco2(i,j,k)*(pa(i,j,k)/prc(2))**pm(2)                      &
                *(1.+(ac(2)+bc(2)*dt(i,j,k))*dt(i,j,k))

        co2exp(i,j,k,1,2)=expmn(-xc*xkc(2))

        xc=co2exp(i,j,k,1,2)*co2exp(i,j,k,1,2)
        xc=xc*xc
        co2exp(i,j,k,2,2)=xc*xc

        xc=co2exp(i,j,k,2,2)*co2exp(i,j,k,2,2)
        xc=xc*xc
        co2exp(i,j,k,3,2)=xc*xc

        xc=co2exp(i,j,k,3,2)*co2exp(i,j,k,3,2)
        xc=xc*xc
        co2exp(i,j,k,4,2)=xc*xc

        xc=co2exp(i,j,k,4,2)*co2exp(i,j,k,4,2)
        xc=xc*xc
        co2exp(i,j,k,5,2)=xc*xc

        xc=co2exp(i,j,k,5,2)*co2exp(i,j,k,5,2)
        xc=xc*xc
        co2exp(i,j,k,6,2)=xc*xc

      END DO
    END DO
  END DO

  RETURN
END SUBROUTINE co2exps
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE COLUMN                     ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE column(m,n,np,pa,dt,sabs0,sabs,spre,stem)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Calculate column-integrated (from top of the model atmosphere)
!  absorber amount, absorber-weighted pressure and temperature.
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Adopted the original code and formatted it in accordance with the
!  ARPS coding standard.
!
!-----------------------------------------------------------------------
!
!  ORIGINAL COMMENTS:
!
!**************************************************************************
!-----compute column-integrated (from top of the model atmosphere)
!  absorber amount (sabs), absorber-weighted pressure (spre) and
!  temperature (stem).
!  computations of spre and stem follows eqs. (37) and (38).
!
!--- input parameters
!   number of soundings in zonal direction (m)
!   number of soundings in meridional direction (n)
!   number of atmospheric layers (np)
!   layer pressure (pa)
!   layer temperature minus 250K (dt)
!   layer absorber amount (sabs0)
!
!--- output parameters
!   column-integrated absorber amount (sabs)
!   column absorber-weighted pressure (spre)
!   column absorber-weighted temperature (stem)
!
!--- units of pa and dt are mb and k, respectively.
!    units of sabs are g/cm**2 for water vapor and (cm-atm)stp for co2 and o3
!**************************************************************************
!
!-----------------------------------------------------------------------
!
!  Variable Declarations.
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

  INTEGER :: m,n,np,i,j,k

!---- input parameters -----

  REAL :: pa(m,n,np)
  REAL :: dt(m,n,np)
  REAL :: sabs0(m,n,np)

!---- output parameters -----

  REAL :: sabs(m,n,np+1)
  REAL :: spre(m,n,np+1)
  REAL :: stem(m,n,np+1)

!*********************************************************************
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
  DO j=1,n
    DO i=1,m
      sabs(i,j,1)=0.0
      spre(i,j,1)=0.0
      stem(i,j,1)=0.0
    END DO
  END DO

  DO k=1,np
    DO j=1,n
      DO i=1,m
        sabs(i,j,k+1)=sabs(i,j,k)+sabs0(i,j,k)
        spre(i,j,k+1)=spre(i,j,k)+pa(i,j,k)*sabs0(i,j,k)
        stem(i,j,k+1)=stem(i,j,k)+dt(i,j,k)*sabs0(i,j,k)
      END DO
    END DO
  END DO

  RETURN
END SUBROUTINE column
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE TABLUP                     ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE tablup(k1,k2,m,n,np,nx,nh,nt,sabs,spre,stem,w1,p1,           &
           dwe,dpe,coef1,coef2,coef3,tran)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Calculate water vapor, co2, and o3 transmittances using table
!  look-up. rlwopt = 0, or high=.false.
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Adopted the original code and formatted it in accordance with the
!  ARPS coding standard.
!
!-----------------------------------------------------------------------
!
!  ORIGINAL COMMENTS:
!
!**********************************************************************
!   compute water vapor, co2, and o3 transmittances between levels k1 and k2
!   using table look-up for m x n soundings.
!
!   Calculations follow Eq. (40) of Chou and Suarez (1995)
!
!---- input ---------------------
!  indices for pressure levels (k1 and k2)
!  number of grid intervals in zonal direction (m)
!  number of grid intervals in meridional direction (n)
!  number of atmospheric layers (np)
!  number of pressure intervals in the table (nx)
!  number of absorber amount intervals in the table (nh)
!  number of tables copied (nt)
!  column-integrated absorber amount (sabs)
!  column absorber amount-weighted pressure (spre)
!  column absorber amount-weighted temperature (stem)
!  first value of absorber amount (log10) in the table (w1)
!  first value of pressure (log10) in the table (p1)
!  size of the interval of absorber amount (log10) in the table (dwe)
!  size of the interval of pressure (log10) in the table (dpe)
!  pre-computed coefficients (coef1, coef2, and coef3)
!
!---- updated ---------------------
!  transmittance (tran)
!
!  Note:
!   (1) units of sabs are g/cm**2 for water vapor and (cm-atm)stp for co2 and o3.
!   (2) units of spre and stem are, respectively, mb and K.
!   (3) there are nt identical copies of the tables (coef1, coef2, and
!    coef3).  the prupose of using the multiple copies of tables is
!    to increase the speed in parallel (vectorized) computations.
!    if such advantage does not exist, nt can be set to 1.
!
!**********************************************************************
!
!-----------------------------------------------------------------------
!
!  Variable declarations
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE
  INTEGER :: k1,k2,m,n,np,nx,nh,nt,i,j

!---- input parameters -----

  REAL :: w1,p1,dwe,dpe
  REAL :: sabs(m,n,np+1)
  REAL :: spre(m,n,np+1)
  REAL :: stem(m,n,np+1)

  REAL :: coef1(nx,nh,nt)
  REAL :: coef2(nx,nh,nt)
  REAL :: coef3(nx,nh,nt)

!---- update parameter -----

  REAL :: tran(m,n)

!---- temporary variables -----

  REAL :: x1,x2,x3,we,pe,fw,fp,pa,pb,pc,ax,ba,bb,t1,ca,cb,t2
  INTEGER :: iw,ip,nn

!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
  DO j=1,n
    DO i=1,m

      nn=MOD(i,nt)+1

      x1=sabs(i,j,k2)-sabs(i,j,k1)
      x2=(spre(i,j,k2)-spre(i,j,k1))/x1
      x3=(stem(i,j,k2)-stem(i,j,k1))/x1

      we=(LOG10(x1)-w1)/dwe
      pe=(LOG10(x2)-p1)/dpe

      we=MAX(we,w1-2.*dwe)
      pe=MAX(pe,p1)

      iw=INT(we+1.5)
      ip=INT(pe+1.5)

      iw=MIN(iw,nh-1)
      iw=MAX(iw, 2)

      ip=MIN(ip,nx-1)
      ip=MAX(ip, 1)

      fw=we-FLOAT(iw-1)
      fp=pe-FLOAT(ip-1)

!-----linear interpolation in pressure

      pa = coef1(ip,iw-1,nn)*(1.-fp)+coef1(ip+1,iw-1,nn)*fp
      pb = coef1(ip,iw,  nn)*(1.-fp)+coef1(ip+1,iw,  nn)*fp
      pc = coef1(ip,iw+1,nn)*(1.-fp)+coef1(ip+1,iw+1,nn)*fp

!-----quadratic interpolation in absorber amount for coef1

      ax = (-pa*(1.-fw)+pc*(1.+fw)) *fw*0.5 + pb*(1.-fw*fw)

!-----linear interpolation in absorber amount for coef2 and coef3

      ba = coef2(ip,iw,  nn)*(1.-fp)+coef2(ip+1,iw,  nn)*fp
      bb = coef2(ip,iw+1,nn)*(1.-fp)+coef2(ip+1,iw+1,nn)*fp
      t1 = ba*(1.-fw) + bb*fw

      ca = coef3(ip,iw,  nn)*(1.-fp)+coef3(ip+1,iw,  nn)*fp
      cb = coef3(ip,iw+1,nn)*(1.-fp)+coef3(ip+1,iw+1,nn)*fp
      t2 = ca*(1.-fw) + cb*fw

!-----update the total transmittance between levels k1 and k2

      tran(i,j)= (ax + (t1+t2*x3) * x3)*tran(i,j)

    END DO
  END DO

  RETURN
END SUBROUTINE tablup
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE WVKDIS                     ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE wvkdis(ib,m,n,np,k,h2oexp,conexp,th2o,tcon,tran)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Calculate water vapor transmittance using the k-distribution
!  method.
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Adopted the original code and formatted it in accordance with the
!  ARPS coding standard.
!
!-----------------------------------------------------------------------
!
!  ORIGINAL COMMENTS:
!
!**********************************************************************
!   compute water vapor transmittance between levels k1 and k2 for
!   m x n soundings using the k-distribution method.
!
!   computations follow eqs. (34), (46), (50) and (52).
!
!---- input parameters
!  spectral band (ib)
!  number of grid intervals in zonal direction (m)
!  number of grid intervals in meridional direction (n)
!  number of levels (np)
!  current level (k)
!  exponentials for line absorption (h2oexp)
!  exponentials for continuum absorption (conexp)
!
!---- updated parameters
!  transmittance between levels k1 and k2 due to
!    water vapor line absorption (th2o)
!  transmittance between levels k1 and k2 due to
!    water vapor continuum absorption (tcon)
!  total transmittance (tran)
!
!**********************************************************************
!
!-----------------------------------------------------------------------
!
!  Variable declarations
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE
  INTEGER :: ib,m,n,np,k,i,j

!---- input parameters ------

  REAL :: conexp(m,n,np,3)
  REAL :: h2oexp(m,n,np,6)

!---- updated parameters -----

  REAL :: th2o(m,n,6)
  REAL :: tcon(m,n,3)
  REAL :: tran(m,n)

!---- static data -----

  INTEGER :: NE(8)
  REAL :: fkw(6,8),gkw(6,3)

!---- temporary variable -----

  REAL :: trnth2o

!-----fkw is the planck-weighted k-distribution function due to h2o
!  line absorption given in table 4 of Chou and Suarez (1995).
!  the k-distribution function for the third band, fkw(*,3), is not used

  DATA fkw / 0.2747,0.2717,0.2752,0.1177,0.0352,0.0255,                 &
             0.1521,0.3974,0.1778,0.1826,0.0374,0.0527,                 &
             6*1.00,                                                    &
             0.4654,0.2991,0.1343,0.0646,0.0226,0.0140,                 &
             0.5543,0.2723,0.1131,0.0443,0.0160,0.0000,                 &
             0.1846,0.2732,0.2353,0.1613,0.1146,0.0310,                 &
             0.0740,0.1636,0.4174,0.1783,0.1101,0.0566,                 &
             0.1437,0.2197,0.3185,0.2351,0.0647,0.0183/

!-----gkw is the planck-weighted k-distribution function due to h2o
!  line absorption in the 3 subbands (800-720,620-720,540-620 /cm)
!  of band 3 given in table 7.  Note that the order of the sub-bands
!  is reversed.

  DATA gkw/  0.1782,0.0593,0.0215,0.0068,0.0022,0.0000,                 &
             0.0923,0.1675,0.0923,0.0187,0.0178,0.0000,                 &
             0.0000,0.1083,0.1581,0.0455,0.0274,0.0041/

!-----ne is the number of terms used in each band to compute water vapor
!  continuum transmittance (table 6).

  DATA NE /0,0,3,1,1,1,0,0/
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!

!-----tco2 are the six exp factors between levels k1 and k2
!  tran is the updated total transmittance between levels k1 and k2


!-----th2o is the 6 exp factors between levels k1 and k2 due to
!  h2o line absorption.

!-----tcon is the 3 exp factors between levels k1 and k2 due to
!  h2o continuum absorption.

!-----trnth2o is the total transmittance between levels k1 and k2 due
!  to both line and continuum absorption computed from eq. (52).

  DO j=1,n
    DO i=1,m
      th2o(i,j,1) = th2o(i,j,1)*h2oexp(i,j,k,1)
      th2o(i,j,2) = th2o(i,j,2)*h2oexp(i,j,k,2)
      th2o(i,j,3) = th2o(i,j,3)*h2oexp(i,j,k,3)
      th2o(i,j,4) = th2o(i,j,4)*h2oexp(i,j,k,4)
      th2o(i,j,5) = th2o(i,j,5)*h2oexp(i,j,k,5)
      th2o(i,j,6) = th2o(i,j,6)*h2oexp(i,j,k,6)
    END DO
  END DO


  IF (NE(ib) == 0) THEN


    DO j=1,n
      DO i=1,m

        trnth2o      =(fkw(1,ib)*th2o(i,j,1)                            &
                     + fkw(2,ib)*th2o(i,j,2)                            &
                     + fkw(3,ib)*th2o(i,j,3)                            &
                     + fkw(4,ib)*th2o(i,j,4)                            &
                     + fkw(5,ib)*th2o(i,j,5)                            &
                     + fkw(6,ib)*th2o(i,j,6))

        tran(i,j)=tran(i,j)*trnth2o

      END DO
    END DO

  ELSE IF (NE(ib) == 1) THEN


    DO j=1,n
      DO i=1,m

        tcon(i,j,1)= tcon(i,j,1)*conexp(i,j,k,1)

        trnth2o      =(fkw(1,ib)*th2o(i,j,1)                            &
                     + fkw(2,ib)*th2o(i,j,2)                            &
                     + fkw(3,ib)*th2o(i,j,3)                            &
                     + fkw(4,ib)*th2o(i,j,4)                            &
                     + fkw(5,ib)*th2o(i,j,5)                            &
                     + fkw(6,ib)*th2o(i,j,6))*tcon(i,j,1)

        tran(i,j)=tran(i,j)*trnth2o

      END DO
    END DO

  ELSE

    DO j=1,n
      DO i=1,m

        tcon(i,j,1)= tcon(i,j,1)*conexp(i,j,k,1)
        tcon(i,j,2)= tcon(i,j,2)*conexp(i,j,k,2)
        tcon(i,j,3)= tcon(i,j,3)*conexp(i,j,k,3)

        trnth2o      = (  gkw(1,1)*th2o(i,j,1)                          &
                        + gkw(2,1)*th2o(i,j,2)                          &
                        + gkw(3,1)*th2o(i,j,3)                          &
                        + gkw(4,1)*th2o(i,j,4)                          &
                        + gkw(5,1)*th2o(i,j,5)                          &
                        + gkw(6,1)*th2o(i,j,6) ) * tcon(i,j,1)          &
                     + (  gkw(1,2)*th2o(i,j,1)                          &
                        + gkw(2,2)*th2o(i,j,2)                          &
                        + gkw(3,2)*th2o(i,j,3)                          &
                        + gkw(4,2)*th2o(i,j,4)                          &
                        + gkw(5,2)*th2o(i,j,5)                          &
                        + gkw(6,2)*th2o(i,j,6) ) * tcon(i,j,2)          &
                     + (  gkw(1,3)*th2o(i,j,1)                          &
                        + gkw(2,3)*th2o(i,j,2)                          &
                        + gkw(3,3)*th2o(i,j,3)                          &
                        + gkw(4,3)*th2o(i,j,4)                          &
                        + gkw(5,3)*th2o(i,j,5)                          &
                        + gkw(6,3)*th2o(i,j,6) ) * tcon(i,j,3)

        tran(i,j)=tran(i,j)*trnth2o

      END DO
    END DO

  END IF

  RETURN
END SUBROUTINE wvkdis
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE CO2KDIS                    ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE co2kdis(m,n,np,k,co2exp,tco2,tran)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Calculate co2 transmittances using the k-distribution method
!
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Adopted the original code and formatted it in accordance with the
!  ARPS coding standard.
!
!-----------------------------------------------------------------------
!
!  ORIGINAL COMMENTS:
!
!**********************************************************************
!   compute co2 transmittances between levels k1 and k2 for m x n soundings
!   using the k-distribution method with linear pressure scaling.
!
!   computations follow eq. (34).
!
!---- input parameters
!   number of grid intervals in zonal direction (m)
!   number of grid intervals in meridional direction (n)
!
!---- updated parameters
!   transmittance between levels k1 and k2 due to co2 absorption
!  for the various values of the absorption coefficient (tco2)
!   total transmittance (tran)
!
!**********************************************************************
!
!-----------------------------------------------------------------------
!
!  Variable declarations
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE
  INTEGER :: m,n,np,k,i,j

!---- input parameters -----

  REAL :: co2exp(m,n,np,6,2)

!---- updated parameters -----

  REAL :: tco2(m,n,6,2)
  REAL :: tran(m,n)

!---- static data -----

  REAL :: gkc(6,2)

!---- temporary variable -----

  REAL :: xc

!-----gkc is the planck-weighted co2 k-distribution function
!  in the band-wing and band-center regions given in table 7.
!  for computing efficiency, sub-bands 3a and 3c are combined.

  DATA gkc/  0.1395,0.1407,0.1549,0.1357,0.0182,0.0220,                 &
             0.0766,0.1372,0.1189,0.0335,0.0169,0.0059/
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!

!-----tco2 is the 6 exp factors between levels k1 and k2.
!  xc is the total co2 transmittance given by eq. (53).

  DO j=1,n
    DO i=1,m

!-----band-wings

      tco2(i,j,1,1)=tco2(i,j,1,1)*co2exp(i,j,k,1,1)
      xc=             gkc(1,1)*tco2(i,j,1,1)

      tco2(i,j,2,1)=tco2(i,j,2,1)*co2exp(i,j,k,2,1)
      xc=xc+gkc(2,1)*tco2(i,j,2,1)

      tco2(i,j,3,1)=tco2(i,j,3,1)*co2exp(i,j,k,3,1)
      xc=xc+gkc(3,1)*tco2(i,j,3,1)

      tco2(i,j,4,1)=tco2(i,j,4,1)*co2exp(i,j,k,4,1)
      xc=xc+gkc(4,1)*tco2(i,j,4,1)

      tco2(i,j,5,1)=tco2(i,j,5,1)*co2exp(i,j,k,5,1)
      xc=xc+gkc(5,1)*tco2(i,j,5,1)

      tco2(i,j,6,1)=tco2(i,j,6,1)*co2exp(i,j,k,6,1)
      xc=xc+gkc(6,1)*tco2(i,j,6,1)

!-----band-center region

      tco2(i,j,1,2)=tco2(i,j,1,2)*co2exp(i,j,k,1,2)
      xc=xc+gkc(1,2)*tco2(i,j,1,2)

      tco2(i,j,2,2)=tco2(i,j,2,2)*co2exp(i,j,k,2,2)
      xc=xc+gkc(2,2)*tco2(i,j,2,2)

      tco2(i,j,3,2)=tco2(i,j,3,2)*co2exp(i,j,k,3,2)
      xc=xc+gkc(3,2)*tco2(i,j,3,2)

      tco2(i,j,4,2)=tco2(i,j,4,2)*co2exp(i,j,k,4,2)
      xc=xc+gkc(4,2)*tco2(i,j,4,2)

      tco2(i,j,5,2)=tco2(i,j,5,2)*co2exp(i,j,k,5,2)
      xc=xc+gkc(5,2)*tco2(i,j,5,2)

      tco2(i,j,6,2)=tco2(i,j,6,2)*co2exp(i,j,k,6,2)
      xc=xc+gkc(6,2)*tco2(i,j,6,2)

      tran(i,j)=tran(i,j)*xc

    END DO
  END DO

  RETURN
END SUBROUTINE co2kdis

sorad3d.F/      1298670057  19071 8000  100644  69155     `
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE SORAD                      ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE sorad(idim,jdim,m,n,np,                                      &
           pl,ta,wa,oa,co2,                                             &
           taucldi,taucldl,reffi,reffl,fcld,ict,icb,                    &
           taual,rsirbm,rsirdf,rsuvbm,rsuvdf,cosz,                      &
           flx,flc,fdirir,fdifir,fdirpar,fdifpar,                       &
           sdf,sclr,csm,cc,                                             &
           tauclb,tauclf,dp,wh,oh,scal,swh,so2,df,                      &
           tem2d1, tem2d2, tem2d3, tem2d4, tem2d5,                      &
           tem2d6, tem2d7, tem2d8, tem2d9, tem2d10,                     &
           tem2d11,tem2d12,tem2d13,tem2d14,tem2d15,                     &
           tem2d16,tem2d17,tem2d18,tem2d19,                             &
           tem3d1, tem3d2, tem3d3, tem3d4, tem3d5,                      &
           tem4d1, tem4d2, tem4d3, tem4d4, tem4d5,                      &
           tem5d1, tem5d2, tem5d3, tem5d4, tem5d5)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Calculate solar fluxes due to the absoption by water vapor, ozone,
!  co2, o2, clouds, and aerosols and due to the scattering by clouds,
!  aerosols, and gases.
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Adopted the original code and formatted it in accordance with the
!  ARPS coding standard.
!
!-----------------------------------------------------------------------
!
!  ORIGINAL COMMENTS:
!
!****************  charney  /silo/z1mhy/new/solar.f  ***10/24/95******
!********************************************************************
!
! This routine computes solar fluxes due to the absoption by water
!  vapor, ozone, co2, o2, clouds, and aerosols and due to the
!  scattering by clouds, aerosols, and gases.
!
! This is a vectorized code. It computes the fluxes simultaneous for
!  (m x n) soundings, which is a subset of the (m x ndim) soundings.
!  In a global climate model, m and ndim correspond to the numbers of
!  grid boxes in the zonal and meridional directions, respectively.
!
! Ice and liquid cloud particles are allowed to co-exist in any of the
!  np layers. Two sets of cloud parameters are required as inputs, one
!  for ice paticles and the other for liquid particles.  These parameters
!  are optical thickness (taucld) and effective particle size (reff).
!
! If no information is available for reff, a default value of
!  10 micron for liquid water and 75 micron for ice can be used.
!
! Clouds are grouped into high, middle, and low clouds separated by the
!  level indices ict and icb.  For detail, see the subroutine cldscale.
!
!----- Input parameters:
!                                                units      size
!   number of soundings in zonal direction (m)       n/d        1
!   number of soundings in meridional direction (n)  n/d        1
!   maximum number of soundings in                   n/d        1
!        meridional direction (ndim)
!   number of atmospheric layers (np)                n/d        1
!   level pressure (pl)                              mb       m*ndim*(np+1)
!   layer temperature (ta)                           k        m*ndim*np
!   layer specific humidity (wa)                     gm/gm    m*ndim*np
!   layer ozone concentration (oa)                   gm/gm    m*ndim*np
!   co2 mixing ratio by volumn (co2)               parts/part   1
!   cloud optical thickness (taucld)                 n/d      m*ndim*np*2
!             index 1 for ice particles
!             index 2 for liquid drops
!   effective cloud-particle size (reff)           micrometer m*ndim*np*2
!             index 1 for ice particles
!             index 2 for liquid drops
!
!   ARPS notes: taucld were changed to taucldi and taucldl
!            reff   were changed to reffi   and reffl
!
!   cloud amount (fcld)                            fraction   m*ndim*np
!   level index separating high and middle           n/d        1
!             clouds (ict)
!   level index separating middle and low clouds     n/d        1
!             clouds (icb)
!   aerosol optical thickness (taual)                n/d      m*ndim*np
!   solar ir surface albedo for beam                fraction   m*ndim
!             radiation (rsirbm)
!   solar ir surface albedo for diffuse             fraction   m*ndim
!             radiation (rsirdf)
!   uv + par surface albedo for beam                     fraction   m*ndim
!             radiation (rsuvbm)
!   uv + par surface albedo for diffuse                  fraction   m*ndim
!             radiation (rsuvdf)
!   cosine of solar zenith angle (cosz)            n/d        m*ndim
!
!----- Output parameters
!
!   all-sky flux (downward minus upward) (flx)     fraction   m*ndim*(np+1)
!   clear-sky flux (downward minus upward) (flc)   fraction   m*ndim*(np+1)
!   all-sky direct downward ir (0.7-10 micron)
!             flux at the surface (fdirir)      fraction   m*ndim
!   all-sky diffuse downward ir flux at
!             the surface (fdifir)              fraction   m*ndim
!   all-sky direct downward par (0.4-0.7 micron)
!             flux at the surface (fdirpar)     fraction   m*ndim
!   all-sky diffuse downward par flux at
!             the surface (fdifpar)             fraction   m*ndim
!
!----- Notes:
!
!    (1) The unit of flux is fraction of the incoming solar radiation
!     at the top of the atmosphere.  Therefore, fluxes should
!     be equal to flux multiplied by the extra-terrestrial solar
!     flux and the cosine of solar zenith angle.
!    (2) Clouds and aerosols can be included in any layers by specifying
!     fcld(i,j,k), taucld(i,j,k,*) and taual(i,j,k), k=1,np.
!     For an atmosphere without clouds and aerosols,
!     set fcld(i,j,k)=taucld(i,j,k,*)=taual(i,j,k)=0.0.
!    (3) Aerosol single scattering albedos and asymmetry
!     factors are specified in the subroutines solir and soluv.
!    (4) pl(i,j,1) is the pressure at the top of the model, and
!     pl(i,j,np+1) is the surface pressure.
!
!    ARPS note: pl was replaced by pa at scalar points (layers)
!
!    (5) the pressure levels ict and icb correspond approximately
!     to 400 and 700 mb.
!
!**************************************************************************
!
!fpp$ expand (expmn)
!!dir$ inline always expmn
!*$*  inline routine (expmn)
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

  INTEGER :: idim,jdim             ! ARPS nx, ny. NX is used in this
                                   ! subroutine for other purpose

  INTEGER :: m,n,np
  INTEGER :: ict,icb

  REAL :: pl(idim,jdim,np+1)       ! pressure at scalar points (layers)
  REAL :: ta(idim,jdim,np)
  REAL :: wa(idim,jdim,np)
  REAL :: oa(idim,jdim,np)
  REAL :: taucldi(idim,jdim,np)
  REAL :: taucldl(idim,jdim,np)
  REAL :: reffi(idim,jdim,np)
  REAL :: reffl(idim,jdim,np)
  REAL :: fcld(idim,jdim,np)
  REAL :: taual(idim,jdim,np)
  REAL :: rsirbm(idim,jdim)
  REAL :: rsirdf(idim,jdim)
  REAL :: rsuvbm(idim,jdim)
  REAL :: rsuvdf(idim,jdim)
  REAL :: cosz(idim,jdim)
  REAL :: co2

  REAL :: flx(idim,jdim,np+1)
  REAL :: flc(idim,jdim,np+1)
  REAL :: fdirir(idim,jdim)
  REAL :: fdifir(idim,jdim)
  REAL :: fdirpar(idim,jdim)
  REAL :: fdifpar(idim,jdim)
!
!-----------------------------------------------------------------------
!
!  Local temporary arrays
!
!-----------------------------------------------------------------------
!
  REAL :: sdf(m,n)
  REAL :: sclr(m,n)
  REAL :: csm(m,n)
  REAL :: cc(m,n,3)

  REAL :: tauclb(m,n,np)
  REAL :: tauclf(m,n,np)
  REAL :: dp(m,n,np)
  REAL :: wh(m,n,np)
  REAL :: oh(m,n,np)
  REAL :: scal(m,n,np)
  REAL :: swh(m,n,np+1)
  REAL :: so2(m,n,np+1)
  REAL :: df(m,n,np+1)

!-----temporary arrays used in subroutine cldflx

  REAL :: tem2d1 (m,n)
  REAL :: tem2d2 (m,n)
  REAL :: tem2d3 (m,n)
  REAL :: tem2d4 (m,n)
  REAL :: tem2d5 (m,n)
  REAL :: tem2d6 (m,n)
  REAL :: tem2d7 (m,n)
  REAL :: tem2d8 (m,n)
  REAL :: tem2d9 (m,n)
  REAL :: tem2d10(m,n)
  REAL :: tem2d11(m,n)
  REAL :: tem2d12(m,n)
  REAL :: tem2d13(m,n)
  REAL :: tem2d14(m,n)
  REAL :: tem2d15(m,n)
  REAL :: tem2d16(m,n)
  REAL :: tem2d17(m,n)
  REAL :: tem2d18(m,n)
  REAL :: tem2d19(m,n)

  REAL :: tem3d1(m,n,np)
  REAL :: tem3d2(m,n,np)
  REAL :: tem3d3(m,n,np+1)
  REAL :: tem3d4(m,n,np+1)
  REAL :: tem3d5(m,n,np+1)

  REAL :: tem4d1(m,n,np+1,2)
  REAL :: tem4d2(m,n,np+1,2)
  REAL :: tem4d3(m,n,np+1,2)
  REAL :: tem4d4(m,n,np+1,2)
  REAL :: tem4d5(m,n,np+1,2)

  REAL :: tem5d1(m,n,np+1,2,2)
  REAL :: tem5d2(m,n,np+1,2,2)
  REAL :: tem5d3(m,n,np+1,2,2)
  REAL :: tem5d4(m,n,np+1,2,2)
  REAL :: tem5d5(m,n,np+1,2,2)

!-----temporary variables

  INTEGER :: i,j,k
  REAL :: x
!
!-----------------------------------------------------------------------
!
!  Functions:
!
!-----------------------------------------------------------------------
!
  REAL :: expmn
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
  DO j=1,n
    DO i=1,m

      swh(i,j,1)=0.
      so2(i,j,1)=0.

!-----csm is the effective secant of the solar zenith angle
!  see equation (12) of Lacis and Hansen (1974, JAS)

      csm(i,j)=35./SQRT(1224.*cosz(i,j)*cosz(i,j)+1.)

    END DO
  END DO


  DO k=1,np
    DO j=1,n
      DO i=1,m

!-----compute layer thickness and pressure-scaling function.
!  indices for the surface level and surface layer
!  are np+1 and np, respectively.

        dp(i,j,k)=pl(i,j,k+1)-pl(i,j,k)
        scal(i,j,k)=dp(i,j,k)*(.5*(pl(i,j,k)+pl(i,j,k+1))/300.)**.8

!-----compute scaled water vapor amount, unit is g/cm**2

        wh(i,j,k)=1.02*wa(i,j,k)*scal(i,j,k)*                           &
                  (1.-0.00135*(ta(i,j,k)-240.))
        swh(i,j,k+1)=swh(i,j,k)+wh(i,j,k)

!-----compute ozone amount, unit is (cm-atm)stp.

        oh(i,j,k)=1.02*oa(i,j,k)*dp(i,j,k)*466.7

      END DO
    END DO
  END DO


!-----scale cloud optical thickness in each layer from taucld (with
!  cloud amount fcld) to tauclb and tauclf (with cloud amount cc).
!  tauclb is the scaled optical thickness for beam radiation and
!  tauclf is for diffuse radiation.

  CALL cldscale(idim,jdim,                                              &
                m,n,np,cosz,fcld,taucldi,taucldl,ict,icb,               &
                cc,tauclb,tauclf)

!-----initialize fluxes for all-sky (flx), clear-sky (flc), and
!  flux reduction (df)

  DO k=1,np+1
    DO j=1,n
      DO i=1,m
        flx(i,j,k)=0.
        flc(i,j,k)=0.
        df(i,j,k)=0.
      END DO
    END DO
  END DO

!-----compute solar ir fluxes

  CALL solir (idim,jdim,                                                &
              m,n,np,wh,taucldi,taucldl,tauclb,tauclf,                  &
              reffi,reffl,ict,icb,                                      &
              fcld,cc,taual,csm,rsirbm,rsirdf,                          &
              flx,flc,fdirir,fdifir,                                    &
              tem2d1, tem2d2, tem2d3, tem2d4,                           &
              tem2d5, tem2d6, tem2d7, tem2d8, tem2d9,                   &
              tem2d10,tem2d11,tem2d12,tem2d13,tem2d14,                  &
              tem3d1, tem3d2, tem3d3, tem3d4,                           &
              tem4d1, tem4d2, tem4d3, tem4d4, tem4d5,                   &
              tem2d15,tem2d16,tem2d17,tem2d18,tem2d19,                  &
              tem3d5,                                                   &
              tem5d1,tem5d2,tem5d3,tem5d4,tem5d5)

!  DO k=1,np
!    write (6,'(a,i2,a,i2,a,e20.10)')
!    :  'IR:  flx(2,2,',k+1,')-flx(2,2,',k,')=',
!    :  flx(2,2,k+1)-flx(2,2,k)
!  ENDDO

!-----compute and update uv and par fluxes

  CALL soluv (idim,jdim,                                                &
              m,n,np,oh,dp,taucldi,taucldl,tauclb,tauclf,               &
              reffi,reffl,ict,icb,                                      &
              fcld,cc,taual,csm,rsuvbm,rsuvdf,                          &
              flx,flc,fdirpar,fdifpar,                                  &
              tem2d1, tem2d2, tem2d3,                                   &
              tem2d5, tem2d6, tem2d7, tem2d8, tem2d9,                   &
              tem2d10,tem2d11,tem2d12,tem2d13,tem2d14,                  &
              tem3d1, tem3d3, tem3d4,                                   &
              tem4d1, tem4d2, tem4d3, tem4d4, tem4d5,                   &
              tem2d15,tem2d16,tem2d17,tem2d18,tem2d19,                  &
              tem3d5,                                                   &
              tem5d1,tem5d2,tem5d3,tem5d4,tem5d5)

!  write (6,'(a/a3,2a15)') 'Total flux for PAR',
!    :  'k','dflxPAR','flxPAR'
!  DO k=1,np
!    write (6,'(i3,2e15.7)')
!    :  k,flx(2,2,k+1)-flx(2,2,k),flx(2,2,k)
!  ENDDO

!-----compute scaled amount of o2 (so2), unit is (cm-atm)stp.

  DO k=1,np
    DO j=1,n
      DO i=1,m
        so2(i,j,k+1)=so2(i,j,k)+165.22*scal(i,j,k)
      END DO
    END DO
  END DO

!-----compute flux reduction due to oxygen following
!   chou (J. climate, 1990). The fraction 0.0287 is the
!   extraterrestrial solar flux in the o2 bands.

  DO k=2,np+1
    DO j=1,n
      DO i=1,m
        x=so2(i,j,k)*csm(i,j)
        df(i,j,k)=df(i,j,k)+0.0287*(1.-expmn(-0.00027*SQRT(x)))
      END DO
    END DO
  END DO

!  write (6,'(a/a3,3a15)')
!    : 'Flux reduction due to oxygen, i=j=3',
!    : 'k','ddf','df','so2'
!  DO k=2,np+1
!    write (6,'(i3,3e15.7)')
!    :  k,df(3,3,k)-df(3,3,k-1),df(3,3,k),so2(3,3,k)
!  ENDDO

!-----compute scaled amounts for co2 (so2). unit is (cm-atm)stp.

  DO k=1,np
    DO j=1,n
      DO i=1,m
        so2(i,j,k+1)=so2(i,j,k)+co2*789.*scal(i,j,k)
      END DO
    END DO
  END DO

!-----compute and update flux reduction due to co2 following
!  chou (J. Climate, 1990)

  CALL flxco2(m,n,np,so2,swh,csm,df)

!-----adjust for the effect of o2 cnd co2 on clear-sky fluxes.

  DO k=2,np+1
    DO j=1,n
      DO i=1,m
        flc(i,j,k)=flc(i,j,k)-df(i,j,k)
      END DO
    END DO
  END DO

!-----adjust for the all-sky fluxes due to o2 and co2.  It is
!  assumed that o2 and co2 have no effects on solar radiation
!  below clouds. clouds are assumed randomly overlapped.

  DO j=1,n
    DO i=1,m
      sdf(i,j)=0.0
      sclr(i,j)=1.0
    END DO
  END DO

  DO k=1,np
    DO j=1,n
      DO i=1,m

!-----sclr is the fraction of clear sky.
!  sdf is the flux reduction below clouds.

        IF(fcld(i,j,k) > 0.01) THEN
          sdf(i,j)=sdf(i,j)+df(i,j,k)*sclr(i,j)*fcld(i,j,k)
          sclr(i,j)=sclr(i,j)*(1.-fcld(i,j,k))
        END IF
        flx(i,j,k+1)=flx(i,j,k+1)-sdf(i,j)-df(i,j,k+1)*sclr(i,j)

      END DO
    END DO
  END DO

!-----adjust for the direct downward ir flux.
  DO j=1,n
    DO i=1,m
      fdirir(i,j)=fdirir(i,j)-sdf(i,j)-df(i,j,np+1)*sclr(i,j)
    END DO
  END DO

!  write (6,'(a3,2a15)') 'k','flx','flc'
!  DO k=1,np
!    write (6,'(i3,2e15.8)') k,flx(1,1,k),flc(1,1,k)
!  ENDDO
!
!  write (6,'(4a15)')
!    : 'fdirir','fdifir','fdirpar','fdifpar'
!
!  write (6,'(4e15.8)')
!    :  fdirir(1,1),fdifir(1,1),fdirpar(1,1),fdifpar(1,1)

  RETURN
END SUBROUTINE sorad
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE SOLIR                      ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######                University of Oklahoma                ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE solir(idim,jdim,                                             &
           m,n,np,wh,taucldi,taucldl,tauclb,tauclf,reffi,reffl,         &
           ict,icb,fcld,cc,taual,csm,rsirbm,rsirdf,                     &
           flx,flc,fdirir,fdifir,                                       &
           fsdir,fsdif, ssaclt,asyclt,                                  &
           rr1t,tt1t,td1t,rs1t,ts1t,                                    &
           rr2t,tt2t,td2t,rs2t,ts2t,                                    &
           ssacl,asycl,fall,fclr,                                       &
           rr,tt,td,rs,ts,                                              &
           tem2d1,tem2d2,tem2d3,tem2d4,tem2d5,                          &
           tem3d,                                                       &
           tem5d1,tem5d2,tem5d3,tem5d4,tem5d5)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Calculate solar flux in the infrared region. The spectrum is
!  divided into three bands. (See original comments.)
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION:
!
!  03/11/1996 (Yuhe Liu)
!  Modified the original code from 1-D to 3-D
!
!  12/14/1998 (Keith Brewster)
!  Modified values of ssaal and asymal in data statement.
!
!-----------------------------------------------------------------------
!
!  ORIGINAL COMMENTS:
!
!************************************************************************
!  compute solar flux in the infrared region. The spectrum is divided
!   into three bands:
!
!       band   wavenumber(/cm)  wavelength (micron)
!        1       1000-4400         2.27-10.0
!        2       4400-8200         1.22-2.27
!        3       8200-14300        0.70-1.22
!
!----- Input parameters:                            units      size
!
!   number of soundings in zonal direction (m)       n/d        1
!   number of soundings in meridional direction (n)  n/d        1
!   maximum number of soundings in                   n/d        1
!       meridional direction (ndim)
!   number of atmospheric layers (np)                n/d        1
!   layer water vapor content (wh)                 gm/cm^2    m*n*np
!   cloud optical thickness (taucld)                 n/d      m*ndim*np*2
!       index 1 for ice paticles
!       index 2 for liquid particles
!   scaled cloud optical thickness                   n/d      m*n*np
!       for beam radiation (tauclb)
!   scaled cloud optical thickness                   n/d      m*n*np
!       for diffuse radiation  (tauclf)
!   effective cloud-particle size (reff)           micrometer m*ndim*np*2
!       index 1 for ice paticles
!       index 2 for liquid particles
!   level index separating high and                  n/d      m*n
!       middle clouds (ict)
!   level index separating middle and                n/d      m*n
!       low clouds (icb)
!   cloud amount (fcld)                            fraction   m*ndim*np
!   cloud amount of high, middle, and                n/d      m*n*3
!       low clouds (cc)
!   aerosol optical thickness (taual)                n/d      m*ndim*np
!   cosecant of the solar zenith angle (csm)         n/d      m*n
!   near ir surface albedo for beam                fraction   m*ndim
!             radiation (rsirbm)
!   near ir surface albedo for diffuse             fraction   m*ndim
!             radiation (rsirdf)
!
!----- output (updated) parameters:
!
!   all-sky flux (downward-upward) (flx)           fraction   m*ndim*(np+1)
!   clear-sky flux (downward-upward) (flc)         fraction   m*ndim*(np+1)
!   all-sky direct downward ir flux at
!       the surface (fdirir)                    fraction   m*ndim
!   all-sky diffuse downward ir flux at
!       the surface (fdifir)                    fraction   m*ndim
!
!----- note: the following parameters must be specified by users:
!   aerosol single scattering albedo (ssaal)         n/d      nband
!   aerosol asymmetry factor (asyal)                 n/d      nband
!
!*************************************************************************
!
!fpp$ expand (expmn)
!fpp$ expand (deledd)
!fpp$ expand (sagpol)
!!dir$ inline always expmn,deledd,sagpol
!*$*  inline routine (expmn,deledd,sagpol)
!
!-----------------------------------------------------------------------
!
!  Variable declarations
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

!-----input parameters

  INTEGER :: idim,jdim
  INTEGER :: m,n,np,ict,icb

  REAL :: taucldi(idim,jdim,np)
  REAL :: taucldl(idim,jdim,np)
  REAL :: reffi(idim,jdim,np)
  REAL :: reffl(idim,jdim,np)
  REAL :: fcld(idim,jdim,np)
  REAL :: rsirbm(idim,jdim)
  REAL :: rsirdf(idim,jdim)
  REAL :: taual(idim,jdim,np)

  REAL :: tauclb(m,n,np)
  REAL :: tauclf(m,n,np)
  REAL :: cc(m,n,3)
  REAL :: wh(m,n,np)
  REAL :: csm(m,n)

!-----output (updated) parameters

  REAL :: flx(idim,jdim,np+1)
  REAL :: flc(idim,jdim,np+1)
  REAL :: fdirir(idim,jdim)
  REAL :: fdifir(idim,jdim)

!-----static parameters

  INTEGER :: nk,nband
  PARAMETER (nk=10,nband=3)
  REAL :: xk(nk),hk(nband,nk),ssaal(nband),asyal(nband)
  REAL :: aia(nband,3),awa(nband,3),aig(nband,3),awg(nband,3)

!-----temporary array

  REAL :: fsdir(m,n)
  REAL :: fsdif(m,n)

  REAL :: ssaclt(m,n)
  REAL :: asyclt(m,n)
  REAL :: rr1t(m,n)
  REAL :: tt1t(m,n)
  REAL :: td1t(m,n)
  REAL :: rs1t(m,n)
  REAL :: ts1t(m,n)
  REAL :: rr2t(m,n)
  REAL :: tt2t(m,n)
  REAL :: td2t(m,n)
  REAL :: rs2t(m,n)
  REAL :: ts2t(m,n)

  REAL :: ssacl(m,n,np)
  REAL :: asycl(m,n,np)
  REAL :: fall(m,n,np+1)
  REAL :: fclr(m,n,np+1)

  REAL :: rr(m,n,np+1,2)
  REAL :: tt(m,n,np+1,2)
  REAL :: td(m,n,np+1,2)
  REAL :: rs(m,n,np+1,2)
  REAL :: ts(m,n,np+1,2)

!-----temporary arrays used in subroutine cldflx

  REAL :: tem2d1(m,n)
  REAL :: tem2d2(m,n)
  REAL :: tem2d3(m,n)
  REAL :: tem2d4(m,n)
  REAL :: tem2d5(m,n)

  REAL :: tem3d (m,n,np+1)

  REAL :: tem5d1(m,n,np+1,2,2)
  REAL :: tem5d2(m,n,np+1,2,2)
  REAL :: tem5d3(m,n,np+1,2,2)
  REAL :: tem5d4(m,n,np+1,2,2)
  REAL :: tem5d5(m,n,np+1,2,2)

!-----temporary variables

  INTEGER :: ib,ik,i,j,k

  REAL :: tauwv,tausto,ssatau,asysto,tauto,ssato,asyto
  REAL :: taux,reff1,reff2,w1,w2,g1,g2

!-----function

  REAL :: expmn

!-----water vapor absorption coefficient for 10 k-intervals.
!  unit: cm^2/gm

  DATA xk/                                                              &
      0.0010, 0.0133, 0.0422, 0.1334, 0.4217,                           &
      1.334,  5.623,  31.62,  177.8,  1000.0/

!-----water vapor k-distribution function,
!  the sum of hk is 0.52926. unit: fraction

  DATA hk/                                                              &
      .01074,.08236,.20673,  .00360,.01157,.03497,                      &
      .00411,.01133,.03011,  .00421,.01143,.02260,                      &
      .00389,.01240,.01336,  .00326,.01258,.00696,                      &
      .00499,.01381,.00441,  .00465,.00650,.00115,                      &
      .00245,.00244,.00026,  .00145,.00094,.00000/

!-----aerosol single-scattering albedo and asymmetry factor

!  data ssaal,asyal/nband*0.999,nband*0.850/
  DATA ssaal/0.75,0.55,0.90/
  DATA asyal/0.40,0.50,0.60/

!  data ssaal,asyal/nband*0.400,nband*0.500/

!-----coefficients for computing the single scattering albedo of
!  ice clouds from ssa=1-(aia(*,1)+aia(*,2)*reff+aia(*,3)*reff**2)

  DATA aia/                                                             &
      .08938331, .00215346,-.00000260,                                  &
      .00299387, .00073709, .00000746,                                  &
      -.00001038,-.00000134, .00000000/

!-----coefficients for computing the single scattering albedo of
!  liquid clouds from ssa=1-(awa(*,1)+awa(*,2)*reff+awa(*,3)*reff**2)

  DATA awa/                                                             &
      .01209318,-.00019934, .00000007,                                  &
      .01784739, .00088757, .00000845,                                  &
      -.00036910,-.00000650,-.00000004/

!-----coefficients for computing the asymmetry factor of ice clouds
!  from asycl=aig(*,1)+aig(*,2)*reff+aig(*,3)*reff**2

  DATA aig/                                                             &
      .84090400, .76098937, .74935228,                                  &
      .00126222, .00141864, .00119715,                                  &
      -.00000385,-.00000396,-.00000367/

!-----coefficients for computing the asymmetry factor of liquid clouds
!  from asycl=awg(*,1)+awg(*,2)*reff+awg(*,3)*reff**2

  DATA awg/                                                             &
      .83530748, .74513197, .79375035,                                  &
      .00257181, .01370071, .00832441,                                  &
      .00005519,-.00038203,-.00023263/
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!

!-----initialize surface fluxes, reflectances, and transmittances

  DO j= 1, n
    DO i= 1, m
      fdirir(i,j)=0.0
      fdifir(i,j)=0.0
      rr(i,j,np+1,1)=rsirbm(i,j)
      rr(i,j,np+1,2)=rsirdf(i,j)
      rs(i,j,np+1,1)=rsirbm(i,j)
      rs(i,j,np+1,2)=rsirdf(i,j)
      td(i,j,np+1,1)=0.0
      td(i,j,np+1,2)=0.0
      tt(i,j,np+1,1)=0.0
      tt(i,j,np+1,2)=0.0
      ts(i,j,np+1,1)=0.0
      ts(i,j,np+1,2)=0.0
    END DO
  END DO

!-----integration over spectral bands

  DO ib=1,nband

!-----compute cloud single scattering albedo and asymmetry factor
!  for a mixture of ice and liquid particles.

    DO k= 1, np

      DO j= 1, n
        DO i= 1, m

          ssaclt(i,j)=1.0
          asyclt(i,j)=1.0

          taux=taucldi(i,j,k)+taucldl(i,j,k)
          IF (taux > 0.05 .AND. fcld(i,j,k) > 0.01) THEN

            reff1=MIN(reffi(i,j,k),130.)
            reff2=MIN(reffl(i,j,k),20.0)

            w1=(1.-(aia(ib,1)+(aia(ib,2)+                               &
                aia(ib,3)*reff1)*reff1))*taucldi(i,j,k)
            w2=(1.-(awa(ib,1)+(awa(ib,2)+                               &
                awa(ib,3)*reff2)*reff2))*taucldl(i,j,k)
            ssaclt(i,j)=(w1+w2)/taux

            g1=(aig(ib,1)+(aig(ib,2)+aig(ib,3)*reff1)*reff1)*w1
            g2=(awg(ib,1)+(awg(ib,2)+awg(ib,3)*reff2)*reff2)*w2
            asyclt(i,j)=(g1+g2)/(w1+w2)

          END IF

        END DO
      END DO

      DO j=1,n
        DO i=1,m
          ssacl(i,j,k)=ssaclt(i,j)
        END DO
      END DO
      DO j=1,n
        DO i=1,m
          asycl(i,j,k)=asyclt(i,j)
        END DO
      END DO

    END DO

!-----integration over the k-distribution function

    DO ik=1,nk

      DO k= 1, np

        DO j= 1, n
          DO i= 1, m

            tauwv=xk(ik)*wh(i,j,k)

!-----compute total optical thickness, single scattering albedo,
!  and asymmetry factor.

            tausto=tauwv+taual(i,j,k)+1.0E-8
            ssatau=ssaal(ib)*taual(i,j,k)
            asysto=asyal(ib)*ssaal(ib)*taual(i,j,k)

!-----compute reflectance and transmittance for cloudless layers

            tauto=tausto
            ssato=ssatau/tauto+1.0E-8

            IF (ssato > 0.001) THEN

              ssato=MIN(ssato,0.999999)
              asyto=asysto/(ssato*tauto)

              CALL deledd (tauto,ssato,asyto,csm(i,j),                  &
                           rr1t(i,j),tt1t(i,j),td1t(i,j))

              CALL sagpol (tauto,ssato,asyto,rs1t(i,j),ts1t(i,j))

            ELSE

              td1t(i,j)=expmn(-tauto*csm(i,j))
              ts1t(i,j)=expmn(-1.66*tauto)
              tt1t(i,j)=0.0
              rr1t(i,j)=0.0
              rs1t(i,j)=0.0

            END IF

!-----compute reflectance and transmittance for cloud layers

            IF (tauclb(i,j,k) < 0.01) THEN

              rr2t(i,j)=rr1t(i,j)
              tt2t(i,j)=tt1t(i,j)
              td2t(i,j)=td1t(i,j)
              rs2t(i,j)=rs1t(i,j)
              ts2t(i,j)=ts1t(i,j)

            ELSE

              tauto=tausto+tauclb(i,j,k)
              ssato=(ssatau+ssacl(i,j,k)*tauclb(i,j,k))/tauto+1.0E-8
              ssato=MIN(ssato,0.999999)
              asyto=(asysto+asycl(i,j,k)*ssacl(i,j,k)*tauclb(i,j,k))/   &
                    (ssato*tauto)

              CALL deledd (tauto,ssato,asyto,csm(i,j),                  &
                           rr2t(i,j),tt2t(i,j),td2t(i,j))

              tauto=tausto+tauclf(i,j,k)
              ssato=(ssatau+ssacl(i,j,k)*tauclf(i,j,k))/tauto+1.0E-8
              ssato=MIN(ssato,0.999999)
              asyto=(asysto+asycl(i,j,k)*ssacl(i,j,k)*tauclf(i,j,k))/   &
                    (ssato*tauto)

              CALL sagpol (tauto,ssato,asyto,rs2t(i,j),ts2t(i,j))

            END IF

          END DO
        END DO

        DO j=1,n
          DO i=1,m
            rr(i,j,k,1)=rr1t(i,j)
          END DO
        END DO
        DO j=1,n
          DO i=1,m
            tt(i,j,k,1)=tt1t(i,j)
          END DO
        END DO
        DO j=1,n
          DO i=1,m
            td(i,j,k,1)=td1t(i,j)
          END DO
        END DO
        DO j=1,n
          DO i=1,m
            rs(i,j,k,1)=rs1t(i,j)
          END DO
        END DO
        DO j=1,n
          DO i=1,m
            ts(i,j,k,1)=ts1t(i,j)
          END DO
        END DO

        DO j=1,n
          DO i=1,m
            rr(i,j,k,2)=rr2t(i,j)
          END DO
        END DO
        DO j=1,n
          DO i=1,m
            tt(i,j,k,2)=tt2t(i,j)
          END DO
        END DO
        DO j=1,n
          DO i=1,m
            td(i,j,k,2)=td2t(i,j)
          END DO
        END DO
        DO j=1,n
          DO i=1,m
            rs(i,j,k,2)=rs2t(i,j)
          END DO
        END DO
        DO j=1,n
          DO i=1,m
            ts(i,j,k,2)=ts2t(i,j)
          END DO
        END DO

      END DO

!-----flux calculations

      CALL cldflx (m,n,np,ict,icb,cc,rr,tt,td,rs,ts,                    &
                   fclr,fall,fsdir,fsdif,                               &
                   tem2d1,tem2d2,tem2d3,tem2d4,tem2d5,                  &
                   tem3d, tem5d1,tem5d2,tem5d3,tem5d4,tem5d5)

      DO k= 1, np+1
        DO j= 1, n
          DO i= 1, m
            flx(i,j,k) = flx(i,j,k)+fall(i,j,k)*hk(ib,ik)
          END DO
        END DO
        DO j= 1, n
          DO i= 1, m
            flc(i,j,k) = flc(i,j,k)+fclr(i,j,k)*hk(ib,ik)
          END DO
        END DO
      END DO

!  write (6,'(a/2a3,2a15)') 'Flux for IR',
!    :  'ib','k','dflxIR','flxIR'
!  DO k=1,np
!    write (6,'(2i3,2e15.7)')
!    :  ib,k,fall(2,2,k+1)-fall(2,2,k),fall(2,2,k)
!  ENDDO

      DO j= 1, n
        DO i= 1, m
          fdirir(i,j) = fdirir(i,j)+fsdir(i,j)*hk(ib,ik)
          fdifir(i,j) = fdifir(i,j)+fsdif(i,j)*hk(ib,ik)
        END DO
      END DO

    END DO
  END DO

  RETURN
END SUBROUTINE solir
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE SOLUV                      ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE soluv(idim,jdim,                                             &
           m,n,np,oh,dp,taucldi,taucldl,tauclb,tauclf,reffi,reffl,      &
           ict,icb,fcld,cc,taual,csm,rsuvbm,rsuvdf,                     &
           flx,flc,fdirpar,fdifpar,                                     &
           fsdir,fsdif,asyclt,                                          &
           rr1t,tt1t,td1t,rs1t,ts1t,                                    &
           rr2t,tt2t,td2t,rs2t,ts2t,                                    &
           asycl,fall,fclr,                                             &
           td,rr,tt,rs,ts,                                              &
           tem2d1,tem2d2,tem2d3,tem2d4,tem2d5,                          &
           tem3d,                                                       &
           tem5d1,tem5d2,tem5d3,tem5d4,tem5d5)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Calculate solar fluxes in the uv+visible region. the spectrum is
!  grouped into 8 bands. (See original comments.)
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Adapted the original code and formatted it in accordance with the
!  ARPS coding standard.
!
!  12/07/1998 (Keith Brewster)
!  Modified values of ssaal and asymal in data statement.
!
!-----------------------------------------------------------------------
!
!  ORIGINAL COMMENTS:
!
!************************************************************************
!  compute solar fluxes in the uv+visible region. the spectrum is
!  grouped into 8 bands:
!
!           Band     Micrometer
!
!    UV-C    1.     .175 - .225
!            2.     .225 - .245
!                   .260 - .280
!            3.     .245 - .260
!
!    UV-B    4.     .280 - .295
!            5.     .295 - .310
!            6.     .310 - .320
!
!    UV-A    7.     .320 - .400
!
!    PAR     8.     .400 - .700
!
!----- Input parameters:                            units      size
!
!   number of soundings in zonal direction (m)       n/d        1
!   number of soundings in meridional direction (n)  n/d        1
!   maximum number of soundings in                   n/d        1
!        meridional direction (ndim)
!   number of atmospheric layers (np)                n/d        1
!   layer ozone content (oh)                      (cm-atm)stp m*n*np
!   layer pressure thickness (dp)                    mb       m*n*np
!   cloud optical thickness (taucld)                 n/d      m*ndim*np*2
!       index 1 for ice paticles
!       index 2 for liquid particles
!   scaled cloud optical thickness                   n/d      m*n*np
!       for beam radiation (tauclb)
!   scaled cloud optical thickness                   n/d      m*n*np
!       for diffuse radiation  (tauclf)
!   effective cloud-particle size (reff)           micrometer m*ndim*np*2
!       index 1 for ice paticles
!       index 2 for liquid particles
!   level indiex separating high and                 n/d      m*n
!       middle clouds (ict)
!   level indiex separating middle and               n/d      m*n
!       low clouds (icb)
!   cloud amount (fcld)                            fraction   m*ndim*np
!   cloud amounts of high, middle, and               n/d      m*n*3
!       low clouds (cc)
!   aerosol optical thickness (taual)                n/d      m*ndim*np
!   cosecant of the solar zenith angle (csm)         n/d      m*n
!   uv+par surface albedo for beam                 fraction   m*ndim
!        radiation (rsuvbm)
!   uv+par surface albedo for diffuse              fraction   m*ndim
!        radiation (rsuvdf)
!
!----- output (updated) parameters:
!
!   all-sky net downward flux (flx)                fraction   m*ndim*(np+1)
!   clear-sky net downward flux (flc)              fraction   m*ndim*(np+1)
!   all-sky direct downward par flux at
!       the surface (fdirpar)                   fraction   m*ndim
!   all-sky diffuse downward par flux at
!       the surface (fdifpar)                   fraction   m*ndim
!
!----- note: the following parameters must be specified by users:
!
!   aerosol single scattering albedo (ssaal)         n/d        1
!   aerosol asymmetry factor (asyal)                 n/d        1
!
!
!***********************************************************************
!
!fpp$ expand (deledd)
!fpp$ expand (sagpol)
!!dir$ inline always deledd,sagpol
!*$*  inline routine (deledd,sagpol)
!
!-----------------------------------------------------------------------
!
!  Variable Declarations.
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

!-----input parameters

  INTEGER :: idim,jdim
  INTEGER :: m,n,np,ict,icb

  REAL :: taucldi(idim,jdim,np)
  REAL :: taucldl(idim,jdim,np)
  REAL :: reffi(idim,jdim,np)
  REAL :: reffl(idim,jdim,np)
  REAL :: fcld(idim,jdim,np)
  REAL :: taual(idim,jdim,np)
  REAL :: rsuvbm(idim,jdim)
  REAL :: rsuvdf(idim,jdim)

  REAL :: tauclb(m,n,np)
  REAL :: tauclf(m,n,np)
  REAL :: cc(m,n,3)
  REAL :: oh(m,n,np)
  REAL :: dp(m,n,np)
  REAL :: csm(m,n)

!-----output (updated) parameter

  REAL :: flx(idim,jdim,np+1)
  REAL :: flc(idim,jdim,np+1)
  REAL :: fdirpar(idim,jdim)
  REAL :: fdifpar(idim,jdim)

!-----static parameters

  INTEGER :: nband
  PARAMETER (nband=8)
  REAL :: hk(nband)
  REAL :: xk(nband)
  REAL :: ry(nband)
  REAL :: asyal(nband)
  REAL :: ssaal(nband)
  REAL :: aig(3)
  REAL :: awg(3)

!-----temporary array

  REAL :: fsdir(m,n)
  REAL :: fsdif(m,n)
  REAL :: asyclt(m,n)
  REAL :: rr1t(m,n)
  REAL :: tt1t(m,n)
  REAL :: td1t(m,n)
  REAL :: rs1t(m,n)
  REAL :: ts1t(m,n)
  REAL :: rr2t(m,n)
  REAL :: tt2t(m,n)
  REAL :: td2t(m,n)
  REAL :: rs2t(m,n)
  REAL :: ts2t(m,n)

  REAL :: asycl(m,n,np)
  REAL :: fall(m,n,np+1)
  REAL :: fclr(m,n,np+1)

  REAL :: td(m,n,np+1,2)
  REAL :: rr(m,n,np+1,2)
  REAL :: tt(m,n,np+1,2)
  REAL :: rs(m,n,np+1,2)
  REAL :: ts(m,n,np+1,2)

!-----temporary arrays used in subroutine cldflx

  REAL :: tem2d1(m,n)
  REAL :: tem2d2(m,n)
  REAL :: tem2d3(m,n)
  REAL :: tem2d4(m,n)
  REAL :: tem2d5(m,n)

  REAL :: tem3d (m,n,np+1)

  REAL :: tem5d1(m,n,np+1,2,2)
  REAL :: tem5d2(m,n,np+1,2,2)
  REAL :: tem5d3(m,n,np+1,2,2)
  REAL :: tem5d4(m,n,np+1,2,2)
  REAL :: tem5d5(m,n,np+1,2,2)

!-----temporary variables

  INTEGER :: i,j,k,ib
  REAL :: taurs,tauoz,tausto,ssatau,asysto,tauto,ssato,asyto
  REAL :: taux,reff1,reff2,g1,g2

!-----hk is the fractional extra-terrestrial solar flux.
!  the sum of hk is 0.47074.

  DATA hk/.00057, .00367, .00083, .00417,                               &
          .00600, .00556, .05913, .39081/

!-----xk is the ozone absorption coefficient. unit: /(cm-atm)stp

  DATA xk /30.47, 187.2,  301.9,   42.83,                               &
           7.09,  1.25,   0.0345,  0.0539/

!-----ry is the extinction coefficient for Rayleigh scattering.
!  unit: /mb.

  DATA ry /.00604, .00170, .00222, .00132,                              &
           .00107, .00091, .00055, .00012/

!-----aerosol single-scattering albedo and asymmetry factor

!  data ssaal,asyal/nband*0.999,nband*0.850/
  DATA ssaal,asyal/nband*0.960,nband*0.700/

!-----coefficients for computing the asymmetry factor of ice clouds
!  from asycl=aig(*,1)+aig(*,2)*reff+aig(*,3)*reff**2

  DATA aig/.74625000,.00105410,-.00000264/

!-----coefficients for computing the asymmetry factor of liquid
!  clouds from asycl=awg(*,1)+awg(*,2)*reff+awg(*,3)*reff**2

  DATA awg/.82562000,.00529000,-.00014866/

!-----initialize surface reflectances and transmittances

!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
  DO j= 1, n
    DO i= 1, m
      rr(i,j,np+1,1)=rsuvbm(i,j)
      rr(i,j,np+1,2)=rsuvdf(i,j)
      rs(i,j,np+1,1)=rsuvbm(i,j)
      rs(i,j,np+1,2)=rsuvdf(i,j)
      td(i,j,np+1,1)=0.0
      td(i,j,np+1,2)=0.0
      tt(i,j,np+1,1)=0.0
      tt(i,j,np+1,2)=0.0
      ts(i,j,np+1,1)=0.0
      ts(i,j,np+1,2)=0.0
    END DO
  END DO

!-----compute cloud asymmetry factor for a mixture of
!  liquid and ice particles.  unit of reff is micrometers.

  DO k= 1, np

    DO j= 1, n
      DO i= 1, m

        asyclt(i,j)=1.0

        taux=taucldi(i,j,k)+taucldl(i,j,k)
        IF (taux > 0.05 .AND. fcld(i,j,k) > 0.01) THEN

          reff1=MIN(reffi(i,j,k),130.)
          reff2=MIN(reffl(i,j,k),20.0)

          g1=(aig(1)+(aig(2)+aig(3)*reff1)*reff1)*taucldi(i,j,k)
          g2=(awg(1)+(awg(2)+awg(3)*reff2)*reff2)*taucldl(i,j,k)
          asyclt(i,j)=(g1+g2)/taux

        END IF

      END DO
    END DO

    DO j=1,n
      DO i=1,m
        asycl(i,j,k)=asyclt(i,j)
      END DO
    END DO

  END DO

!-----integration over spectral bands

  DO ib=1,nband

    DO k= 1, np

      DO j= 1, n
        DO i= 1, m

!-----compute ozone and rayleigh optical thicknesses

          taurs=ry(ib)*dp(i,j,k)
          tauoz=xk(ib)*oh(i,j,k)

!-----compute total optical thickness, single scattering albedo,
!  and asymmetry factor

          tausto=taurs+tauoz+taual(i,j,k)+1.0E-8
          ssatau=ssaal(ib)*taual(i,j,k)+taurs
          asysto=asyal(ib)*ssaal(ib)*taual(i,j,k)

!-----compute reflectance and transmittance for cloudless layers

          tauto=tausto
          ssato=ssatau/tauto+1.0E-8
          ssato=MIN(ssato,0.999999)
          asyto=asysto/(ssato*tauto)

          CALL deledd (tauto,ssato,asyto,csm(i,j),                      &
                       rr1t(i,j),tt1t(i,j),td1t(i,j))

          CALL sagpol (tauto,ssato,asyto,rs1t(i,j),ts1t(i,j))

!-----compute reflectance and transmittance for cloud layers

          IF (tauclb(i,j,k) < 0.01) THEN

            rr2t(i,j)=rr1t(i,j)
            tt2t(i,j)=tt1t(i,j)
            td2t(i,j)=td1t(i,j)
            rs2t(i,j)=rs1t(i,j)
            ts2t(i,j)=ts1t(i,j)

          ELSE

            tauto=tausto+tauclb(i,j,k)
            ssato=(ssatau+tauclb(i,j,k))/tauto+1.0E-8
            ssato=MIN(ssato,0.999999)
            asyto=(asysto+asycl(i,j,k)*tauclb(i,j,k))/(ssato*tauto)

            CALL deledd (tauto,ssato,asyto,csm(i,j),                    &
                         rr2t(i,j),tt2t(i,j),td2t(i,j))

            tauto=tausto+tauclf(i,j,k)
            ssato=(ssatau+tauclf(i,j,k))/tauto+1.0E-8
            ssato=MIN(ssato,0.999999)
            asyto=(asysto+asycl(i,j,k)*tauclf(i,j,k))/(ssato*tauto)

            CALL sagpol (tauto,ssato,asyto,rs2t(i,j),ts2t(i,j))

          END IF

        END DO
      END DO

      DO j=1,n
        DO i=1,m
          rr(i,j,k,1)=rr1t(i,j)
        END DO
      END DO
      DO j=1,n
        DO i=1,m
          tt(i,j,k,1)=tt1t(i,j)
        END DO
      END DO
      DO j=1,n
        DO i=1,m
          td(i,j,k,1)=td1t(i,j)
        END DO
      END DO
      DO j=1,n
        DO i=1,m
          rs(i,j,k,1)=rs1t(i,j)
        END DO
      END DO
      DO j=1,n
        DO i=1,m
          ts(i,j,k,1)=ts1t(i,j)
        END DO
      END DO

      DO j=1,n
        DO i=1,m
          rr(i,j,k,2)=rr2t(i,j)
        END DO
      END DO
      DO j=1,n
        DO i=1,m
          tt(i,j,k,2)=tt2t(i,j)
        END DO
      END DO
      DO j=1,n
        DO i=1,m
          td(i,j,k,2)=td2t(i,j)
        END DO
      END DO
      DO j=1,n
        DO i=1,m
          rs(i,j,k,2)=rs2t(i,j)
        END DO
      END DO
      DO j=1,n
        DO i=1,m
          ts(i,j,k,2)=ts2t(i,j)
        END DO
      END DO

    END DO

!-----flux calculations

    CALL cldflx (m,n,np,ict,icb,cc,rr,tt,td,rs,ts,                      &
                 fclr,fall,fsdir,fsdif,                                 &
                 tem2d1,tem2d2,tem2d3,tem2d4,tem2d5,                    &
                 tem3d, tem5d1,tem5d2,tem5d3,tem5d4,tem5d5)

    DO k= 1, np+1
      DO j= 1, n
        DO i= 1, m
          flx(i,j,k)=flx(i,j,k)+fall(i,j,k)*hk(ib)
        END DO
      END DO
      DO j= 1, n
        DO i= 1, m
          flc(i,j,k)=flc(i,j,k)+fclr(i,j,k)*hk(ib)
        END DO
      END DO
    END DO

!  write (6,'(a/2a3,2a15)') 'Flux for PAR',
!    :  'ib','k','dflxpa','flxpa'
!  DO k=1,np
!    write (6,'(2i3,2e15.7)')
!    :  ib,k,fall(2,2,k+1)-fall(2,2,k),fall(2,2,k)
!  ENDDO

    IF(ib == 8) THEN
      DO j=1,n
        DO i=1,m
          fdirpar(i,j)=fsdir(i,j)*hk(ib)
          fdifpar(i,j)=fsdif(i,j)*hk(ib)
        END DO
      END DO
    END IF

  END DO

  RETURN
END SUBROUTINE soluv
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE CLDSCALE                   ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######                University of Oklahoma                ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE cldscale(idim,jdim,                                          &
           m,n,np,cosz,fcld,taucldi,taucldl,ict,icb,                    &
           cc,tauclb,tauclf)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Calculate the covers of high, middle, and low clouds and scales
!  the cloud optical thickness.
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION:
!
!  03/11/1996 (Yuhe Liu)
!  Formatted code to ARPS standard format
!
!-----------------------------------------------------------------------
!
!  ORIGINAL COMMENTS:
!
!********************************************************************
!
!   This subroutine computes the covers of high, middle, and
!    low clouds and scales the cloud optical thickness.
!
!   To simplify calculations in a cloudy atmosphere, clouds are
!    grouped into high, middle and low clouds separated by the levels
!    ict and icb (level 1 is the top of the atmosphere).
!
!   Within each of the three groups, clouds are assumed maximally
!    overlapped, and the cloud cover (cc) of a group is the maximum
!    cloud cover of all the layers in the group.  The optical thickness
!    (taucld) of a given layer is then scaled to new values (tauclb and
!    tauclf) so that the layer reflectance corresponding to the cloud
!    cover cc is the same as the original reflectance with optical
!    thickness taucld and cloud cover fcld.
!
!---input parameters
!
!    number of grid intervals in zonal direction (m)
!    number of grid intervals in meridional direction (n)
!    maximum number of grid intervals in meridional direction (ndim)
!    number of atmospheric layers (np)
!    cosine of the solar zenith angle (cosz)
!    fractional cloud cover (fcld)
!    cloud optical thickness (taucld)
!    index separating high and middle clouds (ict)
!    index separating middle and low clouds (icb)
!
!---output parameters
!
!    fractional cover of high, middle, and low clouds (cc)
!    scaled cloud optical thickness for beam radiation (tauclb)
!    scaled cloud optical thickness for diffuse radiation (tauclf)
!
!********************************************************************
!
!-----------------------------------------------------------------------
!
!  Variable declarations
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

!-----input parameters

  INTEGER :: idim,jdim
  INTEGER :: m,n,np,ict,icb

  REAL :: cosz(idim,jdim)
  REAL :: fcld(idim,jdim,np)
  REAL :: taucldi(idim,jdim,np)
  REAL :: taucldl(idim,jdim,np)

!-----output parameters

  REAL :: cc(m,n,3)
  REAL :: tauclb(m,n,np)
  REAL :: tauclf(m,n,np)

!-----temporary variables

  INTEGER :: i,j,k,im,it,ia,kk
  REAL :: fm,ft,fa,xai,taux

!-----pre-computed table

  INTEGER :: nm,nt,na
  PARAMETER (nm=11,nt=9,na=11)
  REAL :: dm,dt,da,t1,caib(nm,nt,na),caif(nt,na)
  PARAMETER (dm=0.1,dt=0.30103,da=0.1,t1=-0.9031)

!-----include the pre-computed table for cai

!  include "cai.dat"
!  save caib,caif

  COMMON /radtab004/ caib,caif
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!

!-----clouds within each of the high, middle, and low clouds are
!  assumed maximally overlapped, and the cloud cover (cc)
!  for a group is the maximum cloud cover of all the layers
!  in the group

  DO j=1,n
    DO i=1,m
      cc(i,j,1)=0.0
      cc(i,j,2)=0.0
      cc(i,j,3)=0.0
    END DO
  END DO

!!!  print *,'  ict,icb = ',ict,icb

  DO k=1,ict-1
    DO j=1,n
      DO i=1,m
        cc(i,j,1)=MAX(cc(i,j,1),fcld(i,j,k))
      END DO
    END DO
  END DO

  DO k=ict,icb-1
    DO j=1,n
      DO i=1,m
        cc(i,j,2)=MAX(cc(i,j,2),fcld(i,j,k))
      END DO
    END DO
  END DO

  DO k=icb,np
    DO j=1,n
      DO i=1,m
        cc(i,j,3)=MAX(cc(i,j,3),fcld(i,j,k))
      END DO
    END DO
  END DO

!!!  print *,cc(1,1,1),cc(1,1,2),cc(1,1,3)

!-----scale the cloud optical thickness.
!  taucldi(i,j,k) is the optical thickness for ice particles, and
!  taucldl(i,j,k) is the optical thickness for liquid particles.

  DO k=1,np

    IF(k < ict) THEN
      kk=1
    ELSE IF(k >= ict .AND. k < icb) THEN
      kk=2
    ELSE
      kk=3
    END IF

    DO j=1,n
      DO i=1,m

        tauclb(i,j,k) = 0.0
        tauclf(i,j,k) = 0.0

        taux=taucldi(i,j,k)+taucldl(i,j,k)
        IF (taux > 0.05 .AND. fcld(i,j,k) > 0.01) THEN

!-----normalize cloud cover

          fa=fcld(i,j,k)/cc(i,j,kk)

!-----table look-up

          taux=MIN(taux,32.)

          fm=cosz(i,j)/dm
          ft=(LOG10(taux)-t1)/dt
          fa=fa/da

          im=INT(fm+1.5)
          it=INT(ft+1.5)
          ia=INT(fa+1.5)

          im=MAX(im,2)
          it=MAX(it,2)
          ia=MAX(ia,2)

          im=MIN(im,nm-1)
          it=MIN(it,nt-1)
          ia=MIN(ia,na-1)

          fm=fm-FLOAT(im-1)
          ft=ft-FLOAT(it-1)
          fa=fa-FLOAT(ia-1)

!-----scale cloud optical thickness for beam radiation.
!  the scaling factor, xai, is a function of the solar zenith
!  angle, optical thickness, and cloud cover.

          xai=    (-caib(im-1,it,ia)*(1.-fm)+                           &
              caib(im+1,it,ia)*(1.+fm))*fm*.5+caib(im,it,ia)*(1.-fm*fm)

          xai=xai+(-caib(im,it-1,ia)*(1.-ft)+                           &
              caib(im,it+1,ia)*(1.+ft))*ft*.5+caib(im,it,ia)*(1.-ft*ft)

          xai=xai+(-caib(im,it,ia-1)*(1.-fa)+                           &
              caib(im,it,ia+1)*(1.+fa))*fa*.5+caib(im,it,ia)*(1.-fa*fa)

          xai= xai-2.*caib(im,it,ia)
          xai=MAX(xai,0.0)

          tauclb(i,j,k) = taux*xai

!-----scale cloud optical thickness for diffuse radiation.
!  the scaling factor, xai, is a function of the cloud optical
!  thickness and cover but not the solar zenith angle.

          xai=    (-caif(it-1,ia)*(1.-ft)+                              &
              caif(it+1,ia)*(1.+ft))*ft*.5+caif(it,ia)*(1.-ft*ft)

          xai=xai+(-caif(it,ia-1)*(1.-fa)+                              &
              caif(it,ia+1)*(1.+fa))*fa*.5+caif(it,ia)*(1.-fa*fa)

          xai= xai-caif(it,ia)
          xai=MAX(xai,0.0)

          tauclf(i,j,k) = taux*xai

        END IF

      END DO
    END DO
  END DO

  RETURN
END SUBROUTINE cldscale
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE FLXCO2                     ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE flxco2(m,n,np,swc,swh,csm,df)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Calculate the reduction of clear-sky downward solar flux
!  due to co2 absorption.
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Adopted the original code and formatted it in accordance with the
!  ARPS coding standard.
!
!-----------------------------------------------------------------------
!
!  ORIGINAL COMMENTS:
!
!*****************************************************************
!
!-----compute the reduction of clear-sky downward solar flux
!  due to co2 absorption.
!
!-----------------------------------------------------------------------
!
!  Variable Declarations.
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

!-----input parameters

  INTEGER :: m,n,np

  REAL :: csm(m,n)
  REAL :: swc(m,n,np+1)
  REAL :: swh(m,n,np+1)
  REAL :: cah(22,19)

!-----output (undated) parameter

  REAL :: df(m,n,np+1)

!-----temporary variables

  INTEGER :: i,j,k,ic,iw
  REAL :: xx,CLOG,wlog,dc,dw,x1,x2,y2

!********************************************************************
!-----include co2 look-up table
!
!  include "cah.dat"
!  save cah

  COMMON /radtab005/ cah
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!

!********************************************************************
!-----table look-up for the reduction of clear-sky solar
!  radiation due to co2. The fraction 0.0343 is the
!  extraterrestrial solar flux in the co2 bands.

!  write (6,'(a/3a3,7a10)') 'Flux reduction due to co2, i=j=3',
!    :'k','ic','iw','x1','y2','x1-y2','ddf','df','swc','swh'

  DO k= 2, np+1
    DO j= 1, n
      DO i= 1, m
        xx=1./.3
        CLOG=LOG10(swc(i,j,k)*csm(i,j))
        wlog=LOG10(swh(i,j,k)*csm(i,j))
        ic=INT( (CLOG+3.15)*xx+1.)
        iw=INT( (wlog+4.15)*xx+1.)
        IF(ic < 2)ic=2
        IF(iw < 2)iw=2
        IF(ic > 22)ic=22
        IF(iw > 19)iw=19
        dc=CLOG-FLOAT(ic-2)*.3+3.
        dw=wlog-FLOAT(iw-2)*.3+4.
        x1=cah(1,iw-1)+(cah(1,iw)-cah(1,iw-1))*xx*dw
        x2=cah(ic-1,iw-1)+(cah(ic-1,iw)-cah(ic-1,iw-1))*xx*dw
        y2=x2+(cah(ic,iw-1)-cah(ic-1,iw-1))*xx*dc
        IF (x1 < y2) x1=y2
        df(i,j,k)=df(i,j,k)+0.0343*(x1-y2)
      END DO
    END DO

!    write (6,'(3i3,7f10.5)')
!    :  k,ic,iw,x1,y2,x1-y2,
!    :  df(3,3,k)-df(3,3,k-1),df (3,3,k),swc(3,3,k),swh(3,3,k)

  END DO

  RETURN
END SUBROUTINE flxco2
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE CLDFLX                     ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE cldflx(m,n,np,ict,icb,cc,rr,tt,td,rs,ts,                     &
           fclr,fall,fsdir,fsdif,                                       &
           ch,cm,ct,fdndir,fdndif,                                      &
           flxdn,                                                       &
           rra,tta,tda,rsa,rxa)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Calculate upward and downward fluxes using a two-stream adding
!  method.
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Adopted the original code and formatted it in accordance with the
!  ARPS coding standard.
!
!-----------------------------------------------------------------------
!
!  ORIGINAL COMMENTS:
!
!*******************************************************************
!  compute upward and downward fluxes using a two-stream adding method
!  following equations (3)-(5) of Chou (1992, JAS).
!
!  clouds are grouped into high, middle, and low clouds which are
!  assumed randomly overlapped. It involves eight sets of calculations.
!  In each set of calculations, each atmospheric layer is homogeneous,
!  either with clouds or without clouds.

!  input parameters:
!  m:   number of soundings in zonal direction
!  n:   number of soundings in meridional direction
!  np:  number of atmospheric layers
!  ict: the level separating high and middle clouds
!  icb: the level separating middle and low clouds
!  cc:  effective cloud covers for high, middle and low clouds
!  tt:  diffuse transmission of a layer illuminated by beam radiation
!  td:  direct beam tranmssion
!  ts:  transmission of a layer illuminated by diffuse radiation
!  rr:  reflection of a layer illuminated by beam radiation
!  rs:  reflection of a layer illuminated by diffuse radiation
!
!  output parameters:
!  fclr:  clear-sky flux (downward minus upward)
!  fall:  all-sky flux (downward minus upward)
!  fdndir: surface direct downward flux
!  fdndif: surface diffuse downward flux
!*********************************************************************c
!
!-----------------------------------------------------------------------
!
!  Variable Declarations.
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

!-----input parameters

  INTEGER :: m,n,np,ict,icb

  REAL :: rr(m,n,np+1,2)
  REAL :: tt(m,n,np+1,2)
  REAL :: td(m,n,np+1,2)
  REAL :: rs(m,n,np+1,2)
  REAL :: ts(m,n,np+1,2)
  REAL :: cc(m,n,3)

!-----output parameters

  REAL :: fclr(m,n,np+1)
  REAL :: fall(m,n,np+1)
  REAL :: fsdir(m,n)
  REAL :: fsdif(m,n)

!-----temporary array

  REAL :: ch(m,n)
  REAL :: cm(m,n)
  REAL :: ct(m,n)
  REAL :: fdndir(m,n)
  REAL :: fdndif(m,n)

  REAL :: flxdn(m,n,np+1)

  REAL :: rra(m,n,np+1,2,2)
  REAL :: tta(m,n,np+1,2,2)
  REAL :: tda(m,n,np+1,2,2)
  REAL :: rsa(m,n,np+1,2,2)
  REAL :: rxa(m,n,np+1,2,2)

!-----temporary variables

  INTEGER :: i,j,k,ih,im,is
  REAL :: fupdif
  REAL :: denm,xx
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!

!-----initialize all-sky flux (fall) and surface downward fluxes

  DO k=1,np+1
    DO j=1,n
      DO i=1,m
        fall(i,j,k)=0.0
      END DO
    END DO
  END DO

  DO j=1,n
    DO i=1,m
      fsdir(i,j)=0.0
      fsdif(i,j)=0.0
    END DO
  END DO

!-----compute transmittances and reflectances for a composite of
!  layers. layers are added one at a time, going down from the top.
!  tda is the composite transmittance illuminated by beam radiation
!  tta is the composite diffuse transmittance illuminated by
!      beam radiation
!  rsa is the composite reflectance illuminated from below
!      by diffuse radiation
!  tta and rsa are computed from eqs. (4b) and (3b) of Chou

!-----for high clouds. indices 1 and 2 denote clear and cloudy
!  situations, respectively.

  DO ih=1,2

    DO j= 1, n
      DO i= 1, m
        tda(i,j,1,ih,1)=td(i,j,1,ih)
        tta(i,j,1,ih,1)=tt(i,j,1,ih)
        rsa(i,j,1,ih,1)=rs(i,j,1,ih)
        tda(i,j,1,ih,2)=td(i,j,1,ih)
        tta(i,j,1,ih,2)=tt(i,j,1,ih)
        rsa(i,j,1,ih,2)=rs(i,j,1,ih)
      END DO
    END DO

    DO k= 2, ict-1
      DO j= 1, n
        DO i= 1, m
          denm = ts(i,j,k,ih)/( 1.-rsa(i,j,k-1,ih,1)*rs(i,j,k,ih))
          tda(i,j,k,ih,1)= tda(i,j,k-1,ih,1)*td(i,j,k,ih)
          tta(i,j,k,ih,1)= tda(i,j,k-1,ih,1)*tt(i,j,k,ih)               &
                        +(tda(i,j,k-1,ih,1)*rr(i,j,k,ih)                &
                        *rsa(i,j,k-1,ih,1)+tta(i,j,k-1,ih,1))*denm
          rsa(i,j,k,ih,1)= rs(i,j,k,ih)+ts(i,j,k,ih)                    &
                        *rsa(i,j,k-1,ih,1)*denm
          tda(i,j,k,ih,2)= tda(i,j,k,ih,1)
          tta(i,j,k,ih,2)= tta(i,j,k,ih,1)
          rsa(i,j,k,ih,2)= rsa(i,j,k,ih,1)
        END DO
      END DO
    END DO

!-----for middle clouds

    DO im=1,2

      DO k= ict, icb-1
        DO j= 1, n
          DO i= 1, m
            denm = ts(i,j,k,im)/( 1.-rsa(i,j,k-1,ih,im)*rs(i,j,k,im))
            tda(i,j,k,ih,im)= tda(i,j,k-1,ih,im)*td(i,j,k,im)
            tta(i,j,k,ih,im)= tda(i,j,k-1,ih,im)*tt(i,j,k,im)           &
                          +(tda(i,j,k-1,ih,im)*rr(i,j,k,im)             &
                          *rsa(i,j,k-1,ih,im)+tta(i,j,k-1,ih,im))*denm
            rsa(i,j,k,ih,im)= rs(i,j,k,im)+ts(i,j,k,im)                 &
                          *rsa(i,j,k-1,ih,im)*denm
          END DO
        END DO
      END DO

    END DO
  END DO

!-----layers are added one at a time, going up from the surface.
!  rra is the composite reflectance illuminated by beam radiation
!  rxa is the composite reflectance illuminated from above
!      by diffuse radiation
!  rra and rxa are computed from eqs. (4a) and (3a) of Chou

!-----for the low clouds

  DO is=1,2

    DO j= 1, n
      DO i= 1, m
        rra(i,j,np+1,1,is)=rr(i,j,np+1,is)
        rxa(i,j,np+1,1,is)=rs(i,j,np+1,is)
        rra(i,j,np+1,2,is)=rr(i,j,np+1,is)
        rxa(i,j,np+1,2,is)=rs(i,j,np+1,is)
      END DO
    END DO

    DO k=np,icb,-1
      DO j= 1, n
        DO i= 1, m
          denm=ts(i,j,k,is)/( 1.-rs(i,j,k,is)*rxa(i,j,k+1,1,is) )
          rra(i,j,k,1,is)=rr(i,j,k,is)+(td(i,j,k,is)                    &
              *rra(i,j,k+1,1,is)+tt(i,j,k,is)*rxa(i,j,k+1,1,is))*denm
          rxa(i,j,k,1,is)= rs(i,j,k,is)+ts(i,j,k,is)                    &
              *rxa(i,j,k+1,1,is)*denm
          rra(i,j,k,2,is)=rra(i,j,k,1,is)
          rxa(i,j,k,2,is)=rxa(i,j,k,1,is)
        END DO
      END DO
    END DO

!-----for middle clouds

    DO im=1,2

      DO k= icb-1,ict,-1
        DO j= 1, n
          DO i= 1, m
            denm=ts(i,j,k,im)/( 1.-rs(i,j,k,im)*rxa(i,j,k+1,im,is) )
            rra(i,j,k,im,is)= rr(i,j,k,im)+(td(i,j,k,im)                &
                *rra(i,j,k+1,im,is)+tt(i,j,k,im)*rxa(i,j,k+1,im,is))*denm
            rxa(i,j,k,im,is)= rs(i,j,k,im)+ts(i,j,k,im)                 &
                *rxa(i,j,k+1,im,is)*denm
          END DO
        END DO
      END DO

    END DO
  END DO

!-----integration over eight sky situations.
!  ih, im, is denotes high, middle and low cloud groups.

  DO ih=1,2

!-----clear portion

    IF(ih == 1) THEN
      DO j=1,n
        DO i=1,m
          ch(i,j)=1.0-cc(i,j,1)
        END DO
      END DO

    ELSE

!-----cloudy portion

      DO j=1,n
        DO i=1,m
          ch(i,j)=cc(i,j,1)
        END DO
      END DO

    END IF

    DO im=1,2

!-----clear portion

      IF(im == 1) THEN

        DO j=1,n
          DO i=1,m
            cm(i,j)=ch(i,j)*(1.0-cc(i,j,2))
          END DO
        END DO

      ELSE

!-----cloudy portion

        DO j=1,n
          DO i=1,m
            cm(i,j)=ch(i,j)*cc(i,j,2)
          END DO
        END DO

      END IF

      DO is=1,2

!-----clear portion

        IF(is == 1) THEN

          DO j=1,n
            DO i=1,m
              ct(i,j)=cm(i,j)*(1.0-cc(i,j,3))
            END DO
          END DO

        ELSE

!-----cloudy portion

          DO j=1,n
            DO i=1,m
              ct(i,j)=cm(i,j)*cc(i,j,3)
            END DO
          END DO

        END IF

!-----add one layer at a time, going down.

        DO k= icb, np
          DO j= 1, n
            DO i= 1, m
              denm = ts(i,j,k,is)/( 1.-rsa(i,j,k-1,ih,im)*rs(i,j,k,is) )
              tda(i,j,k,ih,im)= tda(i,j,k-1,ih,im)*td(i,j,k,is)
              tta(i,j,k,ih,im)=  tda(i,j,k-1,ih,im)*tt(i,j,k,is)        &
                   +(tda(i,j,k-1,ih,im)*rr(i,j,k,is)                    &
                   *rsa(i,j,k-1,ih,im)+tta(i,j,k-1,ih,im))*denm
              rsa(i,j,k,ih,im)= rs(i,j,k,is)+ts(i,j,k,is)               &
                   *rsa(i,j,k-1,ih,im)*denm
            END DO
          END DO
        END DO

!-----add one layer at a time, going up.

        DO k= ict-1,1,-1
          DO j= 1, n
            DO i= 1, m
              denm =ts(i,j,k,ih)/(1.-rs(i,j,k,ih)*rxa(i,j,k+1,im,is))
              rra(i,j,k,im,is)= rr(i,j,k,ih)+(td(i,j,k,ih)              &
                  *rra(i,j,k+1,im,is)+tt(i,j,k,ih)*rxa(i,j,k+1,im,is))*denm
              rxa(i,j,k,im,is)= rs(i,j,k,ih)+ts(i,j,k,ih)               &
                  *rxa(i,j,k+1,im,is)*denm
            END DO
          END DO
        END DO

!-----compute fluxes following eq (5) of Chou (1992)

!  fdndir is the direct  downward flux
!  fdndif is the diffuse downward flux
!  fupdif is the diffuse upward flux

        DO k=2,np+1
          DO j=1, n
            DO i=1, m
              denm= 1./(1.- rxa(i,j,k,im,is)*rsa(i,j,k-1,ih,im))
              fdndir(i,j)= tda(i,j,k-1,ih,im)
              xx = tda(i,j,k-1,ih,im)*rra(i,j,k,im,is)
              fdndif(i,j)= (xx*rsa(i,j,k-1,ih,im)+tta(i,j,k-1,ih,im))*denm
              fupdif= (xx+tta(i,j,k-1,ih,im)*rxa(i,j,k,im,is))*denm
              flxdn(i,j,k)=fdndir(i,j)+fdndif(i,j)-fupdif
            END DO
          END DO
        END DO

        DO j=1, n
          DO i=1, m
            flxdn(i,j,1)=1.0-rra(i,j,1,im,is)
          END DO
        END DO

!-----summation of fluxes over all (eight) sky situations.

        DO k=1,np+1
          DO j=1,n
            DO i=1,m
              IF(ih == 1 .AND. im == 1 .AND. is == 1) THEN
                fclr(i,j,k)=flxdn(i,j,k)
              END IF
              fall(i,j,k)=fall(i,j,k)+flxdn(i,j,k)*ct(i,j)
            END DO
          END DO
        END DO

        DO j=1,n
          DO i=1,m
            fsdir(i,j)=fsdir(i,j)+fdndir(i,j)*ct(i,j)
            fsdif(i,j)=fsdif(i,j)+fdndif(i,j)*ct(i,j)
          END DO
        END DO

      END DO
    END DO
  END DO

  RETURN
END SUBROUTINE cldflx


radtrns3d.F/    1298670057  19071 8000  100644  71817     `
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE RADTRNS                    ######
!######                                                      ######
!######                     Developed by                     ######
!######     Center for Analysis and Prediction of Storms     ######
!######                University of Oklahoma                ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE radtrns(nx,ny,nz,rbufsz,tipa,myid,dx,dy,                     &
           ib,ie,jb,je,kb,ke,xh,yh,prs0s,                               &
           ptprt,pprt,qv,qc,qr,qi,qs,qh,                                &
           ptbar,pbar,ppi, o31, rhostr, tsfc, zp,                            &
           radsw,rnflx,radswnet,radlwin, cosss,                 &
           rsirbm,rsirdf,rsuvbm,rsuvdf, cosz, az,                       &
           fdirir,fdifir,fdirpar,fdifpar,                               &
           plinv,tinv,qvinv,o3a,ccld,                                   &
           flxir,flcir,flxuv,flcuv,dfdts,                               &
           tauir,taual, tauswi,tauswl,reffi,reffl,                      &
           radbuf, tem1, swfrc,lwfrc,doirrad,dosorad)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  This subroutine is to compute the atmospheric radiation forcing
!
!-----------------------------------------------------------------------
!
!  AUTHOR: Yuhe Liu
!  03/11/1996
!
!  MODIFICATION HISTORY:
!
!  04/09/1997 (Yuhe Liu)
!  Removed dimension size check statement. For normal ARPS run, the
!  dimension size check is now done in the main driver, arps##. For
!  nested runs, no need to check the dimension size because the
!  working array is allocated automatically from existing space.
!
!  Added call of subroutine SETRADWRK to set the indeces of working
!  arrays in the radiation buffer. Those indeces are passed by
!  common blocks in radcst.inc.
!
!  10/11/1998 (Keith Brewster)
!  Added option for using RH in cloud optical depth calculation.
!
!  10/30/1998 (Keith Brewster)
!  Added calculation of aerosol density.
!
!  11/18/98 (Keith Brewster)
!  Changed pibar to ppi (full pi).
!
!  07/16/03  (J. Brotzge)
!  Fixed new radswnet bug (detected by T. Katopodes)
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

  INTEGER, intent(in) :: nx,ny,nz
  INTEGER, intent(in) :: rbufsz
  integer, intent(in) :: tipa,myid
  real, intent(in) :: dx,dy
  integer, intent(in) :: ib,ie,jb,je,kb,ke
  real, dimension(ib:ie), intent(in) :: xh
  real, dimension(jb:je), intent(in) :: yh
  real, intent(in) :: prs0s
  logical, intent(in) :: doirrad,dosorad
!
!-----------------------------------------------------------------------
!
!  Define ARPS variables
!
!-----------------------------------------------------------------------
!
  REAL :: x(nx+1)
  REAL :: y(ny+1)
!!!  REAL :: z(nz)
!!!  REAL :: za(nz)
  REAL :: zp(nx,ny,nz)

  REAL :: ptprt (nx,ny,nz)
  REAL :: pprt  (nx,ny,nz)
  REAL :: qv    (nx,ny,nz)
  REAL :: qc    (nx,ny,nz)
  REAL :: qr    (nx,ny,nz)
  REAL :: qi    (nx,ny,nz)
  REAL :: qs    (nx,ny,nz)
  REAL :: qh    (nx,ny,nz)

  REAL :: ptbar (nx,ny,nz)
  REAL :: pbar  (nx,ny,nz)
  REAL :: ppi   (nx,ny,nz)
  REAL :: o31   (nx,ny,nz)

  REAL :: rhostr(nx,ny,nz)

  REAL :: tsfc  (nx,ny)     ! Surface temperature (K)

  REAL, intent(inout) ::  swfrc(nx,ny,nz)  ! Radiation forcing (K/s)
  REAL, intent(inout) ::  lwfrc(nx,ny,nz)  ! Radiation forcing (K/s)

  REAL :: radsw (nx,ny)     ! Solar radiation reaching the surface
  REAL :: rnflx (nx,ny)     ! Net upward radiation flux
  REAL :: radswnet(nx,ny)   ! Net solar radiation at surface
  REAL :: radlwin(nx,ny)    ! Incoming longwave radiation at surface
  REAL :: flxd(nx,ny)         

  REAL :: cosz  (nx,ny)     ! Cosine of zenith
  REAL :: cosss (nx,ny)     ! Cosine of angle between sun light and
                            ! surface terrain slope

  REAL :: az, zen           ! Solar angles

  REAL :: sh(nx,ny)         ! augustin add sh
!
!-----------------------------------------------------------------------
!
!  Define 2-D variables for radiation calculation.
!
!-----------------------------------------------------------------------
!
  REAL :: rsirbm(nx,ny)     ! Solar IR surface albedo for beam radiation
  REAL :: rsirdf(nx,ny)     ! Solar IR surface albedo for diffuse radiation
  REAL :: rsuvbm(nx,ny)     ! Solar UV surface albedo for beam radiation
  REAL :: rsuvdf(nx,ny)     ! Solar UV surface albedo for diffuse radiation

  REAL :: fdirir (nx,ny)    ! all-sky direct downward IR flux
                            ! (0.7-10 micron) at the surface
  REAL :: fdifir (nx,ny)    ! all-sky diffuse downward IR flux
                            ! at the surface
  REAL :: fdirpar(nx,ny)    ! all-sky direct downward par flux
                            ! (0.4-0.7 micron) at the surface
  REAL :: fdifpar(nx,ny)    ! all-sky diffuse downward par flux
                            ! at the surface

!!!  REAL :: st4(nx,ny)        ! Emission by the surface
!
!-----------------------------------------------------------------------
!
!  Arrays which have the vertical coordinate inversed, that
!  is, k=1 is for top while k=nz is at the surface.
!
!-----------------------------------------------------------------------
!
  REAL :: plinv (nx,ny,nz)  ! Pressure in mb at scalar points
                 ! GHB:  I think plinv is really p at w points
  REAL :: tinv  (nx,ny,nz)  ! Temperature
  REAL :: qvinv (nx,ny,nz)  ! Water vapor mixing ratio (g/g)

  REAL :: o3a   (nx,ny,nz)  ! Ozone (o3) mixing ratio (g/g)
  REAL :: ccld  (nx,ny,nz)  ! Cloud coverage (fraction)

  REAL :: flxir (nx,ny,nz)  ! all-sky net downward flux
  REAL :: flcir (nx,ny,nz)  ! clear-sky net downward flux

  REAL :: flxuv (nx,ny,nz)  ! all-sky solar flux (downward minus upward)
  REAL :: flcuv (nx,ny,nz)  ! clear-sky solar flux (downward minus upward)

  REAL :: dfdts (nx,ny,nz)  ! Sensitivity of net downward flux to surface
                            ! temperature

  REAL :: tauir (nx,ny,nz)  ! Cloud optical depth for LW IR
  REAL :: taual (nx,ny,nz)  ! Aerosol optical thickness

  REAL :: tauswi(nx,ny,nz)  ! Cloud optical depth for solar IR for
                            ! ice particles
  REAL :: tauswl(nx,ny,nz)  ! Cloud optical depth for solar IR for
                            ! liquid particles

  REAL :: reffi (nx,ny,nz)  ! Effective cloud-particle size for
                            ! ice particles
  REAL :: reffl (nx,ny,nz)  ! Effective cloud-particle size for
                            ! liquid particles

  REAL :: tem1 (nx,ny,nz)   ! Work array for message passing

!    don't bother saving arrays in current CM1 implementation:  GHB, 100729
!  REAL :: temp (nx,ny,nz)   ! Work array for new coordinate
!  REAL :: tempp (nx,ny,nz)   ! Work array for new coordinate
!  REAL :: tempt (nx,ny,nz)   ! Work array for new coordinate
!  REAL :: temptp (nx,ny,nz)   ! Work array for new coordinate
!  REAL :: temppi (nx,ny,nz)   ! Work array for new coordinate
!  REAL :: temqv (nx,ny,nz)   ! Work array for new coordinate
!  REAL :: temqc (nx,ny,nz)   ! Work array for new coordinate
!  REAL :: temqr (nx,ny,nz)   ! Work array for new coordinate
!  REAL :: temqi (nx,ny,nz)   ! Work array for new coordinate
!  REAL :: temqs (nx,ny,nz)   ! Work array for new coordinate
!  REAL :: temqh (nx,ny,nz)   ! Work array for new coordinate
!!!  REAL :: dz (nz)            ! Vertical grid spacing
!
!-----------------------------------------------------------------------
!
!  Include files:
!
!-----------------------------------------------------------------------
!
!!!  INCLUDE 'globcst.inc'
!!!  INCLUDE 'phycst.inc'
  INCLUDE 'radcst.incl'
  INCLUDE 'radmore.incl'

!!!  INCLUDE 'bndry.inc'                !  add by Yunheng
!!!  INCLUDE 'mp.inc'                   
!
!-----------------------------------------------------------------------
!
!  Include file radcst.inc which contains the definition of dimension
!  sizes for 2-d and 3-d temporary arrays represented by a buffer,
!  radbuf. When radopt is NOT set to 1, the dimensions and buffer
!  sizes can be 1. Otherwise, the dimension sizes should be the same
!  as nx, ny, and nz, and the buffer size should be larger than the
!  total size of 27 2-d arrays and 44 3-d arrays.
!
!  integer n2d_rad  ! number of 2-d arrays in the buffer
!  integer n3d_rad  ! number of 3-d arrays in the buffer
!
!  integer rbufsz   ! nx*ny*(n2d_rad+n3d_rad*nz)
!  real radbuf( rbufsz )
!
!  The 2-d arrays should be always at the beginning of radbuf and
!  the 3-d arrays then following.
!
!-----------------------------------------------------------------------
!
  REAL :: radbuf( rbufsz )
!
!-----------------------------------------------------------------------
!
!  Local variables
!
!-----------------------------------------------------------------------
!
  INTEGER :: nxy, nxyz
  INTEGER :: i,j,k
  INTEGER :: im,jm,km, ij, ijm

  INTEGER :: istgr, jstgr
  INTEGER :: nxodd, nyodd, jeven, jodd

  INTEGER :: m, n

  INTEGER :: night           ! Flag for night time

  REAL :: tqe, dp, coolrate,heatrate
  REAL :: pk,psfc,tk,qvsat,rh,hgtagl,ccld1,ccld2,aden,psqc,aersum

!  REAL, ALLOCATABLE :: difir(:,:)
!  REAL, ALLOCATABLE :: difpa(:,:)
!  REAL, ALLOCATABLE :: ptmp(:,:,:)
!  REAL, ALLOCATABLE :: temc(:,:,:)
!  REAL, ALLOCATABLE :: temal(:,:,:)
!  REAL, ALLOCATABLE :: temsi(:,:,:)
!  REAL, ALLOCATABLE :: temsl(:,:,:)
!  REAL, ALLOCATABLE :: temri(:,:,:)
!  REAL, ALLOCATABLE :: temrl(:,:,:)
!  REAL, ALLOCATABLE :: h_rate(:,:,:)
!  REAL, ALLOCATABLE :: c_rate(:,:,:)
  real, dimension(nx,ny,nz) :: h_rate,c_rate

  LOGICAL :: high

  INTEGER :: rh2cldopt
  REAL :: rhcldwgt,qcwgt
  PARAMETER (rh2cldopt=0,rhcldwgt=0.667)

  INTEGER :: ict             ! Vertical indices of height cldh2m
  INTEGER :: icb             ! Vertical indices of height cldm2l

!-----------------------------------------------------------------------

!  REAL :: fclr(1,1)
!  REAL :: dbs(1,1)
!  REAL :: trant(1,1)
!  REAL :: th2o(1,1,6)
!  REAL :: tcon(1,1,3)
!  REAL :: tco2(1,1,6,2)

!  REAL :: pa(1,1,nz-1)
!  REAL :: dt(1,1,nz-1)
!  REAL :: sh2o(1,1,nz)
!  REAL :: swpre(1,1,nz)
!  REAL :: swtem(1,1,nz)
!  REAL :: sco3(1,1,nz)
!  REAL :: scopre(1,1,nz)
!  REAL :: scotem(1,1,nz)
!  REAL :: dh2o(1,1,nz-1)
!  REAL :: dcont(1,1,nz-1)
!  REAL :: dco2(1,1,nz-1)
!  REAL :: do3(1,1,nz-1)
!  REAL :: flxu(1,1,nz)
!  REAL :: flxdd(1,1,nz)
!  REAL :: clr(1,1,0:nz)
!  REAL :: blayer(1,1,0:nz)

!  REAL :: h2oexp(1,1,nz-1,6)
!  REAL :: conexp(1,1,nz-1,3)

!  REAL :: co2exp(1,1,nz-1,6,2)

!-----------------------------------------------------------------------

 
!
!-----------------------------------------------------------------------
!
!  Functions
!
!-----------------------------------------------------------------------
!
  REAL :: aeroden

!-----------------------------------------------------------------------
!
!  Define additional layer to the top of model atmosphere
!
!-----------------------------------------------------------------------
!
  REAL :: padd                ! Additional pressure level (mb) to TOA
  REAL :: tadd                ! Temperature for additional layer to TOA

  PARAMETER (padd =  1.0)
  PARAMETER (tadd =223.0)

 

!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!

!  ALLOCATE(difir(nx,ny))
!  ALLOCATE(difpa(nx,ny))
!  ALLOCATE(ptmp(nx,ny,nz))
!  ALLOCATE(temc(nx,ny,nz))
!  ALLOCATE(temal(nx,ny,nz))
!  ALLOCATE(temsi(nx,ny,nz))
!  ALLOCATE(temsl(nx,ny,nz))
!  ALLOCATE(temri(nx,ny,nz))
!  ALLOCATE(temrl(nx,ny,nz))
!  ALLOCATE(h_rate(nx,ny,nz))
!  ALLOCATE(c_rate(nx,ny,nz))

  IF ( rlwopt == 0 ) THEN
    high = .false.
  ELSE
    high = .true.
  END IF

  sh = 1.0

!!!  CALL setradwrk(nx,ny,nz)

  nxy  = nx*ny
  nxyz = nxy*nz
  qcwgt=1.-rhcldwgt

  IF ( (pbar(1,1,nz-1)*0.01) <= padd ) THEN
!    WRITE (6,'(a/a)')                                                   &
!        'The pressure at the top of atmosphere was too low to add ',    &
!        'additional levels. Check the sounding profile.',               &
!        'Program stopped in RADTRNS.'
!    CALL arpsstop('arpsstop stopped RADTRNS pressure to low at the top ',1)
    print *,'Program stopped in RADTRNS.'
    call stopcm1
  END IF

!!! 700   CONTINUE   
  ! replace go-to with do loop:   GHB, 100729

!!!      zen = acos(cosz(max(1,nx/2),max(1,ny/2)))
      zen = acos(cosz(1,1))
!---------------


  DO j=1,ny
    DO i=1,nx
      DO k=1,nz-1
        o3a(i,j,k)=qc(i,j,k)
      END DO
    END DO
  END DO
!
!-----------------------------------------------------------------------
!
!  In the staggering case, only those points of (i,j) = (even,even)
!  and (odd,odd) will be calculated. Do defragment to move the points
!  to the left half domain, i=1,nx/2 and j=1,ny-1
!
!-----------------------------------------------------------------------
!
  nyodd = MOD(ny,2)
  nxodd = MOD(nx,2)

  ict = 0
  icb = 0

  IF ( radstgr == 0 ) THEN
    m = nx
    n = ny
!    WARNING: this loop is repeated for radstgr=1, changes made here must
!    also be made there as well.
      DO j=1,n
        DO i=1,m
          psfc = prs0s + pprt(i,j,1)
    DO km=3,nz-1
      k = nz+1-km
          pk = pbar(i,j,k)+pprt(i,j,k)
          ! plinv is pressure (in mb) at w points:
          plinv(i,j,km) = 0.005*((pbar(i,j,k  ) + pprt(i,j,k  ))        &
                                +(pbar(i,j,k+1) + pprt(i,j,k+1)))
          tk = (ptbar(i,j,k)+ptprt(i,j,k))*ppi(i,j,k)
          tinv (i,j,km) = MAX(tk, 190.)
          qvinv(i,j,km) = MAX(qv(i,j,k), 1.0E-6)

          tqe = qc(i,j,k)+qr(i,j,k)+qi(i,j,k)+qs(i,j,k)+qh(i,j,k)
          tqe = MAX(1.0E-20, tqe)

          if( ict.eq.0 )then
            if( (zp(i,j,k)-zp(i,j,2)).le.cldh2m )  ict = km
          endif
          if( icb.eq.0 )then
            if( (zp(i,j,k)-zp(i,j,2)).le.cldm2l )  icb = km
          endif

          IF( rh2cldopt > 0 ) THEN
            stop 22222
          ELSE
            ccld(i,j,km) = MIN(1.0, MAX(0.0, 0.25*ALOG10(tqe)+1.5))
!  borrow o3a to store psuedo-cloud
            o3a(i,j,k) = qc(i,j,k)
          END IF

!!!          psfc = 0.5* (pbar(i,j,1)+pprt(i,j,1) +                        &
!!!                       pbar(i,j,2)+pprt(i,j,2) )
!!!          psfc = prs0s + pprt(i,j,1)
          aden=2.0*aeroden(pk,psfc)
          taual(i,j,km)=aden*0.5*((pbar(i,j,k-1)+pprt(i,j,k-1))         &
                                 -(pbar(i,j,k+1)+pprt(i,j,k+1)))
        END DO
      END DO
    END DO

    if( ict.eq.0 .or. icb.eq.0 )then
      print *
      print *,'  Could not find ict,icb '
      print *
      print *,'  ict,icb = ',ict,icb
      print *
      call stopcm1
    endif

!    WARNING: this loop is repeated for radstgr=1, changes made here must
!    also be made there as well.
    DO j=1,n
      DO i=1,m
        ij = nx*(j-1) + i
        radbuf(ij) = tsfc(i,j)

        plinv(i,j,1) = padd
        tinv (i,j,1) = tadd
        qvinv(i,j,1) = 1.0E-6
        ccld (i,j,1) = 0.0
        taual(i,j,1) = 0.0

        plinv(i,j,2) = 0.5*(plinv(i,j,1)+plinv(i,j,3))
        tinv (i,j,2) = MAX(0.5*(tinv(i,j,1)+tinv(i,j,3)), 190.0)
        qvinv(i,j,2) = MAX(qv(i,j,nz-1), 1.0E-6)
        ccld (i,j,2) = 0.0
        taual(i,j,2) = 0.0

!!!        plinv(i,j,nz) = 0.005*((pbar(i,j,1) + pprt(i,j,1))              &
!!!                            +(pbar(i,j,2) + pprt(i,j,2)))
        plinv(i,j,nz) = 0.01*( prs0s + pprt(i,j,1) )
      END DO
    END DO

  ELSE IF ( radstgr == 1 ) THEN
    stop 77771

  END IF

  DO km=1,nz-1
    DO j=1,n
      DO i=1,m
        dp = plinv(i,j,km+1) - plinv(i,j,km)
        IF ( dp <= 0.0 ) THEN
        print*, 'dp is=',dp
        print*, 'location is=', i  ,j,  km
        print*, 'plinv =',plinv(i,j,:)
!          WRITE (6,'(a,i3,a,i3,a,i3,a,i3,a/a,a/a)')                     &
!              'ERROR: The pressure gradient between level k = ',nz+1-km, &
!              ' and ',nz-km, ' at i = ',i,' and j = ',j,' was <=0.',    &
!              'Please check the sounding file, ',                       &
!              runname(1:lfnkey)//'.sound, or the data sets.',           &
!              'Program stopped in RADTRNS.'
!          CALL arpsstop('arpsstop stopped RADTRNS problem with sounding',1)
          print *,'Program stopped in RADTRNS.'
          call stopcm1
        END IF
      END DO
    END DO
  END DO

!
!-----------------------------------------------------------------------
!
!  Notes: The arguments in subroutine CLDOPTD have different vertical
!         coordinates orders:
!
!         plinv  -- 1 for top
!         tinv   -- 1 for top
!
!         qc     -- 1 for bottom
!         qr     -- 1 for bottom
!         qi     -- 1 for bottom
!         qs     -- 1 for bottom
!         qh     -- 1 for bottom
!
!         tauir  -- 1 for top
!         tauswi -- 1 for top
!         tauswl -- 1 for top
!         reffi  -- 1 for top
!         reffl  -- 1 for top
!
!-----------------------------------------------------------------------
!
!  note borrowed o3a to store psuedo-cloud in place of qc.
  CALL cldoptd(nx,ny,m,n,nz, radstgr,                                   &
               plinv,tinv,o3a,qr,qi,qs,qh, rhostr,                      &
               tauir,tauswi,tauswl,reffi,reffl,zen)

  IF ( radstgr == 1 ) THEN
    stop 77771
  END IF
!
!-----------------------------------------------------------------------
!
!  Fit the ozone concentration by interpolating a standard o3 profile
!  to ARPS pressure levels.
!
!-----------------------------------------------------------------------
!
!!!  CALL fito3(nx,ny,m,n, nz-1, plinv,o3a)
    do k=1,nz-1
    do j=1,ny
    do i=1,nx
      o3a(i,j,k) = o31(i,j,k)
    enddo
    enddo
    enddo
!
!-----------------------------------------------------------------------
!
!  Calculate the downward longwave IR radiation.
!
!  Positions of 2-d arrays in the buffer:
!
!    fclr (m,n)     -- radbuf(1+ 1*nxy)
!    dbs  (m,n)     -- radbuf(1+ 2*nxy)
!    trant(m,n)     -- radbuf(1+ 3*nxy)
!
!    th2o (m,n,6)   -- radbuf(1+ 4*nxy)
!    tcon (m,n,3)   -- radbuf(1+10*nxy)
!    tco2 (m,n,6,2) -- radbuf(1+13*nxy)
!
!  Positions of 3-d arrays in the buffer:
!
!    pa    (m,n,np)     -- radbuf(1+25*nxy)
!    dt    (m,n,np)     -- radbuf(1+25*nxy+ 1*nxyz)
!    sh2o  (m,n,np+1)   -- radbuf(1+25*nxy+ 2*nxyz)
!    swpre (m,n,np+1)   -- radbuf(1+25*nxy+ 3*nxyz)
!    swtem (m,n,np+1)   -- radbuf(1+25*nxy+ 4*nxyz)
!    sco3  (m,n,np+1)   -- radbuf(1+25*nxy+ 5*nxyz)
!    scopre(m,n,np+1)   -- radbuf(1+25*nxy+ 6*nxyz)
!    scotem(m,n,np+1)   -- radbuf(1+25*nxy+ 7*nxyz)
!    dh2o  (m,n,np)     -- radbuf(1+25*nxy+ 8*nxyz)
!    dcont (m,n,np)     -- radbuf(1+25*nxy+ 9*nxyz)
!    dco2  (m,n,np)     -- radbuf(1+25*nxy+10*nxyz)
!    do3   (m,n,np)     -- radbuf(1+25*nxy+11*nxyz)
!    flxu  (m,n,np+1)   -- radbuf(1+25*nxy+12*nxyz)
!    flxd  (m,n,np+1)   -- radbuf(1+25*nxy+13*nxyz)
!    clr   (m,n,0:np+1) -- radbuf(1+25*nxy+14*nxyz) ! nz+1
!    blayer(m,n,0:np+1) -- radbuf(1+26*nxy+15*nxyz) ! nz+1
!
!    h2oexp(m,n,np,6)   -- radbuf(1+27*nxy+16*nxyz)
!    conexp(m,n,np,3)   -- radbuf(1+27*nxy+22*nxyz)
!
!    co2exp(m,n,np,6,2) -- radbuf(1+27*nxy+25*nxyz)
!
!-----------------------------------------------------------------------
!
 IF (doirrad) THEN
  ! (arps code is absurd ... interpolate, then intepolate back?  ugh.)
  ! give irrad the pressure at scalar pts directly:
  do j=1,ny
  do i=1,nx
    km = 1
    radbuf(ir3d1-1+km) = 0.5*(plinv(i,j,km)+plinv(i,j,km+1))
    km = 2
    radbuf(ir3d1-1+km) = 0.5*(plinv(i,j,km)+plinv(i,j,km+1))
    do km=3,nz-1
      k = nz+1-km
      radbuf(ir3d1-1+km) = 0.01*(pbar(i,j,k)+pprt(i,j,k))
    enddo
  enddo
  enddo
  CALL irrad(nx,ny,m,n,nz-1,                                            &
             tauir(1,1,1),ccld(1,1,1), plinv(1,1,1),tinv(1,1,1),qvinv(1,1,1),o3a(1,1,1), co2,radbuf(1),           &
             high,flxd(1,1),flxir(1,1,1),flcir(1,1,1),dfdts(1,1,1),rnflx(1,1),                        &
!!!           fclr,dbs,trant,th2o,tcon,tco2,                               &
!!!           pa,dt,sh2o,swpre,swtem,sco3,scopre,scotem,                   &
!!!           dh2o,dcont,dco2,do3,flxu,flxdd,clr,blayer,                    &
!!!           h2oexp,conexp,co2exp)
             radbuf(ir2d1),radbuf(ir2d2),radbuf(ir2d3),                 &
             radbuf(ir2d4),radbuf(ir2d5),radbuf(ir2d6),                 &
             radbuf(ir3d1),radbuf(ir3d2),radbuf(ir3d3),                 &
             radbuf(ir3d4),radbuf(ir3d5),radbuf(ir3d6),                 &
             radbuf(ir3d7),radbuf(ir3d8),radbuf(ir3d9),                 &
             radbuf(ir3d10),radbuf(ir3d11),radbuf(ir3d12),              &
             radbuf(ir3d13),radbuf(ir3d14),radbuf(ir3d15),              &
             radbuf(ir3d16),radbuf(ir4d1),radbuf(ir4d2),                &
             radbuf(ir5d1))
    DO k=2,nz-2
      km=nz+1-k          ! inverse vertical coordinates to ARPS grid
      DO j=1,ny
        DO i=1,nx
          c_rate(i,j,k) = 9.770687E-05               & ! = g/cp in cgs unit
               * ( flxir(i,j,km+1) - flxir(i,j,km) )                    &
                   / (ppi(i,j,k) * ( plinv(i,j,km) - plinv(i,j,km+1) ))
        END DO
      END DO
    END DO

 END IF
!
!-----------------------------------------------------------------------
!
!  Calculate solar radiation fluxes.
!
!  Output flxuv and flcuv are the fractions to incoming solar flux
!  at the top of atmosphere
!
!  Positions of 2-d arrays used in subroutine SORAD
!
!    sdf  (m,n)     -- radbuf(1+ 1*nxy    )
!    sclr (m,n)     -- radbuf(1+ 2*nxy)
!    csm  (m,n)     -- radbuf(1+ 3*nxy)
!    cc   (m,n,3)   -- radbuf(1+ 4*nxy)
!
!  Positions of 3-d arrays used in subroutine SORAD
!
!    tauclb(m,n,np)   -- radbuf(1+ 7*nxy            )
!    tauclf(m,n,np)   -- radbuf(1+ 7*nxy+ 1*nxyz)
!    dp    (m,n,np)   -- radbuf(1+ 7*nxy+ 2*nxyz)
!    wh    (m,n,np)   -- radbuf(1+ 7*nxy+ 3*nxyz)
!    oh    (m,n,np)   -- radbuf(1+ 7*nxy+ 4*nxyz)
!    scal  (m,n,np)   -- radbuf(1+ 7*nxy+ 5*nxyz)
!    swh   (m,n,np+1) -- radbuf(1+ 7*nxy+ 6*nxyz)
!    so2   (m,n,np+1) -- radbuf(1+ 7*nxy+ 7*nxyz)
!    df    (m,n,np+1) -- radbuf(1+ 7*nxy+ 8*nxyz)
!
!  Positions of temporary arrays used in subroutine SOLIR, SOLUV, and
!  CLDFLX:
!
!    tem2d1 (m,n)         -- radbuf(1+ 7*nxy+ 9*nxyz)
!    tem2d2 (m,n)         -- radbuf(1+ 8*nxy+ 9*nxyz)
!    tem2d3 (m,n)         -- radbuf(1+ 9*nxy+ 9*nxyz)
!    tem2d4 (m,n)         -- radbuf(1+10*nxy+ 9*nxyz)
!    tem2d5 (m,n)         -- radbuf(1+11*nxy+ 9*nxyz)
!    tem2d6 (m,n)         -- radbuf(1+12*nxy+ 9*nxyz)
!    tem2d7 (m,n)         -- radbuf(1+13*nxy+ 9*nxyz)
!    tem2d8 (m,n)         -- radbuf(1+14*nxy+ 9*nxyz)
!    tem2d9 (m,n)         -- radbuf(1+15*nxy+ 9*nxyz)
!    tem2d10(m,n)         -- radbuf(1+16*nxy+ 9*nxyz)
!    tem2d11(m,n)         -- radbuf(1+17*nxy+ 9*nxyz)
!    tem2d12(m,n)         -- radbuf(1+18*nxy+ 9*nxyz)
!    tem2d13(m,n)         -- radbuf(1+19*nxy+ 9*nxyz)
!    tem2d14(m,n)         -- radbuf(1+20*nxy+ 9*nxyz)
!    tem2d15(m,n)         -- radbuf(1+21*nxy+ 9*nxyz)
!    tem2d16(m,n)         -- radbuf(1+22*nxy+ 9*nxyz)
!    tem2d17(m,n)         -- radbuf(1+23*nxy+ 9*nxyz)
!    tem2d18(m,n)         -- radbuf(1+24*nxy+ 9*nxyz)
!    tem2d19(m,n)         -- radbuf(1+25*nxy+ 9*nxyz)
!
!    tem3d1 (m,n,np+1)    -- radbuf(1+26*nxy+ 9*nxyz)
!    tem3d2 (m,n,np+1)    -- radbuf(1+26*nxy+10*nxyz)
!    tem3d3 (m,n,np+1)    -- radbuf(1+26*nxy+11*nxyz)
!    tem3d4 (m,n,np+1)    -- radbuf(1+26*nxy+12*nxyz)
!    tem3d5 (m,n,np+1)    -- radbuf(1+26*nxy+13*nxyz)
!
!    tem4d1 (m,n,np+1,2)  -- radbuf(1+26*nxy+14*nxyz)
!    tem4d2 (m,n,np+1,2)  -- radbuf(1+26*nxy+16*nxyz)
!    tem4d3 (m,n,np+1,2)  -- radbuf(1+26*nxy+18*nxyz)
!    tem4d4 (m,n,np+1,2)  -- radbuf(1+26*nxy+20*nxyz)
!    tem4d5 (m,n,np+1,2)  -- radbuf(1+26*nxy+22*nxyz)
!
!    tem5d1(m,n,np+1,2,2) -- radbuf(1+26*nxy+24*nxyz)
!    tem5d2(m,n,np+1,2,2) -- radbuf(1+26*nxy+28*nxyz)
!    tem5d3(m,n,np+1,2,2) -- radbuf(1+26*nxy+32*nxyz)
!    tem5d4(m,n,np+1,2,2) -- radbuf(1+26*nxy+36*nxyz)
!    tem5d5(m,n,np+1,2,2) -- radbuf(1+26*nxy+40*nxyz)
!
!-----------------------------------------------------------------------
!
 ! GHB, 100729:
 IF( dosorad )THEN

  night = 1
  DO j=1,n
    DO i=1,m
      IF ( cosz(i,j) > 0.0 ) THEN
        night = 0
        GO TO 500
      END IF
    END DO
  END DO

  500   CONTINUE

!  aersum=0.
!  DO 505 k=1,nz-1
!    aersum=aersum+taual(2,2,k)
! 505 CONTINUE
!  write(6,'(a,f10.4))') ' Total aerosol optical depth: ',aersum

  IF ( night == 0 ) THEN

    CALL sorad(nx,ny,m,n,nz-1, plinv,tinv,qvinv,o3a,co2,                &
         tauswi,tauswl,reffi,reffl,ccld,ict,icb,                        &
         taual,rsirbm,rsirdf,rsuvbm,rsuvdf,cosz,                        &
         flxuv,flcuv,fdirir,fdifir,fdirpar,fdifpar,                     &
         radbuf(so2d1),radbuf(so2d2),radbuf(so2d3),radbuf(so2d4),       &
         radbuf(so3d1),radbuf(so3d2),radbuf(so3d3),radbuf(so3d4),       &
         radbuf(so3d5),radbuf(so3d6),radbuf(so3d7),radbuf(so3d8),       &
         radbuf(so3d9),radbuf(so2d5),radbuf(so2d6),radbuf(so2d7),       &
         radbuf(so2d8),radbuf(so2d9),radbuf(so2d10),radbuf(so2d11),     &
         radbuf(so2d12),radbuf(so2d13),radbuf(so2d14),                  &
         radbuf(so2d15),radbuf(so2d16),radbuf(so2d17),                  &
         radbuf(so2d18),radbuf(so2d19),radbuf(so2d20),                  &
         radbuf(so2d21),radbuf(so2d22),radbuf(so2d23),                  &
         radbuf(so3d10),radbuf(so3d11),radbuf(so3d12),                  &
         radbuf(so3d13),radbuf(so3d14),radbuf(so4d1),                   &
         radbuf(so4d2),radbuf(so4d3),radbuf(so4d4),radbuf(so4d5),       &
         radbuf(so5d1), radbuf(so5d2),                                  &
         radbuf(so5d3), radbuf(so5d4), radbuf(so5d5))

  ELSE

    DO k=1,nz
      DO j=1,n
        DO i=1,m
          flxuv(i,j,k) = 0.0
        END DO
      END DO
    END DO

    DO j=1,n
      DO i=1,m
        fdirir (i,j) = 0.0
        fdifir (i,j) = 0.0
        fdirpar(i,j) = 0.0
        fdifpar(i,j) = 0.0
      END DO
    END DO

  ENDIF

 ENDIF

!------------------------------------------------------------------------------


!   IF ((tipa == 1) .AND. (repeat == 0))THEN !.AND. (abs(cosz(1,1)) > 0.5))THEN
!    don't bother saving arrays in current CM1 implementation:  GHB, 100729
!      ptmp = plinv
!      temc = ccld
!      temal = taual
!      temsi = tauswi
!      temsl = tauswl
!      temri = reffi
!      temrl = reffl
!      temp = pbar
!      tempp = pprt
!      tempt = ptbar
!      temptp = ptprt
!      temppi = ppi
!      temqv = qv
!      temqc = qc
!      temqr = qr
!      temqi = qi
!      temqs = qs
!      temqh = qh
!      tem1 = rhostr
!
!      repeat = 1
!
!      zen = acos(cosz(nx/2,ny/2))
!
!      GOTO 700
!
!   END IF


!   IF (tipa == 1) THEN

!    don't bother saving arrays in current CM1 implementation:  GHB, 100729
!      pbar = temp
!      pprt = tempp
!      ptbar = tempt
!      ptprt = temptp
!      qv = temqv
!      qc = temqc
!      qr = temqr
!      qi = temqi
!      qs = temqs
!      qh = temqh
!      rhostr = tem1
!      ccld = temc
!      taual = temal
!      tauswi = temsi
!      tauswl = temsl
!      reffi = temri
!      reffl = temrl

      !Fill-in edges of SW fluxes

!    DO k=1,nz
!        DO j=1,ny
!          flxuv(1,j,k) = flxuv(2,j,k)
!          flxuv(nx,j,k) = flxuv(nx-1,j,k)
!          flcuv(1,j,k) = flcuv(2,j,k)
!          flcuv(nx,j,k) = flcuv(nx-1,j,k)
!        END DO
!
!        DO i=1,nx
!          flxuv(i,1,k) = flxuv(i,2,k)
!          flxuv(i,ny,k) = flxuv(i,ny-1,k)
!          flcuv(i,1,k) = flcuv(i,2,k)
!          flcuv(i,ny,k) = flcuv(i,ny-1,k)
!        END DO
!
!        flxuv(1,1,k) = flxuv(2,2,k)
!        flxuv(nx,1,k) = flxuv(nx-1,2,k)
!        flxuv(nx,ny,k) = flxuv(nx-1,ny-1,k)
!        flxuv(1,ny,k) = flxuv(2,ny-1,k)
!        flcuv(1,1,k) = flcuv(2,2,k)
!        flcuv(nx,1,k) = flcuv(nx-1,2,k)
!        flcuv(nx,ny,k) = flcuv(nx-1,ny-1,k)
!        flcuv(1,ny,k) = flcuv(2,ny-1,k)
!
!    END DO
!   END IF


!  ELSEIF ((repeat == 0) .AND. (tipa == 1)) THEN 
!
!    ! not needed:  GHB, 100729
!    DO k=1,nz-1
!      DO j=1,n
!        DO i=1,m
!          flxuv(i,j,k) = 0.0
!        END DO
!      END DO
!    END DO
!
!    ! moved back to original location (just after sorad):  GHB, 100729
!    DO j=1,n
!      DO i=1,m
!        fdirir (i,j) = 0.0
!        fdifir (i,j) = 0.0
!        fdirpar(i,j) = 0.0
!        fdifpar(i,j) = 0.0
!      END DO
!    END DO

!  END IF
!
!-----------------------------------------------------------------------
!
!  Added the heating rate of solar radiation to total radiation
!  forcing (K/s)
!
!  Constant 9.770687e-05 is equal to g/cp in cgs unit, where g = 980
!  and cp = 1.003e7.
!
!  Outputs from SORAD such as flxuv, flcuv, etc., are fractions of
!  solar flux at the top of atmosphere. Therefore we need to multipy
!  solar constant and cosine of zenith angle to obtain the solar
!  radiation flux.
!
!-----------------------------------------------------------------------
!

!    don't bother saving arrays in current CM1 implementation:  GHB, 100729
!  IF (repeat == 0) THEN
!    temppi = ppi
!    ptmp = plinv
!  END IF

  IF ( radstgr == 0 ) THEN

  IF( night.eq.0 .and. dosorad )THEN
! moved calculation of coolrate up near irrad to avoid unnecessary
! calculations when using tipa:  GHB, 100726
    DO k=2,nz-2
      km=nz+1-k          ! inverse vertical coordinates to ARPS grid
      DO j=1,ny
        DO i=1,nx
          h_rate(i,j,k) = solarc * cosz(i,j) * 9.770687E-05                  &
                   * ( flxuv(i,j,km+1) - flxuv(i,j,km) )                &
                   / (ppi(i,j,k) * ( plinv(i,j,km) - plinv(i,j,km+1) ))
        END DO
      END DO
    END DO
  ELSE
    h_rate = 0.0
  ENDIF


!!!    radfrc = 0

  IF( doirrad )THEN
    DO k=2,nz-2
      DO j=1,ny
        DO i=1,nx
          lwfrc(i,j,k) = c_rate(i,j,k)
        END DO
      END DO
    END DO
    DO j=1,ny
      DO i=1,nx
        radlwin(i,j) = flxd(i,j) 
      END DO
    END DO
  ENDIF

  IF( dosorad )THEN
    DO k=2,nz-2
      DO j=1,ny
        DO i=1,nx
          swfrc(i,j,k) = h_rate(i,j,k)  
        END DO
      END DO
    END DO
    DO j=1,ny
      DO i=1,nx
        rnflx(i,j) = solarc * radsw(i,j) * cosss(i,j)       & ! radsw = a2dr2
                 * ( sh(i,j)*(1.0-rsirbm(i,j)) * fdirir(i,j)            &
                       + sh(i,j)*(1.0-rsuvbm(i,j)) * fdirpar(i,j)       &
                       + (1.0-rsirdf(i,j)) * fdifir(i,j)                &
                       + (1.0-rsuvdf(i,j)) * fdifpar(i,j) )             &
                   + flxir(i,j,nz)       ! net downward LW flux at sfc
        radswnet(i,j) = solarc * radsw(i,j) * cosss(i,j)       & ! radsw = a2dr2
                 * (sh(i,j)*(1.0-rsirbm(i,j)) * fdirir(i,j)             &
                 + sh(i,j)*(1.0-rsuvbm(i,j)) * fdirpar(i,j)             &
                          + (1.0-rsirdf(i,j)) * fdifir(i,j)             &
                          + (1.0-rsuvdf(i,j)) * fdifpar(i,j) )
        radsw(i,j) = solarc * radsw(i,j) * cosss(i,j)                   &
                     * ( sh(i,j)*(fdirir(i,j) + fdirpar(i,j))           &
                       + fdifir(i,j) + fdifpar(i,j) )


      END DO
    END DO
  ENDIF

  ELSE IF ( radstgr == 1 ) THEN
    stop 77773

  END IF

!---------------------------------------------------------------------
!
! Added by Yunheng to update the fake zone for radfrc, radsw, rnflx.
! two more variables (radswnet and radlwin) since IHOP_3
!
!--------------------------------------------------------------------

!  MPI stuff?  Commented out, for now:  GHB, 100720
!  IF (mp_opt > 0) THEN
!    CALL acct_interrupt(mp_acct)
!    CALL mpsendrecv2dew(radfrc, nx, ny, nz, ebc, wbc, 0, tem1)
!    CALL mpsendrecv2dns(radfrc, nx, ny, nz, nbc, sbc, 0, tem1)
!
!    CALL mpsendrecv1dew(radsw,  nx, ny, ebc, wbc, 0, tem1)
!    CALL mpsendrecv1dns(radsw,  nx, ny, nbc, sbc, 0, tem1)
!
!    CALL mpsendrecv1dew(rnflx,  nx, ny, ebc, wbc, 0, tem1)
!    CALL mpsendrecv1dns(rnflx,  nx, ny, nbc, sbc, 0, tem1)
!
!    CALL mpsendrecv1dew(radswnet, nx, ny, ebc, wbc, 0, tem1)
!    CALL mpsendrecv1dns(radswnet, nx, ny, nbc, sbc, 0, tem1)
!
!    CALL mpsendrecv1dew(radlwin,  nx, ny, ebc, wbc, 0, tem1)
!    CALL mpsendrecv1dns(radlwin,  nx, ny, nbc, sbc, 0, tem1)
!
!    CALL acct_stop_inter
!  END IF

!  IF ( raddiag == 1 ) THEN
!    WRITE(6,'(a,i8,a,f10.2,a)')                                         &
!        ' Dump radiation variables at time step,', nstep,               &
!        ', model time=',curtim,' (s)'
!!
!!-----------------------------------------------------------------------
!!
!!  Write out results to GrADS file for display
!!
!!-----------------------------------------------------------------------
!!
!    CALL wrtrad(nx,ny,nz,m,n,x,y,z,                                     &
!                plinv,tinv,qvinv,qc,qr,qi,qs,qh, o3a,radbuf(1),         &
!                ccld, tauir,taual,tauswi,tauswl,reffi,reffl,            &
!                rsirbm,rsirdf,rsuvbm,rsuvdf,                            &
!                fdirir,fdifir,fdirpar,fdifpar,                          &
!                dfdts, radsw,rnflx, cosz,                               &
!                flxir,flcir, flxuv,flcuv,                               &
!                radfrc)
!!    :              radfrc, coolr,heatr)
!
!  END IF

!  DEALLOCATE(difir)
!  DEALLOCATE(difpa)
!  DEALLOCATE(ptmp)
!  DEALLOCATE(temc)
!  DEALLOCATE(temal)
!  DEALLOCATE(temsi)
!  DEALLOCATE(temsl)
!  DEALLOCATE(temri)
!  DEALLOCATE(temrl)
!  DEALLOCATE(h_rate)
!  DEALLOCATE(c_rate)

  RETURN

END SUBROUTINE radtrns
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE SETRADWRK                  ######
!######                                                      ######
!######                     Developed by                     ######
!######     Center for Analysis and Prediction of Storms     ######
!######                University of Oklahoma                ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE setradwrk( nx,ny,nz )
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Set the indeces for radiation working arrays
!
!-----------------------------------------------------------------------
!
!  AUTHOR: Yuhe Liu
!  04/09/1997
!
!  MODIFICATION HISTORY:
!
!-----------------------------------------------------------------------
!
!  INPUT:
!
!    nx       Number of grid points in the x-direction (east/west)
!    ny       Number of grid points in the y-direction (north/south)
!    nz       Number of grid points in the z-direction (vertical)
!
!-----------------------------------------------------------------------
!

!
!-----------------------------------------------------------------------
!
!  Variable Declarations.
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

  INTEGER :: nx,ny,nz       ! The number grid points in 3 directions
  INTEGER :: nxy, nxyz
!
!-----------------------------------------------------------------------
!
!  Include files
!
!-----------------------------------------------------------------------
!
  INCLUDE 'radcst.incl'
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
  nxy  = nx*ny
  nxyz = nxy*nz
!
!-----------------------------------------------------------------------
!
!  Define indices which determine the positions of temporary arrays
!  used in subroutine IRRAD and the subroutine IRRAD calls.
!
!-----------------------------------------------------------------------
!
  ir2d1  = 1+ 1*nxy
  ir2d2  = 1+ 2*nxy
  ir2d3  = 1+ 3*nxy
  ir2d4  = 1+ 4*nxy
  ir2d5  = 1+10*nxy
  ir2d6  = 1+13*nxy

  ir3d1  = 1+25*nxy+ 0*nxyz
  ir3d2  = 1+25*nxy+ 1*nxyz
  ir3d3  = 1+25*nxy+ 2*nxyz
  ir3d4  = 1+25*nxy+ 3*nxyz
  ir3d5  = 1+25*nxy+ 4*nxyz
  ir3d6  = 1+25*nxy+ 5*nxyz
  ir3d7  = 1+25*nxy+ 6*nxyz
  ir3d8  = 1+25*nxy+ 7*nxyz
  ir3d9  = 1+25*nxy+ 8*nxyz
  ir3d10 = 1+25*nxy+ 9*nxyz
  ir3d11 = 1+25*nxy+10*nxyz
  ir3d12 = 1+25*nxy+11*nxyz
  ir3d13 = 1+25*nxy+12*nxyz
  ir3d14 = 1+25*nxy+13*nxyz
  ir3d15 = 1+25*nxy+14*nxyz
  ir3d16 = 1+26*nxy+15*nxyz

  ir4d1  = 1+27*nxy+16*nxyz
  ir4d2  = 1+27*nxy+22*nxyz

  ir5d1  = 1+27*nxy+25*nxyz
!
!-----------------------------------------------------------------------
!
!  Define indices which determine the positions of temporary arrays
!  used in subroutine SOLIR, SOLUV, and CLDFLX.
!
!-----------------------------------------------------------------------
!
  so2d1  = 1+ 1*nxy
  so2d2  = 1+ 2*nxy
  so2d3  = 1+ 3*nxy
  so2d4  = 1+ 4*nxy
  so2d5  = 1+ 7*nxy
  so2d6  = 1+ 8*nxy
  so2d7  = 1+ 9*nxy
  so2d8  = 1+10*nxy
  so2d9  = 1+11*nxy
  so2d10 = 1+12*nxy
  so2d11 = 1+13*nxy
  so2d12 = 1+14*nxy
  so2d13 = 1+15*nxy
  so2d14 = 1+16*nxy
  so2d15 = 1+17*nxy
  so2d16 = 1+18*nxy
  so2d17 = 1+19*nxy
  so2d18 = 1+20*nxy
  so2d19 = 1+21*nxy
  so2d20 = 1+22*nxy
  so2d21 = 1+23*nxy
  so2d22 = 1+24*nxy
  so2d23 = 1+25*nxy

  so3d1  = 1+26*nxy+ 0*nxyz
  so3d2  = 1+26*nxy+ 1*nxyz
  so3d3  = 1+26*nxy+ 2*nxyz
  so3d4  = 1+26*nxy+ 3*nxyz
  so3d5  = 1+26*nxy+ 4*nxyz
  so3d6  = 1+26*nxy+ 5*nxyz
  so3d7  = 1+26*nxy+ 6*nxyz
  so3d8  = 1+26*nxy+ 7*nxyz
  so3d9  = 1+26*nxy+ 8*nxyz
  so3d10 = 1+26*nxy+ 9*nxyz
  so3d11 = 1+26*nxy+10*nxyz
  so3d12 = 1+26*nxy+11*nxyz
  so3d13 = 1+26*nxy+12*nxyz
  so3d14 = 1+26*nxy+13*nxyz

  so4d1  = 1+26*nxy+14*nxyz
  so4d2  = 1+26*nxy+16*nxyz
  so4d3  = 1+26*nxy+18*nxyz
  so4d4  = 1+26*nxy+20*nxyz
  so4d5  = 1+26*nxy+22*nxyz

  so5d1  = 1+26*nxy+24*nxyz
  so5d2  = 1+26*nxy+28*nxyz
  so5d3  = 1+26*nxy+32*nxyz
  so5d4  = 1+26*nxy+36*nxyz
  so5d5  = 1+26*nxy+40*nxyz

  RETURN
END SUBROUTINE setradwrk
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE WRTRAD                     ######
!######                                                      ######
!######                     Developed by                     ######
!######     Center for Analysis and Prediction of Storms     ######
!######                University of Oklahoma                ######
!######                                                      ######
!##################################################################
!##################################################################
!
!  REMOVED ... GHB 100720
!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE CLDOPTD                    ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######                University of Oklahoma                ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE cldoptd(nx,ny,m,n,nz, radstgr,                               &
           pres,temp,qc,qr,qi,qs,qh, rhostr,                            &
           tauir,tauswi,tauswl,reffi,reffl,zen)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Calculate the optical depth
!
!-----------------------------------------------------------------------
!
!  AUTHOR: NASA Goddard Center
!
!  MODIFICATION:
!
!  03/11/1996 (Yuhe Liu)
!  Modified the original code from 1-D to 3-D
!
!-----------------------------------------------------------------------
!
!  INPUT:
!
!    nx       Number of grid points in the x-direction (east/west)
!    ny       Number of grid points in the y-direction (north/south)
!    nz       Number of grid points in the z-direction (vertical)
!
!                                               Vertical index order
!    pres     Pressure (mb)                       1 for top
!    temp     Temperature (K),                    1 for top
!    qc       Cloud water mixing ratio (g/g),     1 for bottom
!    qr       Rain water mixing ratio (g/g),      1 for bottom
!    qi       cloud ice mixing ratio (g/g),       1 for bottom
!    qs       Snow mixing ratio (g/g),            1 for bottom
!    qh       Hail mixing ratio (g/g),            1 for bottom
!    rhostr   Density multiply by j3,             1 for bottom
!    j3inv    1/j3,                               1 for bottom
!    zen      Solar zenith angle
!
!  OUTPUT:
!
!    tauir    Cloud optical depth for longwave,   1 for bottom
!    tauswi   Cloud optical depth for ice cloud
!             for shortwave,                      1 for bottom
!    tauswl   Cloud optical depth for liquid cloud
!             for shortwave,                      1 for bottom
!    reffi    Effective cloud-particle size (mm)
!             for ice cloud for shortwave,        1 for bottom
!    reffl    Effective cloud-particle size (mm)
!             for liquid cloud for shortwave,     1 for bottom
!
!  WORK ARRAY:
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

  INTEGER :: nx,ny,nz
  INTEGER :: m,n
  INTEGER :: radstgr

  REAL :: pres  (nx,ny,nz)      ! in mb
  REAL :: temp  (nx,ny,nz)      ! in K
  REAL :: qc    (nx,ny,nz)      ! in g/g
  REAL :: qr    (nx,ny,nz)      ! in g/g
  REAL :: qi    (nx,ny,nz)      ! in g/g
  REAL :: qs    (nx,ny,nz)      ! in g/g
  REAL :: qh    (nx,ny,nz)      ! in g/g
  REAL :: rhostr(nx,ny,nz)      ! in kg/m**3

  REAL :: tauir (nx,ny,nz)
  REAL :: tauswi(nx,ny,nz)
  REAL :: tauswl(nx,ny,nz)
  REAL :: reffi (nx,ny,nz)
  REAL :: reffl (nx,ny,nz)

  REAL :: tauqc
  REAL :: tauqr
  REAL :: tauqi
  REAL :: tauqs
  REAL :: tauqh
  REAL :: reff1
  REAL :: reff2
  REAL :: zen

  REAL :: w1, effrad

  REAL :: cpi,twco, dpg, rho

  INTEGER :: i,j,k, im,jm,km
!!!  INTEGER :: istgr, jstgr, jodd

      real, parameter :: g      = 9.81
!
!-----------------------------------------------------------------------
!
!  Include files:
!
!-----------------------------------------------------------------------
!
!!!  INCLUDE 'phycst.inc'
  INCLUDE 'radcst.incl'
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
  cpi  = 4.*ATAN(1.)
  twco = 1.e-6

!!!  IF ( radstgr == 0 ) THEN
!!!    istgr = 0
!!!    jstgr = 1
!!!  ELSE
!!!    stop 77774
!!!  END IF

  DO km=3,nz-1
    k = nz+1-km

    DO j=1,ny
      DO i=1,nx

        im = i
        jm = j

        rho = rhostr(i,j,k)*1.0E-3        ! g/cm**3
        dpg = 10.0*(pres(im,jm,km+1)-pres(im,jm,km))/g ! g/cm**2

        IF ( qc(i,j,k) >= twco ) THEN
          w1     = dpg*qc(i,j,k)
          effrad = 0.0015
          tauqc  = w1/effrad
          reff2  = effrad*1.0E4
        ELSE
          tauqc = 0.0
          reff2 = 0.0
        END IF

        IF ( qr(i,j,k) >= twco ) THEN
          w1     = dpg*qr(i,j,k)
          effrad = 3./((cpi*tnw*roqr/(rho*qr(i,j,k)))**.25)
          tauqr  = w1/effrad
        ELSE
          tauqr=0.0
        END IF

        IF ( qi(i,j,k)+qs(i,j,k) >= twco ) THEN
          w1 = 1.e4*dpg*(qi(i,j,k)+qs(i,j,k))

          IF ( temp(im,jm,km) > 243.16 ) THEN
            effrad = 0.0125
          ELSE IF ( temp(im,jm,km) < 223.16 ) THEN
            effrad = 0.0025
          ELSE
            effrad = 0.0125+(temp(im,jm,km)-243.16)*0.00050
          END IF

          tauqs = w1*(-0.006656 +  3.686E-4/effrad)
          tauqi = w1*(-0.011500 +  4.110E-4/effrad                      &
                                + 17.300E-8/(effrad*effrad))
          reff1 = effrad*1.0E4
        ELSE
          tauqi = 0.0
          tauqs = 0.0
          reff1 = 0.0
        END IF

        IF ( qh(i,j,k) >= twco ) THEN
          w1     = dpg*qh(i,j,k)
          effrad = 3./((cpi*tng*roqg/(rho*qh(i,j,k)))**.25)
          tauqh  = w1/effrad
        ELSE
          tauqh  = 0.0
        END IF

        tauswi(im,jm,km) = tauqs + tauqh
        tauswl(im,jm,km) = 1.5 * ( tauqc + tauqr )
        reffi (im,jm,km) = reff1
        reffl (im,jm,km) = reff2
        tauir (im,jm,km)  = 0.5 * tauswl(im,jm,km) + tauqi + tauqh
      END DO
    END DO
  END DO

  IF ( radstgr /= 0 .AND. MOD(ny,2) == 0 ) THEN
    stop 77775
  END IF

  DO jm=1,n
    DO im=1,m
      tauswi(im,jm,1) = 0.0
      tauswl(im,jm,1) = 0.0
      reffi (im,jm,1) = 0.0
      reffl (im,jm,1) = 0.0
      tauir (im,jm,1) = 0.0

      tauswi(im,jm,2) = 0.0
      tauswl(im,jm,2) = 0.0
      reffi (im,jm,2) = 0.0
      reffl (im,jm,2) = 0.0
      tauir (im,jm,2) = 0.0
    END DO
  END DO

  RETURN
END SUBROUTINE cldoptd
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE FITO3                      ######
!######                                                      ######
!######                     Developed by                     ######
!######                                                      ######
!######    Goddard Cumulus Ensemble Modeling Group, NASA     ######
!######                                                      ######
!######     Center for Analysis and Prediction of Storms     ######
!######               University of Oklahoma                 ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE fito3(nx,ny,m,n,np,pl,ao,prs0,o30,ib,ie,jb,je,kb,ke,nk)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  This subroutine is to fit o3 to the model grid
!
!-----------------------------------------------------------------------
!
!  AUTHOR: (a) Radiative Transfer Model: M.-D. Chou and M. Suarez
!          (b) Cloud Optics:Tao, Lang, Simpson, Sui, Ferrier and
!              Chou (1996)
!
!  MODIFICATION HISTORY:
!
!  03/15/1996 (Yuhe Liu)
!  Modified the subroutine from 1-D to 3-D
!
!-----------------------------------------------------------------------
!
!fpp$ expand (terp1)
!!dir$ inline always terp1
!*$*  inline routine (terp1)
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

  INTEGER :: nx,ny,np
  INTEGER :: m,n

  REAL :: pl(nx,ny,np+1)      ! Model pressure (mb)
  REAL :: ao(nx,ny,np+1)        ! Model o3 mixing ratio (g/g)

  integer, intent(in) :: ib,ie,jb,je,kb,ke,nk
  real, dimension(ib:ie,jb:je,kb:ke) :: prs0,o30
!
!-----------------------------------------------------------------------
!
!  Local definitions
!
!-----------------------------------------------------------------------
!
  INTEGER :: lay
  PARAMETER (lay=75)

!  integer iop(2),itab(3),iflag(5)
  INTEGER :: iop(2),itab(3)

  REAL :: pa(lay)       ! Local layer pressure (mb)
  REAL :: ta(lay)       ! Local layer temperature (K)
  REAL :: wa(lay)       ! Local layer water vapor mixing ratio (g/g)
  REAL :: oa(lay)       ! Local layer o3 mixing ratio (g/g)

!  real tsi(5)
!  real w(lay)
  REAL :: tab(3)
  REAL :: wk(lay,4)

  INTEGER :: i,j,k
  INTEGER :: INT, ix
!  integer lun

!  real y
  REAL :: p
!
!----- ix=        1:trp; 2:mls; 3:mlw; 4:sas; 5:saw
!  data iflag/  1   ,  0   ,  0   ,  0   ,  0   /
!  data   tsi/ 300.0, 294.0, 272.2, 287.0, 257.1/
!
!-----------------------------------------------------------------------
!
!  Local data bank for pressure, temperature, moisture, and o3
!
!-----------------------------------------------------------------------
!
  DATA (pa(k),k=1,lay)/                                                 &
           .0003,    .0008,    .0011,    .0015,     .0021,              &
           .0029,    .0041,    .0058,    .0081,     .0113,              &
           .0158,    .0221,    .0310,    .0435,     .0609,              &
           .0855,    .1200,    .1700,    .2400,     .3350,              &
           .4650,    .6500,    .9150,   1.2850,    1.8000,              &
          2.5250,   3.5450,   4.9700,   6.9700,    9.7800,              &
         13.7150,  19.2350,  26.9850,  37.8550,   53.1000,              &
         73.8900,  97.6650, 121.4350, 145.2100,  168.9900,              &
        192.7650, 216.5400, 240.3150, 264.0900,  287.8650,              &
        311.6350, 335.4100, 359.1900, 382.9650,  406.7400,              &
        430.5150, 454.2850, 478.0600, 501.8350,  525.6100,              &
        549.3900, 573.1650, 596.9400, 620.7150,  644.4900,              &
        668.2650, 692.0350, 715.8100, 739.5850,  763.3600,              &
        787.1400, 810.9150, 834.6900, 858.4650,  882.2400,              &
        906.0150, 929.7850, 953.5600, 977.3350, 1001.1100/

  DATA (ta(k),k=1,lay)/                                                 &
        209.86, 210.20, 210.73, 211.27, 211.81,                         &
        212.35, 212.89, 213.44, 213.98, 214.53,                         &
        215.08, 215.62, 216.17, 216.74, 218.11,                         &
        223.20, 230.04, 237.14, 244.46, 252.00,                         &
        259.76, 267.70, 274.93, 274.60, 269.38,                         &
        262.94, 256.45, 250.12, 244.31, 238.96,                         &
        233.74, 228.69, 224.59, 221.75, 219.10,                         &
        216.64, 215.76, 215.75, 215.78, 216.22,                         &
        219.15, 223.79, 228.29, 232.45, 236.33,                         &
        239.92, 243.32, 246.53, 249.56, 252.43,                         &
        255.14, 257.69, 260.11, 262.39, 264.57,                         &
        266.66, 268.67, 270.60, 272.48, 274.29,                         &
        276.05, 277.75, 279.41, 281.02, 282.59,                         &
        284.09, 285.53, 286.86, 288.06, 289.13,                         &
        290.11, 291.03, 291.91, 292.76, 293.59/


  DATA (wa(k),k=1,lay)/                                                 &
        0.400E-05, 0.400E-05, 0.400E-05, 0.400E-05, 0.400E-05,          &
        0.400E-05, 0.400E-05, 0.400E-05, 0.400E-05, 0.400E-05,          &
        0.400E-05, 0.400E-05, 0.400E-05, 0.400E-05, 0.400E-05,          &
        0.400E-05, 0.400E-05, 0.400E-05, 0.400E-05, 0.400E-05,          &
        0.400E-05, 0.400E-05, 0.400E-05, 0.400E-05, 0.400E-05,          &
        0.400E-05, 0.400E-05, 0.400E-05, 0.400E-05, 0.400E-05,          &
        0.400E-05, 0.400E-05, 0.400E-05, 0.400E-05, 0.400E-05,          &
        0.400E-05, 0.400E-05, 0.400E-05, 0.406E-05, 0.520E-05,          &
        0.115E-04, 0.275E-04, 0.572E-04, 0.107E-03, 0.166E-03,          &
        0.223E-03, 0.285E-03, 0.360E-03, 0.446E-03, 0.547E-03,          &
        0.655E-03, 0.767E-03, 0.890E-03, 0.103E-02, 0.118E-02,          &
        0.136E-02, 0.159E-02, 0.190E-02, 0.225E-02, 0.264E-02,          &
        0.306E-02, 0.351E-02, 0.399E-02, 0.450E-02, 0.504E-02,          &
        0.560E-02, 0.619E-02, 0.680E-02, 0.742E-02, 0.805E-02,          &
        0.869E-02, 0.935E-02, 0.100E-01, 0.107E-01, 0.113E-01/

  DATA (oa(k),k=1,lay)/                                                 &
       .643E-07, .202E-06, .246E-06, .290E-06, .334E-06,                &
       .378E-06, .422E-06, .467E-06, .512E-06, .557E-06,                &
       .603E-06, .648E-06, .694E-06, .740E-06, .793E-06,                &
       .101E-05, .131E-05, .164E-05, .198E-05, .234E-05,                &
       .272E-05, .312E-05, .359E-05, .465E-05, .590E-05,                &
       .765E-05, .910E-05, .960E-05, .994E-05, .101E-04,                &
       .990E-05, .853E-05, .710E-05, .576E-05, .423E-05,                &
       .260E-05, .152E-05, .102E-05, .786E-06, .598E-06,                &
       .448E-06, .352E-06, .302E-06, .252E-06, .212E-06,                &
       .193E-06, .176E-06, .160E-06, .147E-06, .137E-06,                &
       .127E-06, .118E-06, .109E-06, .103E-06, .975E-07,                &
       .924E-07, .883E-07, .846E-07, .810E-07, .778E-07,                &
       .749E-07, .721E-07, .694E-07, .671E-07, .648E-07,                &
       .626E-07, .607E-07, .593E-07, .579E-07, .565E-07,                &
       .552E-07, .540E-07, .528E-07, .517E-07, .505E-07/
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
  ix=1

  iop(1)=4
  iop(2)=4
  INT=1

  CALL coeff(lay,pa,oa,wa,iop,INT,wk)

!$omp parallel do default(shared)  &
!$omp private(i,j,k,p,tab,itab)
  DO k=kb,ke
    DO j=jb,je
      DO i=ib,ie
        itab(1)=1
        itab(2)=0
        itab(3)=0
!!!        p = 0.5 * ( pl(i,j,k+1) + pl(i,j,k) )
        p = 0.01*prs0(i,j,k)
        CALL terp1(lay,pa,oa,wa,p,INT,tab,itab)
!!!        ao(i,j,k)=tab(1)
        o30(i,j,nk+1-k)=tab(1)
      END DO
    END DO
  END DO

  RETURN
END SUBROUTINE fito3
!
!##################################################################
!##################################################################
!######                                                      ######
!######                   FUNCTION AERODEN                   ######
!######                                                      ######
!######                     Developed by                     ######
!######     Center for Analysis and Prediction of Storms     ######
!######                University of Oklahoma                ######
!######                                                      ######
!##################################################################
!##################################################################
!

  FUNCTION aeroden(p,psfc)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Assign aerosol optical density (per Pa)
!  For now we use an estimate based on the aerosol density used
!  in simple climate models, where 0.05 of optical depth is
!  assumed uniformly distributed over mass sfc to 800 mb and
!  0.025 is uniformly distributed over mass 800 mb to 225 mb.
!
!  Here we normalize that distribution according to the
!  surface pressure so that the mountains don't lose aerosols.
!
!  Aerosol optical depth is computed by calling routine as
!  layer depth (Pa) times this aerosol density.
!
!  AUTHOR:   Keith Brewster
!
!  MODIFICATION HISTORY
!
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE
  REAL :: p,psfc
  REAL :: aeroden
!
  IF (p < (.225*psfc)) THEN
    aeroden=0.
  ELSE IF (p < (.80*psfc)) THEN
    aeroden=0.025/(0.575*psfc)
  ELSE
    aeroden=0.050/(0.2*psfc)
  END IF
  RETURN
  END FUNCTION aeroden

!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE JULDAY                     ######
!######                                                      ######
!######                     Developed by                     ######
!######     Center for Analysis and Prediction of Storms     ######
!######                University of Oklahoma                ######
!######                                                      ######
!##################################################################
!##################################################################
!

SUBROUTINE julday( year, month, day, jday )
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Compute Julian day from year, month, and day
!
!  Start from 1 (Jan. 1) to 365, or 366 for leap year (Dec. 31)
!
!  The rule is that a year will be a leap year if
!
!    the year can be divided by 400, or
!    the year can by divided by 4, but not by 100
!
!  Form this rule year 1972, 1984, 1996, and 2000 are leap years,
!  but 1700, 1800 and 1900 are not.
!
!-----------------------------------------------------------------------
!
!  AUTHOR: Yuhe Liu
!  07/29/93
!
!  MODIFICATIONS:
!
!  05/06/1998 (Yuhe Liu)
!  Corrected the leap year calculation.
!
!-----------------------------------------------------------------------
!
!  INPUT:
!
!    year       Reference calendar year
!    month      Reference monthe of the year
!    day        Reference day of the month
!
!    OUTPUT:
!
!    jday       Julian day, start from 1 -- Jan. 1 to 365 -- Dec. 31
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

  INTEGER :: year, month, day, jday
  INTEGER :: lpyear, lp

  INTEGER :: mndys(12)     ! Day numbers for each month
  DATA mndys/0,31,59,90,120,151,181,212,243,273,304,334/
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
  IF ( MOD(year,400) == 0 .OR.                                          &
         (MOD(year,4) == 0 .AND. MOD(year,100) /= 0 ) ) THEN
    lpyear = 1
  ELSE
    lpyear = 0
  END IF

  lp = 0
  IF ( month > 2 ) lp = lpyear

  jday = mndys(month) + day + lp

  RETURN
END SUBROUTINE julday

!
!
!##################################################################
!##################################################################
!######                                                      ######
!######                SUBROUTINE ZENANGL                    ######
!######                                                      ######
!######                     Developed by                     ######
!######     Center for Analysis and Prediction of Storms     ######
!######                University of Oklahoma                ######
!######                                                      ######
!##################################################################
!##################################################################
!
SUBROUTINE zenangl(nx,ny, x,y, hterain, cosz, cosss, a2dr2,             &
           rjday,tloc, latscl,lonscl, slpmag,slpdir,                    &
           tem1,tem2,saltitude,sazimuth,dx,dy,dtbig,curtim,             &
           ctrlat,ctrlon,year,month,day,hour,minute,second,jday)
!
!-----------------------------------------------------------------------
!
!  PURPOSE:
!
!  Calculate cosine of solar zenith angle.
!
!-----------------------------------------------------------------------
!
!  AUTHOR: Yuhe Liu and Vince Wong
!  11/16/93
!
!  MODIFICATION HISTORY:
!  2/2/99  Vince Wong and Jik Leong
!  This modification calculates the solar declination angle and
!  equation of time using a method found on page C24 of the
!  1996 Astronomical Almanac.
!  The mothod is good to 0.01 degrees in the sky over the
!  period 1950 to 2050.
!
! augustin
!  8/23/01 Augustin Colette EFML/ Stanford University
!
! Computation of the solar altitude and azimuth
! saltitude and sazimuth are outputs of zenangl to be used in shade
! sources:
! http://www.usc.edu/dept/architecture/mbs/tools/vrsolar/Help/ &
! solar_concepts.html
! http://www.uwinnipeg.ca/~blair/physclim/lab2.htm
! http://ra.stsci.edu/cgi-bin/gethelp.cgi?altaz.src
!
!-----------------------------------------------------------------------
!
!  INPUT:
!
!    nx       Number of grid points in the x-direction (east/west)
!    ny       Number of grid points in the y-direction (north/south)
!
!    x        X coordinates at scalar points
!    y        Y coordinates at scalar points
!    hterain  Surface terrain
!
!  OUTPUT:
!
!    cosz     Cosine of zenith
!    cosss    Cosine of angle between sun light and terrain slope
!    a2dr2    Square ratio of average distance to the time
!             dependent distance from the earth to the sun
!
!augustin
!    sazimuth  solar azimuth
!    saltitude solar altitude
!
!  WORK ARRAY:
!
!    rjday    Julian day at each grid point
!    tloc     Local time at each grid point
!    latscl   Latitudes  at scalar points
!    lonscl   Longitudes at scalar points
!    slpmag   Surface terrain slope magnitude
!    slpdir   Surface terrain slope direction
!
!-----------------------------------------------------------------------
!
  IMPLICIT NONE

  INTEGER :: nx,ny
  real :: dx,dy
  real :: dtbig,curtim
  real :: ctrlat,ctrlon
  integer :: year,month,day,hour,minute,second,jday

  REAL :: x(nx+1)
  REAL :: y(ny+1)
  REAL :: hterain(nx,ny)

  REAL :: cosz(nx,ny),   cosss(nx,ny), a2dr2(nx,ny)
  REAL :: rjday(nx,ny),  tloc(nx,ny)
  REAL :: latscl(nx,ny), lonscl(nx,ny)
  REAL :: slpmag(nx,ny), slpdir(nx,ny)
!augustin add saltitude and sazimuth in the outputs of zenanlg
  REAL :: saltitude
  REAL :: sazimuth

  REAL :: tem1(nx,ny), tem2(nx,ny)
!
!-----------------------------------------------------------------------
!
!  Include file:
!
!-----------------------------------------------------------------------
!
  INCLUDE 'radcst.incl'
  INCLUDE 'radmore.incl'
!!!  INCLUDE 'globcst.inc'
!!!  INCLUDE 'grid.inc'          ! Grid & map parameters.
!!!  INCLUDE 'phycst.inc'
!!!  INCLUDE 'mp.inc'
!
!-----------------------------------------------------------------------
!
!  Local variables:
!
!-----------------------------------------------------------------------
!
  INTEGER :: i,j

  REAL :: xs, ys

!!!  REAL :: hour0, yrday
!!!  REAL :: deg2rad, pi, pi2

  REAL :: etau, shrangl, sdeclin
  REAL :: azimuth, sinz
  REAL :: dpsi, sinpsi, cospsi

  REAL :: anncyc

  REAL :: hr, days2k, lsun, gsun, obliq, lambda, xsun, ysun
!!!  REAL :: asun, alpha, rad2deg
  REAL :: asun, alpha

  LOGICAL :: firstcall        ! First call flag of this subroutine

  include 'radzen.incl'

!!!  SAVE firstcall, hour0, pi, pi2, deg2rad, yrday, rad2deg
!!!  DATA firstcall/.true./

!!!  ! added to calculate saltitude and sazimuth at the middle domain
!!!  INTEGER :: nxmid, nymid, source 
!!!  SAVE nxmid, nymid, source

  REAL :: shrangl_mid
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!  Beginning of executable code...
!
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!
!----- moved this section of code to initrad -----!
!  IF (firstcall) THEN
!    pi  = 3.14159265358979
!    pi2 = 2.0 * pi
!    deg2rad = pi/180.0
!    rad2deg = 1./deg2rad
!
!    hour0 = FLOAT(hour)                                                 &
!          + FLOAT(minute)/60.0                                          &
!          + FLOAT(second)/3600.0
!
!    IF ( MOD(year, 4) == 0 ) THEN
!      yrday = 366.
!    ELSE
!      yrday = 365.
!    END IF
!
!    nxmid = CEILING( 0.5*((nx-3)*nproc_x + 3) )   ! Middle point index at
!    nymid = CEILING( 0.5*((ny-3)*nproc_y + 3) )   ! global domain
!!!! Not using arps MPI code:  GHB, 100720
!    source = 0
!!!!    source = proc( (nxmid-2)/(nx-3)+1 + ( (nymid-2)/(ny-3) )*nproc_x )
!!!!                                ! source processor contain the middle point.
!    nxmid = MOD( (nxmid-2), (nx-3) ) + 2    ! local index of central domain
!    nymid = MOD( (nymid-2), (ny-3) ) + 2
!
!    firstcall = .false.
!  END IF

        slpmag = 0.
        slpdir = 0.
!!!  CALL sfcslp( nx,ny, hterain, slpmag,slpdir, tem1,tem2,dx,dy )

!!! not considering map projections, for now:  GHB, 100720
!  IF ( mapproj == 0 ) THEN
    DO j=1,ny
      DO i=1,nx
        latscl(i,j) = ctrlat
        lonscl(i,j) = ctrlon
      END DO
    END DO
!  ELSE
!    DO j=1,ny
!      ys = 0.5*(y(j)+y(j+1))
!      DO i=1,nx
!        xs = 0.5*(x(i)+x(i+1))
!        CALL xytoll(1,1, xs,ys, latscl(i,j), lonscl(i,j))
!      END DO
!    END DO
!  END IF
!
!-----------------------------------------------------------------------
!
!  Calculate the local time at each grid point. The
!  following formula is based on that the input time is the GMT
!  time at the reference grid point of the center.
!
!-----------------------------------------------------------------------
!
  DO j=1,ny
    DO i=1,nx

      latscl(i,j) = deg2rad * latscl(i,j)        ! lat: -90 to 90

      tloc(i,j) = hour0 + (curtim-dtbig)/3600.0                         &
                + lonscl(i,j)/15.0

      rjday(i,j) = jday + INT( tloc(i,j)/24.0 )

      tloc(i,j) = MOD( tloc(i,j), 24.0 )

      IF ( tloc(i,j) < 0. ) THEN
        tloc(i,j) = tloc(i,j) + 24.0            ! Local time
        rjday(i,j) = MOD( rjday(i,j)-1, yrday ) ! Julian day at each pts
      END IF

    END DO
  END DO

!!!  print *,'  curtim,dtbig = ',curtim,dtbig
!!!  print *,'  tloc,rjday,latscl = ',tloc(2,2),rjday(2,2),latscl(2,2)

  DO j=1,ny
    DO i=1,nx
      anncyc = pi2 * ( rjday(i,j) - 1.0 ) / yrday

      a2dr2(i,j) = 1.000110                                             &
                 + 0.034221 * COS(anncyc)                               &
                 + 0.00128  * SIN(anncyc)                               &
                 + 0.000719 * COS(2.*anncyc)                            &
                 + 0.000077 * SIN(2.*anncyc)  ! PX, Eq. 17

      hr = hour + minute / 60.

!  days before (-ve) or after (+ve) 1/1/2000
      days2k = 367 * year - 7 * ( year + ( month + 9 ) / 12 ) / 4       &
              + 275 * month / 9 + day - 730531.5 + hr / 24.

      lsun = 280.461 + 0.9856474 * days2k     ! Mean Longitude of the Sun
      950     IF ( lsun < 0 ) THEN
        lsun = lsun + 360.
        GO TO 950
      ELSE IF ( lsun > 360 ) THEN
        lsun = lsun - 360.
        GO TO 950
      END IF

      gsun = 357.528 + 0.9856003 * days2k     ! Mean anomaly of the Sun
      960     IF ( gsun < 0 ) THEN
        gsun = gsun + 360.
        GO TO 960
      ELSE IF ( gsun > 360 ) THEN
        gsun = gsun - 360.
        GO TO 960
      END IF

      lambda = lsun + 1.915 * SIN(gsun*deg2rad)  & ! Ecliptic longitude
          + 0.02 * SIN(2*gsun*deg2rad)
      970     IF ( lambda < 0 ) THEN
        lambda = lambda + 360.
        GO TO 970
      ELSE IF ( lambda > 360 ) THEN
        lambda = lambda - 360.
        GO TO 970
      END IF

      obliq = 23.439 - 0.0000004 * days2k     ! Obliquity of the ecliptic

      xsun = COS(lambda*deg2rad)
      ysun = COS(obliq*deg2rad) * SIN(lambda*deg2rad)
      asun = ATAN(ysun/xsun)*rad2deg
      IF ( xsun < 0. ) THEN
        alpha = asun + 180   ! Right Ascension (RA)
      ELSE IF ( ( ysun < 0. ) .AND. ( xsun > 0. ) ) THEN
        alpha = asun + 360
      ELSE
        alpha = asun
      END IF

      etau = ( lsun - alpha ) * 4. / 60.      ! Equation of time in hour

!    etau = 0.158 * sin( pi*(rjday(i,j)+10.)/91.25 ) ! Equation of time
!    :       + 0.125 * sin( pi*rjday(i,j)/182.5 )       ! Wong, Eq. 8

      shrangl = 15.0 * deg2rad                        & ! Hour angle
                     * ( tloc(i,j) + etau - 12.0)       ! Wong, Eq. 7

!    sdeclin = 23.5 * deg2rad
!    :          * cos( 2.0*pi*(rjday(i,j)-173.)/yrday ) ! Wong, Eq. 6
      sdeclin = ASIN(SIN(obliq*deg2rad)*SIN(lambda*deg2rad))
                                                ! Declination (in radian)

      cosz(i,j) = COS(latscl(i,j)) * COS(sdeclin) * COS(shrangl)        &
                + SIN(latscl(i,j)) * SIN(sdeclin)

!    print *, cos(latscl(i,j)),cos(sdeclin),cos(shrangl)
!    print *, sin(latscl(i,j)),sin(sdeclin)
!    print *,sdeclin,shrangl

      sinz = SIN ( ACOS(cosz(i,j)) )
!
!-----------------------------------------------------------------------
!
!  Consider the effects of the terrain slope on the solar radiation.
!  The slope magnitude and direction has been computed by subroutine
!  SFCSLP and passed in by slpmag and slpdir.
!
!-----------------------------------------------------------------------
!

      sinpsi = COS(sdeclin) * SIN(shrangl) *COS(latscl(i,j))
      cospsi = COSZ(i,j) * SIN( latscl(i,j) ) - SIN( sdeclin )
      azimuth = ATAN2( sinpsi, cospsi)

      dpsi = azimuth - slpdir(i,j)

      cosss(i,j) = COS( slpmag(i,j) ) * cosz(i,j)                       &
                 + SIN( slpmag(i,j) ) * sinz * COS( dpsi )

      cosz (i,j) = MAX( cosz (i,j), 0.0 )
      cosss(i,j) = MAX( cosss(i,j), 0.0 )

! added to calculate saltitude and sazimuth later for shading
!     IF( radshade /= 0) THEN  want azimuth regardless of shading

        IF (i == nxmid .AND. j == nymid) THEN
  
! augustin
! computes the solar altitudes and azimuth,
! sazimuth: 0=North; pi/2=East; Pi=South; 3*pi/2=West
! see the reference listed in the header of subroutine ZENANGL for more 
! information

        saltitude = pi/2-ACOS(cosz(i,j))

!  the following code is not computation safe (division by zero) DBW
!       sazimuth  = ACOS ( (SIN(sdeclin) * COS (latscl(i,j))             &
!                   - COS(sdeclin) * SIN (latscl(i,j))                   &
!                      * COS (shrangl))/sinz)

!  the above is replaced with:   DBW

        sinpsi = COS(sdeclin) * SIN(shrangl) * COS(latscl(i,j))
        cospsi = - COSZ(i,j) * SIN( latscl(i,j) ) + SIN( sdeclin )
        sazimuth = ABS( ATAN2(sinpsi, cospsi) )

!  end or replacement code  DBW

        shrangl_mid = shrangl

       END IF

 !     END IF  !  end of radshade if block..!want azimuth regardless of rshade

    END DO
  END DO

 ! IF( radshade /= 0) THEN

! broadcast these value from source to all other processors

! GHB, 100720
!!!    CALL mpbcastr(saltitude,   source)
!!!    CALL mpbcastr(sazimuth,    source)
!!!    CALL mpbcastr(shrangl_mid, source)

! modification of shrangl

! In the definition of the hour angle, shrangl  should be
! between -pi and 0 before solar noon and between 0 and pi after.
! Before this error, zenangl gave positive values
! between pi and 2*pi of shrangl
! before solar noon for some latitudes and day.
! for instance, +45 deg north March 21 2001
! it causes not problem in the original ARPS since it is just 
! a problem of module but subroutine shade needs to have shrangl 
! between -pi and pi


    IF ((shrangl_mid > pi) .AND. (shrangl_mid < pi2)) THEN
      shrangl_mid = shrangl_mid - pi2
    END IF
    IF ((shrangl_mid > pi2) .AND. (shrangl_mid < pi2+pi)) THEN
      shrangl_mid = shrangl_mid - pi2
    END IF

    IF (shrangl_mid > 0) THEN
      sazimuth = pi2 - sazimuth
    END IF

 ! END IF  !  end of radshade if block...

  RETURN
END SUBROUTINE zenangl

getcape.F/      1298670057  19071 8000  100644  16645     `
!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------

    subroutine getcape( source, nk , p_in , t_in , q_in, cape , cin,   &
                        zlcl, zlfc, zel , psource , tsource , qvsource )
    implicit none

    integer, intent(in) :: source,nk
    real, dimension(nk), intent(in) :: p_in,t_in,q_in
    real, intent(out) :: cape,cin,psource,tsource,qvsource

!-----------------------------------------------------------------------
!
!  getcape - a fortran90 subroutine to calculate Convective Available
!            Potential Energy (CAPE) from a sounding.
!
!   *** Modified version to calculate Lifted Condensation Level (LCL)  ***
!   *** Level of Free Convection (LFC), and Equilibrium Level (EL)     ***
!
!  Version 1.04                           Last modified:  8 October 2010
!
!  Author:  George H. Bryan
!           Mesoscale and Microscale Meteorology Division
!           National Center for Atmospheric Research
!           Boulder, Colorado, USA
!           gbryan@ucar.edu
!
!  Disclaimer:  This code is made available WITHOUT WARRANTY.
!
!  References:  Bolton (1980, MWR, p. 1046) (constants and definitions)
!               Bryan and Fritsch (2004, MWR, p. 2421) (ice processes)
!
!-----------------------------------------------------------------------
!
!  Input:     nk - number of levels in the sounding (integer)
!
!           p_in - one-dimensional array of pressure (mb) (real)
!
!           t_in - one-dimensional array of temperature (C) (real)
!
!           q_in - one-dimensional array of water vapor mixing ratio (kg/kg) (real)
!
!  Output:  cape - Convective Available Potential Energy (J/kg) (real)
!
!            cin - Convective Inhibition (J/kg) (real)
!
!-----------------------------------------------------------------------
!  User options:

    real, parameter :: pinc = 100.0   ! Pressure increment (Pa)
                                      ! (smaller number yields more accurate
                                      !  results,larger number makes code 
                                      !  go faster)

!!!    integer, parameter :: source = 2    ! Source parcel:
!!!                                        ! 1 = surface
!!!                                        ! 2 = most unstable (max theta-e)
!!!                                        ! 3 = mixed-layer (specify ml_depth)

    real, parameter :: ml_depth =  500.0  ! depth (m) of mixed layer 
                                          ! for source=3

    integer, parameter :: adiabat = 1   ! Formulation of moist adiabat:
                                        ! 1 = pseudoadiabatic, liquid only
                                        ! 2 = reversible, liquid only
                                        ! 3 = pseudoadiabatic, with ice
                                        ! 4 = reversible, with ice

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------
!            No need to modify anything below here:
!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------

    logical :: doit,ice,cloud,not_converged
    integer :: k,kmax,n,nloop,i,orec
    real, dimension(nk) :: p,t,td,pi,q,th,thv,z,pt,pb,pc,pn,ptv,ptd,pqv,pql

    real :: the,maxthe,parea,narea,lfc
    real :: th1,p1,t1,qv1,ql1,qi1,b1,pi1,thv1,qt,dp,dz,ps,frac
    real :: th2,p2,t2,qv2,ql2,qi2,b2,pi2,thv2
    real :: thlast,fliq,fice,tbar,qvbar,qlbar,qibar,lhv,lhs,lhf,rm,cpm
    real*8 :: avgth,avgqv
    real :: getqvl,getqvi,getthx,gettd
    real :: ee,zlcl,zlfc,zel,plcl,plfc,pel,zh

!-----------------------------------------------------------------------

    real, parameter :: g     = 9.81
    real, parameter :: p00   = 100000.0
    real, parameter :: cp    = 1005.7
    real, parameter :: rd    = 287.04
    real, parameter :: rv    = 461.5
    real, parameter :: xlv   = 2501000.0
    real, parameter :: xls   = 2836017.0
    real, parameter :: t0    = 273.15
    real, parameter :: cpv   = 1875.0
    real, parameter :: cpl   = 4190.0
    real, parameter :: cpi   = 2118.636
    real, parameter :: lv1   = xlv+(cpl-cpv)*t0
    real, parameter :: lv2   = cpl-cpv
    real, parameter :: ls1   = xls+(cpi-cpv)*t0
    real, parameter :: ls2   = cpi-cpv

    real, parameter :: rp00  = 1.0/p00
    real, parameter :: eps   = rd/rv
    real, parameter :: reps  = rv/rd
    real, parameter :: rddcp = rd/cp
    real, parameter :: cpdrd = cp/rd
    real, parameter :: cpdg  = cp/g

    real, parameter :: converge = 0.0002

    integer, parameter :: debug_level =   0

!-----------------------------------------------------------------------

!---- convert p,t,td to mks units; get pi,q,th,thv ----!

    do k=1,nk
        p(k) = 100.0*p_in(k)
        t(k) = 273.15+t_in(k)
        q(k) = q_in(k)
!!!       td(k) = 273.15+td_in(k)
       ee = alog((q(k)/eps)*p(k)/100.0/(1.0+(q(k)/eps)))
       td(k) = 273.15+(243.5*ee-440.8)/(19.48-ee)
       pi(k) = (p(k)*rp00)**rddcp
!!!        q(k) = getqvl(p(k),td(k))
       th(k) = t(k)/pi(k)
      thv(k) = th(k)*(1.0+reps*q(k))/(1.0+q(k))
!!!      print *,k,t(k)-273.15,td(k)-273.15
    enddo

!---- get height using the hydrostatic equation ----!

    z(1) = 0.0
    do k=2,nk
      dz = -cpdg*0.5*(thv(k)+thv(k-1))*(pi(k)-pi(k-1))
      z(k) = z(k-1) + dz
    enddo

!----------------------------------------------------------------

!---- find source parcel ----!

  IF(source.eq.1)THEN
    ! use surface parcel
    kmax = 1

  ELSEIF(source.eq.2)THEN
    ! use most unstable parcel (max theta-e)

    IF(p(1).lt.50000.0)THEN
      ! first report is above 500 mb ... just use the first level reported
      kmax = 1
      maxthe = getthx(p(1),t(1),td(1),q(1))
    ELSE
      ! find max thetae below 500 mb
      maxthe = 0.0
      do k=1,nk
        if(p(k).ge.50000.0)then
          the = getthx(p(k),t(k),td(k),q(k))
          if( the.gt.maxthe )then
            maxthe = the
            kmax = k
          endif
        endif
      enddo
    ENDIF
    if(debug_level.ge.100) print *,'  kmax,maxthe = ',kmax,maxthe

  ELSEIF(source.eq.3)THEN
    ! use mixed layer

    IF( (z(2)-z(1)).gt.ml_depth )THEN
      ! the second level is above the mixed-layer depth:  just use the
      ! lowest level

      avgth = th(1)
      avgqv = q(1)
      kmax = 1

    ELSEIF( z(nk).lt.ml_depth )THEN
      ! the top-most level is within the mixed layer:  just use the
      ! upper-most level

      avgth = th(nk)
      avgqv = q(nk)
      kmax = nk

    ELSE
      ! calculate the mixed-layer properties:

      avgth = 0.0
      avgqv = 0.0
      k = 2
      if(debug_level.ge.100) print *,'  ml_depth = ',ml_depth
      if(debug_level.ge.100) print *,'  k,z,th,q:'
      if(debug_level.ge.100) print *,1,z(1),th(1),q(1)

      do while( (z(k).le.ml_depth) .and. (k.le.nk) )

        if(debug_level.ge.100) print *,k,z(k),th(k),q(k)

        avgth = avgth + 0.5*(z(k)-z(k-1))*(th(k)+th(k-1))
        avgqv = avgqv + 0.5*(z(k)-z(k-1))*(q(k)+q(k-1))

        k = k + 1

      enddo

      th2 = th(k-1)+(th(k)-th(k-1))*(ml_depth-z(k-1))/(z(k)-z(k-1))
      qv2 =  q(k-1)+( q(k)- q(k-1))*(ml_depth-z(k-1))/(z(k)-z(k-1))

      if(debug_level.ge.100) print *,999,ml_depth,th2,qv2

      avgth = avgth + 0.5*(ml_depth-z(k-1))*(th2+th(k-1))
      avgqv = avgqv + 0.5*(ml_depth-z(k-1))*(qv2+q(k-1))

      if(debug_level.ge.100) print *,k,z(k),th(k),q(k)

      avgth = avgth/ml_depth
      avgqv = avgqv/ml_depth

      kmax = 1

    ENDIF

    if(debug_level.ge.100) print *,avgth,avgqv

  ELSE

    print *
    print *,'  Unknown value for source'
    print *
    print *,'  source = ',source
    print *
    stop

  ENDIF

!---- define parcel properties at initial location ----!
    narea = 0.0

  if( (source.eq.1).or.(source.eq.2) )then
    k    = kmax
    th2  = th(kmax)
    pi2  = pi(kmax)
    p2   = p(kmax)
    t2   = t(kmax)
    thv2 = thv(kmax)
    qv2  = q(kmax)
    b2   = 0.0
  elseif( source.eq.3 )then
    k    = kmax
    th2  = avgth
    qv2  = avgqv
    thv2 = th2*(1.0+reps*qv2)/(1.0+qv2)
    pi2  = pi(kmax)
    p2   = p(kmax)
    t2   = th2*pi2
    b2   = g*( thv2-thv(kmax) )/thv(kmax)
  endif

    psource = p2
    tsource = t2
   qvsource = qv2

    ql2 = 0.0
    qi2 = 0.0
    qt  = qv2

    cape = 0.0
    cin  = 0.0
    lfc  = 0.0

    doit = .true.
    cloud = .false.
    if(adiabat.eq.1.or.adiabat.eq.2)then
      ice = .false.
    else
      ice = .true.
    endif

      the = getthx(p2,t2,t2,qv2)
      if(debug_level.ge.100) print *,'  the = ',the

      pt(k) = t2
      if( cloud )then
        ptd(k) = t2
      else
        ptd(k) = gettd(p2,t2,qv2)
      endif
      ptv(k) = t2*(1.0+reps*qv2)/(1.0+qv2)
      pb(k) = 0.0
      pqv(k) = qv2
      pql(k) = 0.0

      zlcl = -1.0
      zlfc = -1.0
      zel  = -1.0

!---- begin ascent of parcel ----!

      if(debug_level.ge.100)then
        print *,'  Start loop:'
        print *,'  p2,th2,qv2 = ',p2,th2,qv2
      endif

    do while( doit .and. (k.lt.nk) )

        k = k+1
       b1 =  b2

       dp = p(k-1)-p(k)

      if( dp.lt.pinc )then
        nloop = 1
      else
        nloop = 1 + int( dp/pinc )
        dp = dp/float(nloop)
      endif

      do n=1,nloop

         p1 =  p2
         t1 =  t2
        pi1 = pi2
        th1 = th2
        qv1 = qv2
        ql1 = ql2
        qi1 = qi2
        thv1 = thv2

        p2 = p2 - dp
        pi2 = (p2*rp00)**rddcp

        thlast = th1
        i = 0
        not_converged = .true.

        do while( not_converged )
          i = i + 1
          t2 = thlast*pi2
          if(ice)then
            fliq = max(min((t2-233.15)/(273.15-233.15),1.0),0.0)
            fice = 1.0-fliq
          else
            fliq = 1.0
            fice = 0.0
          endif
          qv2 = min( qt , fliq*getqvl(p2,t2) + fice*getqvi(p2,t2) )
          qi2 = max( fice*(qt-qv2) , 0.0 )
          ql2 = max( qt-qv2-qi2 , 0.0 )

          tbar  = 0.5*(t1+t2)
          qvbar = 0.5*(qv1+qv2)
          qlbar = 0.5*(ql1+ql2)
          qibar = 0.5*(qi1+qi2)

          lhv = lv1-lv2*tbar
          lhs = ls1-ls2*tbar
          lhf = lhs-lhv

          rm=rd+rv*qvbar
          cpm=cp+cpv*qvbar+cpl*qlbar+cpi*qibar
          th2=th1*exp(  lhv*(ql2-ql1)/(cpm*tbar)     &
                       +lhs*(qi2-qi1)/(cpm*tbar)     &
                       +(rm/cpm-rd/cp)*alog(p2/p1) )

          if(i.gt.90) print *,i,th2,thlast,th2-thlast
          if(i.gt.100)then
            print *
            print *,'  Error:  lack of convergence'
            print *
            print *,'  ... stopping iteration '
            print *
            stop 1001
          endif
          if( abs(th2-thlast).gt.converge )then
            thlast=thlast+0.3*(th2-thlast)
          else
            not_converged = .false.
          endif
        enddo

        ! Latest pressure increment is complete.  Calculate some
        ! important stuff:

        if( ql2.ge.1.0e-10 ) cloud = .true.
        if( cloud .and. zlcl.lt.0.0 )then
           zlcl = z(k-1)+(z(k)-z(k-1))*float(n)/float(nloop)
           plcl = p(k-1)+(p(k)-p(k-1))*float(n)/float(nloop)
        endif

        IF(adiabat.eq.1.or.adiabat.eq.3)THEN
          ! pseudoadiabat
          qt  = qv2
          ql2 = 0.0
          qi2 = 0.0
        ELSEIF(adiabat.le.0.or.adiabat.ge.5)THEN
          print *
          print *,'  Undefined adiabat'
          print *
          stop 10000
        ENDIF

      enddo

      thv2 = th2*(1.0+reps*qv2)/(1.0+qv2+ql2+qi2)
        b2 = g*( thv2-thv(k) )/thv(k)
        dz = -cpdg*0.5*(thv(k)+thv(k-1))*(pi(k)-pi(k-1))

      if( zlcl.gt.0.0 .and. zlfc.lt.0.0 .and. b2.gt.0.0 )then
        if( b1.gt.0.0 )then
          zlfc = zlcl
          plfc = plcl
        else
          zlfc = z(k-1)+(z(k)-z(k-1))*(0.0-b1)/(b2-b1)
          plfc = p(k-1)+(p(k)-p(k-1))*(0.0-b1)/(b2-b1)
        endif
      endif

      if( zlfc.gt.0.0 .and. zel.lt.0.0 .and. b2.lt.0.0 )then
        zel = z(k-1)+(z(k)-z(k-1))*(0.0-b1)/(b2-b1)
        pel = p(k-1)+(p(k)-p(k-1))*(0.0-b1)/(b2-b1)
      endif

      the = getthx(p2,t2,t2,qv2)

      pt(k) = t2
      if( cloud )then
        ptd(k) = t2
      else
        ptd(k) = gettd(p2,t2,qv2)
      endif
      ptv(k) = t2*(1.0+reps*qv2)/(1.0+qv2)
      pb(k) = b2
      pqv(k) = qv2
      pql(k) = ql2

      ! Get contributions to CAPE and CIN:

      if( (b2.ge.0.0) .and. (b1.lt.0.0) )then
        ! first trip into positive area
        ps = p(k-1)+(p(k)-p(k-1))*(0.0-b1)/(b2-b1)
        frac = b2/(b2-b1)
        parea =  0.5*b2*dz*frac
        narea = narea-0.5*b1*dz*(1.0-frac)
        if(debug_level.ge.200)then
          print *,'      b1,b2 = ',b1,b2
          print *,'      p1,ps,p2 = ',p(k-1),ps,p(k)
          print *,'      frac = ',frac
          print *,'      parea = ',parea
          print *,'      narea = ',narea
        endif
        cin  = cin  + narea
        narea = 0.0
      elseif( (b2.lt.0.0) .and. (b1.gt.0.0) )then
        ! first trip into neg area
        ps = p(k-1)+(p(k)-p(k-1))*(0.0-b1)/(b2-b1)
        frac = b1/(b1-b2)
        parea =  0.5*b1*dz*frac
        narea = -0.5*b2*dz*(1.0-frac)
        if(debug_level.ge.200)then
          print *,'      b1,b2 = ',b1,b2
          print *,'      p1,ps,p2 = ',p(k-1),ps,p(k)
          print *,'      frac = ',frac
          print *,'      parea = ',parea
          print *,'      narea = ',narea
        endif
      elseif( b2.lt.0.0 )then
        ! still collecting negative buoyancy
        parea =  0.0
        narea = narea-0.5*dz*(b1+b2)
      else
        ! still collecting positive buoyancy
        parea =  0.5*dz*(b1+b2)
        narea =  0.0
      endif

      cape = cape + max(0.0,parea)
      pc(k) = cape

      if(debug_level.ge.200)then
        write(6,102) p2,b1,b2,cape,cin,cloud
102     format(5(f13.4),2x,l1)
      endif

      if( (p(k).le.10000.0).and.(b2.lt.0.0) )then
        ! stop if b < 0 and p < 100 mb
        doit = .false.
      endif

    enddo

!!!    print *,'  zlcl,zlfc,zel = ',zlcl,zlfc,zel
!!!    print *,'  plcl,plfc,pel = ',plcl,plfc,pel

!---- All done ----!

    return
    end subroutine getcape

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------

    real function getqvl(p,t)
    implicit none

    real :: p,t,es

    real, parameter :: eps = 287.04/461.5

    es = 611.2*exp(17.67*(t-273.15)/(t-29.65))
    getqvl = eps*es/(p-es)

    return
    end function getqvl

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------

    real function getqvi(p,t)
    implicit none

    real :: p,t,es

    real, parameter :: eps = 287.04/461.5

    es = 611.2*exp(21.8745584*(t-273.15)/(t-7.66))
    getqvi = eps*es/(p-es)

    return
    end function getqvi

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------

    real function getthx(p,t,td,q)
    implicit none

    real :: p,t,td,q
    real :: tlcl

    if( (td-t).ge.-0.1 )then
      tlcl = t
    else
      tlcl = 56.0 + ( (td-56.0)**(-1) + 0.00125*alog(t/td) )**(-1)
    endif

    getthx=t*( (100000.0/p)**(0.2854*(1.0-0.28*q)) )   &
            *exp( ((3376.0/tlcl)-2.54)*q*(1.0+0.81*q) )

    return
    end function getthx

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------

    real function gettd(p,t,q)
    implicit none

    real :: p,t,q

    real :: el
    real, parameter :: eps = 287.04/461.5

    el = alog((q/eps)*p/100.0/(1.0+(q/eps)))
    gettd = 273.15+(243.5*el-440.8)/(19.48-el)

    return
    end function gettd

!-----------------------------------------------------------------------
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!-----------------------------------------------------------------------

ysu.F/          1298670057  19071 8000  100644  52171     `
!WRf:model_layer:physics
!
!
!
!
!
!
!
module module_bl_ysu
contains
!
!
!-------------------------------------------------------------------
!
   subroutine ysu(u3d,v3d,th3d,t3d,qv3d,qc3d,qi3d,p3d,p3di,pi3d,               &
                  rublten,rvblten,rthblten,                                    &
                  rqvblten,rqcblten,rqiblten,flag_qi,                          &
                  cp,g,rovcp,rd,rovg,ep1,ep2,karman,xlv,rv,                    &
                  dz8w,psfc,                                                   &
!!!                  znu,znw,mut,p_top,                                        &
                  znt,ust,hpbl,psim,psih,                                      &
                  xland,hfx,qfx,gz1oz0,wspd,br,                                &
                  dt,kpbl2d,                                                   &
                  exch_h,exch_m,                                               &
                  u10,v10,                                                     &
                  ids,ide, jds,jde, kds,kde,                                   &
                  ims,ime, jms,jme, kms,kme,                                   &
                  its,ite, jts,jte, kts,kte,                                   &
                !optional
                  regime                                           )
!-------------------------------------------------------------------
      implicit none
!-------------------------------------------------------------------
!-- u3d         3d u-velocity interpolated to theta points (m/s)
!-- v3d         3d v-velocity interpolated to theta points (m/s)
!-- th3d	3d potential temperature (k)
!-- t3d         temperature (k)
!-- qv3d        3d water vapor mixing ratio (kg/kg)
!-- qc3d        3d cloud mixing ratio (kg/kg)
!-- qi3d        3d ice mixing ratio (kg/kg)
!               (note: if P_QI<PARAM_FIRST_SCALAR this should be zero filled)
!-- p3d         3d pressure (pa)
!-- p3di        3d pressure (pa) at interface level
!-- pi3d	3d exner function (dimensionless)
!-- rr3d	3d dry air density (kg/m^3)
!-- rublten     u tendency due to
!               pbl parameterization (m/s/s)
!-- rvblten     v tendency due to
!               pbl parameterization (m/s/s)
!-- rthblten    theta tendency due to
!               pbl parameterization (K/s)
!-- rqvblten    qv tendency due to
!               pbl parameterization (kg/kg/s)
!-- rqcblten    qc tendency due to
!               pbl parameterization (kg/kg/s)
!-- rqiblten    qi tendency due to
!               pbl parameterization (kg/kg/s)
!-- cp          heat capacity at constant pressure for dry air (j/kg/k)
!-- g           acceleration due to gravity (m/s^2)
!-- rovcp       r/cp
!-- rd          gas constant for dry air (j/kg/k)
!-- rovg 	r/g
!-- dz8w	dz between full levels (m)
!-- xlv         latent heat of vaporization (j/kg)
!-- rv 		gas constant for water vapor (j/kg/k)
!-- psfc        pressure at the surface (pa)
!-- znt		roughness length (m)
!-- ust		u* in similarity theory (m/s)
!-- hpbl	pbl height (m)
!-- psim        similarity stability function for momentum
!-- psih        similarity stability function for heat
!-- xland	land mask (1 for land, 2 for water)
!-- hfx		upward heat flux at the surface (w/m^2)
!-- qfx		upward moisture flux at the surface (kg/m^2/s)
!-- gz1oz0      log(z/z0) where z0 is roughness length
!-- wspd        wind speed at lowest model level (m/s)
!-- u10         u-wind speed at 10 m (m/s)
!-- v10         v-wind speed at 10 m (m/s)
!-- br          bulk richardson number in surface layer
!-- dt		time step (s)
!-- rvovrd      r_v divided by r_d (dimensionless)
!-- ep1         constant for virtual temperature (r_v/r_d - 1) (dimensionless)
!-- ep2         constant for specific humidity calculation
!-- karman      von karman constant
!-- ids         start index for i in domain
!-- ide         end index for i in domain
!-- jds         start index for j in domain
!-- jde         end index for j in domain
!-- kds         start index for k in domain
!-- kde         end index for k in domain
!-- ims         start index for i in memory
!-- ime         end index for i in memory
!-- jms         start index for j in memory
!-- jme         end index for j in memory
!-- kms         start index for k in memory
!-- kme         end index for k in memory
!-- its         start index for i in tile
!-- ite         end index for i in tile
!-- jts         start index for j in tile
!-- jte         end index for j in tile
!-- kts         start index for k in tile
!-- kte         end index for k in tile
!-------------------------------------------------------------------
!
   integer,parameter ::  ndiff = 3
   real,parameter    ::  rcl = 1.0
!
   integer,  intent(in   )   ::      ids,ide, jds,jde, kds,kde,                &
                                     ims,ime, jms,jme, kms,kme,                &
                                     its,ite, jts,jte, kts,kte
!
   real,     intent(in   )   ::      dt,cp,g,rovcp,rovg,rd,xlv,rv
!
   real,     intent(in )     ::      ep1,ep2,karman
!
   real,     dimension( ims:ime, jms:jme , kms:kme )                          , &
             intent(in   )   ::                                          qv3d, &
                                         			         qc3d, &
 				                                         qi3d, &
                                   		                          p3d, &
            		                                                 pi3d, &
		                      	                                 th3d, &
		                                		          t3d, &
				                                         dz8w
   real,     dimension( ims:ime, jms:jme , kms:kme )                          , &
             intent(in   )   ::                                          p3di
!
   real,     dimension( ims:ime, jms:jme , kms:kme )                          , &
             intent(inout)   ::                                       rublten, &
                                              			      rvblten, &
                                               			     rthblten, &
                                                 	             rqvblten, &
                                                                     rqcblten
!
   real,     dimension( ims:ime, jms:jme , kms:kme )                         , &
             intent(inout)   ::                                        exch_h, &
                                                                       exch_m
   real,     dimension( ims:ime, jms:jme )                                   , &
             intent(in   )   ::                                           u10, &
                                                                          v10
!
   real,     dimension( ims:ime, jms:jme )                                   , &
             intent(in   )   ::                                         xland, &
     			                                                  hfx, &
                                                                          qfx, &
                                                                           br, &
                                                                         psfc
   real,     dimension( ims:ime, jms:jme )                                   , &
             intent(in   )   ::                                                &
                                                                         psim, &
                                                                         psih, &
                                                                       gz1oz0
   real,     dimension( ims:ime, jms:jme )                                   , &
             intent(inout)   ::                                           znt, &
                                                                          ust, &
                                                                         hpbl, &
                                                                          wspd
!
  real,      dimension( ims:ime, jms:jme , kms:kme )                          , &
             intent(in   )   ::                                           u3d, &
                                                                          v3d
!
  integer,   dimension( ims:ime, jms:jme )                                   , &
             intent(out  )   ::                                        kpbl2d
  logical, intent(in)        ::                                       flag_qi
!optional
   real,     dimension( ims:ime, jms:jme )                                   , &
             optional                                                        , &
             intent(inout)   ::                                        regime
!
   real,     dimension( ims:ime, jms:jme , kms:kme )                          , &
             optional                                                        , &
             intent(inout)   ::                                       rqiblten
!
!!!   real,     dimension( kms:kme )                                            , &
!!!             optional                                                        , &
!!!             intent(in   )   ::                                           znu, &
!!!                                                                          znw
!
!!!   real,     dimension( ims:ime, jms:jme )                                   , &
!!!             optional                                                        , &
!!!             intent(in   )   ::                                           mut
!
!!!   real,     optional, intent(in   )   ::                               p_top
!
!local
   integer ::  i,j,k
   real,     dimension( its:ite, kts:kte*ndiff )  ::                 rqvbl2dt, &
                                                                         qv2d
   real,     dimension( its:ite, kts:kte )  ::                            pdh
   real,     dimension( ims:ime, kms:kme )  ::                                 &
                         u2d,v2d,t2d,pi2d,dz2d,uten,vten,tten,km2d,kh2d
   real,     dimension( its:ite, kts:kte+1 )  ::                         pdhi
   real,     dimension( its:ite )  ::                                          &
                                                                        dusfc, &
                                                                        dvsfc, &
                                                                        dtsfc, &
                                                                        dqsfc
!
   qv2d(:,:) = 0.0

!$omp parallel do default(shared)  &
!$omp private(i,j,k,pdh,pdhi,u2d,v2d,t2d,pi2d,dz2d,qv2d,tten,uten,vten,   &
!$omp rqvbl2dt,dusfc,dvsfc,dtsfc,dqsfc,km2d,kh2d)
   do j = jts,jte
!      if(present(mut))then
!! For ARW we will replace p and p8w with dry hydrostatic pressure
!        do k = kts,kte+1
!          do i = its,ite
!             if(k.le.kte)pdh(i,k) = mut(i,j)*znu(k) + p_top
!             pdhi(i,k) = mut(i,j)*znw(k) + p_top
!          enddo
!        enddo
!      else
        do k = kts,kte+1
          do i = its,ite
             if(k.le.kte)pdh(i,k) = p3d(i,j,k)
             pdhi(i,k) = p3di(i,j,k)
          enddo
        enddo
!      endif
      do k = kts,kte
        do i = its,ite
          u2d(i,k) = u3d(i,j,k)
          v2d(i,k) = v3d(i,j,k)
          t2d(i,k) = t3d(i,j,k)
          pi2d(i,k) = pi3d(i,j,k)
          dz2d(i,k) = dz8w(i,j,k)
          qv2d(i,k) = qv3d(i,j,k)
          qv2d(i,k+kte) = qc3d(i,j,k)
          if(present(rqiblten)) qv2d(i,k+kte+kte) = qi3d(i,j,k)
        enddo
      enddo
      km2d = 0.0
      kh2d = 0.0
!
      call ysu2d(J=j,ux=u2d(ims,kms),vx=v2d(ims,kms)                       &
              ,tx=t2d(ims,kms)                                               &
              ,qx=qv2d(its,kts)                                                &
              ,p2d=pdh(its,kts),p2di=pdhi(its,kts)                             &
              ,pi2d=pi2d(ims,kms)                                            &
              ,utnp=uten(ims,kms),vtnp=vten(ims,kms)                 &
              ,ttnp=tten(ims,kms),qtnp=rqvbl2dt(its,kts),ndiff=ndiff     &
              ,cp=cp,g=g,rovcp=rovcp,rd=rd,rovg=rovg                           &
              ,xlv=xlv,rv=rv                                                   &
              ,ep1=ep1,ep2=ep2,karman=karman                                   &
              ,dz8w2d=dz2d(ims,kms)                                          &
              ,psfcpa=psfc(ims,j),znt=znt(ims,j),ust=ust(ims,j)                &
              ,hpbl=hpbl(ims,j)                                                &
              ,regime=regime(ims,j),psim=psim(ims,j)                           &
              ,psih=psih(ims,j),xland=xland(ims,j)                             &
              ,hfx=hfx(ims,j),qfx=qfx(ims,j)                                   &
              ,wspd=wspd(ims,j),br=br(ims,j)                                   &
              ,dusfc=dusfc,dvsfc=dvsfc,dtsfc=dtsfc,dqsfc=dqsfc                 &
              ,dt=dt,rcl=1.0,kpbl1d=kpbl2d(ims,j)                              &
              ,exch_hx=kh2d(ims,kms),exch_mx=km2d(ims,kms)                     &
              ,u10=u10(ims,j),v10=v10(ims,j)                                   &
              ,gz1oz0=gz1oz0(ims,j)                                            &
              ,ids=ids,ide=ide, jds=jds,jde=jde, kds=kds,kde=kde               &
              ,ims=ims,ime=ime, jms=jms,jme=jme, kms=kms,kme=kme               &
              ,its=its,ite=ite, jts=jts,jte=jte, kts=kts,kte=kte   )
!
      do k = kts,kte
        do i = its,ite
          rthblten(i,j,k) = tten(i,k)/pi3d(i,j,k)
          rublten(i,j,k) = uten(i,k)
          rvblten(i,j,k) = vten(i,k)
          rqvblten(i,j,k) = rqvbl2dt(i,k)
          rqcblten(i,j,k) = rqvbl2dt(i,k+kte)
          if(present(rqiblten)) rqiblten(i,j,k) = rqvbl2dt(i,k+kte+kte)
          exch_h(i,j,k) = kh2d(i,k)
          exch_m(i,j,k) = km2d(i,k)
        enddo
      enddo
   enddo
!
   end subroutine ysu
!
!-------------------------------------------------------------------
!
   subroutine ysu2d(j,ux,vx,tx,qx,p2d,p2di,pi2d,                               &
                  utnp,vtnp,ttnp,qtnp,ndiff,                                   &
                  cp,g,rovcp,rd,rovg,ep1,ep2,karman,xlv,rv,                    &
                  dz8w2d,psfcpa,                                               &
                  znt,ust,hpbl,psim,psih,                                      &
                  xland,hfx,qfx,wspd,br,                                       &
                  dusfc,dvsfc,dtsfc,dqsfc,                                     &
                  dt,rcl,kpbl1d,                                               &
                  exch_hx,exch_mx,                                             &
                  u10,v10,                                                     &
                  gz1oz0,                                                      &
                  ids,ide, jds,jde, kds,kde,                                   &
                  ims,ime, jms,jme, kms,kme,                                   &
                  its,ite, jts,jte, kts,kte,                                   &
                !optional
                  regime                                           )
!-------------------------------------------------------------------
   implicit none
!-------------------------------------------------------------------
!
!     this code is a revised vertical diffusion package ("ysupbl")
!     with a nonlocal turbulent mixing in the pbl after "mrfpbl".
!     the ysupbl (hong et al. 2006) is based on the study of noh 
!     et al.(2003) and accumulated realism of the behavior of the 
!     troen and mahrt (1986) concept implemented by hong and pan(1996). 
!     the major ingredient of the ysupbl is the inclusion of an explicit
!     treatment of the entrainment processes at the entrainment layer.
!     this routine uses an implicit approach for vertical flux
!     divergence and does not require "miter" timesteps.
!     it includes vertical diffusion in the stable atmosphere
!     and moist vertical diffusion in clouds.
!
!     mrfpbl:
!     coded by song-you hong (ncep), implemented by jimy dudhia (ncar)
!              fall 1996
!
!     ysupbl:
!     coded by song-you hong (yonsei university) and implemented by
!              song-you hong (yonsei university) and jimy dudhia (ncar)
!              summer 2002
!
!     further modifications :
!              an enhanced stable layer mixing, april 2008
!               ==> increase pbl height when sfc is stable (hong 2010)
!              pressure-level diffusion, april 2009
!               ==> negligible differences
!              implicit forcing for momentum with clean up, july 2009
!               ==> prevents model blowup when sfc layer is too low
!              incresea of lamda, 30 < 0.1 x del z < 300, feb 2010
!               ==> prevents model blowup when delz is extremely large
!              revised prandtl number at surface, peggy lemone, feb 2010
!               ==> increase kh, decrease mixing due to counter-gradient term
!
!     references:
!
!        hong (2010) quart. j. roy. met. soc
!        hong, noh, and dudhia (2006), mon. wea. rev. 
!        hong and pan (1996), mon. wea. rev.
!        noh, chun, hong, and raasch (2003), boundary layer met.
!        troen and mahrt (1986), boundary layer met.
!
!-------------------------------------------------------------------
!
   real,parameter    ::  xkzmin = 0.01,xkzmax = 1000.,rimin = -100.
   real,parameter    ::  rlam = 30.,prmin = 0.25,prmax = 4.
   real,parameter    ::  brcr_ub = 0.0,brcr_sb = 0.25,cori = 1.e-4
   real,parameter    ::  afac = 6.8,bfac = 6.8,pfac = 2.0,pfac_q = 2.0
   real,parameter    ::  phifac = 8.,sfcfrac = 0.1
   real,parameter    ::  d1 = 0.02, d2 = 0.05, d3 = 0.001
   real,parameter    ::  h1 = 0.33333335, h2 = 0.6666667
   real,parameter    ::  ckz = 0.001,zfmin = 1.e-8,aphi5 = 5.,aphi16 = 16.
   real,parameter    ::  tmin=1.e-2
   real,parameter    ::  gamcrt = 3.,gamcrq = 2.e-3
   real,parameter    ::  xka = 2.4e-5
   integer,parameter ::  imvdif = 1
!
   integer,  intent(in   )   ::     ids,ide, jds,jde, kds,kde,                 &
                                    ims,ime, jms,jme, kms,kme,                 &
                                    its,ite, jts,jte, kts,kte,                 &
                                    j,ndiff
!
   real,     intent(in   )   ::     dt,rcl,cp,g,rovcp,rovg,rd,xlv,rv
!
   real,     intent(in )     ::     ep1,ep2,karman
!
   real,     dimension( ims:ime, kms:kme ),                                    &
             intent(in)      ::                                        dz8w2d, &
                                                                         pi2d
!
   real,     dimension( ims:ime, kms:kme )                                   , &
             intent(in   )   ::                                            tx
   real,     dimension( its:ite, kts:kte*ndiff )                             , &
             intent(in   )   ::                                            qx
!
   real,     dimension( ims:ime, kms:kme )                                   , &
             intent(inout)   ::                                          utnp, &
                                                                         vtnp, &
                                                                         ttnp
   real,     dimension( its:ite, kts:kte*ndiff )                             , &
             intent(inout)   ::                                          qtnp
!
   real,     dimension( its:ite, kts:kte+1 )                                 , &
             intent(in   )   ::                                          p2di
!
   real,     dimension( its:ite, kts:kte )                                   , &
             intent(in   )   ::                                           p2d
!
!
   real,     dimension( ims:ime )                                            , &
             intent(inout)   ::                                           ust, &
                                                                         hpbl, &
                                                                          znt
   real,     dimension( ims:ime )                                            , &
             intent(in   )   ::                                         xland, &
                                                                          hfx, &
                                                                          qfx
!
   real,     dimension( ims:ime ), intent(inout)   ::                    wspd
   real,     dimension( ims:ime ), intent(in  )    ::                      br
!
   real,     dimension( ims:ime ), intent(in   )   ::                    psim, &
                                                                         psih
   real,     dimension( ims:ime ), intent(in   )   ::                  gz1oz0
!
   real,     dimension( ims:ime ), intent(in   )   ::                  psfcpa
   integer,  dimension( ims:ime ), intent(out  )   ::                  kpbl1d
!
   real,     dimension( ims:ime, kms:kme )                                   , &
             intent(in   )   ::                                            ux, &
                                                                           vx
!optional
   real,     dimension( ims:ime )                                            , &
             optional                                                        , &
             intent(inout)   ::                                        regime
!
! local vars
!
   real,     dimension( its:ite )            ::                           hol
   real,     dimension( its:ite, kts:kte+1 ) ::                            zq
!
   real,     dimension( its:ite, kts:kte )   ::                        	       &
                                                                     thx,thvx, &
                                                                          del, &
                                                                          dza, &
                                                                          dzq, &
                                                                           za
!
   real,    dimension( its:ite )             ::                                &
                                                                         rhox, &
                                                                       govrth, &
                                                                  zl1,thermal, &
                                                                 wscale,hgamt, &
                                                                   hgamq,brdn, &
                                                                    brup,phim, &
                                                                         phih, &
                                                                  dusfc,dvsfc, &
                                                                  dtsfc,dqsfc, &
                                                                        prpbl, &
                                                                        wspd1
!
   real,    dimension( its:ite, kts:kte )    ::                     xkzm,xkzh, &
                                                     		        f1,f2, &
                                                     		        r1,r2, &
                                                                        ad,au, &
                                                                           cu, &
                                                                           al, &
                                                                         xkzq, &
                                                                         zfac
!
!jdf added exch_hx
   real,    dimension( ims:ime, kms:kme )                                    , &
            intent(inout)   ::                                        exch_hx, &
                                                                      exch_mx
!
   real,    dimension( ims:ime )                                             , & 
            intent(in  )    ::                                            u10, &
                                                                          v10
   real,    dimension( its:ite )    ::                                         &
                                                                         brcr, &
                                                                        sflux, &
                                                                    brcr_sbro
!
   real,    dimension( its:ite, kts:kte, ndiff)  ::                     r3,f3
   integer, dimension( its:ite )             ::                          kpbl
!
   logical, dimension( its:ite )             ::                        pblflg, &
                                                                       sfcflg, &
                                                                       stable
!
   integer ::  n,i,k,l,ic,is
   integer ::  klpbl, ktrace1, ktrace2, ktrace3
!
!
   real    ::  dt2,rdt,spdk2,fm,fh,hol1,gamfac,vpert,prnum,prnum0
   real    ::  xkzo,ss,ri,qmean,tmean,alph,chi,zk,rl2,dk,sri
   real    ::  brint,dtodsd,dtodsu,rdz,dsdzt,dsdzq,dsdz2,rlamdz
   real    ::  utend,vtend,ttend,qtend
   real    ::  dtstep,govrthv
   real    ::  cont, conq, conw, conwrc 
!
   real, dimension( its:ite, kts:kte )     ::                         wscalek, &
                                                                  xkzml,xkzhl, &
                                                               zfacent,entfac
   real, dimension( its:ite )              ::                            ust3, &
                                                                 wstar3,wstar, &
                                                                  hgamu,hgamv, &
                                                                      wm2, we, &
                                                                       bfxpbl, &
                                                                hfxpbl,qfxpbl, &
                                                                ufxpbl,vfxpbl, &
                                                                  delta,dthvx
   real    ::  prnumfac,bfx0,hfx0,qfx0,delb,dux,dvx,                           &
               dsdzu,dsdzv,wm3,dthx,dqx,wspd10,ross,tem1,dsig,tvcon,conpr,     &
               prfac,phim8z
!
!----------------------------------------------------------------------
!
   klpbl = kte
!
   cont=cp/g
   conq=xlv/g
   conw=1./g
   conwrc = conw*sqrt(rcl)
   conpr = bfac*karman*sfcfrac
!
!  k-start index for tracer diffusion
!
   ktrace1 = 0
   ktrace2 = 0 + kte
   ktrace3 = 0 + kte*2
!
   do k = kts,kte
     do i = its,ite
       thx(i,k) = tx(i,k)/pi2d(i,k)
     enddo
   enddo
!
   do k = kts,kte
     do i = its,ite
       tvcon = (1.+ep1*qx(i,k))
       thvx(i,k) = thx(i,k)*tvcon
     enddo
   enddo
!
   do i = its,ite
     tvcon = (1.+ep1*qx(i,1))
     rhox(i) = psfcpa(i)/(rd*tx(i,1)*tvcon)
     govrth(i) = g/thx(i,1)
   enddo
!
!-----compute the height of full- and half-sigma levels above ground
!     level, and the layer thicknesses.
!
   do i = its,ite
     zq(i,1) = 0.
   enddo
!
   do k = kts,kte
     do i = its,ite
       zq(i,k+1) = dz8w2d(i,k)+zq(i,k)
     enddo
   enddo
! 
   do k = kts,kte
     do i = its,ite
       za(i,k) = 0.5*(zq(i,k)+zq(i,k+1))
       dzq(i,k) = zq(i,k+1)-zq(i,k)
       del(i,k) = p2di(i,k)-p2di(i,k+1)
     enddo
   enddo
!
   do i = its,ite
     dza(i,1) = za(i,1)
   enddo
!
   do k = kts+1,kte
     do i = its,ite
       dza(i,k) = za(i,k)-za(i,k-1)
     enddo
   enddo
!
!
!-----initialize vertical tendencies and
!
   utnp(:,:) = 0.
   vtnp(:,:) = 0.
   ttnp(:,:) = 0.
   qtnp(:,:) = 0.
!
   do i = its,ite
     wspd1(i) = sqrt(ux(i,1)*ux(i,1)+vx(i,1)*vx(i,1))+1.e-9
   enddo
!
!---- compute vertical diffusion
!
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!     compute preliminary variables
!
   dtstep = dt
   dt2 = 2.*dtstep
   rdt = 1./dt2
!
   do i = its,ite
     bfxpbl(i) = 0.0
     hfxpbl(i) = 0.0
     qfxpbl(i) = 0.0
     ufxpbl(i) = 0.0
     vfxpbl(i) = 0.0
     hgamu(i)  = 0.0
     hgamv(i)  = 0.0
     delta(i)  = 0.0
   enddo
!
   do k = kts,klpbl
     do i = its,ite
       wscalek(i,k) = 0.0
     enddo
   enddo
!
   do k = kts,klpbl
     do i = its,ite
       zfac(i,k) = 0.0
     enddo
   enddo
!
   do i = its,ite
     dusfc(i) = 0.
     dvsfc(i) = 0.
     dtsfc(i) = 0.
     dqsfc(i) = 0.
   enddo
!
   do i = its,ite
     hgamt(i)  = 0.
     hgamq(i)  = 0.
     wscale(i) = 0.
     kpbl(i)   = 1
     hpbl(i)   = zq(i,1)
     zl1(i)    = za(i,1)
     thermal(i)= thvx(i,1)
     pblflg(i) = .true.
     sfcflg(i) = .true.
     sflux(i) = hfx(i)/rhox(i)/cp + qfx(i)/rhox(i)*ep1*thx(i,1)
     if(br(i).gt.0.0) sfcflg(i) = .false.
   enddo
!
!     compute the first guess of pbl height
!
   do i = its,ite
     stable(i) = .false.
     brup(i) = br(i)
     brcr(i) = brcr_ub
   enddo
!
   do k = 2,klpbl
     do i = its,ite
       if(.not.stable(i))then
         brdn(i) = brup(i)
         spdk2   = max(ux(i,k)**2+vx(i,k)**2,1.)
         brup(i) = (thvx(i,k)-thermal(i))*(g*za(i,k)/thvx(i,1))/spdk2
         kpbl(i) = k
         stable(i) = brup(i).gt.brcr(i)
       endif
     enddo
   enddo
!
   do i = its,ite
     k = kpbl(i)
     if(brdn(i).ge.brcr(i))then
       brint = 0.
     elseif(brup(i).le.brcr(i))then
       brint = 1.
     else
       brint = (brcr(i)-brdn(i))/(brup(i)-brdn(i))
     endif
     hpbl(i) = za(i,k-1)+brint*(za(i,k)-za(i,k-1))
     if(hpbl(i).lt.zq(i,2)) kpbl(i) = 1
     if(kpbl(i).le.1) pblflg(i) = .false.
   enddo
!
   do i = its,ite
     fm = gz1oz0(i)-psim(i)
     fh = gz1oz0(i)-psih(i)
     hol(i) = max(br(i)*fm*fm/fh,rimin)
     if(sfcflg(i))then
       hol(i) = min(hol(i),-zfmin)
     else
       hol(i) = max(hol(i),zfmin)
     endif
     hol1 = hol(i)*hpbl(i)/zl1(i)*sfcfrac
     hol(i) = -hol(i)*hpbl(i)/zl1(i)
     if(sfcflg(i))then
       phim(i) = (1.-aphi16*hol1)**(-1./4.)
       phih(i) = (1.-aphi16*hol1)**(-1./2.)
       bfx0 = max(sflux(i),0.)
       hfx0 = max(hfx(i)/rhox(i)/cp,0.)
       qfx0 = max(ep1*thx(i,1)*qfx(i)/rhox(i),0.)
       wstar3(i) = (govrth(i)*bfx0*hpbl(i))
       wstar(i) = (wstar3(i))**h1
     else
       phim(i) = (1.+aphi5*hol1)
       phih(i) = phim(i)
       wstar(i)  = 0.
       wstar3(i) = 0.
     endif
     ust3(i)   = ust(i)**3.
     wscale(i) = (ust3(i)+phifac*karman*wstar3(i)*0.5)**h1
     wscale(i) = min(wscale(i),ust(i)*aphi16)
     wscale(i) = max(wscale(i),ust(i)/aphi5)
   enddo
!
!     compute the surface variables for pbl height estimation
!     under unstable conditions
!
   do i = its,ite
     if(sfcflg(i).and.sflux(i).gt.0.0)then
       gamfac   = bfac/rhox(i)/wscale(i)
       hgamt(i) = min(gamfac*hfx(i)/cp,gamcrt)
       hgamq(i) = min(gamfac*qfx(i),gamcrq)
       vpert = (hgamt(i)+ep1*thx(i,1)*hgamq(i))/bfac*afac
       thermal(i) = thermal(i)+max(vpert,0.)
       hgamt(i) = max(hgamt(i),0.0)
       hgamq(i) = max(hgamq(i),0.0)
       brint    = -15.9*ust(i)*ust(i)/wspd(i)*wstar3(i)/(wscale(i)**4.)
       hgamu(i) = brint*ux(i,1)
       hgamv(i) = brint*vx(i,1)
     else
       pblflg(i) = .false.
     endif
   enddo
!
!     enhance the pbl height by considering the thermal
!
   do i = its,ite
     if(pblflg(i))then
       kpbl(i) = 1
       hpbl(i) = zq(i,1)
     endif
   enddo
!
   do i = its,ite
     if(pblflg(i))then
       stable(i) = .false.
       brup(i) = br(i)
       brcr(i) = brcr_ub
     endif
   enddo
!
   do k = 2,klpbl
     do i = its,ite
       if(.not.stable(i).and.pblflg(i))then
         brdn(i) = brup(i)
         spdk2   = max(ux(i,k)**2+vx(i,k)**2,1.)
         brup(i) = (thvx(i,k)-thermal(i))*(g*za(i,k)/thvx(i,1))/spdk2
         kpbl(i) = k
         stable(i) = brup(i).gt.brcr(i)
       endif
     enddo
   enddo
!
   do i = its,ite
     if(pblflg(i)) then
       k = kpbl(i)
       if(brdn(i).ge.brcr(i))then
         brint = 0.
       elseif(brup(i).le.brcr(i))then
         brint = 1.
       else
         brint = (brcr(i)-brdn(i))/(brup(i)-brdn(i))
       endif
       hpbl(i) = za(i,k-1)+brint*(za(i,k)-za(i,k-1))
       if(hpbl(i).lt.zq(i,2)) kpbl(i) = 1
       if(kpbl(i).le.1) pblflg(i) = .false.
     endif
   enddo
!
!     stable boundary layer
!
   do i = its,ite
     if((.not.sfcflg(i)).and.hpbl(i).lt.zq(i,2)) then
       brup(i) = br(i)
       stable(i) = .false.
     else
       stable(i) = .true.
     endif
   enddo
!
   do i = its,ite
     if((.not.stable(i)).and.((xland(i)-1.5).ge.0))then
       wspd10 = u10(i)*u10(i) + v10(i)*v10(i)
       wspd10 = sqrt(wspd10)
       ross = wspd10 / (cori*znt(i))
       brcr_sbro(i) = min(0.16*(1.e-7*ross)**(-0.18),.3)
     endif
   enddo
!
   do i = its,ite
     if(.not.stable(i))then
       if((xland(i)-1.5).ge.0)then
         brcr(i) = brcr_sbro(i)
       else
         brcr(i) = brcr_sb
       endif
     endif
   enddo
   do k = 2,klpbl
     do i = its,ite
       if(.not.stable(i))then
         brdn(i) = brup(i)
         spdk2   = max(ux(i,k)**2+vx(i,k)**2,1.)
         brup(i) = (thvx(i,k)-thermal(i))*(g*za(i,k)/thvx(i,1))/spdk2
         kpbl(i) = k
         stable(i) = brup(i).gt.brcr(i)
       endif
     enddo
   enddo
!
   do i = its,ite
     if((.not.sfcflg(i)).and.hpbl(i).lt.zq(i,2)) then
       k = kpbl(i)
       if(brdn(i).ge.brcr(i))then
         brint = 0.
       elseif(brup(i).le.brcr(i))then
         brint = 1.
       else
         brint = (brcr(i)-brdn(i))/(brup(i)-brdn(i))
       endif
       hpbl(i) = za(i,k-1)+brint*(za(i,k)-za(i,k-1))
       if(hpbl(i).lt.zq(i,2)) kpbl(i) = 1
       if(kpbl(i).le.1) pblflg(i) = .false.
     endif
   enddo
!
!     estimate the entrainment parameters
!
   do i = its,ite
     if(pblflg(i)) then
       k = kpbl(i) - 1
       prpbl(i) = 1.0
       wm3       = wstar3(i) + 5. * ust3(i)
       wm2(i)    = wm3**h2
       bfxpbl(i) = -0.15*thvx(i,1)/g*wm3/hpbl(i)
       dthvx(i)  = max(thvx(i,k+1)-thvx(i,k),tmin)
       dthx  = max(thx(i,k+1)-thx(i,k),tmin)
       dqx   = min(qx(i,k+1)-qx(i,k),0.0)
       we(i) = max(bfxpbl(i)/dthvx(i),-sqrt(wm2(i)))
       hfxpbl(i) = we(i)*dthx
       qfxpbl(i) = we(i)*dqx
!
       dux = ux(i,k+1)-ux(i,k)
       dvx = vx(i,k+1)-vx(i,k)
       if(dux.gt.tmin) then
         ufxpbl(i) = max(prpbl(i)*we(i)*dux,-ust(i)*ust(i))
       elseif(dux.lt.-tmin) then
         ufxpbl(i) = min(prpbl(i)*we(i)*dux,ust(i)*ust(i))
       else
         ufxpbl(i) = 0.0
       endif
       if(dvx.gt.tmin) then
         vfxpbl(i) = max(prpbl(i)*we(i)*dvx,-ust(i)*ust(i))
       elseif(dvx.lt.-tmin) then
         vfxpbl(i) = min(prpbl(i)*we(i)*dvx,ust(i)*ust(i))
       else
         vfxpbl(i) = 0.0
       endif
       delb  = govrth(i)*d3*hpbl(i)
       delta(i) = min(d1*hpbl(i) + d2*wm2(i)/delb,100.)
     endif
   enddo
!
   do k = kts,klpbl
     do i = its,ite
       if(pblflg(i).and.k.ge.kpbl(i))then
         entfac(i,k) = ((zq(i,k+1)-hpbl(i))/delta(i))**2.
       else
         entfac(i,k) = 1.e30
       endif
     enddo
   enddo
!
!     compute diffusion coefficients below pbl
!
   do k = kts,klpbl
     do i = its,ite
       if(k.lt.kpbl(i)) then
         zfac(i,k) = min(max((1.-(zq(i,k+1)-zl1(i))/(hpbl(i)-zl1(i))),zfmin),1.)
         xkzo = ckz*dza(i,k+1)
         zfacent(i,k) = (1.-zfac(i,k))**3.
         wscalek(i,k) = (ust3(i)+phifac*karman*wstar3(i)*(1.-zfac(i,k)))**h1
         if(sfcflg(i)) then 
           prfac = conpr/phim(i)/((1.+4.*karman*wstar3(i)/ust3(i)))**h1
           prnumfac = -3.*(max(zq(i,k+1)-sfcfrac*hpbl(i),0.))**2./hpbl(i)**2.
         else
           prfac = 0.
           prnumfac = 0.
           phim8z = 1.+(phim(i)-1.)*zq(i,k+1)/sfcfrac/hpbl(i)
           wscalek(i,k) = ust(i)/phim8z
           wscalek(i,k) = max(wscalek(i,k),ust(i)/aphi5)
         endif
         prnum0 = (phih(i)/phim(i)+prfac)
         prnum0 = min(prnum0,prmax)
         prnum0 = max(prnum0,prmin)
         xkzm(i,k) = xkzo+wscalek(i,k)*karman*zq(i,k+1)*zfac(i,k)**pfac
         prnum =  1. + (prnum0-1.)*exp(prnumfac)
         xkzq(i,k) = xkzm(i,k)/prnum*zfac(i,k)**(pfac_q-pfac)
         prnum0 = prnum0/(1.+prfac)
         prnum =  1. + (prnum0-1.)*exp(prnumfac)
         xkzh(i,k) = xkzm(i,k)/prnum
         xkzm(i,k) = min(xkzm(i,k),xkzmax)
         xkzm(i,k) = max(xkzm(i,k),xkzmin)
         xkzh(i,k) = min(xkzh(i,k),xkzmax)
         xkzh(i,k) = max(xkzh(i,k),xkzmin)
         xkzq(i,k) = min(xkzq(i,k),xkzmax)
         xkzq(i,k) = max(xkzq(i,k),xkzmin)
       endif
     enddo
   enddo
!
!     compute diffusion coefficients over pbl (free atmosphere)
!
   do k = kts,kte-1
     do i = its,ite
       xkzo = ckz*dza(i,k+1)
       if(k.ge.kpbl(i)) then
         ss = ((ux(i,k+1)-ux(i,k))*(ux(i,k+1)-ux(i,k))                         &
              +(vx(i,k+1)-vx(i,k))*(vx(i,k+1)-vx(i,k)))                        &
              /(dza(i,k+1)*dza(i,k+1))+1.e-9
         govrthv = g/(0.5*(thvx(i,k+1)+thvx(i,k)))
         ri = govrthv*(thvx(i,k+1)-thvx(i,k))/(ss*dza(i,k+1))
         if(imvdif.eq.1.and.ndiff.ge.3)then
           if((qx(i,ktrace2+k)+qx(i,ktrace3+k)).gt.0.01e-3.and.(qx(i           &
             ,ktrace2+k+1)+qx(i,ktrace3+k+1)).gt.0.01e-3)then
!      in cloud
             qmean = 0.5*(qx(i,k)+qx(i,k+1))
             tmean = 0.5*(tx(i,k)+tx(i,k+1))
             alph  = xlv*qmean/rd/tmean
             chi   = xlv*xlv*qmean/cp/rv/tmean/tmean
             ri    = (1.+alph)*(ri-g*g/ss/tmean/cp*((chi-alph)/(1.+chi)))
           endif
         endif
         zk = karman*zq(i,k+1)
         rlamdz = min(max(0.1*dza(i,k+1),rlam),300.)
         rl2 = (zk*rlamdz/(rlamdz+zk))**2
         dk = rl2*sqrt(ss)
         if(ri.lt.0.)then
! unstable regime
           sri = sqrt(-ri)
           xkzm(i,k) = xkzo+dk*(1+8.*(-ri)/(1+1.746*sri))
           xkzh(i,k) = xkzo+dk*(1+8.*(-ri)/(1+1.286*sri))
         else
! stable regime
           xkzh(i,k) = xkzo+dk/(1+5.*ri)**2
           prnum = 1.0+2.1*ri
           prnum = min(prnum,prmax)
           xkzm(i,k) = (xkzh(i,k)-xkzo)*prnum+xkzo
         endif
!
         xkzm(i,k) = min(xkzm(i,k),xkzmax)
         xkzm(i,k) = max(xkzm(i,k),xkzmin)
         xkzh(i,k) = min(xkzh(i,k),xkzmax)
         xkzh(i,k) = max(xkzh(i,k),xkzmin)
         xkzml(i,k) = xkzm(i,k)
         xkzhl(i,k) = xkzh(i,k)
       endif
     enddo
   enddo
!
!     compute tridiagonal matrix elements for heat
!
   do k = kts,kte
     do i = its,ite
       au(i,k) = 0.
       al(i,k) = 0.
       ad(i,k) = 0.
       f1(i,k) = 0.
     enddo
   enddo
!
   do i = its,ite
     ad(i,1) = 1.
     f1(i,1) = thx(i,1)-300.+hfx(i)/cont/del(i,1)*dt2
   enddo
!
   do k = kts,kte-1
     do i = its,ite
       dtodsd = dt2/del(i,k)
       dtodsu = dt2/del(i,k+1)
       dsig   = p2d(i,k)-p2d(i,k+1)
       rdz    = 1./dza(i,k+1)
       tem1   = dsig*xkzh(i,k)*rdz
       if(pblflg(i).and.k.lt.kpbl(i)) then
         dsdzt = tem1*(-hgamt(i)/hpbl(i)-hfxpbl(i)*zfacent(i,k)/xkzh(i,k))
         f1(i,k)   = f1(i,k)+dtodsd*dsdzt
         f1(i,k+1) = thx(i,k+1)-300.-dtodsu*dsdzt
       elseif(pblflg(i).and.k.ge.kpbl(i).and.entfac(i,k).lt.4.6) then
         xkzh(i,k) = -we(i)*dza(i,kpbl(i))*exp(-entfac(i,k))
         xkzh(i,k) = sqrt(xkzh(i,k)*xkzhl(i,k))
         xkzh(i,k) = min(xkzh(i,k),xkzmax)
         xkzh(i,k) = max(xkzh(i,k),xkzmin)
         f1(i,k+1) = thx(i,k+1)-300.
       else
         f1(i,k+1) = thx(i,k+1)-300.
       endif
       tem1   = dsig*xkzh(i,k)*rdz
       dsdz2     = tem1*rdz
       au(i,k)   = -dtodsd*dsdz2
       al(i,k)   = -dtodsu*dsdz2
       ad(i,k)   = ad(i,k)-au(i,k)
       ad(i,k+1) = 1.-al(i,k)
       exch_hx(i,k+1) = xkzh(i,k)
     enddo
   enddo
!
! copies here to avoid duplicate input args for tridin
!
   do k = kts,kte
     do i = its,ite
       cu(i,k) = au(i,k)
       r1(i,k) = f1(i,k)
     enddo
   enddo
!
   call tridin_ysu(al,ad,cu,r1,au,f1,its,ite,kts,kte,1)
!
!     recover tendencies of heat
!
   do k = kte,kts,-1
     do i = its,ite
       ttend = (f1(i,k)-thx(i,k)+300.)*rdt*pi2d(i,k)
       ttnp(i,k) = ttnp(i,k)+ttend
       dtsfc(i) = dtsfc(i)+ttend*cont*del(i,k)/pi2d(i,k)
     enddo
   enddo
!
!     compute tridiagonal matrix elements for moisture, clouds, and tracers
!
   do k = kts,kte
     do i = its,ite
       au(i,k) = 0.
       al(i,k) = 0.
       ad(i,k) = 0.
     enddo
   enddo
!
   do ic = 1,ndiff
     do i = its,ite
       do k = kts,kte
         f3(i,k,ic) = 0.
       enddo
     enddo
   enddo
!
   do i = its,ite
     ad(i,1) = 1.
     f3(i,1,1) = qx(i,1)+qfx(i)*g/del(i,1)*dt2
   enddo
!
   if(ndiff.ge.2) then
     do ic = 2,ndiff
       is = (ic-1) * kte
       do i = its,ite
         f3(i,1,ic) = qx(i,1+is)
       enddo
     enddo
   endif
!
   do k = kts,kte
     do i = its,ite
       if(k.ge.kpbl(i)) then
         xkzq(i,k) = xkzh(i,k)
       endif
     enddo
   enddo
!
   do k = kts,kte-1
     do i = its,ite
       dtodsd = dt2/del(i,k)
       dtodsu = dt2/del(i,k+1)
       dsig   = p2d(i,k)-p2d(i,k+1)
       rdz    = 1./dza(i,k+1)
       tem1   = dsig*xkzq(i,k)*rdz
       if(pblflg(i).and.k.lt.kpbl(i)) then
         dsdzq = tem1*(-qfxpbl(i)*zfacent(i,k)/xkzq(i,k))
         f3(i,k,1) = f3(i,k,1)+dtodsd*dsdzq
         f3(i,k+1,1) = qx(i,k+1)-dtodsu*dsdzq
       elseif(pblflg(i).and.k.ge.kpbl(i).and.entfac(i,k).lt.4.6) then
         xkzq(i,k) = -we(i)*dza(i,kpbl(i))*exp(-entfac(i,k))
         xkzq(i,k) = sqrt(xkzq(i,k)*xkzhl(i,k))
         xkzq(i,k) = min(xkzq(i,k),xkzmax)
         xkzq(i,k) = max(xkzq(i,k),xkzmin)
         f3(i,k+1,1) = qx(i,k+1)
       else
         f3(i,k+1,1) = qx(i,k+1)
       endif
       tem1   = dsig*xkzq(i,k)*rdz
       dsdz2     = tem1*rdz
       au(i,k)   = -dtodsd*dsdz2
       al(i,k)   = -dtodsu*dsdz2
       ad(i,k)   = ad(i,k)-au(i,k)
       ad(i,k+1) = 1.-al(i,k)
!      exch_hx(i,k+1) = xkzh(i,k)
     enddo
   enddo
!
   if(ndiff.ge.2) then
     do ic = 2,ndiff
       is = (ic-1) * kte
       do k = kts,kte-1
         do i = its,ite
           f3(i,k+1,ic) = qx(i,k+1+is)
         enddo
       enddo
     enddo
   endif
!
! copies here to avoid duplicate input args for tridin
!
   do k = kts,kte
     do i = its,ite
       cu(i,k) = au(i,k)
     enddo
   enddo
!
   do ic = 1,ndiff
     do k = kts,kte
       do i = its,ite
         r3(i,k,ic) = f3(i,k,ic)
       enddo
     enddo
   enddo
!
!     solve tridiagonal problem for moisture, clouds, and tracers
!
   call tridin_ysu(al,ad,cu,r3,au,f3,its,ite,kts,kte,ndiff)
!
!     recover tendencies of heat and moisture
!
   do k = kte,kts,-1
     do i = its,ite
       qtend = (f3(i,k,1)-qx(i,k))*rdt
       qtnp(i,k) = qtnp(i,k)+qtend
       dqsfc(i) = dqsfc(i)+qtend*conq*del(i,k)
     enddo
   enddo
!
   if(ndiff.ge.2) then
     do ic = 2,ndiff
       is = (ic-1) * kte
       do k = kte,kts,-1
         do i = its,ite
           qtend = (f3(i,k,ic)-qx(i,k+is))*rdt
           qtnp(i,k+is) = qtnp(i,k+is)+qtend
         enddo
       enddo
     enddo
   endif
!
!     compute tridiagonal matrix elements for momentum
!
   do i = its,ite
     do k = kts,kte
       au(i,k) = 0.
       al(i,k) = 0.
       ad(i,k) = 0.
       f1(i,k) = 0.
       f2(i,k) = 0.
     enddo
   enddo
!
   do i = its,ite
     ad(i,1) = 1.+ust(i)**2/wspd1(i)*rhox(i)*g/del(i,1)*dt2                    &
              *(wspd1(i)/wspd(i))**2
     f1(i,1) = ux(i,1)
     f2(i,1) = vx(i,1)
   enddo
!
   do k = kts,kte-1
     do i = its,ite
       dtodsd = dt2/del(i,k)
       dtodsu = dt2/del(i,k+1)
       dsig   = p2d(i,k)-p2d(i,k+1)
       rdz    = 1./dza(i,k+1)
       tem1   = dsig*xkzm(i,k)*rdz
     if(pblflg(i).and.k.lt.kpbl(i))then
       dsdzu     = tem1*(-hgamu(i)/hpbl(i)-ufxpbl(i)*zfacent(i,k)/xkzm(i,k))
       dsdzv     = tem1*(-hgamv(i)/hpbl(i)-vfxpbl(i)*zfacent(i,k)/xkzm(i,k))
       f1(i,k)   = f1(i,k)+dtodsd*dsdzu
       f1(i,k+1) = ux(i,k+1)-dtodsu*dsdzu
       f2(i,k)   = f2(i,k)+dtodsd*dsdzv
       f2(i,k+1) = vx(i,k+1)-dtodsu*dsdzv
     elseif(pblflg(i).and.k.ge.kpbl(i).and.entfac(i,k).lt.4.6) then
       xkzm(i,k) = prpbl(i)*xkzh(i,k)
       xkzm(i,k) = sqrt(xkzm(i,k)*xkzml(i,k))
       xkzm(i,k) = min(xkzm(i,k),xkzmax)
       xkzm(i,k) = max(xkzm(i,k),xkzmin)
       f1(i,k+1) = ux(i,k+1)
       f2(i,k+1) = vx(i,k+1)
     else
       f1(i,k+1) = ux(i,k+1)
       f2(i,k+1) = vx(i,k+1)
     endif
       tem1   = dsig*xkzm(i,k)*rdz
       dsdz2     = tem1*rdz
       au(i,k)   = -dtodsd*dsdz2
       al(i,k)   = -dtodsu*dsdz2
       ad(i,k)   = ad(i,k)-au(i,k)
       ad(i,k+1) = 1.-al(i,k)
       exch_mx(i,k+1) = xkzm(i,k)
     enddo
   enddo
!
! copies here to avoid duplicate input args for tridin
!
   do k = kts,kte
     do i = its,ite
       cu(i,k) = au(i,k)
       r1(i,k) = f1(i,k)
       r2(i,k) = f2(i,k)
     enddo
   enddo
!
!     solve tridiagonal problem for momentum
!
   call tridi1n(al,ad,cu,r1,r2,au,f1,f2,its,ite,kts,kte,1)
!
!     recover tendencies of momentum
!
   do k = kte,kts,-1
     do i = its,ite
       utend = (f1(i,k)-ux(i,k))*rdt
       vtend = (f2(i,k)-vx(i,k))*rdt
       utnp(i,k) = utnp(i,k)+utend
       vtnp(i,k) = vtnp(i,k)+vtend
       dusfc(i) = dusfc(i) + utend*conwrc*del(i,k)
       dvsfc(i) = dvsfc(i) + vtend*conwrc*del(i,k)
     enddo
   enddo
!
!---- end of vertical diffusion
!
   do i = its,ite
     kpbl1d(i) = kpbl(i)
   enddo
!
   end subroutine ysu2d
!
   subroutine tridi1n(cl,cm,cu,r1,r2,au,f1,f2,its,ite,kts,kte,nt)
!----------------------------------------------------------------
   implicit none
!----------------------------------------------------------------
!
   integer, intent(in )      ::     its,ite, kts,kte, nt
!
   real, dimension( its:ite, kts+1:kte+1 )                                   , &
         intent(in   )  ::                                                 cl
!
   real, dimension( its:ite, kts:kte )                                       , &
         intent(in   )  ::                                                 cm, &
						                           r1
   real, dimension( its:ite, kts:kte,nt )                                    , &
         intent(in   )  ::                                                 r2
!
   real, dimension( its:ite, kts:kte )                                       , &
         intent(inout)  ::                                                 au, &
						                           cu, &
							                   f1
   real, dimension( its:ite, kts:kte,nt )                                    , &
         intent(inout)  ::                                                 f2
!
   real    :: fk
   integer :: i,k,l,n,it
!
!----------------------------------------------------------------
!
   l = ite
   n = kte
!
   do i = its,l
     fk = 1./cm(i,1)
     au(i,1) = fk*cu(i,1)
     f1(i,1) = fk*r1(i,1)
   enddo
   do it = 1,nt
     do i = its,l
       fk = 1./cm(i,1)
       f2(i,1,it) = fk*r2(i,1,it)
     enddo
   enddo
   do k = kts+1,n-1
     do i = its,l
       fk = 1./(cm(i,k)-cl(i,k)*au(i,k-1))
       au(i,k) = fk*cu(i,k)
       f1(i,k) = fk*(r1(i,k)-cl(i,k)*f1(i,k-1))
     enddo
   enddo
   do it = 1,nt
   do k = kts+1,n-1
     do i = its,l
       fk = 1./(cm(i,k)-cl(i,k)*au(i,k-1))
       f2(i,k,it) = fk*(r2(i,k,it)-cl(i,k)*f2(i,k-1,it))
     enddo
   enddo
   enddo
   do i = its,l
     fk = 1./(cm(i,n)-cl(i,n)*au(i,n-1))
     f1(i,n) = fk*(r1(i,n)-cl(i,n)*f1(i,n-1))
   enddo
   do it = 1,nt
   do i = its,l
     fk = 1./(cm(i,n)-cl(i,n)*au(i,n-1))
     f2(i,n,it) = fk*(r2(i,n,it)-cl(i,n)*f2(i,n-1,it))
   enddo
   enddo
   do k = n-1,kts,-1
     do i = its,l
       f1(i,k) = f1(i,k)-au(i,k)*f1(i,k+1)
     enddo
   enddo
   do it = 1,nt
   do k = n-1,kts,-1
     do i = its,l
       f2(i,k,it) = f2(i,k,it)-au(i,k)*f2(i,k+1,it)
     enddo
   enddo
   enddo
!
   end subroutine tridi1n
!
   subroutine tridin_ysu(cl,cm,cu,r2,au,f2,its,ite,kts,kte,nt)
!----------------------------------------------------------------
   implicit none
!----------------------------------------------------------------
!
   integer, intent(in )      ::     its,ite, kts,kte, nt
!
   real, dimension( its:ite, kts+1:kte+1 )                                   , &
         intent(in   )  ::                                                 cl
!
   real, dimension( its:ite, kts:kte )                                       , &
         intent(in   )  ::                                                 cm
   real, dimension( its:ite, kts:kte,nt )                                    , &
         intent(in   )  ::                                                 r2
!
   real, dimension( its:ite, kts:kte )                                       , &
         intent(inout)  ::                                                 au, &
						                           cu
   real, dimension( its:ite, kts:kte,nt )                                    , &
         intent(inout)  ::                                                 f2
!
   real    :: fk
   integer :: i,k,l,n,it
!
!----------------------------------------------------------------
!
   l = ite
   n = kte
!
   do it = 1,nt
     do i = its,l
       fk = 1./cm(i,1)
       au(i,1) = fk*cu(i,1)
       f2(i,1,it) = fk*r2(i,1,it)
     enddo
   enddo
   do it = 1,nt
   do k = kts+1,n-1
     do i = its,l
       fk = 1./(cm(i,k)-cl(i,k)*au(i,k-1))
       au(i,k) = fk*cu(i,k)
       f2(i,k,it) = fk*(r2(i,k,it)-cl(i,k)*f2(i,k-1,it))
     enddo
   enddo
   enddo
   do it = 1,nt
   do i = its,l
     fk = 1./(cm(i,n)-cl(i,n)*au(i,n-1))
     f2(i,n,it) = fk*(r2(i,n,it)-cl(i,n)*f2(i,n-1,it))
   enddo
   enddo
   do it = 1,nt
   do k = n-1,kts,-1
     do i = its,l
       f2(i,k,it) = f2(i,k,it)-au(i,k)*f2(i,k+1,it)
     enddo
   enddo
   enddo
!
   end subroutine tridin_ysu
!
   subroutine ysuinit(rublten,rvblten,rthblten,rqvblten,                       &
                      rqcblten,rqiblten,p_qi,p_first_scalar,                   &
                      restart, allowed_to_read,                                &
                      ids, ide, jds, jde, kds, kde,                            &
                      ims, ime, jms, jme, kms, kme,                            &
                      its, ite, jts, jte, kts, kte                 )
!-------------------------------------------------------------------
   implicit none
!-------------------------------------------------------------------
!
   logical , intent(in)          :: restart, allowed_to_read
   integer , intent(in)          ::  ids, ide, jds, jde, kds, kde,             &
                                     ims, ime, jms, jme, kms, kme,             &
                                     its, ite, jts, jte, kts, kte
   integer , intent(in)          ::  p_qi,p_first_scalar
   real , dimension( ims:ime , kms:kme , jms:jme ), intent(out) ::             &
                                                                      rublten, &
                                                                      rvblten, &
                                                                     rthblten, &
                                                                     rqvblten, &
                                                                     rqcblten, &
                                                                     rqiblten
   integer :: i, j, k, itf, jtf, ktf
!
   jtf = min0(jte,jde-1)
   ktf = min0(kte,kde-1)
   itf = min0(ite,ide-1)
!
   if(.not.restart)then
     do j = jts,jtf
     do k = kts,ktf
     do i = its,itf
        rublten(i,k,j) = 0.
        rvblten(i,k,j) = 0.
        rthblten(i,k,j) = 0.
        rqvblten(i,k,j) = 0.
        rqcblten(i,k,j) = 0.
     enddo
     enddo
     enddo
   endif
!
   if (p_qi .ge. p_first_scalar .and. .not.restart) then
      do j = jts,jtf
      do k = kts,ktf
      do i = its,itf
         rqiblten(i,k,j) = 0.
      enddo
      enddo
      enddo
   endif
!
   end subroutine ysuinit
!-------------------------------------------------------------------
end module module_bl_ysu

sfclay.F/       1298670057  19071 8000  100644  47402     `
!WRF:MODEL_LAYER:PHYSICS
!
MODULE module_sf_sfclay

 REAL    , PARAMETER ::  VCONVC=1.
 REAL    , PARAMETER ::  CZO=0.0185
 REAL    , PARAMETER ::  OZO=1.59E-5

 REAL,   DIMENSION(0:1000 ),SAVE          :: PSIMTB,PSIHTB

CONTAINS

!-------------------------------------------------------------------
   SUBROUTINE SFCLAY(U3D,V3D,T3D,QV3D,P3D,dz8w,                    &
                     CP,G,ROVCP,R,XLV,PSFC,CHS,CHS2,CQS2,CPM,      &
                     ZNT,UST,PBLH,MAVAIL,ZOL,MOL,REGIME,PSIM,PSIH, &
                     XLAND,HFX,QFX,LH,TSK,FLHC,FLQC,QGH,QSFC,RMOL, &
                     U10,V10,TH2,T2,Q2,                            &
                     GZ1OZ0,WSPD,BR,ISFFLX,DX,                     &
                     SVP1,SVP2,SVP3,SVPT0,EP1,EP2,                 &
                     KARMAN,EOMEG,STBOLT,                          &
                     P1000mb,                                      &
                     ids,ide, jds,jde, kds,kde,                    &
                     ims,ime, jms,jme, kms,kme,                    &
                     its,ite, jts,jte, kts,kte,                    &
                     ustm,ck,cka,cd,cda,isftcflx,iz0tlnd           )
!-------------------------------------------------------------------
      IMPLICIT NONE
!-------------------------------------------------------------------
!-- U3D         3D u-velocity interpolated to theta points (m/s)
!-- V3D         3D v-velocity interpolated to theta points (m/s)
!-- T3D         temperature (K)
!-- QV3D        3D water vapor mixing ratio (Kg/Kg)
!-- P3D         3D pressure (Pa)
!-- dz8w        dz between full levels (m)
!-- CP          heat capacity at constant pressure for dry air (J/kg/K)
!-- G           acceleration due to gravity (m/s^2)
!-- ROVCP       R/CP
!-- R           gas constant for dry air (J/kg/K)
!-- XLV         latent heat of vaporization for water (J/kg)
!-- PSFC        surface pressure (Pa)
!-- ZNT         roughness length (m)
!-- UST         u* in similarity theory (m/s)
!-- USTM        u* in similarity theory (m/s) without vconv correction
!               used to couple with TKE scheme
!-- PBLH        PBL height from previous time (m)
!-- MAVAIL      surface moisture availability (between 0 and 1)
!-- ZOL         z/L height over Monin-Obukhov length
!-- MOL         T* (similarity theory) (K)
!-- REGIME      flag indicating PBL regime (stable, unstable, etc.)
!-- PSIM        similarity stability function for momentum
!-- PSIH        similarity stability function for heat
!-- XLAND       land mask (1 for land, 2 for water)
!-- HFX         upward heat flux at the surface (W/m^2)
!-- QFX         upward moisture flux at the surface (kg/m^2/s)
!-- LH          net upward latent heat flux at surface (W/m^2)
!-- TSK         surface temperature (K)
!-- FLHC        exchange coefficient for heat (W/m^2/K)
!-- FLQC        exchange coefficient for moisture (kg/m^2/s)
!-- CHS         heat/moisture exchange coefficient for LSM (m/s)
!-- QGH         lowest-level saturated mixing ratio
!-- QSFC        ground saturated mixing ratio
!-- U10         diagnostic 10m u wind
!-- V10         diagnostic 10m v wind
!-- TH2         diagnostic 2m theta (K)
!-- T2          diagnostic 2m temperature (K)
!-- Q2          diagnostic 2m mixing ratio (kg/kg)
!-- GZ1OZ0      log(z/z0) where z0 is roughness length
!-- WSPD        wind speed at lowest model level (m/s)
!-- BR          bulk Richardson number in surface layer
!-- ISFFLX      isfflx=1 for surface heat and moisture fluxes
!-- DX          horizontal grid size (m)
!-- SVP1        constant for saturation vapor pressure (kPa)
!-- SVP2        constant for saturation vapor pressure (dimensionless)
!-- SVP3        constant for saturation vapor pressure (K)
!-- SVPT0       constant for saturation vapor pressure (K)
!-- EP1         constant for virtual temperature (R_v/R_d - 1) (dimensionless)
!-- EP2         constant for specific humidity calculation 
!               (R_d/R_v) (dimensionless)
!-- KARMAN      Von Karman constant
!-- EOMEG       angular velocity of earth's rotation (rad/s)
!-- STBOLT      Stefan-Boltzmann constant (W/m^2/K^4)
!-- ck          enthalpy exchange coeff at 10 meters
!-- cd          momentum exchange coeff at 10 meters
!-- cka         enthalpy exchange coeff at the lowest model level
!-- cda         momentum exchange coeff at the lowest model level
!-- isftcflx    =0, (Charnock and Carlson-Boland); =1, AHW Ck, Cd, =2 Garratt
!-- iz0tlnd     =0 Carlson-Boland, =1 Czil_new
!-- ids         start index for i in domain
!-- ide         end index for i in domain
!-- jds         start index for j in domain
!-- jde         end index for j in domain
!-- kds         start index for k in domain
!-- kde         end index for k in domain
!-- ims         start index for i in memory
!-- ime         end index for i in memory
!-- jms         start index for j in memory
!-- jme         end index for j in memory
!-- kms         start index for k in memory
!-- kme         end index for k in memory
!-- its         start index for i in tile
!-- ite         end index for i in tile
!-- jts         start index for j in tile
!-- jte         end index for j in tile
!-- kts         start index for k in tile
!-- kte         end index for k in tile
!-------------------------------------------------------------------
      INTEGER,  INTENT(IN )   ::        ids,ide, jds,jde, kds,kde, &
                                        ims,ime, jms,jme, kms,kme, &
                                        its,ite, jts,jte, kts,kte
!                                                               
      INTEGER,  INTENT(IN )   ::        ISFFLX
      REAL,     INTENT(IN )   ::        SVP1,SVP2,SVP3,SVPT0
      REAL,     INTENT(IN )   ::        EP1,EP2,KARMAN,EOMEG,STBOLT
      REAL,     INTENT(IN )   ::        P1000mb
!
      REAL,     DIMENSION( ims:ime, jms:jme , kms:kme )           , &
                INTENT(IN   )   ::                           dz8w
                                        
      REAL,     DIMENSION( ims:ime, jms:jme , kms:kme )           , &
                INTENT(IN   )   ::                           QV3D, &
                                                              P3D, &
                                                              T3D

      REAL,     DIMENSION( ims:ime, jms:jme )                    , &
                INTENT(IN   )               ::             MAVAIL, &
                                                             PBLH, &
                                                            XLAND, &
                                                              TSK
      REAL,     DIMENSION( ims:ime, jms:jme )                    , &
                INTENT(OUT  )               ::                U10, &
                                                              V10, &
                                                              TH2, &
                                                               T2, &
                                                               Q2, &
                                                             QSFC

!
      REAL,     DIMENSION( ims:ime, jms:jme )                    , &
                INTENT(INOUT)               ::             REGIME, &
                                                              HFX, &
                                                              QFX, &
                                                               LH, &
                                                          MOL,RMOL
!m the following 5 are change to memory size
!
      REAL,     DIMENSION( ims:ime, jms:jme )                    , &
                INTENT(INOUT)   ::                 GZ1OZ0,WSPD,BR, &
                                                        PSIM,PSIH

      REAL,     DIMENSION( ims:ime, jms:jme , kms:kme )           , &
                INTENT(IN   )   ::                            U3D, &
                                                              V3D
                                        
      REAL,     DIMENSION( ims:ime, jms:jme )                    , &
                INTENT(IN   )               ::               PSFC, &
                                                               DX

      REAL,     DIMENSION( ims:ime, jms:jme )                    , &
                INTENT(INOUT)   ::                            ZNT, &
                                                              ZOL, &
                                                              UST, &
                                                              CPM, &
                                                             CHS2, &
                                                             CQS2, &
                                                              CHS

      REAL,     DIMENSION( ims:ime, jms:jme )                    , &
                INTENT(INOUT)   ::                      FLHC,FLQC

      REAL,     DIMENSION( ims:ime, jms:jme )                    , &
                INTENT(INOUT)   ::                                 &
                                                              QGH


                                    
      REAL,     INTENT(IN   )               ::   CP,G,ROVCP,R,XLV
 
      REAL, OPTIONAL, DIMENSION( ims:ime, jms:jme )              , &
                INTENT(OUT)     ::              ck,cka,cd,cda,ustm

      INTEGER,  OPTIONAL,  INTENT(IN )   ::     ISFTCFLX, IZ0TLND

! LOCAL VARS

      REAL,     DIMENSION( its:ite ) ::                       U1D, &
                                                              V1D, &
                                                             QV1D, &
                                                              P1D, &
                                                              T1D

      REAL,     DIMENSION( its:ite ) ::                    dz8w1d

      INTEGER ::  I,J

!$omp parallel do default(shared)   &
!$omp private(i,j,dz8w1d,u1d,v1d,qv1d,p1d,t1d)
      DO J=jts,jte
        DO i=its,ite
          dz8w1d(I) = dz8w(i,j,1)
        ENDDO
   
        DO i=its,ite
           U1D(i) =U3D(i,j,1)
           V1D(i) =V3D(i,j,1)
           QV1D(i)=QV3D(i,j,1)
           P1D(i) =P3D(i,j,1)
           T1D(i) =T3D(i,j,1)
        ENDDO

        !  Sending array starting locations of optional variables may cause
        !  troubles, so we explicitly change the call.

        CALL SFCLAY1D(J,U1D,V1D,T1D,QV1D,P1D,dz8w1d,               &
                CP,G,ROVCP,R,XLV,PSFC(ims,j),CHS(ims,j),CHS2(ims,j),&
                CQS2(ims,j),CPM(ims,j),PBLH(ims,j), RMOL(ims,j),   &
                ZNT(ims,j),UST(ims,j),MAVAIL(ims,j),ZOL(ims,j),    &
                MOL(ims,j),REGIME(ims,j),PSIM(ims,j),PSIH(ims,j),  &
                XLAND(ims,j),HFX(ims,j),QFX(ims,j),TSK(ims,j),     &
                U10(ims,j),V10(ims,j),TH2(ims,j),T2(ims,j),        &
                Q2(ims,j),FLHC(ims,j),FLQC(ims,j),QGH(ims,j),      &
                QSFC(ims,j),LH(ims,j),                             &
                GZ1OZ0(ims,j),WSPD(ims,j),BR(ims,j),ISFFLX,DX(ims,j),  &
                SVP1,SVP2,SVP3,SVPT0,EP1,EP2,KARMAN,EOMEG,STBOLT,  &
                P1000mb,                                           &
                ids,ide, jds,jde, kds,kde,                         &
                ims,ime, jms,jme, kms,kme,                         &
                its,ite, jts,jte, kts,kte                          &
!!!#if ( EM_CORE == 1 )
                ,isftcflx,iz0tlnd,                                 &
                USTM(ims,j),CK(ims,j),CKA(ims,j),                  &
                CD(ims,j),CDA(ims,j)                               &
!!!#endif
                                                                   )
      ENDDO


   END SUBROUTINE SFCLAY


!-------------------------------------------------------------------
   SUBROUTINE SFCLAY1D(J,UX,VX,T1D,QV1D,P1D,dz8w1d,                &
                     CP,G,ROVCP,R,XLV,PSFCPA,CHS,CHS2,CQS2,CPM,PBLH,RMOL, &
                     ZNT,UST,MAVAIL,ZOL,MOL,REGIME,PSIM,PSIH,      &
                     XLAND,HFX,QFX,TSK,                            &
                     U10,V10,TH2,T2,Q2,FLHC,FLQC,QGH,              &
                     QSFC,LH,GZ1OZ0,WSPD,BR,ISFFLX,DX,             &
                     SVP1,SVP2,SVP3,SVPT0,EP1,EP2,                 &
                     KARMAN,EOMEG,STBOLT,                          &
                     P1000mb,                                      &
                     ids,ide, jds,jde, kds,kde,                    &
                     ims,ime, jms,jme, kms,kme,                    &
                     its,ite, jts,jte, kts,kte,                    &
                     isftcflx, iz0tlnd,                            &
                     ustm,ck,cka,cd,cda                            )
!-------------------------------------------------------------------
      IMPLICIT NONE
!-------------------------------------------------------------------
      REAL,     PARAMETER     ::        XKA=2.4E-5
      REAL,     PARAMETER     ::        PRT=1.

      INTEGER,  INTENT(IN )   ::        ids,ide, jds,jde, kds,kde, &
                                        ims,ime, jms,jme, kms,kme, &
                                        its,ite, jts,jte, kts,kte, &
                                        J
!                                                               
      INTEGER,  INTENT(IN )   ::        ISFFLX
      REAL,     INTENT(IN )   ::        SVP1,SVP2,SVP3,SVPT0
      REAL,     INTENT(IN )   ::        EP1,EP2,KARMAN,EOMEG,STBOLT
      REAL,     INTENT(IN )   ::        P1000mb

!
      REAL,     DIMENSION( ims:ime )                             , &
                INTENT(IN   )               ::             MAVAIL, &
                                                             PBLH, &
                                                            XLAND, &
                                                              TSK
!
      REAL,     DIMENSION( ims:ime )                             , &
                INTENT(IN   )               ::             PSFCPA, &
                                                               DX

      REAL,     DIMENSION( ims:ime )                             , &
                INTENT(INOUT)               ::             REGIME, &
                                                              HFX, &
                                                              QFX, &
                                                         MOL,RMOL
!m the following 5 are changed to memory size---
!
      REAL,     DIMENSION( ims:ime )                             , &
                INTENT(INOUT)   ::                 GZ1OZ0,WSPD,BR, &
                                                        PSIM,PSIH

      REAL,     DIMENSION( ims:ime )                             , &
                INTENT(INOUT)   ::                            ZNT, &
                                                              ZOL, &
                                                              UST, &
                                                              CPM, &
                                                             CHS2, &
                                                             CQS2, &
                                                              CHS

      REAL,     DIMENSION( ims:ime )                             , &
                INTENT(INOUT)   ::                      FLHC,FLQC

      REAL,     DIMENSION( ims:ime )                             , &
                INTENT(INOUT)   ::                                 &
                                                              QGH

      REAL,     DIMENSION( ims:ime )                             , &
                INTENT(OUT)     ::                        U10,V10, &
                                                TH2,T2,Q2,QSFC,LH

                                    
      REAL,     INTENT(IN   )               ::   CP,G,ROVCP,R,XLV

! MODULE-LOCAL VARIABLES, DEFINED IN SUBROUTINE SFCLAY
      REAL,     DIMENSION( its:ite ),  INTENT(IN   )   ::  dz8w1d

      REAL,     DIMENSION( its:ite ),  INTENT(IN   )   ::      UX, &
                                                               VX, &
                                                             QV1D, &
                                                              P1D, &
                                                              T1D
 
      REAL, OPTIONAL, DIMENSION( ims:ime )                       , &
                INTENT(OUT)     ::              ck,cka,cd,cda,ustm

      INTEGER,  OPTIONAL,  INTENT(IN )   ::     ISFTCFLX, IZ0TLND

! LOCAL VARS

      REAL,     DIMENSION( its:ite )        ::                 ZA, &
                                                        THVX,ZQKL, &
                                                           ZQKLP1, &
                                                           THX,QX, &
                                                            PSIH2, &
                                                            PSIM2, &
                                                           PSIH10, &
                                                           PSIM10, &
                                                           DENOMQ, &
                                                          DENOMQ2, &
                                                          DENOMT2, &
                                                            WSPDI, &
                                                           GZ2OZ0, &
                                                           GZ10OZ0
!
      REAL,     DIMENSION( its:ite )        ::                     &
                                                      RHOX,GOVRTH, &
                                                            TGDSA
!
      REAL,     DIMENSION( its:ite)         ::          SCR3,SCR4
      REAL,     DIMENSION( its:ite )        ::         THGB, PSFC
!
      INTEGER                               ::                 KL

      INTEGER ::  N,I,K,KK,L,NZOL,NK,NZOL2,NZOL10

      REAL    ::  PL,THCON,TVCON,E1
      REAL    ::  ZL,TSKV,DTHVDZ,DTHVM,VCONV,RZOL,RZOL2,RZOL10,ZOL2,ZOL10
      REAL    ::  DTG,PSIX,DTTHX,PSIX10,PSIT,PSIT2,PSIQ,PSIQ2,PSIQ10
      REAL    ::  FLUXC,VSGD,Z0Q,VISC,RESTAR,CZIL,RESTAR2
!-------------------------------------------------------------------
      KL=kte

      DO i=its,ite
! PSFC cb
         PSFC(I)=PSFCPA(I)/1000.
      ENDDO
!                                                      
!----CONVERT GROUND TEMPERATURE TO POTENTIAL TEMPERATURE:  
!                                                            
      DO 5 I=its,ite                                   
        TGDSA(I)=TSK(I)                                    
! PSFC cb
!        THGB(I)=TSK(I)*(100./PSFC(I))**ROVCP                
        THGB(I)=TSK(I)*(P1000mb/PSFCPA(I))**ROVCP   
    5 CONTINUE                                               
!                                                            
!-----DECOUPLE FLUX-FORM VARIABLES TO GIVE U,V,T,THETA,THETA-VIR.,
!     T-VIR., QV, AND QC AT CROSS POINTS AND AT KTAU-1.  
!                                                                 
!     *** NOTE ***                                           
!         THE BOUNDARY WINDS MAY NOT BE ADEQUATELY AFFECTED BY FRICTION,         
!         SO USE ONLY INTERIOR VALUES OF UX AND VX TO CALCULATE 
!         TENDENCIES.                             
!                                                           
   10 CONTINUE                                                     

!     DO 24 I=its,ite
!        UX(I)=U1D(I)
!        VX(I)=V1D(I)
!  24 CONTINUE                                             
                                                             
   26 CONTINUE                                               
                                                   
!.....SCR3(I,K) STORE TEMPERATURE,                           
!     SCR4(I,K) STORE VIRTUAL TEMPERATURE.                                       
                                                                                 
      DO 30 I=its,ite
! PL cb
         PL=P1D(I)/1000.
         SCR3(I)=T1D(I)                                                   
!         THCON=(100./PL)**ROVCP                                                 
         THCON=(P1000mb*0.001/PL)**ROVCP
         THX(I)=SCR3(I)*THCON                                               
         SCR4(I)=SCR3(I)                                                    
         THVX(I)=THX(I)                                                     
         QX(I)=0.                                                             
   30 CONTINUE                                                                 
!                                                                                
      DO I=its,ite
         QGH(I)=0.                                                                
         FLHC(I)=0.                                                               
         FLQC(I)=0.                                                               
         CPM(I)=CP                                                                
      ENDDO
!                                                                                
!     IF(IDRY.EQ.1)GOTO 80                                                   
      DO 50 I=its,ite
         QX(I)=QV1D(I)                                                    
         TVCON=(1.+EP1*QX(I))                                      
         THVX(I)=THX(I)*TVCON                                               
         SCR4(I)=SCR3(I)*TVCON                                              
   50 CONTINUE                                                                 
!                                                                                
      DO 60 I=its,ite
        E1=SVP1*EXP(SVP2*(TGDSA(I)-SVPT0)/(TGDSA(I)-SVP3))                       
!  for land points QSFC can come from previous time step
        if(xland(i).gt.1.5.or.qsfc(i).le.0.0)QSFC(I)=EP2*E1/(PSFC(I)-E1)                                                 
! QGH CHANGED TO USE LOWEST-LEVEL AIR TEMP CONSISTENT WITH MYJSFC CHANGE
! Q2SAT = QGH IN LSM
        E1=SVP1*EXP(SVP2*(T1D(I)-SVPT0)/(T1D(I)-SVP3))                       
        PL=P1D(I)/1000.
        QGH(I)=EP2*E1/(PL-E1)                                                 
        CPM(I)=CP*(1.+0.8*QX(I))                                   
   60 CONTINUE                                                                   
   80 CONTINUE
                                                                                 
!-----COMPUTE THE HEIGHT OF FULL- AND HALF-SIGMA LEVELS ABOVE GROUND             
!     LEVEL, AND THE LAYER THICKNESSES.                                          
                                                                                 
      DO 90 I=its,ite
        ZQKLP1(I)=0.
        RHOX(I)=PSFC(I)*1000./(R*SCR4(I))                                       
   90 CONTINUE                                                                   
!                                                                                
      DO 110 I=its,ite                                                   
           ZQKL(I)=dz8w1d(I)+ZQKLP1(I)
  110 CONTINUE                                                                 
!                                                                                
      DO 120 I=its,ite
         ZA(I)=0.5*(ZQKL(I)+ZQKLP1(I))                                        
  120 CONTINUE                                                                 
!                                                                                
      DO 160 I=its,ite
        GOVRTH(I)=G/THX(I)                                                    
  160 CONTINUE                                                                   
                                                                                 
!-----CALCULATE BULK RICHARDSON NO. OF SURFACE LAYER, ACCORDING TO               
!     AKB(1976), EQ(12).                                                         
                   
      DO 260 I=its,ite
        GZ1OZ0(I)=ALOG(ZA(I)/ZNT(I))                                        
        GZ2OZ0(I)=ALOG(2./ZNT(I))                                        
        GZ10OZ0(I)=ALOG(10./ZNT(I))                                        
        IF((XLAND(I)-1.5).GE.0)THEN                                            
          ZL=ZNT(I)                                                            
        ELSE                                                                     
          ZL=0.01                                                                
        ENDIF                                                                    
        WSPD(I)=SQRT(UX(I)*UX(I)+VX(I)*VX(I))                        

        TSKV=THGB(I)*(1.+EP1*QSFC(I))                     
        DTHVDZ=(THVX(I)-TSKV)                                                 
!  Convective velocity scale Vc and subgrid-scale velocity Vsg
!  following Beljaars (1995, QJRMS) and Mahrt and Sun (1995, MWR)
!                                ... HONG Aug. 2001
!
!       VCONV = 0.25*sqrt(g/tskv*pblh(i)*dthvm)
!      Use Beljaars over land, old MM5 (Wyngaard) formula over water
        if (xland(i).lt.1.5) then
        fluxc = max(hfx(i)/rhox(i)/cp                    &
              + ep1*tskv*qfx(i)/rhox(i),0.)
        VCONV = vconvc*(g/tgdsa(i)*pblh(i)*fluxc)**.33
        else
        IF(-DTHVDZ.GE.0)THEN
          DTHVM=-DTHVDZ
        ELSE
          DTHVM=0.
        ENDIF
        VCONV = 2.*SQRT(DTHVM)
        endif
! Mahrt and Sun low-res correction
        VSGD = 0.32 * (max(dx(i)/5000.-1.,0.))**.33
        WSPD(I)=SQRT(WSPD(I)*WSPD(I)+VCONV*VCONV+vsgd*vsgd)
        WSPD(I)=AMAX1(WSPD(I),0.1)
        BR(I)=GOVRTH(I)*ZA(I)*DTHVDZ/(WSPD(I)*WSPD(I))                        
!  IF PREVIOUSLY UNSTABLE, DO NOT LET INTO REGIMES 1 AND 2
        IF(MOL(I).LT.0.)BR(I)=AMIN1(BR(I),0.0)
!jdf
        RMOL(I)=-GOVRTH(I)*DTHVDZ*ZA(I)*KARMAN
!jdf

  260 CONTINUE                                                                   

!                                                                                
!-----DIAGNOSE BASIC PARAMETERS FOR THE APPROPRIATED STABILITY CLASS:            
!                                                                                
!                                                                                
!     THE STABILITY CLASSES ARE DETERMINED BY BR (BULK RICHARDSON NO.)           
!     AND HOL (HEIGHT OF PBL/MONIN-OBUKHOV LENGTH).                              
!                                                                                
!     CRITERIA FOR THE CLASSES ARE AS FOLLOWS:                                   
!                                                                                
!        1. BR .GE. 0.2;                                                         
!               REPRESENTS NIGHTTIME STABLE CONDITIONS (REGIME=1),               
!                                                                                
!        2. BR .LT. 0.2 .AND. BR .GT. 0.0;                                       
!               REPRESENTS DAMPED MECHANICAL TURBULENT CONDITIONS                
!               (REGIME=2),                                                      
!                                                                                
!        3. BR .EQ. 0.0                                                          
!               REPRESENTS FORCED CONVECTION CONDITIONS (REGIME=3),              
!                                                                                
!        4. BR .LT. 0.0                                                          
!               REPRESENTS FREE CONVECTION CONDITIONS (REGIME=4).                
!                                                                                
!CCCCC                                                                           

      DO 320 I=its,ite
!CCCCC                                                                           
!CC     REMOVE REGIME 3 DEPENDENCE ON PBL HEIGHT                                 
!CC          IF(BR(I).LT.0..AND.HOL(I,J).GT.1.5)GOTO 310                         
        IF(BR(I).LT.0.)GOTO 310                                                  
!                                                                                
!-----CLASS 1; STABLE (NIGHTTIME) CONDITIONS:                                    
!                                                                                
        IF(BR(I).LT.0.2)GOTO 270                                                 
        REGIME(I)=1.                                                           
        PSIM(I)=-10.*GZ1OZ0(I)                                                   
!    LOWER LIMIT ON PSI IN STABLE CONDITIONS                                     
        PSIM(I)=AMAX1(PSIM(I),-10.)                                              
        PSIH(I)=PSIM(I)                                                          
        PSIM10(I)=10./ZA(I)*PSIM(I)
        PSIM10(I)=AMAX1(PSIM10(I),-10.)                               
        PSIH10(I)=PSIM10(I)                                          
        PSIM2(I)=2./ZA(I)*PSIM(I)
        PSIM2(I)=AMAX1(PSIM2(I),-10.)                              
        PSIH2(I)=PSIM2(I)                                         

!       1.0 over Monin-Obukhov length
        IF(UST(I).LT.0.01)THEN
           RMOL(I)=BR(I)*GZ1OZ0(I) !ZA/L
        ELSE
           RMOL(I)=KARMAN*GOVRTH(I)*ZA(I)*MOL(I)/(UST(I)*UST(I)) !ZA/L
        ENDIF
        RMOL(I)=AMIN1(RMOL(I),9.999) ! ZA/L
        RMOL(I) = RMOL(I)/ZA(I) !1.0/L

        GOTO 320                                                                 
!                                                                                
!-----CLASS 2; DAMPED MECHANICAL TURBULENCE:                                     
!                                                                                
  270   IF(BR(I).EQ.0.0)GOTO 280                                                 
        REGIME(I)=2.                                                           
        PSIM(I)=-5.0*BR(I)*GZ1OZ0(I)/(1.1-5.0*BR(I))                             
!    LOWER LIMIT ON PSI IN STABLE CONDITIONS                                     
        PSIM(I)=AMAX1(PSIM(I),-10.)                                              
!.....AKB(1976), EQ(16).                                                         
        PSIH(I)=PSIM(I)                                                          
        PSIM10(I)=10./ZA(I)*PSIM(I)
        PSIM10(I)=AMAX1(PSIM10(I),-10.)                               
        PSIH10(I)=PSIM10(I)                                          
        PSIM2(I)=2./ZA(I)*PSIM(I)
        PSIM2(I)=AMAX1(PSIM2(I),-10.)                              
        PSIH2(I)=PSIM2(I)                                         

        ! Linear form: PSIM = -0.5*ZA/L; e.g, see eqn 16 of
        ! Blackadar, Modeling the nocturnal boundary layer, Preprints,
        ! Third Symposium on Atmospheric Turbulence Diffusion and Air Quality,
        ! Raleigh, NC, 1976
        ZOL(I) = BR(I)*GZ1OZ0(I)/(1.00001-5.0*BR(I))

        if ( ZOL(I) .GT. 0.5 ) then ! linear form ok
           ! Holtslag and de Bruin, J. App. Meteor 27, 689-704, 1988;
           ! see also, Launiainen, Boundary-Layer Meteor 76,165-179, 1995
           ! Eqn (8) of Launiainen, 1995
           ZOL(I) = ( 1.89*GZ1OZ0(I) + 44.2 ) * BR(I)*BR(I)    &
                + ( 1.18*GZ1OZ0(I) - 1.37 ) * BR(I)
           ZOL(I)=AMIN1(ZOL(I),9.999)
        end if

        ! 1.0 over Monin-Obukhov length
        RMOL(I)= ZOL(I)/ZA(I)

        GOTO 320                                                                 
!                                                                                
!-----CLASS 3; FORCED CONVECTION:                                                
!                                                                                
  280   REGIME(I)=3.                                                           
        PSIM(I)=0.0                                                              
        PSIH(I)=PSIM(I)                                                          
        PSIM10(I)=0.                                                   
        PSIH10(I)=PSIM10(I)                                           
        PSIM2(I)=0.                                                  
        PSIH2(I)=PSIM2(I)                                           

                                                                                 
        IF(UST(I).LT.0.01)THEN                                                 
          ZOL(I)=BR(I)*GZ1OZ0(I)                                               
        ELSE                                                                     
          ZOL(I)=KARMAN*GOVRTH(I)*ZA(I)*MOL(I)/(UST(I)*UST(I)) 
        ENDIF                                                                    

        RMOL(I) = ZOL(I)/ZA(I)  

        GOTO 320                                                                 
!                                                                                
!-----CLASS 4; FREE CONVECTION:                                                  
!                                                                                
  310   CONTINUE                                                                 
        REGIME(I)=4.                                                           
        IF(UST(I).LT.0.01)THEN                                                 
          ZOL(I)=BR(I)*GZ1OZ0(I)                                               
        ELSE                                                                     
          ZOL(I)=KARMAN*GOVRTH(I)*ZA(I)*MOL(I)/(UST(I)*UST(I))
        ENDIF                                                                    
        ZOL10=10./ZA(I)*ZOL(I)                                    
        ZOL2=2./ZA(I)*ZOL(I)                                     
        ZOL(I)=AMIN1(ZOL(I),0.)                                              
        ZOL(I)=AMAX1(ZOL(I),-9.9999)                                         
        ZOL10=AMIN1(ZOL10,0.)                                          
        ZOL10=AMAX1(ZOL10,-9.9999)                                    
        ZOL2=AMIN1(ZOL2,0.)                                          
        ZOL2=AMAX1(ZOL2,-9.9999)                                    
        NZOL=INT(-ZOL(I)*100.)                                                 
        RZOL=-ZOL(I)*100.-NZOL                                                 
        NZOL10=INT(-ZOL10*100.)                                        
        RZOL10=-ZOL10*100.-NZOL10                                     
        NZOL2=INT(-ZOL2*100.)                                        
        RZOL2=-ZOL2*100.-NZOL2                                      
        PSIM(I)=PSIMTB(NZOL)+RZOL*(PSIMTB(NZOL+1)-PSIMTB(NZOL))                  
        PSIH(I)=PSIHTB(NZOL)+RZOL*(PSIHTB(NZOL+1)-PSIHTB(NZOL))                  
        PSIM10(I)=PSIMTB(NZOL10)+RZOL10*(PSIMTB(NZOL10+1)-PSIMTB(NZOL10))                                                    
        PSIH10(I)=PSIHTB(NZOL10)+RZOL10*(PSIHTB(NZOL10+1)-PSIHTB(NZOL10))
        PSIM2(I)=PSIMTB(NZOL2)+RZOL2*(PSIMTB(NZOL2+1)-PSIMTB(NZOL2))    
        PSIH2(I)=PSIHTB(NZOL2)+RZOL2*(PSIHTB(NZOL2+1)-PSIHTB(NZOL2))   

!---LIMIT PSIH AND PSIM IN THE CASE OF THIN LAYERS AND HIGH ROUGHNESS            
!---  THIS PREVENTS DENOMINATOR IN FLUXES FROM GETTING TOO SMALL                 
!       PSIH(I)=AMIN1(PSIH(I),0.9*GZ1OZ0(I))                                     
!       PSIM(I)=AMIN1(PSIM(I),0.9*GZ1OZ0(I))                                     
        PSIH(I)=AMIN1(PSIH(I),0.9*GZ1OZ0(I))
        PSIM(I)=AMIN1(PSIM(I),0.9*GZ1OZ0(I))
        PSIH2(I)=AMIN1(PSIH2(I),0.9*GZ2OZ0(I))
        PSIM10(I)=AMIN1(PSIM10(I),0.9*GZ10OZ0(I))
! AHW: mods to compute ck, cd
        PSIH10(I)=AMIN1(PSIH10(I),0.9*GZ10OZ0(I))

        RMOL(I) = ZOL(I)/ZA(I)  

  320 CONTINUE                                                                   
!                                                                                
!-----COMPUTE THE FRICTIONAL VELOCITY:                                           
!     ZA(1982) EQS(2.60),(2.61).                                                 
!                                                                                
      DO 330 I=its,ite
        DTG=THX(I)-THGB(I)                                                   
        PSIX=GZ1OZ0(I)-PSIM(I)                                                   
        PSIX10=GZ10OZ0(I)-PSIM10(I)
!     LOWER LIMIT ADDED TO PREVENT LARGE FLHC IN SOIL MODEL
!     ACTIVATES IN UNSTABLE CONDITIONS WITH THIN LAYERS OR HIGH Z0
        PSIT=AMAX1(GZ1OZ0(I)-PSIH(I),2.)

        IF((XLAND(I)-1.5).GE.0)THEN                                            
          ZL=ZNT(I)                                                            
        ELSE                                                                     
          ZL=0.01                                                                
        ENDIF                                                                    
        PSIQ=ALOG(KARMAN*UST(I)*ZA(I)/XKA+ZA(I)/ZL)-PSIH(I)   
        PSIT2=GZ2OZ0(I)-PSIH2(I)                                     
        PSIQ2=ALOG(KARMAN*UST(I)*2./XKA+2./ZL)-PSIH2(I)                                   
! AHW: mods to compute ck, cd
        PSIQ10=ALOG(KARMAN*UST(I)*10./XKA+10./ZL)-PSIH10(I)
        IF ( PRESENT(ISFTCFLX) ) THEN
           IF ( ISFTCFLX.EQ.1 .AND. (XLAND(I)-1.5).GE.0. ) THEN
! v3.1
!             Z0Q = 1.e-4 + 1.e-3*(MAX(0.,UST(I)-1.))**2
! hfip1
!             Z0Q = 0.62*2.0E-5/UST(I) + 1.E-3*(MAX(0.,UST(I)-1.5))**2
! v3.2
              Z0Q = 1.e-4
              PSIQ=ALOG(ZA(I)/Z0Q)-PSIH(I)
              PSIT=PSIQ
              PSIQ2=ALOG(2./Z0Q)-PSIH2(I)
              PSIQ10=ALOG(10./Z0Q)-PSIH10(I)
              PSIT2=PSIQ2
           ENDIF
           IF ( ISFTCFLX.EQ.2 .AND. (XLAND(I)-1.5).GE.0. ) THEN
! AHW: Garratt formula: Calculate roughness Reynolds number
!        Kinematic viscosity of air (linear approc to
!                 temp dependence at sea levle)
              VISC=(1.32+0.009*(SCR3(I)-273.15))*1.E-5
!!            VISC=1.5E-5
              RESTAR=UST(I)*ZNT(I)/VISC
              RESTAR2=2.48*SQRT(SQRT(RESTAR))-2.
              PSIT=GZ1OZ0(I)-PSIH(I)+RESTAR2
              PSIQ=GZ1OZ0(I)-PSIH(I)+2.28*SQRT(SQRT(RESTAR))-2.
              PSIT2=GZ2OZ0(I)-PSIH2(I)+RESTAR2
              PSIQ2=GZ2OZ0(I)-PSIH2(I)+2.28*SQRT(SQRT(RESTAR))-2.
              PSIQ10=GZ10OZ0(I)-PSIH(I)+2.28*SQRT(SQRT(RESTAR))-2.
           ENDIF
        ENDIF
        IF(PRESENT(ck) .and. PRESENT(cd) .and. PRESENT(cka) .and. PRESENT(cda)) THEN
           Ck(I)=(karman/psix10)*(karman/psiq10)
           Cd(I)=(karman/psix10)*(karman/psix10)
           Cka(I)=(karman/psix)*(karman/psiq)
           Cda(I)=(karman/psix)*(karman/psix)
        ENDIF
        IF ( PRESENT(IZ0TLND) ) THEN
           IF ( IZ0TLND.EQ.1 .AND. (XLAND(I)-1.5).LE.0. ) THEN
              ZL=ZNT(I)
!             CZIL RELATED CHANGES FOR LAND
              VISC=(1.32+0.009*(SCR3(I)-273.15))*1.E-5
              RESTAR=UST(I)*ZL/VISC
!             Modify CZIL according to Chen & Zhang, 2009

              CZIL = 10.0 ** ( -0.40 * ( ZL / 0.07 ) )

              PSIT=GZ1OZ0(I)-PSIH(I)+CZIL*KARMAN*SQRT(RESTAR)
              PSIQ=GZ1OZ0(I)-PSIH(I)+CZIL*KARMAN*SQRT(RESTAR)
              PSIT2=GZ2OZ0(I)-PSIH2(I)+CZIL*KARMAN*SQRT(RESTAR)
              PSIQ2=GZ2OZ0(I)-PSIH2(I)+CZIL*KARMAN*SQRT(RESTAR)

           ENDIF
        ENDIF
! TO PREVENT OSCILLATIONS AVERAGE WITH OLD VALUE 
        UST(I)=0.5*UST(I)+0.5*KARMAN*WSPD(I)/PSIX                                             
! TKE coupling: compute ust without vconv for use in tke scheme
        WSPDI(I)=SQRT(UX(I)*UX(I)+VX(I)*VX(I))
        IF ( PRESENT(USTM) ) THEN
        USTM(I)=0.5*USTM(I)+0.5*KARMAN*WSPDI(I)/PSIX
        ENDIF
        U10(I)=UX(I)*PSIX10/PSIX                                    
        V10(I)=VX(I)*PSIX10/PSIX                                   
        TH2(I)=THGB(I)+DTG*PSIT2/PSIT                                
        Q2(I)=QSFC(I)+(QX(I)-QSFC(I))*PSIQ2/PSIQ                   
!        T2(I) = TH2(I)*(PSFC(I)/100.)**ROVCP                     
        T2(I) = TH2(I)*(PSFCPA(I)/P1000mb)**ROVCP                     
!       LATER Q2 WILL BE OVERWRITTEN FOR LAND POINTS IN SURFCE     
!       QA2(I,J) = Q2(I)                                         
!       UA10(I,J) = U10(I)                                      
!       VA10(I,J) = V10(I)                                     
!       write(*,1002)UST(I),KARMAN*WSPD(I),PSIX,KARMAN*WSPD(I)/PSIX
!                                                                                
        IF((XLAND(I)-1.5).LT.0.)THEN                                            
          UST(I)=AMAX1(UST(I),0.1)
        ENDIF                                                                    
        MOL(I)=KARMAN*DTG/PSIT/PRT                              
        DENOMQ(I)=PSIQ
        DENOMQ2(I)=PSIQ2
        DENOMT2(I)=PSIT2
  330 CONTINUE                                                                   
!                                                                                
  335 CONTINUE                                                                   
                                                                                  
!-----COMPUTE THE SURFACE SENSIBLE AND LATENT HEAT FLUXES:                       
                                                                                 
      DO i=its,ite
        QFX(i)=0.                                                              
        HFX(i)=0.                                                              
      ENDDO

      IF (ISFFLX.EQ.0) GOTO 410                                                
                                                                                 
!-----OVER WATER, ALTER ROUGHNESS LENGTH (ZNT) ACCORDING TO WIND (UST).          
                                                                                 
      DO 360 I=its,ite
        IF((XLAND(I)-1.5).GE.0)THEN                                            
          ZNT(I)=CZO*UST(I)*UST(I)/G+OZO                                   
! AHW: change roughness length, and hence the drag coefficients Ck and Cd
          IF ( PRESENT(ISFTCFLX) ) THEN
             IF ( ISFTCFLX.NE.0 ) THEN
!               ZNT(I)=10.*exp(-9.*UST(I)**(-.3333))
                ZNT(I)=10.*exp(-9.5*UST(I)**(-.3333))
                ZNT(I)=ZNT(I) + 0.11*1.5E-5/AMAX1(UST(I),0.01)
                ZNT(I)=MIN(ZNT(I),2.85e-3)
                ZNT(I)=MAX(ZNT(I),1.27e-7)
             ENDIF
          ENDIF
          ZL = ZNT(I)
        ELSE
          ZL = 0.01
        ENDIF                                                                    
        FLQC(I)=RHOX(I)*MAVAIL(I)*UST(I)*KARMAN/DENOMQ(I)
!       FLQC(I)=RHOX(I)*MAVAIL(I)*UST(I)*KARMAN/(   &
!               ALOG(KARMAN*UST(I)*ZA(I)/XKA+ZA(I)/ZL)-PSIH(I))
        DTTHX=ABS(THX(I)-THGB(I))                                            
        IF(DTTHX.GT.1.E-5)THEN                                                   
          FLHC(I)=CPM(I)*RHOX(I)*UST(I)*MOL(I)/(THX(I)-THGB(I))          
!         write(*,1001)FLHC(I),CPM(I),RHOX(I),UST(I),MOL(I),THX(I),THGB(I),I
 1001   format(f8.5,2x,f12.7,2x,f12.10,2x,f12.10,2x,f13.10,2x,f12.8,f12.8,2x,i3)
        ELSE                                                                     
          FLHC(I)=0.                                                             
        ENDIF                                                                    
  360 CONTINUE                                                                   

!                                                                                
!-----COMPUTE SURFACE MOIST FLUX:                                                
!                                                                                
!     IF(IDRY.EQ.1)GOTO 390                                                
!                                                                                
      DO 370 I=its,ite
        QFX(I)=FLQC(I)*(QSFC(I)-QX(I))                                     
        QFX(I)=AMAX1(QFX(I),0.)                                            
        LH(I)=XLV*QFX(I)
  370 CONTINUE                                                                 
                                                                                
!-----COMPUTE SURFACE HEAT FLUX:                                                 
!                                                                                
  390 CONTINUE                                                                 
      DO 400 I=its,ite
        IF(XLAND(I)-1.5.GT.0.)THEN                                           
          HFX(I)=FLHC(I)*(THGB(I)-THX(I))                                
!!!          IF ( PRESENT(ISFTCFLX) ) THEN
!!!             IF ( ISFTCFLX.NE.0 ) THEN
!!!! AHW: add dissipative heating term
!!!                HFX(I)=HFX(I)+RHOX(I)*USTM(I)*USTM(I)*WSPDI(I)
!!!             ENDIF
!!!          ENDIF
        ELSEIF(XLAND(I)-1.5.LT.0.)THEN                                       
          HFX(I)=FLHC(I)*(THGB(I)-THX(I))                                
          HFX(I)=AMAX1(HFX(I),-250.)                                       
        ENDIF                                                                  
  400 CONTINUE                                                                 
         
      DO I=its,ite
         IF((XLAND(I)-1.5).GE.0)THEN
           ZL=ZNT(I)
         ELSE
           ZL=0.01
         ENDIF
         CHS(I)=UST(I)*KARMAN/DENOMQ(I)
!        GZ2OZ0(I)=ALOG(2./ZNT(I))
!        PSIM2(I)=-10.*GZ2OZ0(I)
!        PSIM2(I)=AMAX1(PSIM2(I),-10.)
!        PSIH2(I)=PSIM2(I)
         CQS2(I)=UST(I)*KARMAN/DENOMQ2(I)
         CHS2(I)=UST(I)*KARMAN/DENOMT2(I)
      ENDDO
                                                                        
  410 CONTINUE                                                                   
!jdf
!     DO I=its,ite
!       IF(UST(I).GE.0.1) THEN
!         RMOL(I)=RMOL(I)*(-FLHC(I))/(UST(I)*UST(I)*UST(I))
!       ELSE
!         RMOL(I)=RMOL(I)*(-FLHC(I))/(0.1*0.1*0.1)
!       ENDIF
!     ENDDO
!jdf

!                                                                                
   END SUBROUTINE SFCLAY1D

!====================================================================
!!!   SUBROUTINE sfclayinit( allowed_to_read )         
   SUBROUTINE sfclayinit( )

!!!   LOGICAL , INTENT(IN)      ::      allowed_to_read
   INTEGER                   ::      N
   REAL                      ::      ZOLN,X,Y

   DO N=0,1000
      ZOLN=-FLOAT(N)*0.01
      X=(1-16.*ZOLN)**0.25
      PSIMTB(N)=2*ALOG(0.5*(1+X))+ALOG(0.5*(1+X*X))- &
                2.*ATAN(X)+2.*ATAN(1.)
      Y=(1-16*ZOLN)**0.5
      PSIHTB(N)=2*ALOG(0.5*(1+Y))
   ENDDO

   END SUBROUTINE sfclayinit

!-------------------------------------------------------------------          

END MODULE module_sf_sfclay
slab.F/         1298670057  19071 8000  100644  28086     `
!WRF:MODEL_LAYER:PHYSICS
!
MODULE module_sf_slab

   !---SPECIFY CONSTANTS AND LAYERS FOR SOIL MODEL
   !---SOIL DIFFUSION CONSTANT SET (M^2/S)

   REAL, PARAMETER :: DIFSL=5.e-7

   !---FACTOR TO MAKE SOIL STEP MORE CONSERVATIVE

   REAL , PARAMETER :: SOILFAC=1.25

CONTAINS

!----------------------------------------------------------------
   SUBROUTINE SLAB(T3D,QV3D,P3D,FLHC,FLQC,                      &
                   PSFC,XLAND,TMN,HFX,QFX,LH,TSK,QSFC,CHKLOWQ,  &
                   GSW,GLW,CAPG,THC,SNOWC,EMISS,MAVAIL,         &
                   DELTSM,ROVCP,XLV,DTMIN,IFSNOW,               &
                   SVP1,SVP2,SVP3,SVPT0,EP2,                    &
                   KARMAN,EOMEG,STBOLT,                         &
                   TSLB,ZS,DZS,num_soil_layers,radiation,       &
                   P1000mb,                                     &
                   ids,ide, jds,jde, kds,kde,                   &
                   ims,ime, jms,jme, kms,kme,                   &
                   its,ite, jts,jte, kts,kte                    )
!----------------------------------------------------------------
    IMPLICIT NONE
!----------------------------------------------------------------
!                                                                        
!     SUBROUTINE SLAB CALCULATES THE GROUND TEMPERATURE TENDENCY 
!     ACCORDING TO THE RESIDUAL OF THE SURFACE ENERGY BUDGET           
!     (BLACKADAR, 1978B).                                              
!                                                                      
!     CHANGES:                                                         
!          FOR SOIL SUB-TIMESTEPS UPDATE SURFACE HFX AND QFX AS TG     
!          CHANGES TO PREVENT POSSIBLE INSTABILITY FOR LONG MODEL      
!          STEPS (DT > ~200 SEC).                                      
!                                                                      
!          PUT SNOW COVER CHECK ON SOIL SUB-TIMESTEPS                  
!                                                                      
!          MAKE UPPER LIMIT ON SOIL SUB-STEP LENGTH MORE CONSERVATIVE  
!                                                                      
!----------------------------------------------------------------          
!-- T3D         temperature (K)
!-- QV3D        3D water vapor mixing ratio (Kg/Kg)
!-- P3D         3D pressure (Pa)
!-- FLHC        exchange coefficient for heat (m/s)
!-- FLQC        exchange coefficient for moisture (m/s)
!-- PSFC        surface pressure (Pa)
!-- XLAND       land mask (1 for land, 2 for water)
!-- TMN         soil temperature at lower boundary (K)
!-- HFX         upward heat flux at the surface (W/m^2)
!-- QFX         upward moisture flux at the surface (kg/m^2/s)
!-- LH          latent heat flux at the surface (W/m^2)
!-- TSK         surface temperature (K)
!-- GSW         downward short wave flux at ground surface (W/m^2)      
!-- GLW         downward long wave flux at ground surface (W/m^2)
!-- CAPG        heat capacity for soil (J/K/m^3)
!-- THC         thermal inertia (Cal/cm/K/s^0.5)
!-- SNOWC       flag indicating snow coverage (1 for snow cover)
!-- EMISS       surface emissivity (between 0 and 1)
!-- DELTSM      time step (second)
!-- ROVCP       R/CP
!-- XLV         latent heat of melting (J/kg)
!-- DTMIN       time step (minute)
!-- IFSNOW      ifsnow=1 for snow-cover effects
!-- SVP1        constant for saturation vapor pressure (kPa)
!-- SVP2        constant for saturation vapor pressure (dimensionless)
!-- SVP3        constant for saturation vapor pressure (K)
!-- SVPT0       constant for saturation vapor pressure (K)
!-- EP1         constant for virtual temperature (R_v/R_d - 1) (dimensionless)
!-- EP2         constant for specific humidity calculation 
!               (R_d/R_v) (dimensionless)
!-- KARMAN      Von Karman constant
!-- EOMEG       angular velocity of earth's rotation (rad/s)
!-- STBOLT      Stefan-Boltzmann constant (W/m^2/K^4)
!-- TSLB        soil temperature in 5-layer model
!-- ZS          depths of centers of soil layers
!-- DZS         thicknesses of soil layers
!-- num_soil_layers   the number of soil layers
!-- ids         start index for i in domain
!-- ide         end index for i in domain
!-- jds         start index for j in domain
!-- jde         end index for j in domain
!-- kds         start index for k in domain
!-- kde         end index for k in domain
!-- ims         start index for i in memory
!-- ime         end index for i in memory
!-- jms         start index for j in memory
!-- jme         end index for j in memory
!-- kms         start index for k in memory
!-- kme         end index for k in memory
!-- its         start index for i in tile
!-- ite         end index for i in tile
!-- jts         start index for j in tile
!-- jte         end index for j in tile
!-- kts         start index for k in tile
!-- kte         end index for k in tile
!----------------------------------------------------------------
   INTEGER,  INTENT(IN   )   ::     ids,ide, jds,jde, kds,kde,  &
                                    ims,ime, jms,jme, kms,kme,  &
                                    its,ite, jts,jte, kts,kte

   INTEGER, INTENT(IN)       ::     num_soil_layers
   LOGICAL, INTENT(IN)       ::     radiation

   INTEGER,  INTENT(IN   )   ::     IFSNOW

!
   REAL,     INTENT(IN   )   ::     DTMIN,XLV,ROVCP,DELTSM

   REAL,     INTENT(IN )     ::     SVP1,SVP2,SVP3,SVPT0
   REAL,     INTENT(IN )     ::     EP2,KARMAN,EOMEG,STBOLT
   REAL,     INTENT(IN )     ::     P1000mb

   REAL,     DIMENSION( ims:ime , jms:jme , 1:num_soil_layers ), &
             INTENT(INOUT)   :: TSLB

   REAL,     DIMENSION(1:num_soil_layers), INTENT(IN)::ZS,DZS

   REAL,    DIMENSION( ims:ime, jms:jme, kms:kme )            , &
            INTENT(IN   )    ::                           QV3D, &
                                                           P3D, &
                                                           T3D
!
   REAL,    DIMENSION( ims:ime, jms:jme )                     , &
            INTENT(IN   )    ::                          SNOWC, &
                                                         XLAND, &
                                                         EMISS, &
                                                        MAVAIL, &
                                                           TMN, &
                                                           GSW, &
                                                           GLW, &
                                                           THC

!CHKLOWQ is declared as memory size
!
   REAL,    DIMENSION( ims:ime, jms:jme )                     , &
            INTENT(INOUT)    ::                            HFX, &
                                                           QFX, &
                                                            LH, &
                                                          CAPG, &
                                                           TSK, &
                                                          QSFC, &
                                                       CHKLOWQ

   REAL,     DIMENSION( ims:ime, jms:jme )                    , &
             INTENT(IN   )               ::               PSFC
!
   REAL,    DIMENSION( ims:ime, jms:jme ), INTENT(INOUT) ::     &
                                                          FLHC, &
                                                          FLQC

! LOCAL VARS

   REAL,     DIMENSION( its:ite ) ::                      QV1D, &
                                                           P1D, &
                                                           T1D
   REAL,     DIMENSION( its:ite , 1:num_soil_layers ) :: TSLB2D
   INTEGER ::  I,J,n

!$omp parallel do default(shared)   &
!$omp private(i,j,n,t1d,qv1d,p1d,tslb2d)
   DO J=jts,jte

      DO i=its,ite
         T1D(i) =T3D(i,j,1)
         QV1D(i)=QV3D(i,j,1)
         P1D(i) =P3D(i,j,1)
         do n=1,num_soil_layers
           TSLB2D(i,n) = TSLB(i,j,n)
         enddo
      ENDDO

! the indices to the PSFC argument in the following call look
! wrong; however, it is correct to call with its (and not ims)
! because of the way PSFC is defined in SLAB1D. Whether *that*
! is a good idea or not, this commenter cannot comment. JM

      CALL SLAB1D(J,T1D,QV1D,P1D,FLHC(ims,j),FLQC(ims,j),       &
           PSFC(ims,j),XLAND(ims,j),TMN(ims,j),HFX(ims,j),      &
           QFX(ims,j),TSK(ims,j),QSFC(ims,j),CHKLOWQ(ims,j),    &
           LH(ims,j),GSW(ims,j),GLW(ims,j),                     &
           CAPG(ims,j),THC(ims,j),SNOWC(ims,j),EMISS(ims,j),    &
           MAVAIL(ims,j),DELTSM,ROVCP,XLV,DTMIN,IFSNOW,         &
           SVP1,SVP2,SVP3,SVPT0,EP2,KARMAN,EOMEG,STBOLT,        &
           TSLB2D       ,ZS,DZS,num_soil_layers,radiation,      &
           P1000mb,                                             &
           ids,ide, jds,jde, kds,kde,                           &
           ims,ime, jms,jme, kms,kme,                           &
           its,ite, jts,jte, kts,kte                            )

      DO i=its,ite
         do n=1,num_soil_layers
           TSLB(i,j,n) = TSLB2D(i,n)
         enddo
      ENDDO

   ENDDO

   END SUBROUTINE SLAB

!----------------------------------------------------------------
   SUBROUTINE SLAB1D(J,T1D,QV1D,P1D,FLHC,FLQC,                  &
                   PSFCPA,XLAND,TMN,HFX,QFX,TSK,QSFC,CHKLOWQ,   &
                   LH,GSW,GLW,CAPG,THC,SNOWC,EMISS,MAVAIL,      &
                   DELTSM,ROVCP,XLV,DTMIN,IFSNOW,               &
                   SVP1,SVP2,SVP3,SVPT0,EP2,                    &
                   KARMAN,EOMEG,STBOLT,                         &
                   TSLB2D,ZS,DZS,num_soil_layers,radiation,     &
                   P1000mb,                                     &
                   ids,ide, jds,jde, kds,kde,                   &
                   ims,ime, jms,jme, kms,kme,                   &
                   its,ite, jts,jte, kts,kte                    )
!----------------------------------------------------------------
    IMPLICIT NONE
!----------------------------------------------------------------
!                                                                        
!     SUBROUTINE SLAB CALCULATES THE GROUND TEMPERATURE TENDENCY 
!     ACCORDING TO THE RESIDUAL OF THE SURFACE ENERGY BUDGET           
!     (BLACKADAR, 1978B).                                              
!                                                                      
!     CHANGES:                                                         
!          FOR SOIL SUB-TIMESTEPS UPDATE SURFACE HFX AND QFX AS TG     
!          CHANGES TO PREVENT POSSIBLE INSTABILITY FOR LONG MODEL      
!          STEPS (DT > ~200 SEC).                                      
!                                                                      
!          PUT SNOW COVER CHECK ON SOIL SUB-TIMESTEPS                  
!                                                                      
!          MAKE UPPER LIMIT ON SOIL SUB-STEP LENGTH MORE CONSERVATIVE  
!                                                                      
!----------------------------------------------------------------          

   INTEGER,  INTENT(IN   )   ::     ids,ide, jds,jde, kds,kde,  &
                                    ims,ime, jms,jme, kms,kme,  &
                                    its,ite, jts,jte, kts,kte,J 

   INTEGER , INTENT(IN)      ::     num_soil_layers
   LOGICAL,  INTENT(IN   )   ::     radiation

   INTEGER,  INTENT(IN   )   ::     IFSNOW
!
   REAL,     INTENT(IN   )   ::     DTMIN,XLV,ROVCP,DELTSM

   REAL,     INTENT(IN )     ::     SVP1,SVP2,SVP3,SVPT0
   REAL,     INTENT(IN )     ::     EP2,KARMAN,EOMEG,STBOLT
   REAL,     INTENT(IN )     ::     P1000mb

   REAL,     DIMENSION( its:ite , 1:num_soil_layers ),          &
             INTENT(INOUT)   :: TSLB2D

   REAL,     DIMENSION(1:num_soil_layers), INTENT(IN)::ZS,DZS

!
   REAL,    DIMENSION( ims:ime )                              , &
            INTENT(INOUT)    ::                            HFX, &
                                                           QFX, &
                                                            LH, &
                                                          CAPG, &
                                                           TSK, &
                                                          QSFC, &
                                                       CHKLOWQ
!
   REAL,    DIMENSION( ims:ime )                              , &
            INTENT(IN   )    ::                          SNOWC, &
                                                         XLAND, &
                                                         EMISS, &
                                                        MAVAIL, &
                                                           TMN, &
                                                           GSW, &
                                                           GLW, &
                                                           THC
!
   REAL,    DIMENSION( its:ite )                              , &
            INTENT(IN   )    ::                           QV1D, &
                                                           P1D, &
                                                           T1D
!
   REAL,     DIMENSION( ims:ite )                             , &
             INTENT(IN   )               ::             PSFCPA

!
   REAL,    DIMENSION( ims:ime ), INTENT(INOUT) ::              &
                                                          FLHC, &
                                                          FLQC
! LOCAL VARS

   REAL,    DIMENSION( its:ite )          ::              PSFC

   REAL,    DIMENSION( its:ite )          ::                    &
                                                           THX, &
                                                            QX, &
                                                          SCR3 

   REAL,    DIMENSION( its:ite )          ::            DTHGDT, &
                                                           TG0, &
                                                         THTMN, &
                                                          XLD1, &
                                                         TSCVN, &
                                                          OLTG, &
                                                        UPFLUX, &
                                                            HM, &
                                                          RNET, &
                                                         XINET, &
                                                            QS, &
                                                         DTSDT
!
   REAL, DIMENSION( its:ite, num_soil_layers )        :: FLUX
!
   INTEGER :: I,K,NSOIL,ITSOIL,L,NK,RADSWTCH
   REAL    :: PS,PS1,XLDCOL,TSKX,RNSOIL,RHOG1,RHOG2,RHOG3,LAMDAG
   REAL    :: THG,ESG,QSG,HFXT,QFXT,CS,CSW,LAMG(4),THCON,PL
 
!----------------------------------------------------------------------          
!-----DETERMINE IF ANY POINTS IN COLUMN ARE LAND (RATHER THAN OCEAN)             
!       POINTS.  IF NOT, SKIP DOWN TO THE PRINT STATEMENTS SINCE OCEAN           
!       SURFACE TEMPERATURES ARE NOT ALLOWED TO CHANGE.                          
!                                                                                
! from sfcrad   
!----------------------------------------------------------------------
   DATA CSW/4.183E6/
   DATA LAMG/1.407E-8, -1.455E-5, 6.290E-3, 0.16857/

   DO i=its,ite
! in cmb
      PSFC(I)=PSFCPA(I)/1000.
   ENDDO


      DO I=its,ite
! PL cmb
         PL=P1D(I)/1000.
         SCR3(I)=T1D(I)
!         THCON=(100./PL)**ROVCP
         THCON=(P1000mb*0.001/PL)**ROVCP
         THX(I)=SCR3(I)*THCON
         QX(I)=0.
      ENDDO

!     IF(IDRY.EQ.1) GOTO 81
      DO I=its,ite
         QX(I)=QV1D(I)
      ENDDO
   81 CONTINUE

!
!-----THE SLAB THERMAL CAPACITY CAPG(I) ARE DEPENDENT ON:
!     THC(I) - SOIL THERMAL INERTIAL, ONLY.
!
      DO I=its,ite
         CAPG(I)=3.298E6*THC(I)
         IF(num_soil_layers .gt. 1)THEN

! CAPG REPRESENTS SOIL HEAT CAPACITY (J/K/M^3) WHEN DIFSL=5.E-7 (M^2/S)
! TO GIVE A CORRECT THERMAL INERTIA (=CAPG*DIFSL^0.5)

            CAPG(I)=5.9114E7*THC(I)
         ENDIF
      ENDDO
!        
      XLDCOL=2.0                                                                 
      DO 10 I=its,ite
        XLDCOL=AMIN1(XLDCOL,XLAND(I))                                          
   10 CONTINUE                                                                   
!                                                                                
      IF(XLDCOL.GT.1.5)GOTO 90                                                   
!                                                                                
!                                                                                
!-----CONVERT SLAB TEMPERATURE TO POTENTIAL TEMPERATURE AND                      
!     SET XLD1(I) = 0. FOR OCEAN POINTS:                                         
!                                                                                
!                                                                                
      DO 20 I=its,ite
        IF((XLAND(I)-1.5).GE.0)THEN                                            
          XLD1(I)=0.                                                             
        ELSE                                                                     
          XLD1(I)=1.                                                             
        ENDIF                                                                    
   20 CONTINUE                                                                   
!                                                                                
!-----CONVERT 'TSK(THETAG)' TO 'TG' FOR 'IUP' CALCULATION ....                   
!       IF WE ARE USING THE BLACKADAR MULTI-LEVEL (HIGH-RESOLUTION)              
!       PBL MODEL                                                                
!                                                                                
      DO 50 I=its,ite
        IF(XLD1(I).LT.0.5)GOTO 50                                                

! PS cmb
        PS=PSFC(I)

! TSK is Temperature at gound sfc
!       TG0(I)=TSK(I)*(PS*0.01)**ROVCP                                         
        TG0(I)=TSK(I)
   50 CONTINUE                                                                   
!                                                                                
!-----COMPUTE THE SURFACE ENERGY BUDGET:                                         
!                                                                                
!     IF(ISOIL.EQ.1)NSOIL=1                                                      
      IF(num_soil_layers .gt. 1)NSOIL=1                                                      


      IF (radiation) then
        RADSWTCH=1
      ELSE
        RADSWTCH=0
      ENDIF

      DO 70 I=its,ite
        IF(XLD1(I).LT.0.5)GOTO 70
!        OLTG(I)=TSK(I)*(100./PSFC(I))**ROVCP
        OLTG(I)=TSK(I)*(P1000mb*0.001/PSFC(I))**ROVCP
        UPFLUX(I)=RADSWTCH*STBOLT*TG0(I)**4                            
        XINET(I)=EMISS(I)*(GLW(I)-UPFLUX(I))    
        RNET(I)=GSW(I)+XINET(I)                                                
        HM(I)=1.18*EOMEG*(TG0(I)-TMN(I))                                       
!       MOISTURE FLUX CALCULATED HERE (OVERWRITES SFC LAYER VALUE FOR LAND)
                ESG=SVP1*EXP(SVP2*(TG0(I)-SVPT0)/(TG0(I)-SVP3))
                QSG=EP2*ESG/(PSFC(I)-ESG)
                THG=TSK(I)*(100./PSFC(I))**ROVCP
                HFX(I)=FLHC(I)*(THG-THX(I))
                QFX(I)=FLQC(I)*(QSG-QX(I))
                LH(I)=QFX(I)*XLV
        QS(I)=HFX(I)+QFX(I)*XLV                                
!       IF(ISOIL.EQ.0)THEN                                                       
        IF(num_soil_layers .EQ. 1)THEN                                                       
          DTHGDT(I)=(RNET(I)-QS(I))/CAPG(I)-HM(I)                              
        ELSE
          DTHGDT(I)=0.                                                           
        ENDIF                                                                    
   70 CONTINUE                                                                   
!     IF(ISOIL.EQ.1)THEN                                                         
      IF(num_soil_layers .gt. 1)THEN                                                         
        NSOIL=1+IFIX(SOILFAC*4*DIFSL/DZS(1)*DELTSM/DZS(1))   
        RNSOIL=1./FLOAT(NSOIL)                                                   
!                                                                                
!     SOIL SUB-TIMESTEP                                                          
!                                                                                
        DO ITSOIL=1,NSOIL                                                        
          DO I=its,ite
             DO L=1,num_soil_layers-1
              IF(XLD1(I).LT.0.5)GOTO 75                                          
              IF(L.EQ.1.AND.ITSOIL.GT.1)THEN                                     
!                PS1=(PSFC(I)*0.01)**ROVCP    
                PS1=(PSFCPA(I)/P1000mb)**ROVCP    

! for rk scheme A and B are the same
                PS=PSFC(I)
                THG=TSLB2D(I,1)/PS1                                              
                ESG=SVP1*EXP(SVP2*(TSLB2D(I,1)-SVPT0)/(TSLB2D(I,1) & 
                    -SVP3))                                                      
                QSG=EP2*ESG/(PS-ESG)                                             
!     UPDATE FLUXES FOR NEW GROUND TEMPERATURE                                   
                HFXT=FLHC(I)*(THG-THX(I))                                     
                QFXT=FLQC(I)*(QSG-QX(I))
                QS(I)=HFXT+QFXT*XLV                                
!     SUM HFX AND QFX OVER SOIL TIMESTEPS                                        
                HFX(I)=HFX(I)+HFXT                                           
                QFX(I)=QFX(I)+QFXT                                           
              ENDIF                                                              
              FLUX(I,1)=RNET(I)-QS(I)                                            
              FLUX(I,L+1)=-DIFSL*CAPG(I)*(TSLB2D(I,L+1)-TSLB2D(I,L))/( & 
                          ZS(L+1)-ZS(L))                                         
              DTSDT(I)=-(FLUX(I,L+1)-FLUX(I,L))/(DZS(L)*CAPG(I))               
              TSLB2D(I,L)=TSLB2D(I,L)+DTSDT(I)*DELTSM*RNSOIL                     
              IF(IFSNOW.EQ.1.AND.L.EQ.1)THEN                              
                IF((SNOWC(I).GT.0..AND.TSLB2D(I,1).GT.273.16))THEN             
                  TSLB2D(I,1)=273.16                                             
                ENDIF                                                            
              ENDIF                                                              
              IF(L.EQ.1)DTHGDT(I)=DTHGDT(I)+RNSOIL*DTSDT(I)                      
              IF(ITSOIL.EQ.NSOIL.AND.L.EQ.1)THEN                                 
!     AVERAGE HFX AND QFX OVER SOIL TIMESTEPS FOR OUTPUT TO PBL                  
                HFX(I)=HFX(I)*RNSOIL                                         
                QFX(I)=QFX(I)*RNSOIL                                         
                LH(I)=QFX(I)*XLV
              ENDIF                                                              
   75         CONTINUE                                                           
            ENDDO                                                                
          ENDDO                                                                  
        ENDDO                                                                    
      ENDIF                                                                      
!                                                                                
      DO 80 I=its,ite
        IF(XLD1(I).LT.0.5) GOTO 80                                                
        TSKX=TG0(I)+DELTSM*DTHGDT(I)                                             

! TSK is temperature
!       TSK(I)=TSKX*(100./PS1)**ROVCP                                          
        TSK(I)=TSKX
   80 CONTINUE                                                                   

!                                                                                
!-----MODIFY THE THE GROUND TEMPERATURE IF THE SNOW COVER EFFECTS ARE            
!     CONSIDERED: LIMIT THE GROUND TEMPERATURE UNDER 0 C.                        
!                                                                                
      IF(IFSNOW.EQ.0)GOTO 90                                              
      DO 85 I=its,ite
        IF(XLD1(I).LT.0.5)GOTO 85                                                
!       PS1=(PSFC(I)*0.01)**ROVCP             
!       TSCVN(I)=TSK(I)*PS1                                            
        TSCVN(I)=TSK(I)
        IF((SNOWC(I).GT.0..AND.TSCVN(I).GT.273.16))THEN                        
          TSCVN(I)=273.16                                                        
        ELSE                                                                     
          TSCVN(I)=TSCVN(I)                                                      
        ENDIF                                                                    
!       TSK(I)=TSCVN(I)/PS1                                                    
        TSK(I)=TSCVN(I)
   85 CONTINUE                                                                   
!                                                                                
   90 CONTINUE                                                                   
      DO I=its,ite
! QSFC and CHKLOWQ needed by Eta PBL
        QSFC(I)=QX(I)+QFX(I)/FLQC(I)
        CHKLOWQ(I)=MAVAIL(I)
      ENDDO
!                                                                                
  140 CONTINUE                                                                   

   END SUBROUTINE SLAB1D

!================================================================
   SUBROUTINE slabinit(TSK,TMN,                                 &
                       TSLB,ZS,DZS,num_soil_layers,             &
                       allowed_to_read, start_of_simulation,    &
                       ids,ide, jds,jde, kds,kde,               &
                       ims,ime, jms,jme, kms,kme,               &
                       its,ite, jts,jte, kts,kte                )
!----------------------------------------------------------------
   IMPLICIT NONE
!----------------------------------------------------------------
   LOGICAL , INTENT(IN)      ::      allowed_to_read
   LOGICAL , INTENT(IN)      ::      start_of_simulation
   INTEGER, INTENT(IN   )    ::      ids,ide, jds,jde, kds,kde, &
                                     ims,ime, jms,jme, kms,kme, &
                                     its,ite, jts,jte, kts,kte

   INTEGER, INTENT(IN   )    ::      num_soil_layers
!   
   REAL,     DIMENSION( ims:ime , 1:num_soil_layers , jms:jme ), INTENT(INOUT) :: TSLB

   REAL,     DIMENSION(1:num_soil_layers), INTENT(IN)  ::  ZS,DZS

   REAL,    DIMENSION( ims:ime, jms:jme )                     , &
            INTENT(IN)    ::                               TSK, &
                                                           TMN

!  LOCAR VAR

   INTEGER                   ::      L,J,I,itf,jtf
   CHARACTER*1024 message

!----------------------------------------------------------------
 
   itf=min0(ite,ide-1)
   jtf=min0(jte,jde-1)

   END SUBROUTINE slabinit
!-------------------------------------------------------------------          

END MODULE module_sf_slab
orfmod.F/       1298670057  19071 8000  100644  2899      `
module orfiomod

implicit none
!ORF only ranks and comms are needed here
!Groups do not need to be here, can be defined
!in param.F only
integer &
        niv,njv,nkv,ibv,iev,jbv,jev,kbv,kev,                            &
        myroot,mysubgroupcomm,mcmrootcomm, mcmrootrank, &
        mybxgroupcomm, mytxgroupcomm,                                   &
        mybxgrouprank, mytxgrouprank,                                   &
        mylygroupcomm, myrygroupcomm,                                   &
        mylygrouprank, myrygrouprank,                                   &
        mybxgroup,mytxgroup,mylygroup,myrygroup,                        &
        cores_per_mcm,corex,corey,mymcmi,mymcmj,mymcmid,nmcm,           &
        x1dgroup,x1drank,x1dcomm,x1dtype, &
        y1dgroup,y1drank,y1dcomm,y1dtype, &
        rootonlyrank, rootonlygroup, &
        mygroupoffseti,mygroupoffsetj, &
        myfulloffseti,myfulloffsetj, &
        mygroup,mcmrootgroup,                       &
        mysubgrouprank,mygroupi,mygroupj,                                    &
        corextype,coreytype,corexytype,corexyztype,                         &
        corexztype,coreyztype, &
        corexyzutype,corexyzvtype,corexyzwtype,                            &
        ioid,iocomm,iorank,                                             &
        iomyi,iomyj,ionumi,ionumj,ionodex,ionodey,                      &
        iox0,iox1,ioy0,ioy1

character(len=100) filedir
integer, parameter :: ctrlunit = 77
integer :: ctrldropslice,ctrldrophist,ctrldroprestart,ctrlexit
logical :: wr2d,wr3d
logical, parameter :: iodebug = .false.
logical, parameter :: iodebug2 = .false.


contains

subroutine reset_control_file
         open(unit=ctrlunit,file='cm1control.txt',status='unknown')
         write(ctrlunit,*) "CM1 CONTROL FILE. Changing this file will signal to CM1 that you want to"
         write(ctrlunit,*) "do something including: (1) drop a slice file (2) drop a full history"
         write(ctrlunit,*) "(3) drop a restart file (4) exit gracefully. You can mix and match."
         write(ctrlunit,*) "File is read at the beginning of each time step. 0=no 1=yes"
         write(ctrlunit,*) "---slice---history---restart---exit---"
         write(ctrlunit,*) "     0        0         0       0"
         close(ctrlunit)
end subroutine reset_control_file

subroutine read_control_file
         open(unit=ctrlunit,file='cm1control.txt',status='old')
         read(ctrlunit,*)
         read(ctrlunit,*)
         read(ctrlunit,*)
         read(ctrlunit,*)
         read(ctrlunit,*)
         read(ctrlunit,*) ctrldropslice,ctrldrophist,ctrldroprestart,ctrlexit
         close(ctrlunit)
end subroutine read_control_file

end module orfiomod

module orfswathsmod
      integer slcfrq,swindex
      integer, parameter :: norfswaths = 5
      real, dimension (:,:,:,:), allocatable :: orfswaths
end module orfswathsmod

oml.F/          1298670057  19071 8000  100644  11886     `
!WRF:MODEL_LAYER:PHYSICS
!
MODULE module_sf_oml

CONTAINS

!----------------------------------------------------------------
   SUBROUTINE OCEANML(tml,t0ml,hml,h0ml,huml,hvml,ust,u_phy,v_phy, &
                      tmoml,f,g,oml_gamma,                         &
                      XLAND,HFX,LH,TSK,GSW,GLW,EMISS,              &
                      DELTSM,STBOLT,                               &
                      ids,ide, jds,jde, kds,kde,                   &
                      ims,ime, jms,jme, kms,kme,                   &
                      its,ite, jts,jte, kts,kte                    )

!----------------------------------------------------------------
   IMPLICIT NONE
!----------------------------------------------------------------
!
!  SUBROUTINE OCEANML CALCULATES THE SEA SURFACE TEMPERATURE (TSK)
!  FROM A SIMPLE OCEAN MIXED LAYER MODEL BASED ON
!  (Pollard, Rhines and Thompson (1973).
!
!-- TML         ocean mixed layer temperature (K)
!-- T0ML        ocean mixed layer temperature (K) at initial time
!-- TMOML       top 200 m ocean mean temperature (K) at initial time
!-- HML         ocean mixed layer depth (m)
!-- H0ML        ocean mixed layer depth (m) at initial time
!-- HUML        ocean mixed layer u component of wind
!-- HVML        ocean mixed layer v component of wind
!-- OML_GAMMA   deep water lapse rate (K m-1)
!-- UAIR,VAIR   lowest model level wind component
!-- UST         frictional velocity
!-- HFX         upward heat flux at the surface (W/m^2)
!-- LH          latent heat flux at the surface (W/m^2)
!-- TSK         surface temperature (K)
!-- GSW         downward short wave flux at ground surface (W/m^2)
!-- GLW         downward long wave flux at ground surface (W/m^2)
!-- EMISS       emissivity of the surface
!-- XLAND       land mask (1 for land, 2 for water)
!-- STBOLT      Stefan-Boltzmann constant (W/m^2/K^4)
!-- F           Coriolis parameter
!-- DT          time step (second)
!-- G           acceleration due to gravity

   INTEGER,  INTENT(IN   )   ::     ids,ide, jds,jde, kds,kde,  &
                                    ims,ime, jms,jme, kms,kme,  &
                                    its,ite, jts,jte, kts,kte

   REAL,     INTENT(IN   )   ::     DELTSM, STBOLT

   REAL,    DIMENSION( ims:ime, jms:jme )                     , &
            INTENT(IN   )    ::                          EMISS, &
                                                         XLAND, &
                                                           GSW, &
                                                           GLW, &
                                                           HFX, &
                                                            LH

   REAL,    DIMENSION( ims:ime, jms:jme )                     , &
            INTENT(INOUT)    ::                            TSK

   REAL,    DIMENSION( ims:ime, jms:jme ), INTENT(INOUT) ::     &
                                    TML,T0ML,HML,H0ML,HUML,HVML

   REAL,    DIMENSION( ims:ime, jms:jme, kms:kme ), INTENT(IN   ) ::     &
                                             U_PHY,V_PHY

   REAL,    DIMENSION( ims:ime, jms:jme ), INTENT(IN   ) ::     &
                                             UST, F, TMOML

   REAL,    INTENT(IN   )   ::     G
   REAL,    INTENT(IN   )   ::     OML_GAMMA

! LOCAL VARS

   INTEGER ::  I,J

   DO J=jts,jte

!!!      CALL wrf_debug( 100, 'Call OML' )
         DO i=its,ite
            IF (XLAND(I,J).GT.1.5) THEN
               CALL OML1D(I,J,TML(i,j),T0ML(i,j),HML(i,j),H0ML(i,j),           &
                          HUML(i,j),HVML(i,j),TSK(i,j),HFX(i,j),               &
                          LH(i,j),GSW(i,j),GLW(i,j),TMOML(i,j),                &
                          U_PHY(i,j,kts),V_PHY(i,j,kts),UST(i,j),F(i,j),       &
                          EMISS(i,j),STBOLT,G,DELTSM,OML_GAMMA,                &
                          ids,ide, jds,jde, kds,kde,                           &
                          ims,ime, jms,jme, kms,kme,                           &
                          its,ite, jts,jte, kts,kte                            )
            ENDIF
         ENDDO

   ENDDO

   END SUBROUTINE OCEANML

!----------------------------------------------------------------
   SUBROUTINE OML1D(I,J,TML,T0ML,H,H0,HUML,                              &
                    HVML,TSK,HFX,                                        &
                    LH,GSW,GLW,TMOML,                                    &
                    UAIR,VAIR,UST,F,EMISS,STBOLT,G,DT,OML_GAMMA,         &
                    ids,ide, jds,jde, kds,kde,                           &
                    ims,ime, jms,jme, kms,kme,                           &
                    its,ite, jts,jte, kts,kte                            )

!----------------------------------------------------------------
   IMPLICIT NONE
!----------------------------------------------------------------
!
!  SUBROUTINE OCEANML CALCULATES THE SEA SURFACE TEMPERATURE (TSK) 
!  FROM A SIMPLE OCEAN MIXED LAYER MODEL BASED ON 
!  (Pollard, Rhines and Thompson (1973).
!
!-- TML         ocean mixed layer temperature (K)
!-- T0ML        ocean mixed layer temperature (K) at initial time
!-- TMOML       top 200 m ocean mean temperature (K) at initial time
!-- H           ocean mixed layer depth (m)
!-- H0          ocean mixed layer depth (m) at initial time
!-- HUML        ocean mixed layer u component of wind
!-- HVML        ocean mixed layer v component of wind
!-- OML_GAMMA   deep water lapse rate (K m-1)
!-- OMLCALL     whether to call oml model
!-- UAIR,VAIR   lowest model level wind component
!-- UST         frictional velocity
!-- HFX         upward heat flux at the surface (W/m^2)
!-- LH          latent heat flux at the surface (W/m^2)
!-- TSK         surface temperature (K)
!-- GSW         downward short wave flux at ground surface (W/m^2)
!-- GLW         downward long wave flux at ground surface (W/m^2)
!-- EMISS       emissivity of the surface
!-- STBOLT      Stefan-Boltzmann constant (W/m^2/K^4)
!-- F           Coriolis parameter
!-- DT          time step (second)
!-- G           acceleration due to gravity
!
!----------------------------------------------------------------
   INTEGER, INTENT(IN   )    ::      I, J
   INTEGER, INTENT(IN   )    ::      ids,ide, jds,jde, kds,kde, &
                                     ims,ime, jms,jme, kms,kme, &
                                     its,ite, jts,jte, kts,kte

   REAL,    INTENT(INOUT)    :: TML, H, H0, HUML, HVML, TSK

   REAL,    INTENT(IN   )    :: T0ML, HFX, LH, GSW, GLW,        &
                                UAIR, VAIR, UST, F, EMISS, TMOML

   REAL,    INTENT(IN) :: STBOLT, G, DT, OML_GAMMA

! Local
   REAL :: rhoair, rhowater, Gam, alp, BV2, A1, A2, B2, u, v, wspd, &
           hu1, hv1, hu2, hv2, taux, tauy, tauxair, tauyair, q, hold, &
           hsqrd, thp, cwater, ust2
   CHARACTER(LEN=120) :: time_series

      hu1=huml
      hv1=hvml
      rhoair=1.
      rhowater=1000.
      cwater=4200.
! Deep ocean lapse rate (K/m) - from Rich
      Gam=oml_gamma
!     if(i.eq.1 .and. j.eq.1 .or. i.eq.105.and.j.eq.105) print *, 'gamma = ', gam
!     Gam=0.14
!     Gam=5.6/40.
!     Gam=5./100.
! Thermal expansion coeff (/K)
!     alp=.0002
!     temp dependence (/K)
      alp=max((tml-273.15)*1.e-5, 1.e-6)
      BV2=alp*g*Gam
      thp=t0ml-Gam*(h-h0)
      A1=(tml-thp)*h - 0.5*Gam*h*h
      if(h.ne.0.)then
        u=hu1/h
        v=hv1/h
      else
        u=0.
        v=0.
      endif

!  time step

        q=(-hfx-lh+gsw+glw-stbolt*emiss*tml*tml*tml*tml)/(rhowater*cwater)
!       wspd=max(sqrt(uair*uair+vair*vair),0.1)
        wspd=sqrt(uair*uair+vair*vair)
        if (wspd .lt. 1.e-10 ) then
!          print *, 'i,j,wspd are ', i,j,wspd
           wspd = 1.e-10
        endif
! limit ust to 1.6 to give a value of ust for water of 0.05
!       ust2=min(ust, 1.6)
! new limit for ust: reduce atmospheric ust by half for ocean
        ust2=0.5*ust
        tauxair=ust2*ust2*uair/wspd
        taux=rhoair/rhowater*tauxair
        tauyair=ust2*ust2*vair/wspd
        tauy=rhoair/rhowater*tauyair
! note: forward-backward coriolis force for effective time-centering
        hu2=hu1+dt*( f*hv1 + taux)
        hv2=hv1+dt*(-f*hu2 + tauy)
! consider the flux effect
        A2=A1+q*dt

        huml=hu2
        hvml=hv2

        hold=h
        B2=hu2*hu2+hv2*hv2
        hsqrd=-A2/Gam + sqrt(A2*A2/(Gam*Gam) + 2.*B2/BV2)
        h=sqrt(max(hsqrd,0.0))
! limit to positive h change
        if(h.lt.hold)h=hold

        if(h.ne.0.)then
          tml=max(t0ml - Gam*(h-h0) + 0.5*Gam*h + A2/h, tmoml)
          u=hu2/h
          v=hv2/h
        else
          tml=t0ml
          u=0.
          v=0.
        endif
        tsk=tml
!        if(h.gt.100.)print *,i,j,h,tml,' h,tml'

! ww: output point data
!     if( (i.eq.190 .and. j.eq.115) .or. (i.eq.170 .and. j.eq.125) ) then
!        write(jtime,fmt='("TS ",f10.0)') float(itimestep)
!        CALL wrf_message ( TRIM(jtime) )
!        write(time_series,fmt='("OML",2I4,2F9.5,2F8.2,2E15.5,F8.3)') &
!              i,j,u,v,tml,h,taux,tauy,a2
!        CALL wrf_message ( TRIM(time_series) )
!     end if

   END SUBROUTINE OML1D

!================================================================
   SUBROUTINE omlinit(outfile,oml_hml0, tsk,                   &
                      tml,t0ml,hml,h0ml,huml,hvml,tmoml,       &
                      allowed_to_read, start_of_simulation,    &
                      ids,ide, jds,jde, kds,kde,               &
                      ims,ime, jms,jme, kms,kme,               &
                      its,ite, jts,jte, kts,kte                )
!----------------------------------------------------------------
   IMPLICIT NONE
!----------------------------------------------------------------
   INTEGER, INTENT(IN   )    ::      outfile
   LOGICAL , INTENT(IN)      ::      allowed_to_read
   LOGICAL , INTENT(IN)      ::      start_of_simulation
   INTEGER, INTENT(IN   )    ::      ids,ide, jds,jde, kds,kde, &
                                     ims,ime, jms,jme, kms,kme, &
                                     its,ite, jts,jte, kts,kte

   REAL,    DIMENSION( ims:ime, jms:jme )                     , &
            INTENT(IN)    ::                               TSK

   REAL,    DIMENSION( ims:ime, jms:jme )                     , &
            INTENT(INOUT)    ::     TML, T0ML, HML, H0ML, HUML, HVML, TMOML
   REAL   , INTENT(IN   )    ::     oml_hml0

!  LOCAR VAR

   INTEGER                   ::      L,J,I,itf,jtf
   CHARACTER*1024 message

!----------------------------------------------------------------
 
   itf=min0(ite,ide-1)
   jtf=min0(jte,jde-1)

   IF(start_of_simulation) THEN
     DO J=jts,jtf
     DO I=its,itf
       TML(I,J)=TSK(I,J)
       T0ML(I,J)=TSK(I,J)
     ENDDO
     ENDDO
     IF (oml_hml0 .gt. 0.) THEN
!!!        WRITE(message,*)'Initializing OML with HML0 = ', oml_hml0
!!!        CALL wrf_debug (0, TRIM(message))
!write(outfile,*) 'Initializing OML with HML0 = ', oml_hml0
        DO J=jts,jtf
        DO I=its,itf
          HML(I,J)=oml_hml0
          H0ML(I,J)=HML(I,J)
          HUML(I,J)=0.
          HVML(I,J)=0.
          TMOML(I,J)=TSK(I,J)-5.
        ENDDO
        ENDDO
     ELSE
!!!        WRITE(message,*)'Initializing OML with real HML0, h(1,1) = ', h0ml(1,1)
!!!        CALL wrf_debug (0, TRIM(message))
!write(outfile,*) 'Initializing OML with real HML0, h(1,1) = ', h0ml(1,1)
        stop 34543
        DO J=jts,jtf
        DO I=its,itf
          HML(I,J)=H0ML(I,J)
! fill in near coast area with SST: 200 K was set as missing value in ocean pre-processing code
          IF(TMOML(I,J).GT.200. .and. TMOML(I,J).LE.201.) TMOML(I,J)=TSK(I,J)
        ENDDO
        ENDDO
     ENDIF
   ENDIF

   END SUBROUTINE omlinit
!-------------------------------------------------------------------          
END MODULE module_sf_oml
