// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "Model.hpp"

namespace damaris
{
  namespace model
  {
    // DeprecatedClients
    // 

    const DeprecatedClients::count_type& DeprecatedClients::
    count () const
    {
      return this->count_.get ();
    }

    DeprecatedClients::count_type& DeprecatedClients::
    count ()
    {
      return this->count_.get ();
    }

    void DeprecatedClients::
    count (const count_type& x)
    {
      this->count_.set (x);
    }

    const DeprecatedClients::domains_type& DeprecatedClients::
    domains () const
    {
      return this->domains_.get ();
    }

    DeprecatedClients::domains_type& DeprecatedClients::
    domains ()
    {
      return this->domains_.get ();
    }

    void DeprecatedClients::
    domains (const domains_type& x)
    {
      this->domains_.set (x);
    }

    DeprecatedClients::domains_type DeprecatedClients::
    domains_default_value ()
    {
      return domains_type (1U);
    }


    // DeprecatedCores
    // 

    const DeprecatedCores::clients_type& DeprecatedCores::
    clients () const
    {
      return this->clients_.get ();
    }

    DeprecatedCores::clients_type& DeprecatedCores::
    clients ()
    {
      return this->clients_.get ();
    }

    void DeprecatedCores::
    clients (const clients_type& x)
    {
      this->clients_.set (x);
    }

    void DeprecatedCores::
    clients (::std::unique_ptr< clients_type > x)
    {
      this->clients_.set (std::move (x));
    }

    const DeprecatedCores::count_type& DeprecatedCores::
    count () const
    {
      return this->count_.get ();
    }

    DeprecatedCores::count_type& DeprecatedCores::
    count ()
    {
      return this->count_.get ();
    }

    void DeprecatedCores::
    count (const count_type& x)
    {
      this->count_.set (x);
    }


    // KeyVal
    // 

    const KeyVal::key_optional& KeyVal::
    key () const
    {
      return this->key_;
    }

    KeyVal::key_optional& KeyVal::
    key ()
    {
      return this->key_;
    }

    void KeyVal::
    key (const key_type& x)
    {
      this->key_.set (x);
    }

    void KeyVal::
    key (const key_optional& x)
    {
      this->key_ = x;
    }

    void KeyVal::
    key (::std::unique_ptr< key_type > x)
    {
      this->key_.set (std::move (x));
    }


    // Dedicated
    // 

    const Dedicated::cores_type& Dedicated::
    cores () const
    {
      return this->cores_.get ();
    }

    Dedicated::cores_type& Dedicated::
    cores ()
    {
      return this->cores_.get ();
    }

    void Dedicated::
    cores (const cores_type& x)
    {
      this->cores_.set (x);
    }

    Dedicated::cores_type Dedicated::
    cores_default_value ()
    {
      return cores_type (0U);
    }

    const Dedicated::nodes_type& Dedicated::
    nodes () const
    {
      return this->nodes_.get ();
    }

    Dedicated::nodes_type& Dedicated::
    nodes ()
    {
      return this->nodes_.get ();
    }

    void Dedicated::
    nodes (const nodes_type& x)
    {
      this->nodes_.set (x);
    }

    Dedicated::nodes_type Dedicated::
    nodes_default_value ()
    {
      return nodes_type (0U);
    }


    // Domains
    // 

    const Domains::count_type& Domains::
    count () const
    {
      return this->count_.get ();
    }

    Domains::count_type& Domains::
    count ()
    {
      return this->count_.get ();
    }

    void Domains::
    count (const count_type& x)
    {
      this->count_.set (x);
    }

    Domains::count_type Domains::
    count_default_value ()
    {
      return count_type (1U);
    }


    // Placement
    // 

    const Placement::mask_type& Placement::
    mask () const
    {
      return this->mask_.get ();
    }

    Placement::mask_type& Placement::
    mask ()
    {
      return this->mask_.get ();
    }

    void Placement::
    mask (const mask_type& x)
    {
      this->mask_.set (x);
    }

    void Placement::
    mask (::std::unique_ptr< mask_type > x)
    {
      this->mask_.set (std::move (x));
    }

    const Placement::mask_type& Placement::
    mask_default_value ()
    {
      return mask_default_value_;
    }

    const Placement::start_type& Placement::
    start () const
    {
      return this->start_.get ();
    }

    Placement::start_type& Placement::
    start ()
    {
      return this->start_.get ();
    }

    void Placement::
    start (const start_type& x)
    {
      this->start_.set (x);
    }

    Placement::start_type Placement::
    start_default_value ()
    {
      return start_type (0);
    }

    const Placement::step_type& Placement::
    step () const
    {
      return this->step_.get ();
    }

    Placement::step_type& Placement::
    step ()
    {
      return this->step_.get ();
    }

    void Placement::
    step (const step_type& x)
    {
      this->step_.set (x);
    }

    Placement::step_type Placement::
    step_default_value ()
    {
      return step_type (0U);
    }

    const Placement::blocksize_type& Placement::
    blocksize () const
    {
      return this->blocksize_.get ();
    }

    Placement::blocksize_type& Placement::
    blocksize ()
    {
      return this->blocksize_.get ();
    }

    void Placement::
    blocksize (const blocksize_type& x)
    {
      this->blocksize_.set (x);
    }

    Placement::blocksize_type Placement::
    blocksize_default_value ()
    {
      return blocksize_type (0U);
    }

    const Placement::comment_optional& Placement::
    comment () const
    {
      return this->comment_;
    }

    Placement::comment_optional& Placement::
    comment ()
    {
      return this->comment_;
    }

    void Placement::
    comment (const comment_type& x)
    {
      this->comment_.set (x);
    }

    void Placement::
    comment (const comment_optional& x)
    {
      this->comment_ = x;
    }

    void Placement::
    comment (::std::unique_ptr< comment_type > x)
    {
      this->comment_.set (std::move (x));
    }


    // ShmType
    // 

    ShmType::
    ShmType (value v)
    : ::xml_schema::string (_xsd_ShmType_literals_[v])
    {
    }

    ShmType::
    ShmType (const char* v)
    : ::xml_schema::string (v)
    {
    }

    ShmType::
    ShmType (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    ShmType::
    ShmType (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    ShmType::
    ShmType (const ShmType& v,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    ShmType& ShmType::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_ShmType_literals_[v]);

      return *this;
    }


    // Buffer
    // 

    const Buffer::name_type& Buffer::
    name () const
    {
      return this->name_.get ();
    }

    Buffer::name_type& Buffer::
    name ()
    {
      return this->name_.get ();
    }

    void Buffer::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void Buffer::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }

    const Buffer::size_type& Buffer::
    size () const
    {
      return this->size_.get ();
    }

    Buffer::size_type& Buffer::
    size ()
    {
      return this->size_.get ();
    }

    void Buffer::
    size (const size_type& x)
    {
      this->size_.set (x);
    }

    const Buffer::type_type& Buffer::
    type () const
    {
      return this->type_.get ();
    }

    Buffer::type_type& Buffer::
    type ()
    {
      return this->type_.get ();
    }

    void Buffer::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void Buffer::
    type (::std::unique_ptr< type_type > x)
    {
      this->type_.set (std::move (x));
    }

    const Buffer::type_type& Buffer::
    type_default_value ()
    {
      return type_default_value_;
    }

    const Buffer::blocks_type& Buffer::
    blocks () const
    {
      return this->blocks_.get ();
    }

    Buffer::blocks_type& Buffer::
    blocks ()
    {
      return this->blocks_.get ();
    }

    void Buffer::
    blocks (const blocks_type& x)
    {
      this->blocks_.set (x);
    }

    Buffer::blocks_type Buffer::
    blocks_default_value ()
    {
      return blocks_type (0U);
    }

    const Buffer::enabled_type& Buffer::
    enabled () const
    {
      return this->enabled_.get ();
    }

    Buffer::enabled_type& Buffer::
    enabled ()
    {
      return this->enabled_.get ();
    }

    void Buffer::
    enabled (const enabled_type& x)
    {
      this->enabled_.set (x);
    }

    Buffer::enabled_type Buffer::
    enabled_default_value ()
    {
      return enabled_type (true);
    }


    // Queue
    // 

    const Queue::name_type& Queue::
    name () const
    {
      return this->name_.get ();
    }

    Queue::name_type& Queue::
    name ()
    {
      return this->name_.get ();
    }

    void Queue::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void Queue::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }

    const Queue::size_type& Queue::
    size () const
    {
      return this->size_.get ();
    }

    Queue::size_type& Queue::
    size ()
    {
      return this->size_.get ();
    }

    void Queue::
    size (const size_type& x)
    {
      this->size_.set (x);
    }


    // Architecture
    // 

    const Architecture::domains_type& Architecture::
    domains () const
    {
      return this->domains_.get ();
    }

    Architecture::domains_type& Architecture::
    domains ()
    {
      return this->domains_.get ();
    }

    void Architecture::
    domains (const domains_type& x)
    {
      this->domains_.set (x);
    }

    void Architecture::
    domains (::std::unique_ptr< domains_type > x)
    {
      this->domains_.set (std::move (x));
    }

    const Architecture::dedicated_type& Architecture::
    dedicated () const
    {
      return this->dedicated_.get ();
    }

    Architecture::dedicated_type& Architecture::
    dedicated ()
    {
      return this->dedicated_.get ();
    }

    void Architecture::
    dedicated (const dedicated_type& x)
    {
      this->dedicated_.set (x);
    }

    void Architecture::
    dedicated (::std::unique_ptr< dedicated_type > x)
    {
      this->dedicated_.set (std::move (x));
    }

    const Architecture::placement_type& Architecture::
    placement () const
    {
      return this->placement_.get ();
    }

    Architecture::placement_type& Architecture::
    placement ()
    {
      return this->placement_.get ();
    }

    void Architecture::
    placement (const placement_type& x)
    {
      this->placement_.set (x);
    }

    void Architecture::
    placement (::std::unique_ptr< placement_type > x)
    {
      this->placement_.set (std::move (x));
    }

    const Architecture::buffer_type& Architecture::
    buffer () const
    {
      return this->buffer_.get ();
    }

    Architecture::buffer_type& Architecture::
    buffer ()
    {
      return this->buffer_.get ();
    }

    void Architecture::
    buffer (const buffer_type& x)
    {
      this->buffer_.set (x);
    }

    void Architecture::
    buffer (::std::unique_ptr< buffer_type > x)
    {
      this->buffer_.set (std::move (x));
    }

    const Architecture::queue_type& Architecture::
    queue () const
    {
      return this->queue_.get ();
    }

    Architecture::queue_type& Architecture::
    queue ()
    {
      return this->queue_.get ();
    }

    void Architecture::
    queue (const queue_type& x)
    {
      this->queue_.set (x);
    }

    void Architecture::
    queue (::std::unique_ptr< queue_type > x)
    {
      this->queue_.set (std::move (x));
    }

    const Architecture::name_optional& Architecture::
    name () const
    {
      return this->name_;
    }

    Architecture::name_optional& Architecture::
    name ()
    {
      return this->name_;
    }

    void Architecture::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void Architecture::
    name (const name_optional& x)
    {
      this->name_ = x;
    }

    void Architecture::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }


    // Language
    // 

    Language::
    Language (value v)
    : ::xml_schema::string (_xsd_Language_literals_[v])
    {
    }

    Language::
    Language (const char* v)
    : ::xml_schema::string (v)
    {
    }

    Language::
    Language (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    Language::
    Language (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    Language::
    Language (const Language& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    Language& Language::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_Language_literals_[v]);

      return *this;
    }


    // Type
    // 

    Type::
    Type (value v)
    : ::xml_schema::string (_xsd_Type_literals_[v])
    {
    }

    Type::
    Type (const char* v)
    : ::xml_schema::string (v)
    {
    }

    Type::
    Type (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    Type::
    Type (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    Type::
    Type (const Type& v,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    Type& Type::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_Type_literals_[v]);

      return *this;
    }


    // Layout
    // 

    const Layout::name_type& Layout::
    name () const
    {
      return this->name_.get ();
    }

    Layout::name_type& Layout::
    name ()
    {
      return this->name_.get ();
    }

    void Layout::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void Layout::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }

    const Layout::type_type& Layout::
    type () const
    {
      return this->type_.get ();
    }

    Layout::type_type& Layout::
    type ()
    {
      return this->type_.get ();
    }

    void Layout::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void Layout::
    type (::std::unique_ptr< type_type > x)
    {
      this->type_.set (std::move (x));
    }

    const Layout::dimensions_type& Layout::
    dimensions () const
    {
      return this->dimensions_.get ();
    }

    Layout::dimensions_type& Layout::
    dimensions ()
    {
      return this->dimensions_.get ();
    }

    void Layout::
    dimensions (const dimensions_type& x)
    {
      this->dimensions_.set (x);
    }

    void Layout::
    dimensions (::std::unique_ptr< dimensions_type > x)
    {
      this->dimensions_.set (std::move (x));
    }

    const Layout::global_type& Layout::
    global () const
    {
      return this->global_.get ();
    }

    Layout::global_type& Layout::
    global ()
    {
      return this->global_.get ();
    }

    void Layout::
    global (const global_type& x)
    {
      this->global_.set (x);
    }

    void Layout::
    global (::std::unique_ptr< global_type > x)
    {
      this->global_.set (std::move (x));
    }

    const Layout::global_type& Layout::
    global_default_value ()
    {
      return global_default_value_;
    }

    const Layout::ghosts_type& Layout::
    ghosts () const
    {
      return this->ghosts_.get ();
    }

    Layout::ghosts_type& Layout::
    ghosts ()
    {
      return this->ghosts_.get ();
    }

    void Layout::
    ghosts (const ghosts_type& x)
    {
      this->ghosts_.set (x);
    }

    void Layout::
    ghosts (::std::unique_ptr< ghosts_type > x)
    {
      this->ghosts_.set (std::move (x));
    }

    const Layout::ghosts_type& Layout::
    ghosts_default_value ()
    {
      return ghosts_default_value_;
    }

    const Layout::language_type& Layout::
    language () const
    {
      return this->language_.get ();
    }

    Layout::language_type& Layout::
    language ()
    {
      return this->language_.get ();
    }

    void Layout::
    language (const language_type& x)
    {
      this->language_.set (x);
    }

    void Layout::
    language (::std::unique_ptr< language_type > x)
    {
      this->language_.set (std::move (x));
    }

    const Layout::language_type& Layout::
    language_default_value ()
    {
      return language_default_value_;
    }

    const Layout::visualizable_type& Layout::
    visualizable () const
    {
      return this->visualizable_.get ();
    }

    Layout::visualizable_type& Layout::
    visualizable ()
    {
      return this->visualizable_.get ();
    }

    void Layout::
    visualizable (const visualizable_type& x)
    {
      this->visualizable_.set (x);
    }

    Layout::visualizable_type Layout::
    visualizable_default_value ()
    {
      return visualizable_type (true);
    }

    const Layout::comment_optional& Layout::
    comment () const
    {
      return this->comment_;
    }

    Layout::comment_optional& Layout::
    comment ()
    {
      return this->comment_;
    }

    void Layout::
    comment (const comment_type& x)
    {
      this->comment_.set (x);
    }

    void Layout::
    comment (const comment_optional& x)
    {
      this->comment_ = x;
    }

    void Layout::
    comment (::std::unique_ptr< comment_type > x)
    {
      this->comment_.set (std::move (x));
    }


    // VarType
    // 

    VarType::
    VarType (value v)
    : ::xml_schema::string (_xsd_VarType_literals_[v])
    {
    }

    VarType::
    VarType (const char* v)
    : ::xml_schema::string (v)
    {
    }

    VarType::
    VarType (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    VarType::
    VarType (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    VarType::
    VarType (const VarType& v,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    VarType& VarType::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_VarType_literals_[v]);

      return *this;
    }


    // VarCentering
    // 

    VarCentering::
    VarCentering (value v)
    : ::xml_schema::string (_xsd_VarCentering_literals_[v])
    {
    }

    VarCentering::
    VarCentering (const char* v)
    : ::xml_schema::string (v)
    {
    }

    VarCentering::
    VarCentering (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    VarCentering::
    VarCentering (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    VarCentering::
    VarCentering (const VarCentering& v,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    VarCentering& VarCentering::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_VarCentering_literals_[v]);

      return *this;
    }


    // Variable
    // 

    const Variable::name_type& Variable::
    name () const
    {
      return this->name_.get ();
    }

    Variable::name_type& Variable::
    name ()
    {
      return this->name_.get ();
    }

    void Variable::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void Variable::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }

    const Variable::unit_type& Variable::
    unit () const
    {
      return this->unit_.get ();
    }

    Variable::unit_type& Variable::
    unit ()
    {
      return this->unit_.get ();
    }

    void Variable::
    unit (const unit_type& x)
    {
      this->unit_.set (x);
    }

    void Variable::
    unit (::std::unique_ptr< unit_type > x)
    {
      this->unit_.set (std::move (x));
    }

    const Variable::unit_type& Variable::
    unit_default_value ()
    {
      return unit_default_value_;
    }

    const Variable::layout_type& Variable::
    layout () const
    {
      return this->layout_.get ();
    }

    Variable::layout_type& Variable::
    layout ()
    {
      return this->layout_.get ();
    }

    void Variable::
    layout (const layout_type& x)
    {
      this->layout_.set (x);
    }

    void Variable::
    layout (::std::unique_ptr< layout_type > x)
    {
      this->layout_.set (std::move (x));
    }

    const Variable::enabled_type& Variable::
    enabled () const
    {
      return this->enabled_.get ();
    }

    Variable::enabled_type& Variable::
    enabled ()
    {
      return this->enabled_.get ();
    }

    void Variable::
    enabled (const enabled_type& x)
    {
      this->enabled_.set (x);
    }

    Variable::enabled_type Variable::
    enabled_default_value ()
    {
      return enabled_type (true);
    }

    const Variable::mesh_type& Variable::
    mesh () const
    {
      return this->mesh_.get ();
    }

    Variable::mesh_type& Variable::
    mesh ()
    {
      return this->mesh_.get ();
    }

    void Variable::
    mesh (const mesh_type& x)
    {
      this->mesh_.set (x);
    }

    void Variable::
    mesh (::std::unique_ptr< mesh_type > x)
    {
      this->mesh_.set (std::move (x));
    }

    const Variable::mesh_type& Variable::
    mesh_default_value ()
    {
      return mesh_default_value_;
    }

    const Variable::type_type& Variable::
    type () const
    {
      return this->type_.get ();
    }

    Variable::type_type& Variable::
    type ()
    {
      return this->type_.get ();
    }

    void Variable::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void Variable::
    type (::std::unique_ptr< type_type > x)
    {
      this->type_.set (std::move (x));
    }

    const Variable::type_type& Variable::
    type_default_value ()
    {
      return type_default_value_;
    }

    const Variable::vectorlength_type& Variable::
    vectorlength () const
    {
      return this->vectorlength_.get ();
    }

    Variable::vectorlength_type& Variable::
    vectorlength ()
    {
      return this->vectorlength_.get ();
    }

    void Variable::
    vectorlength (const vectorlength_type& x)
    {
      this->vectorlength_.set (x);
    }

    Variable::vectorlength_type Variable::
    vectorlength_default_value ()
    {
      return vectorlength_type (1U);
    }

    const Variable::centering_type& Variable::
    centering () const
    {
      return this->centering_.get ();
    }

    Variable::centering_type& Variable::
    centering ()
    {
      return this->centering_.get ();
    }

    void Variable::
    centering (const centering_type& x)
    {
      this->centering_.set (x);
    }

    void Variable::
    centering (::std::unique_ptr< centering_type > x)
    {
      this->centering_.set (std::move (x));
    }

    const Variable::centering_type& Variable::
    centering_default_value ()
    {
      return centering_default_value_;
    }

    const Variable::visualizable_type& Variable::
    visualizable () const
    {
      return this->visualizable_.get ();
    }

    Variable::visualizable_type& Variable::
    visualizable ()
    {
      return this->visualizable_.get ();
    }

    void Variable::
    visualizable (const visualizable_type& x)
    {
      this->visualizable_.set (x);
    }

    Variable::visualizable_type Variable::
    visualizable_default_value ()
    {
      return visualizable_type (true);
    }

    const Variable::time_varying_type& Variable::
    time_varying () const
    {
      return this->time_varying_.get ();
    }

    Variable::time_varying_type& Variable::
    time_varying ()
    {
      return this->time_varying_.get ();
    }

    void Variable::
    time_varying (const time_varying_type& x)
    {
      this->time_varying_.set (x);
    }

    Variable::time_varying_type Variable::
    time_varying_default_value ()
    {
      return time_varying_type (true);
    }

    const Variable::store_type& Variable::
    store () const
    {
      return this->store_.get ();
    }

    Variable::store_type& Variable::
    store ()
    {
      return this->store_.get ();
    }

    void Variable::
    store (const store_type& x)
    {
      this->store_.set (x);
    }

    void Variable::
    store (::std::unique_ptr< store_type > x)
    {
      this->store_.set (std::move (x));
    }

    const Variable::store_type& Variable::
    store_default_value ()
    {
      return store_default_value_;
    }

    const Variable::script_type& Variable::
    script () const
    {
      return this->script_.get ();
    }

    Variable::script_type& Variable::
    script ()
    {
      return this->script_.get ();
    }

    void Variable::
    script (const script_type& x)
    {
      this->script_.set (x);
    }

    void Variable::
    script (::std::unique_ptr< script_type > x)
    {
      this->script_.set (std::move (x));
    }

    const Variable::script_type& Variable::
    script_default_value ()
    {
      return script_default_value_;
    }

    const Variable::comment_optional& Variable::
    comment () const
    {
      return this->comment_;
    }

    Variable::comment_optional& Variable::
    comment ()
    {
      return this->comment_;
    }

    void Variable::
    comment (const comment_type& x)
    {
      this->comment_.set (x);
    }

    void Variable::
    comment (const comment_optional& x)
    {
      this->comment_ = x;
    }

    void Variable::
    comment (::std::unique_ptr< comment_type > x)
    {
      this->comment_.set (std::move (x));
    }


    // Group
    // 

    const Group::layout_sequence& Group::
    layout () const
    {
      return this->layout_;
    }

    Group::layout_sequence& Group::
    layout ()
    {
      return this->layout_;
    }

    void Group::
    layout (const layout_sequence& s)
    {
      this->layout_ = s;
    }

    const Group::variable_sequence& Group::
    variable () const
    {
      return this->variable_;
    }

    Group::variable_sequence& Group::
    variable ()
    {
      return this->variable_;
    }

    void Group::
    variable (const variable_sequence& s)
    {
      this->variable_ = s;
    }

    const Group::group_sequence& Group::
    group () const
    {
      return this->group_;
    }

    Group::group_sequence& Group::
    group ()
    {
      return this->group_;
    }

    void Group::
    group (const group_sequence& s)
    {
      this->group_ = s;
    }

    const Group::mesh_sequence& Group::
    mesh () const
    {
      return this->mesh_;
    }

    Group::mesh_sequence& Group::
    mesh ()
    {
      return this->mesh_;
    }

    void Group::
    mesh (const mesh_sequence& s)
    {
      this->mesh_ = s;
    }

    const Group::curve_sequence& Group::
    curve () const
    {
      return this->curve_;
    }

    Group::curve_sequence& Group::
    curve ()
    {
      return this->curve_;
    }

    void Group::
    curve (const curve_sequence& s)
    {
      this->curve_ = s;
    }

    const Group::name_type& Group::
    name () const
    {
      return this->name_.get ();
    }

    Group::name_type& Group::
    name ()
    {
      return this->name_.get ();
    }

    void Group::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void Group::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }

    const Group::enabled_type& Group::
    enabled () const
    {
      return this->enabled_.get ();
    }

    Group::enabled_type& Group::
    enabled ()
    {
      return this->enabled_.get ();
    }

    void Group::
    enabled (const enabled_type& x)
    {
      this->enabled_.set (x);
    }

    Group::enabled_type Group::
    enabled_default_value ()
    {
      return enabled_type (true);
    }

    const Group::store_type& Group::
    store () const
    {
      return this->store_.get ();
    }

    Group::store_type& Group::
    store ()
    {
      return this->store_.get ();
    }

    void Group::
    store (const store_type& x)
    {
      this->store_.set (x);
    }

    void Group::
    store (::std::unique_ptr< store_type > x)
    {
      this->store_.set (std::move (x));
    }

    const Group::store_type& Group::
    store_default_value ()
    {
      return store_default_value_;
    }


    // Parameter
    // 

    const Parameter::name_type& Parameter::
    name () const
    {
      return this->name_.get ();
    }

    Parameter::name_type& Parameter::
    name ()
    {
      return this->name_.get ();
    }

    void Parameter::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void Parameter::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }

    const Parameter::type_type& Parameter::
    type () const
    {
      return this->type_.get ();
    }

    Parameter::type_type& Parameter::
    type ()
    {
      return this->type_.get ();
    }

    void Parameter::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void Parameter::
    type (::std::unique_ptr< type_type > x)
    {
      this->type_.set (std::move (x));
    }

    const Parameter::value_type& Parameter::
    value () const
    {
      return this->value_.get ();
    }

    Parameter::value_type& Parameter::
    value ()
    {
      return this->value_.get ();
    }

    void Parameter::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void Parameter::
    value (::std::unique_ptr< value_type > x)
    {
      this->value_.set (std::move (x));
    }

    const Parameter::comment_optional& Parameter::
    comment () const
    {
      return this->comment_;
    }

    Parameter::comment_optional& Parameter::
    comment ()
    {
      return this->comment_;
    }

    void Parameter::
    comment (const comment_type& x)
    {
      this->comment_.set (x);
    }

    void Parameter::
    comment (const comment_optional& x)
    {
      this->comment_ = x;
    }

    void Parameter::
    comment (::std::unique_ptr< comment_type > x)
    {
      this->comment_.set (std::move (x));
    }


    // MeshType
    // 

    MeshType::
    MeshType (value v)
    : ::xml_schema::string (_xsd_MeshType_literals_[v])
    {
    }

    MeshType::
    MeshType (const char* v)
    : ::xml_schema::string (v)
    {
    }

    MeshType::
    MeshType (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    MeshType::
    MeshType (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    MeshType::
    MeshType (const MeshType& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    MeshType& MeshType::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_MeshType_literals_[v]);

      return *this;
    }


    // Coord
    // 

    const Coord::name_type& Coord::
    name () const
    {
      return this->name_.get ();
    }

    Coord::name_type& Coord::
    name ()
    {
      return this->name_.get ();
    }

    void Coord::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void Coord::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }

    const Coord::unit_type& Coord::
    unit () const
    {
      return this->unit_.get ();
    }

    Coord::unit_type& Coord::
    unit ()
    {
      return this->unit_.get ();
    }

    void Coord::
    unit (const unit_type& x)
    {
      this->unit_.set (x);
    }

    void Coord::
    unit (::std::unique_ptr< unit_type > x)
    {
      this->unit_.set (std::move (x));
    }

    const Coord::unit_type& Coord::
    unit_default_value ()
    {
      return unit_default_value_;
    }

    const Coord::label_type& Coord::
    label () const
    {
      return this->label_.get ();
    }

    Coord::label_type& Coord::
    label ()
    {
      return this->label_.get ();
    }

    void Coord::
    label (const label_type& x)
    {
      this->label_.set (x);
    }

    void Coord::
    label (::std::unique_ptr< label_type > x)
    {
      this->label_.set (std::move (x));
    }

    const Coord::label_type& Coord::
    label_default_value ()
    {
      return label_default_value_;
    }

    const Coord::comment_optional& Coord::
    comment () const
    {
      return this->comment_;
    }

    Coord::comment_optional& Coord::
    comment ()
    {
      return this->comment_;
    }

    void Coord::
    comment (const comment_type& x)
    {
      this->comment_.set (x);
    }

    void Coord::
    comment (const comment_optional& x)
    {
      this->comment_ = x;
    }

    void Coord::
    comment (::std::unique_ptr< comment_type > x)
    {
      this->comment_.set (std::move (x));
    }


    // VertexGID
    // 

    const VertexGID::name_type& VertexGID::
    name () const
    {
      return this->name_.get ();
    }

    VertexGID::name_type& VertexGID::
    name ()
    {
      return this->name_.get ();
    }

    void VertexGID::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void VertexGID::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }

    const VertexGID::offset_type& VertexGID::
    offset () const
    {
      return this->offset_.get ();
    }

    VertexGID::offset_type& VertexGID::
    offset ()
    {
      return this->offset_.get ();
    }

    void VertexGID::
    offset (const offset_type& x)
    {
      this->offset_.set (x);
    }

    VertexGID::offset_type VertexGID::
    offset_default_value ()
    {
      return offset_type (0);
    }

    const VertexGID::comment_optional& VertexGID::
    comment () const
    {
      return this->comment_;
    }

    VertexGID::comment_optional& VertexGID::
    comment ()
    {
      return this->comment_;
    }

    void VertexGID::
    comment (const comment_type& x)
    {
      this->comment_.set (x);
    }

    void VertexGID::
    comment (const comment_optional& x)
    {
      this->comment_ = x;
    }

    void VertexGID::
    comment (::std::unique_ptr< comment_type > x)
    {
      this->comment_.set (std::move (x));
    }


    // SectionVTKTypes
    // 

    const SectionVTKTypes::name_type& SectionVTKTypes::
    name () const
    {
      return this->name_.get ();
    }

    SectionVTKTypes::name_type& SectionVTKTypes::
    name ()
    {
      return this->name_.get ();
    }

    void SectionVTKTypes::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void SectionVTKTypes::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }

    const SectionVTKTypes::comment_optional& SectionVTKTypes::
    comment () const
    {
      return this->comment_;
    }

    SectionVTKTypes::comment_optional& SectionVTKTypes::
    comment ()
    {
      return this->comment_;
    }

    void SectionVTKTypes::
    comment (const comment_type& x)
    {
      this->comment_.set (x);
    }

    void SectionVTKTypes::
    comment (const comment_optional& x)
    {
      this->comment_ = x;
    }

    void SectionVTKTypes::
    comment (::std::unique_ptr< comment_type > x)
    {
      this->comment_.set (std::move (x));
    }


    // SectionSizes
    // 

    const SectionSizes::name_type& SectionSizes::
    name () const
    {
      return this->name_.get ();
    }

    SectionSizes::name_type& SectionSizes::
    name ()
    {
      return this->name_.get ();
    }

    void SectionSizes::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void SectionSizes::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }

    const SectionSizes::comment_optional& SectionSizes::
    comment () const
    {
      return this->comment_;
    }

    SectionSizes::comment_optional& SectionSizes::
    comment ()
    {
      return this->comment_;
    }

    void SectionSizes::
    comment (const comment_type& x)
    {
      this->comment_.set (x);
    }

    void SectionSizes::
    comment (const comment_optional& x)
    {
      this->comment_ = x;
    }

    void SectionSizes::
    comment (::std::unique_ptr< comment_type > x)
    {
      this->comment_.set (std::move (x));
    }


    // SectionConnectivity
    // 

    const SectionConnectivity::name_type& SectionConnectivity::
    name () const
    {
      return this->name_.get ();
    }

    SectionConnectivity::name_type& SectionConnectivity::
    name ()
    {
      return this->name_.get ();
    }

    void SectionConnectivity::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void SectionConnectivity::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }

    const SectionConnectivity::comment_optional& SectionConnectivity::
    comment () const
    {
      return this->comment_;
    }

    SectionConnectivity::comment_optional& SectionConnectivity::
    comment ()
    {
      return this->comment_;
    }

    void SectionConnectivity::
    comment (const comment_type& x)
    {
      this->comment_.set (x);
    }

    void SectionConnectivity::
    comment (const comment_optional& x)
    {
      this->comment_ = x;
    }

    void SectionConnectivity::
    comment (::std::unique_ptr< comment_type > x)
    {
      this->comment_.set (std::move (x));
    }


    // Mesh
    // 

    const Mesh::coord_sequence& Mesh::
    coord () const
    {
      return this->coord_;
    }

    Mesh::coord_sequence& Mesh::
    coord ()
    {
      return this->coord_;
    }

    void Mesh::
    coord (const coord_sequence& s)
    {
      this->coord_ = s;
    }

    const Mesh::vertex_global_id_optional& Mesh::
    vertex_global_id () const
    {
      return this->vertex_global_id_;
    }

    Mesh::vertex_global_id_optional& Mesh::
    vertex_global_id ()
    {
      return this->vertex_global_id_;
    }

    void Mesh::
    vertex_global_id (const vertex_global_id_type& x)
    {
      this->vertex_global_id_.set (x);
    }

    void Mesh::
    vertex_global_id (const vertex_global_id_optional& x)
    {
      this->vertex_global_id_ = x;
    }

    void Mesh::
    vertex_global_id (::std::unique_ptr< vertex_global_id_type > x)
    {
      this->vertex_global_id_.set (std::move (x));
    }

    const Mesh::section_types_optional& Mesh::
    section_types () const
    {
      return this->section_types_;
    }

    Mesh::section_types_optional& Mesh::
    section_types ()
    {
      return this->section_types_;
    }

    void Mesh::
    section_types (const section_types_type& x)
    {
      this->section_types_.set (x);
    }

    void Mesh::
    section_types (const section_types_optional& x)
    {
      this->section_types_ = x;
    }

    void Mesh::
    section_types (::std::unique_ptr< section_types_type > x)
    {
      this->section_types_.set (std::move (x));
    }

    const Mesh::section_sizes_optional& Mesh::
    section_sizes () const
    {
      return this->section_sizes_;
    }

    Mesh::section_sizes_optional& Mesh::
    section_sizes ()
    {
      return this->section_sizes_;
    }

    void Mesh::
    section_sizes (const section_sizes_type& x)
    {
      this->section_sizes_.set (x);
    }

    void Mesh::
    section_sizes (const section_sizes_optional& x)
    {
      this->section_sizes_ = x;
    }

    void Mesh::
    section_sizes (::std::unique_ptr< section_sizes_type > x)
    {
      this->section_sizes_.set (std::move (x));
    }

    const Mesh::section_connectivity_optional& Mesh::
    section_connectivity () const
    {
      return this->section_connectivity_;
    }

    Mesh::section_connectivity_optional& Mesh::
    section_connectivity ()
    {
      return this->section_connectivity_;
    }

    void Mesh::
    section_connectivity (const section_connectivity_type& x)
    {
      this->section_connectivity_.set (x);
    }

    void Mesh::
    section_connectivity (const section_connectivity_optional& x)
    {
      this->section_connectivity_ = x;
    }

    void Mesh::
    section_connectivity (::std::unique_ptr< section_connectivity_type > x)
    {
      this->section_connectivity_.set (std::move (x));
    }

    const Mesh::name_type& Mesh::
    name () const
    {
      return this->name_.get ();
    }

    Mesh::name_type& Mesh::
    name ()
    {
      return this->name_.get ();
    }

    void Mesh::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void Mesh::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }

    const Mesh::type_type& Mesh::
    type () const
    {
      return this->type_.get ();
    }

    Mesh::type_type& Mesh::
    type ()
    {
      return this->type_.get ();
    }

    void Mesh::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void Mesh::
    type (::std::unique_ptr< type_type > x)
    {
      this->type_.set (std::move (x));
    }

    const Mesh::topology_type& Mesh::
    topology () const
    {
      return this->topology_.get ();
    }

    Mesh::topology_type& Mesh::
    topology ()
    {
      return this->topology_.get ();
    }

    void Mesh::
    topology (const topology_type& x)
    {
      this->topology_.set (x);
    }

    Mesh::topology_type Mesh::
    topology_default_value ()
    {
      return topology_type (2U);
    }

    const Mesh::time_varying_type& Mesh::
    time_varying () const
    {
      return this->time_varying_.get ();
    }

    Mesh::time_varying_type& Mesh::
    time_varying ()
    {
      return this->time_varying_.get ();
    }

    void Mesh::
    time_varying (const time_varying_type& x)
    {
      this->time_varying_.set (x);
    }

    Mesh::time_varying_type Mesh::
    time_varying_default_value ()
    {
      return time_varying_type (false);
    }

    const Mesh::comment_optional& Mesh::
    comment () const
    {
      return this->comment_;
    }

    Mesh::comment_optional& Mesh::
    comment ()
    {
      return this->comment_;
    }

    void Mesh::
    comment (const comment_type& x)
    {
      this->comment_.set (x);
    }

    void Mesh::
    comment (const comment_optional& x)
    {
      this->comment_ = x;
    }

    void Mesh::
    comment (::std::unique_ptr< comment_type > x)
    {
      this->comment_.set (std::move (x));
    }


    // Curve
    // 

    const Curve::coord_sequence& Curve::
    coord () const
    {
      return this->coord_;
    }

    Curve::coord_sequence& Curve::
    coord ()
    {
      return this->coord_;
    }

    void Curve::
    coord (const coord_sequence& s)
    {
      this->coord_ = s;
    }

    const Curve::name_type& Curve::
    name () const
    {
      return this->name_.get ();
    }

    Curve::name_type& Curve::
    name ()
    {
      return this->name_.get ();
    }

    void Curve::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void Curve::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }


    // Data
    // 

    const Data::parameter_sequence& Data::
    parameter () const
    {
      return this->parameter_;
    }

    Data::parameter_sequence& Data::
    parameter ()
    {
      return this->parameter_;
    }

    void Data::
    parameter (const parameter_sequence& s)
    {
      this->parameter_ = s;
    }

    const Data::layout_sequence& Data::
    layout () const
    {
      return this->layout_;
    }

    Data::layout_sequence& Data::
    layout ()
    {
      return this->layout_;
    }

    void Data::
    layout (const layout_sequence& s)
    {
      this->layout_ = s;
    }

    const Data::variable_sequence& Data::
    variable () const
    {
      return this->variable_;
    }

    Data::variable_sequence& Data::
    variable ()
    {
      return this->variable_;
    }

    void Data::
    variable (const variable_sequence& s)
    {
      this->variable_ = s;
    }

    const Data::group_sequence& Data::
    group () const
    {
      return this->group_;
    }

    Data::group_sequence& Data::
    group ()
    {
      return this->group_;
    }

    void Data::
    group (const group_sequence& s)
    {
      this->group_ = s;
    }

    const Data::mesh_sequence& Data::
    mesh () const
    {
      return this->mesh_;
    }

    Data::mesh_sequence& Data::
    mesh ()
    {
      return this->mesh_;
    }

    void Data::
    mesh (const mesh_sequence& s)
    {
      this->mesh_ = s;
    }

    const Data::curve_sequence& Data::
    curve () const
    {
      return this->curve_;
    }

    Data::curve_sequence& Data::
    curve ()
    {
      return this->curve_;
    }

    void Data::
    curve (const curve_sequence& s)
    {
      this->curve_ = s;
    }


    // Scope
    // 

    Scope::
    Scope (value v)
    : ::xml_schema::string (_xsd_Scope_literals_[v])
    {
    }

    Scope::
    Scope (const char* v)
    : ::xml_schema::string (v)
    {
    }

    Scope::
    Scope (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    Scope::
    Scope (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    Scope::
    Scope (const Scope& v,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    Scope& Scope::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_Scope_literals_[v]);

      return *this;
    }


    // Exec
    // 

    Exec::
    Exec (value v)
    : ::xml_schema::string (_xsd_Exec_literals_[v])
    {
    }

    Exec::
    Exec (const char* v)
    : ::xml_schema::string (v)
    {
    }

    Exec::
    Exec (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    Exec::
    Exec (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    Exec::
    Exec (const Exec& v,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    Exec& Exec::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_Exec_literals_[v]);

      return *this;
    }


    // Event
    // 

    const Event::name_type& Event::
    name () const
    {
      return this->name_.get ();
    }

    Event::name_type& Event::
    name ()
    {
      return this->name_.get ();
    }

    void Event::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void Event::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }

    const Event::action_type& Event::
    action () const
    {
      return this->action_.get ();
    }

    Event::action_type& Event::
    action ()
    {
      return this->action_.get ();
    }

    void Event::
    action (const action_type& x)
    {
      this->action_.set (x);
    }

    void Event::
    action (::std::unique_ptr< action_type > x)
    {
      this->action_.set (std::move (x));
    }

    const Event::execution_type& Event::
    execution () const
    {
      return this->execution_.get ();
    }

    Event::execution_type& Event::
    execution ()
    {
      return this->execution_.get ();
    }

    void Event::
    execution (const execution_type& x)
    {
      this->execution_.set (x);
    }

    void Event::
    execution (::std::unique_ptr< execution_type > x)
    {
      this->execution_.set (std::move (x));
    }

    const Event::execution_type& Event::
    execution_default_value ()
    {
      return execution_default_value_;
    }

    const Event::library_type& Event::
    library () const
    {
      return this->library_.get ();
    }

    Event::library_type& Event::
    library ()
    {
      return this->library_.get ();
    }

    void Event::
    library (const library_type& x)
    {
      this->library_.set (x);
    }

    void Event::
    library (::std::unique_ptr< library_type > x)
    {
      this->library_.set (std::move (x));
    }

    const Event::library_type& Event::
    library_default_value ()
    {
      return library_default_value_;
    }

    const Event::scope_type& Event::
    scope () const
    {
      return this->scope_.get ();
    }

    Event::scope_type& Event::
    scope ()
    {
      return this->scope_.get ();
    }

    void Event::
    scope (const scope_type& x)
    {
      this->scope_.set (x);
    }

    void Event::
    scope (::std::unique_ptr< scope_type > x)
    {
      this->scope_.set (std::move (x));
    }

    const Event::scope_type& Event::
    scope_default_value ()
    {
      return scope_default_value_;
    }

    const Event::external_type& Event::
    external () const
    {
      return this->external_.get ();
    }

    Event::external_type& Event::
    external ()
    {
      return this->external_.get ();
    }

    void Event::
    external (const external_type& x)
    {
      this->external_.set (x);
    }

    Event::external_type Event::
    external_default_value ()
    {
      return external_type (false);
    }


    // Script
    // 

    const Script::name_type& Script::
    name () const
    {
      return this->name_.get ();
    }

    Script::name_type& Script::
    name ()
    {
      return this->name_.get ();
    }

    void Script::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void Script::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }

    const Script::file_type& Script::
    file () const
    {
      return this->file_.get ();
    }

    Script::file_type& Script::
    file ()
    {
      return this->file_.get ();
    }

    void Script::
    file (const file_type& x)
    {
      this->file_.set (x);
    }

    void Script::
    file (::std::unique_ptr< file_type > x)
    {
      this->file_.set (std::move (x));
    }

    const Script::execution_type& Script::
    execution () const
    {
      return this->execution_.get ();
    }

    Script::execution_type& Script::
    execution ()
    {
      return this->execution_.get ();
    }

    void Script::
    execution (const execution_type& x)
    {
      this->execution_.set (x);
    }

    void Script::
    execution (::std::unique_ptr< execution_type > x)
    {
      this->execution_.set (std::move (x));
    }

    const Script::execution_type& Script::
    execution_default_value ()
    {
      return execution_default_value_;
    }

    const Script::language_type& Script::
    language () const
    {
      return this->language_.get ();
    }

    Script::language_type& Script::
    language ()
    {
      return this->language_.get ();
    }

    void Script::
    language (const language_type& x)
    {
      this->language_.set (x);
    }

    void Script::
    language (::std::unique_ptr< language_type > x)
    {
      this->language_.set (std::move (x));
    }

    const Script::scope_type& Script::
    scope () const
    {
      return this->scope_.get ();
    }

    Script::scope_type& Script::
    scope ()
    {
      return this->scope_.get ();
    }

    void Script::
    scope (const scope_type& x)
    {
      this->scope_.set (x);
    }

    void Script::
    scope (::std::unique_ptr< scope_type > x)
    {
      this->scope_.set (std::move (x));
    }

    const Script::scope_type& Script::
    scope_default_value ()
    {
      return scope_default_value_;
    }

    const Script::external_type& Script::
    external () const
    {
      return this->external_.get ();
    }

    Script::external_type& Script::
    external ()
    {
      return this->external_.get ();
    }

    void Script::
    external (const external_type& x)
    {
      this->external_.set (x);
    }

    Script::external_type Script::
    external_default_value ()
    {
      return external_type (false);
    }

    const Script::frequency_type& Script::
    frequency () const
    {
      return this->frequency_.get ();
    }

    Script::frequency_type& Script::
    frequency ()
    {
      return this->frequency_.get ();
    }

    void Script::
    frequency (const frequency_type& x)
    {
      this->frequency_.set (x);
    }

    Script::frequency_type Script::
    frequency_default_value ()
    {
      return frequency_type (1U);
    }


    // Exception
    // 

    const Exception::event_optional& Exception::
    event () const
    {
      return this->event_;
    }

    Exception::event_optional& Exception::
    event ()
    {
      return this->event_;
    }

    void Exception::
    event (const event_type& x)
    {
      this->event_.set (x);
    }

    void Exception::
    event (const event_optional& x)
    {
      this->event_ = x;
    }

    void Exception::
    event (::std::unique_ptr< event_type > x)
    {
      this->event_.set (std::move (x));
    }

    const Exception::script_optional& Exception::
    script () const
    {
      return this->script_;
    }

    Exception::script_optional& Exception::
    script ()
    {
      return this->script_;
    }

    void Exception::
    script (const script_type& x)
    {
      this->script_.set (x);
    }

    void Exception::
    script (const script_optional& x)
    {
      this->script_ = x;
    }

    void Exception::
    script (::std::unique_ptr< script_type > x)
    {
      this->script_.set (std::move (x));
    }


    // VisitParam
    // 

    const VisitParam::path_optional& VisitParam::
    path () const
    {
      return this->path_;
    }

    VisitParam::path_optional& VisitParam::
    path ()
    {
      return this->path_;
    }

    void VisitParam::
    path (const path_type& x)
    {
      this->path_.set (x);
    }

    void VisitParam::
    path (const path_optional& x)
    {
      this->path_ = x;
    }

    void VisitParam::
    path (::std::unique_ptr< path_type > x)
    {
      this->path_.set (std::move (x));
    }

    const VisitParam::options_optional& VisitParam::
    options () const
    {
      return this->options_;
    }

    VisitParam::options_optional& VisitParam::
    options ()
    {
      return this->options_;
    }

    void VisitParam::
    options (const options_type& x)
    {
      this->options_.set (x);
    }

    void VisitParam::
    options (const options_optional& x)
    {
      this->options_ = x;
    }

    void VisitParam::
    options (::std::unique_ptr< options_type > x)
    {
      this->options_.set (std::move (x));
    }

    const VisitParam::update_frequency_type& VisitParam::
    update_frequency () const
    {
      return this->update_frequency_.get ();
    }

    VisitParam::update_frequency_type& VisitParam::
    update_frequency ()
    {
      return this->update_frequency_.get ();
    }

    void VisitParam::
    update_frequency (const update_frequency_type& x)
    {
      this->update_frequency_.set (x);
    }

    VisitParam::update_frequency_type VisitParam::
    update_frequency_default_value ()
    {
      return update_frequency_type (1U);
    }


    // ParaViewParam
    // 

    const ParaViewParam::script_sequence& ParaViewParam::
    script () const
    {
      return this->script_;
    }

    ParaViewParam::script_sequence& ParaViewParam::
    script ()
    {
      return this->script_;
    }

    void ParaViewParam::
    script (const script_sequence& s)
    {
      this->script_ = s;
    }

    const ParaViewParam::update_frequency_type& ParaViewParam::
    update_frequency () const
    {
      return this->update_frequency_.get ();
    }

    ParaViewParam::update_frequency_type& ParaViewParam::
    update_frequency ()
    {
      return this->update_frequency_.get ();
    }

    void ParaViewParam::
    update_frequency (const update_frequency_type& x)
    {
      this->update_frequency_.set (x);
    }

    ParaViewParam::update_frequency_type ParaViewParam::
    update_frequency_default_value ()
    {
      return update_frequency_type (1U);
    }

    const ParaViewParam::realtime_timestep_type& ParaViewParam::
    realtime_timestep () const
    {
      return this->realtime_timestep_.get ();
    }

    ParaViewParam::realtime_timestep_type& ParaViewParam::
    realtime_timestep ()
    {
      return this->realtime_timestep_.get ();
    }

    void ParaViewParam::
    realtime_timestep (const realtime_timestep_type& x)
    {
      this->realtime_timestep_.set (x);
    }

    ParaViewParam::realtime_timestep_type ParaViewParam::
    realtime_timestep_default_value ()
    {
      return realtime_timestep_type (.1);
    }

    const ParaViewParam::end_iteration_type& ParaViewParam::
    end_iteration () const
    {
      return this->end_iteration_.get ();
    }

    ParaViewParam::end_iteration_type& ParaViewParam::
    end_iteration ()
    {
      return this->end_iteration_.get ();
    }

    void ParaViewParam::
    end_iteration (const end_iteration_type& x)
    {
      this->end_iteration_.set (x);
    }

    ParaViewParam::end_iteration_type ParaViewParam::
    end_iteration_default_value ()
    {
      return end_iteration_type (0U);
    }


    // Actions
    // 

    const Actions::event_sequence& Actions::
    event () const
    {
      return this->event_;
    }

    Actions::event_sequence& Actions::
    event ()
    {
      return this->event_;
    }

    void Actions::
    event (const event_sequence& s)
    {
      this->event_ = s;
    }

    const Actions::error_sequence& Actions::
    error () const
    {
      return this->error_;
    }

    Actions::error_sequence& Actions::
    error ()
    {
      return this->error_;
    }

    void Actions::
    error (const error_sequence& s)
    {
      this->error_ = s;
    }


    // Scripts
    // 

    const Scripts::pyscript_sequence& Scripts::
    pyscript () const
    {
      return this->pyscript_;
    }

    Scripts::pyscript_sequence& Scripts::
    pyscript ()
    {
      return this->pyscript_;
    }

    void Scripts::
    pyscript (const pyscript_sequence& s)
    {
      this->pyscript_ = s;
    }


    // StoreType
    // 

    StoreType::
    StoreType (value v)
    : ::xml_schema::string (_xsd_StoreType_literals_[v])
    {
    }

    StoreType::
    StoreType (const char* v)
    : ::xml_schema::string (v)
    {
    }

    StoreType::
    StoreType (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    StoreType::
    StoreType (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    StoreType::
    StoreType (const StoreType& v,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    StoreType& StoreType::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_StoreType_literals_[v]);

      return *this;
    }


    // Store
    // 

    const Store::option_sequence& Store::
    option () const
    {
      return this->option_;
    }

    Store::option_sequence& Store::
    option ()
    {
      return this->option_;
    }

    void Store::
    option (const option_sequence& s)
    {
      this->option_ = s;
    }

    const Store::name_type& Store::
    name () const
    {
      return this->name_.get ();
    }

    Store::name_type& Store::
    name ()
    {
      return this->name_.get ();
    }

    void Store::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void Store::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }

    const Store::type_type& Store::
    type () const
    {
      return this->type_.get ();
    }

    Store::type_type& Store::
    type ()
    {
      return this->type_.get ();
    }

    void Store::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void Store::
    type (::std::unique_ptr< type_type > x)
    {
      this->type_.set (std::move (x));
    }

    const Store::frequency_type& Store::
    frequency () const
    {
      return this->frequency_.get ();
    }

    Store::frequency_type& Store::
    frequency ()
    {
      return this->frequency_.get ();
    }

    void Store::
    frequency (const frequency_type& x)
    {
      this->frequency_.set (x);
    }

    Store::frequency_type Store::
    frequency_default_value ()
    {
      return frequency_type (1U);
    }


    // Storage
    // 

    const Storage::store_sequence& Storage::
    store () const
    {
      return this->store_;
    }

    Storage::store_sequence& Storage::
    store ()
    {
      return this->store_;
    }

    void Storage::
    store (const store_sequence& s)
    {
      this->store_ = s;
    }


    // LogLevelType
    // 

    LogLevelType::
    LogLevelType (value v)
    : ::xml_schema::string (_xsd_LogLevelType_literals_[v])
    {
    }

    LogLevelType::
    LogLevelType (const char* v)
    : ::xml_schema::string (v)
    {
    }

    LogLevelType::
    LogLevelType (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    LogLevelType::
    LogLevelType (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    LogLevelType::
    LogLevelType (const LogLevelType& v,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    LogLevelType& LogLevelType::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_LogLevelType_literals_[v]);

      return *this;
    }


    // Log
    // 

    const Log::FileName_type& Log::
    FileName () const
    {
      return this->FileName_.get ();
    }

    Log::FileName_type& Log::
    FileName ()
    {
      return this->FileName_.get ();
    }

    void Log::
    FileName (const FileName_type& x)
    {
      this->FileName_.set (x);
    }

    void Log::
    FileName (::std::unique_ptr< FileName_type > x)
    {
      this->FileName_.set (std::move (x));
    }

    const Log::RotationSize_type& Log::
    RotationSize () const
    {
      return this->RotationSize_.get ();
    }

    Log::RotationSize_type& Log::
    RotationSize ()
    {
      return this->RotationSize_.get ();
    }

    void Log::
    RotationSize (const RotationSize_type& x)
    {
      this->RotationSize_.set (x);
    }

    const Log::LogFormat_type& Log::
    LogFormat () const
    {
      return this->LogFormat_.get ();
    }

    Log::LogFormat_type& Log::
    LogFormat ()
    {
      return this->LogFormat_.get ();
    }

    void Log::
    LogFormat (const LogFormat_type& x)
    {
      this->LogFormat_.set (x);
    }

    void Log::
    LogFormat (::std::unique_ptr< LogFormat_type > x)
    {
      this->LogFormat_.set (std::move (x));
    }

    const Log::LogLevel_type& Log::
    LogLevel () const
    {
      return this->LogLevel_.get ();
    }

    Log::LogLevel_type& Log::
    LogLevel ()
    {
      return this->LogLevel_.get ();
    }

    void Log::
    LogLevel (const LogLevel_type& x)
    {
      this->LogLevel_.set (x);
    }

    void Log::
    LogLevel (::std::unique_ptr< LogLevel_type > x)
    {
      this->LogLevel_.set (std::move (x));
    }

    const Log::LogLevel_type& Log::
    LogLevel_default_value ()
    {
      return LogLevel_default_value_;
    }

    const Log::Flush_type& Log::
    Flush () const
    {
      return this->Flush_.get ();
    }

    Log::Flush_type& Log::
    Flush ()
    {
      return this->Flush_.get ();
    }

    void Log::
    Flush (const Flush_type& x)
    {
      this->Flush_.set (x);
    }

    Log::Flush_type Log::
    Flush_default_value ()
    {
      return Flush_type (false);
    }


    // Simulation
    // 

    const Simulation::architecture_type& Simulation::
    architecture () const
    {
      return this->architecture_.get ();
    }

    Simulation::architecture_type& Simulation::
    architecture ()
    {
      return this->architecture_.get ();
    }

    void Simulation::
    architecture (const architecture_type& x)
    {
      this->architecture_.set (x);
    }

    void Simulation::
    architecture (::std::unique_ptr< architecture_type > x)
    {
      this->architecture_.set (std::move (x));
    }

    const Simulation::data_type& Simulation::
    data () const
    {
      return this->data_.get ();
    }

    Simulation::data_type& Simulation::
    data ()
    {
      return this->data_.get ();
    }

    void Simulation::
    data (const data_type& x)
    {
      this->data_.set (x);
    }

    void Simulation::
    data (::std::unique_ptr< data_type > x)
    {
      this->data_.set (std::move (x));
    }

    const Simulation::storage_optional& Simulation::
    storage () const
    {
      return this->storage_;
    }

    Simulation::storage_optional& Simulation::
    storage ()
    {
      return this->storage_;
    }

    void Simulation::
    storage (const storage_type& x)
    {
      this->storage_.set (x);
    }

    void Simulation::
    storage (const storage_optional& x)
    {
      this->storage_ = x;
    }

    void Simulation::
    storage (::std::unique_ptr< storage_type > x)
    {
      this->storage_.set (std::move (x));
    }

    const Simulation::actions_optional& Simulation::
    actions () const
    {
      return this->actions_;
    }

    Simulation::actions_optional& Simulation::
    actions ()
    {
      return this->actions_;
    }

    void Simulation::
    actions (const actions_type& x)
    {
      this->actions_.set (x);
    }

    void Simulation::
    actions (const actions_optional& x)
    {
      this->actions_ = x;
    }

    void Simulation::
    actions (::std::unique_ptr< actions_type > x)
    {
      this->actions_.set (std::move (x));
    }

    const Simulation::scripts_optional& Simulation::
    scripts () const
    {
      return this->scripts_;
    }

    Simulation::scripts_optional& Simulation::
    scripts ()
    {
      return this->scripts_;
    }

    void Simulation::
    scripts (const scripts_type& x)
    {
      this->scripts_.set (x);
    }

    void Simulation::
    scripts (const scripts_optional& x)
    {
      this->scripts_ = x;
    }

    void Simulation::
    scripts (::std::unique_ptr< scripts_type > x)
    {
      this->scripts_.set (std::move (x));
    }

    const Simulation::visit_optional& Simulation::
    visit () const
    {
      return this->visit_;
    }

    Simulation::visit_optional& Simulation::
    visit ()
    {
      return this->visit_;
    }

    void Simulation::
    visit (const visit_type& x)
    {
      this->visit_.set (x);
    }

    void Simulation::
    visit (const visit_optional& x)
    {
      this->visit_ = x;
    }

    void Simulation::
    visit (::std::unique_ptr< visit_type > x)
    {
      this->visit_.set (std::move (x));
    }

    const Simulation::paraview_optional& Simulation::
    paraview () const
    {
      return this->paraview_;
    }

    Simulation::paraview_optional& Simulation::
    paraview ()
    {
      return this->paraview_;
    }

    void Simulation::
    paraview (const paraview_type& x)
    {
      this->paraview_.set (x);
    }

    void Simulation::
    paraview (const paraview_optional& x)
    {
      this->paraview_ = x;
    }

    void Simulation::
    paraview (::std::unique_ptr< paraview_type > x)
    {
      this->paraview_.set (std::move (x));
    }

    const Simulation::log_optional& Simulation::
    log () const
    {
      return this->log_;
    }

    Simulation::log_optional& Simulation::
    log ()
    {
      return this->log_;
    }

    void Simulation::
    log (const log_type& x)
    {
      this->log_.set (x);
    }

    void Simulation::
    log (const log_optional& x)
    {
      this->log_ = x;
    }

    void Simulation::
    log (::std::unique_ptr< log_type > x)
    {
      this->log_.set (std::move (x));
    }

    const Simulation::name_type& Simulation::
    name () const
    {
      return this->name_.get ();
    }

    Simulation::name_type& Simulation::
    name ()
    {
      return this->name_.get ();
    }

    void Simulation::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void Simulation::
    name (::std::unique_ptr< name_type > x)
    {
      this->name_.set (std::move (x));
    }

    const Simulation::language_type& Simulation::
    language () const
    {
      return this->language_.get ();
    }

    Simulation::language_type& Simulation::
    language ()
    {
      return this->language_.get ();
    }

    void Simulation::
    language (const language_type& x)
    {
      this->language_.set (x);
    }

    void Simulation::
    language (::std::unique_ptr< language_type > x)
    {
      this->language_.set (std::move (x));
    }

    const Simulation::language_type& Simulation::
    language_default_value ()
    {
      return language_default_value_;
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace damaris
{
  namespace model
  {
    // DeprecatedClients
    //

    DeprecatedClients::
    DeprecatedClients (const count_type& count)
    : ::xml_schema::type (),
      count_ (count, this),
      domains_ (domains_default_value (), this)
    {
    }

    DeprecatedClients::
    DeprecatedClients (const DeprecatedClients& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      count_ (x.count_, f, this),
      domains_ (x.domains_, f, this)
    {
    }

    DeprecatedClients::
    DeprecatedClients (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      count_ (this),
      domains_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void DeprecatedClients::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "count" && n.namespace_ ().empty ())
        {
          this->count_.set (count_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "domains" && n.namespace_ ().empty ())
        {
          this->domains_.set (domains_traits::create (i, f, this));
          continue;
        }
      }

      if (!count_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "count",
          "");
      }

      if (!domains_.present ())
      {
        this->domains_.set (domains_default_value ());
      }
    }

    DeprecatedClients* DeprecatedClients::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DeprecatedClients (*this, f, c);
    }

    DeprecatedClients& DeprecatedClients::
    operator= (const DeprecatedClients& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->count_ = x.count_;
        this->domains_ = x.domains_;
      }

      return *this;
    }

    DeprecatedClients::
    ~DeprecatedClients ()
    {
    }

    // DeprecatedCores
    //

    DeprecatedCores::
    DeprecatedCores (const clients_type& clients,
                     const count_type& count)
    : ::xml_schema::type (),
      clients_ (clients, this),
      count_ (count, this)
    {
    }

    DeprecatedCores::
    DeprecatedCores (::std::unique_ptr< clients_type > clients,
                     const count_type& count)
    : ::xml_schema::type (),
      clients_ (std::move (clients), this),
      count_ (count, this)
    {
    }

    DeprecatedCores::
    DeprecatedCores (const DeprecatedCores& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      clients_ (x.clients_, f, this),
      count_ (x.count_, f, this)
    {
    }

    DeprecatedCores::
    DeprecatedCores (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      clients_ (this),
      count_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DeprecatedCores::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // clients
        //
        if (n.name () == "clients" && n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
        {
          ::std::unique_ptr< clients_type > r (
            clients_traits::create (i, f, this));

          if (!clients_.present ())
          {
            this->clients_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!clients_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "clients",
          "http://damaris.gforge.inria.fr/damaris/model");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "count" && n.namespace_ ().empty ())
        {
          this->count_.set (count_traits::create (i, f, this));
          continue;
        }
      }

      if (!count_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "count",
          "");
      }
    }

    DeprecatedCores* DeprecatedCores::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DeprecatedCores (*this, f, c);
    }

    DeprecatedCores& DeprecatedCores::
    operator= (const DeprecatedCores& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->clients_ = x.clients_;
        this->count_ = x.count_;
      }

      return *this;
    }

    DeprecatedCores::
    ~DeprecatedCores ()
    {
    }

    // KeyVal
    //

    KeyVal::
    KeyVal ()
    : ::xml_schema::string (),
      key_ (this)
    {
    }

    KeyVal::
    KeyVal (const char* _xsd_string_base)
    : ::xml_schema::string (_xsd_string_base),
      key_ (this)
    {
    }

    KeyVal::
    KeyVal (const ::std::string& _xsd_string_base)
    : ::xml_schema::string (_xsd_string_base),
      key_ (this)
    {
    }

    KeyVal::
    KeyVal (const ::xml_schema::string& _xsd_string_base)
    : ::xml_schema::string (_xsd_string_base),
      key_ (this)
    {
    }

    KeyVal::
    KeyVal (const KeyVal& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c),
      key_ (x.key_, f, this)
    {
    }

    KeyVal::
    KeyVal (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
      key_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void KeyVal::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "key" && n.namespace_ ().empty ())
        {
          this->key_.set (key_traits::create (i, f, this));
          continue;
        }
      }
    }

    KeyVal* KeyVal::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class KeyVal (*this, f, c);
    }

    KeyVal& KeyVal::
    operator= (const KeyVal& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::string& > (*this) = x;
        this->key_ = x.key_;
      }

      return *this;
    }

    KeyVal::
    ~KeyVal ()
    {
    }

    // Dedicated
    //

    Dedicated::
    Dedicated ()
    : ::xml_schema::type (),
      cores_ (cores_default_value (), this),
      nodes_ (nodes_default_value (), this)
    {
    }

    Dedicated::
    Dedicated (const Dedicated& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      cores_ (x.cores_, f, this),
      nodes_ (x.nodes_, f, this)
    {
    }

    Dedicated::
    Dedicated (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      cores_ (this),
      nodes_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void Dedicated::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "cores" && n.namespace_ ().empty ())
        {
          this->cores_.set (cores_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "nodes" && n.namespace_ ().empty ())
        {
          this->nodes_.set (nodes_traits::create (i, f, this));
          continue;
        }
      }

      if (!cores_.present ())
      {
        this->cores_.set (cores_default_value ());
      }

      if (!nodes_.present ())
      {
        this->nodes_.set (nodes_default_value ());
      }
    }

    Dedicated* Dedicated::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Dedicated (*this, f, c);
    }

    Dedicated& Dedicated::
    operator= (const Dedicated& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->cores_ = x.cores_;
        this->nodes_ = x.nodes_;
      }

      return *this;
    }

    Dedicated::
    ~Dedicated ()
    {
    }

    // Domains
    //

    Domains::
    Domains ()
    : ::xml_schema::type (),
      count_ (count_default_value (), this)
    {
    }

    Domains::
    Domains (const Domains& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      count_ (x.count_, f, this)
    {
    }

    Domains::
    Domains (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      count_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void Domains::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "count" && n.namespace_ ().empty ())
        {
          this->count_.set (count_traits::create (i, f, this));
          continue;
        }
      }

      if (!count_.present ())
      {
        this->count_.set (count_default_value ());
      }
    }

    Domains* Domains::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Domains (*this, f, c);
    }

    Domains& Domains::
    operator= (const Domains& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->count_ = x.count_;
      }

      return *this;
    }

    Domains::
    ~Domains ()
    {
    }

    // Placement
    //

    const Placement::mask_type Placement::mask_default_value_ (
      "");

    Placement::
    Placement ()
    : ::xml_schema::type (),
      mask_ (mask_default_value (), this),
      start_ (start_default_value (), this),
      step_ (step_default_value (), this),
      blocksize_ (blocksize_default_value (), this),
      comment_ (this)
    {
    }

    Placement::
    Placement (const Placement& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      mask_ (x.mask_, f, this),
      start_ (x.start_, f, this),
      step_ (x.step_, f, this),
      blocksize_ (x.blocksize_, f, this),
      comment_ (x.comment_, f, this)
    {
    }

    Placement::
    Placement (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      mask_ (this),
      start_ (this),
      step_ (this),
      blocksize_ (this),
      comment_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void Placement::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "mask" && n.namespace_ ().empty ())
        {
          this->mask_.set (mask_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "start" && n.namespace_ ().empty ())
        {
          this->start_.set (start_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "step" && n.namespace_ ().empty ())
        {
          this->step_.set (step_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "blocksize" && n.namespace_ ().empty ())
        {
          this->blocksize_.set (blocksize_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "comment" && n.namespace_ ().empty ())
        {
          this->comment_.set (comment_traits::create (i, f, this));
          continue;
        }
      }

      if (!mask_.present ())
      {
        this->mask_.set (mask_default_value ());
      }

      if (!start_.present ())
      {
        this->start_.set (start_default_value ());
      }

      if (!step_.present ())
      {
        this->step_.set (step_default_value ());
      }

      if (!blocksize_.present ())
      {
        this->blocksize_.set (blocksize_default_value ());
      }
    }

    Placement* Placement::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Placement (*this, f, c);
    }

    Placement& Placement::
    operator= (const Placement& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->mask_ = x.mask_;
        this->start_ = x.start_;
        this->step_ = x.step_;
        this->blocksize_ = x.blocksize_;
        this->comment_ = x.comment_;
      }

      return *this;
    }

    Placement::
    ~Placement ()
    {
    }

    // ShmType
    //

    ShmType::
    ShmType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_ShmType_convert ();
    }

    ShmType::
    ShmType (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_ShmType_convert ();
    }

    ShmType::
    ShmType (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_ShmType_convert ();
    }

    ShmType* ShmType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ShmType (*this, f, c);
    }

    ShmType::value ShmType::
    _xsd_ShmType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ShmType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ShmType_indexes_,
                        _xsd_ShmType_indexes_ + 2,
                        *this,
                        c));

      if (i == _xsd_ShmType_indexes_ + 2 || _xsd_ShmType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const ShmType::
    _xsd_ShmType_literals_[2] =
    {
      "posix",
      "sysv"
    };

    const ShmType::value ShmType::
    _xsd_ShmType_indexes_[2] =
    {
      ::damaris::model::ShmType::posix,
      ::damaris::model::ShmType::sysv
    };

    // Buffer
    //

    const Buffer::type_type Buffer::type_default_value_ (
      "posix");

    Buffer::
    Buffer (const name_type& name,
            const size_type& size)
    : ::xml_schema::type (),
      name_ (name, this),
      size_ (size, this),
      type_ (type_default_value (), this),
      blocks_ (blocks_default_value (), this),
      enabled_ (enabled_default_value (), this)
    {
    }

    Buffer::
    Buffer (const Buffer& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      name_ (x.name_, f, this),
      size_ (x.size_, f, this),
      type_ (x.type_, f, this),
      blocks_ (x.blocks_, f, this),
      enabled_ (x.enabled_, f, this)
    {
    }

    Buffer::
    Buffer (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      name_ (this),
      size_ (this),
      type_ (this),
      blocks_ (this),
      enabled_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void Buffer::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (name_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "size" && n.namespace_ ().empty ())
        {
          this->size_.set (size_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (type_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "blocks" && n.namespace_ ().empty ())
        {
          this->blocks_.set (blocks_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "enabled" && n.namespace_ ().empty ())
        {
          this->enabled_.set (enabled_traits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }

      if (!size_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "size",
          "");
      }

      if (!type_.present ())
      {
        this->type_.set (type_default_value ());
      }

      if (!blocks_.present ())
      {
        this->blocks_.set (blocks_default_value ());
      }

      if (!enabled_.present ())
      {
        this->enabled_.set (enabled_default_value ());
      }
    }

    Buffer* Buffer::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Buffer (*this, f, c);
    }

    Buffer& Buffer::
    operator= (const Buffer& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->name_ = x.name_;
        this->size_ = x.size_;
        this->type_ = x.type_;
        this->blocks_ = x.blocks_;
        this->enabled_ = x.enabled_;
      }

      return *this;
    }

    Buffer::
    ~Buffer ()
    {
    }

    // Queue
    //

    Queue::
    Queue (const name_type& name,
           const size_type& size)
    : ::xml_schema::type (),
      name_ (name, this),
      size_ (size, this)
    {
    }

    Queue::
    Queue (const Queue& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      name_ (x.name_, f, this),
      size_ (x.size_, f, this)
    {
    }

    Queue::
    Queue (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      name_ (this),
      size_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void Queue::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (name_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "size" && n.namespace_ ().empty ())
        {
          this->size_.set (size_traits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }

      if (!size_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "size",
          "");
      }
    }

    Queue* Queue::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Queue (*this, f, c);
    }

    Queue& Queue::
    operator= (const Queue& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->name_ = x.name_;
        this->size_ = x.size_;
      }

      return *this;
    }

    Queue::
    ~Queue ()
    {
    }

    // Architecture
    //

    Architecture::
    Architecture (const domains_type& domains,
                  const dedicated_type& dedicated,
                  const placement_type& placement,
                  const buffer_type& buffer,
                  const queue_type& queue)
    : ::xml_schema::type (),
      domains_ (domains, this),
      dedicated_ (dedicated, this),
      placement_ (placement, this),
      buffer_ (buffer, this),
      queue_ (queue, this),
      name_ (this)
    {
    }

    Architecture::
    Architecture (::std::unique_ptr< domains_type > domains,
                  ::std::unique_ptr< dedicated_type > dedicated,
                  ::std::unique_ptr< placement_type > placement,
                  ::std::unique_ptr< buffer_type > buffer,
                  ::std::unique_ptr< queue_type > queue)
    : ::xml_schema::type (),
      domains_ (std::move (domains), this),
      dedicated_ (std::move (dedicated), this),
      placement_ (std::move (placement), this),
      buffer_ (std::move (buffer), this),
      queue_ (std::move (queue), this),
      name_ (this)
    {
    }

    Architecture::
    Architecture (const Architecture& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      domains_ (x.domains_, f, this),
      dedicated_ (x.dedicated_, f, this),
      placement_ (x.placement_, f, this),
      buffer_ (x.buffer_, f, this),
      queue_ (x.queue_, f, this),
      name_ (x.name_, f, this)
    {
    }

    Architecture::
    Architecture (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      domains_ (this),
      dedicated_ (this),
      placement_ (this),
      buffer_ (this),
      queue_ (this),
      name_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Architecture::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // domains
        //
        if (n.name () == "domains" && n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
        {
          ::std::unique_ptr< domains_type > r (
            domains_traits::create (i, f, this));

          if (!domains_.present ())
          {
            this->domains_.set (::std::move (r));
            continue;
          }
        }

        // dedicated
        //
        if (n.name () == "dedicated" && n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
        {
          ::std::unique_ptr< dedicated_type > r (
            dedicated_traits::create (i, f, this));

          if (!dedicated_.present ())
          {
            this->dedicated_.set (::std::move (r));
            continue;
          }
        }

        // placement
        //
        if (n.name () == "placement" && n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
        {
          ::std::unique_ptr< placement_type > r (
            placement_traits::create (i, f, this));

          if (!placement_.present ())
          {
            this->placement_.set (::std::move (r));
            continue;
          }
        }

        // buffer
        //
        if (n.name () == "buffer" && n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
        {
          ::std::unique_ptr< buffer_type > r (
            buffer_traits::create (i, f, this));

          if (!buffer_.present ())
          {
            this->buffer_.set (::std::move (r));
            continue;
          }
        }

        // queue
        //
        if (n.name () == "queue" && n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
        {
          ::std::unique_ptr< queue_type > r (
            queue_traits::create (i, f, this));

          if (!queue_.present ())
          {
            this->queue_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!domains_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "domains",
          "http://damaris.gforge.inria.fr/damaris/model");
      }

      if (!dedicated_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "dedicated",
          "http://damaris.gforge.inria.fr/damaris/model");
      }

      if (!placement_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "placement",
          "http://damaris.gforge.inria.fr/damaris/model");
      }

      if (!buffer_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "buffer",
          "http://damaris.gforge.inria.fr/damaris/model");
      }

      if (!queue_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "queue",
          "http://damaris.gforge.inria.fr/damaris/model");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (name_traits::create (i, f, this));
          continue;
        }
      }
    }

    Architecture* Architecture::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Architecture (*this, f, c);
    }

    Architecture& Architecture::
    operator= (const Architecture& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->domains_ = x.domains_;
        this->dedicated_ = x.dedicated_;
        this->placement_ = x.placement_;
        this->buffer_ = x.buffer_;
        this->queue_ = x.queue_;
        this->name_ = x.name_;
      }

      return *this;
    }

    Architecture::
    ~Architecture ()
    {
    }

    // Language
    //

    Language::
    Language (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_Language_convert ();
    }

    Language::
    Language (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_Language_convert ();
    }

    Language::
    Language (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_Language_convert ();
    }

    Language* Language::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Language (*this, f, c);
    }

    Language::value Language::
    _xsd_Language_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_Language_literals_);
      const value* i (::std::lower_bound (
                        _xsd_Language_indexes_,
                        _xsd_Language_indexes_ + 6,
                        *this,
                        c));

      if (i == _xsd_Language_indexes_ + 6 || _xsd_Language_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const Language::
    _xsd_Language_literals_[6] =
    {
      "unknown",
      "fortran",
      "c",
      "cpp",
      "python",
      "r"
    };

    const Language::value Language::
    _xsd_Language_indexes_[6] =
    {
      ::damaris::model::Language::c,
      ::damaris::model::Language::cpp,
      ::damaris::model::Language::fortran,
      ::damaris::model::Language::python,
      ::damaris::model::Language::r,
      ::damaris::model::Language::unknown
    };

    // Type
    //

    Type::
    Type (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_Type_convert ();
    }

    Type::
    Type (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_Type_convert ();
    }

    Type::
    Type (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_Type_convert ();
    }

    Type* Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Type (*this, f, c);
    }

    Type::value Type::
    _xsd_Type_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_Type_literals_);
      const value* i (::std::lower_bound (
                        _xsd_Type_indexes_,
                        _xsd_Type_indexes_ + 12,
                        *this,
                        c));

      if (i == _xsd_Type_indexes_ + 12 || _xsd_Type_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const Type::
    _xsd_Type_literals_[12] =
    {
      "short",
      "int",
      "integer",
      "long",
      "float",
      "real",
      "double",
      "char",
      "character",
      "string",
      "label",
      "undefined"
    };

    const Type::value Type::
    _xsd_Type_indexes_[12] =
    {
      ::damaris::model::Type::char_,
      ::damaris::model::Type::character,
      ::damaris::model::Type::double_,
      ::damaris::model::Type::float_,
      ::damaris::model::Type::int_,
      ::damaris::model::Type::integer,
      ::damaris::model::Type::label,
      ::damaris::model::Type::long_,
      ::damaris::model::Type::real,
      ::damaris::model::Type::short_,
      ::damaris::model::Type::string,
      ::damaris::model::Type::undefined
    };

    // Layout
    //

    const Layout::global_type Layout::global_default_value_ (
      "#");

    const Layout::ghosts_type Layout::ghosts_default_value_ (
      "#");

    const Layout::language_type Layout::language_default_value_ (
      "unknown");

    Layout::
    Layout (const name_type& name,
            const type_type& type,
            const dimensions_type& dimensions)
    : ::xml_schema::string (),
      name_ (name, this),
      type_ (type, this),
      dimensions_ (dimensions, this),
      global_ (global_default_value (), this),
      ghosts_ (ghosts_default_value (), this),
      language_ (language_default_value (), this),
      visualizable_ (visualizable_default_value (), this),
      comment_ (this)
    {
    }

    Layout::
    Layout (const char* _xsd_string_base,
            const name_type& name,
            const type_type& type,
            const dimensions_type& dimensions)
    : ::xml_schema::string (_xsd_string_base),
      name_ (name, this),
      type_ (type, this),
      dimensions_ (dimensions, this),
      global_ (global_default_value (), this),
      ghosts_ (ghosts_default_value (), this),
      language_ (language_default_value (), this),
      visualizable_ (visualizable_default_value (), this),
      comment_ (this)
    {
    }

    Layout::
    Layout (const ::std::string& _xsd_string_base,
            const name_type& name,
            const type_type& type,
            const dimensions_type& dimensions)
    : ::xml_schema::string (_xsd_string_base),
      name_ (name, this),
      type_ (type, this),
      dimensions_ (dimensions, this),
      global_ (global_default_value (), this),
      ghosts_ (ghosts_default_value (), this),
      language_ (language_default_value (), this),
      visualizable_ (visualizable_default_value (), this),
      comment_ (this)
    {
    }

    Layout::
    Layout (const ::xml_schema::string& _xsd_string_base,
            const name_type& name,
            const type_type& type,
            const dimensions_type& dimensions)
    : ::xml_schema::string (_xsd_string_base),
      name_ (name, this),
      type_ (type, this),
      dimensions_ (dimensions, this),
      global_ (global_default_value (), this),
      ghosts_ (ghosts_default_value (), this),
      language_ (language_default_value (), this),
      visualizable_ (visualizable_default_value (), this),
      comment_ (this)
    {
    }

    Layout::
    Layout (const Layout& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c),
      name_ (x.name_, f, this),
      type_ (x.type_, f, this),
      dimensions_ (x.dimensions_, f, this),
      global_ (x.global_, f, this),
      ghosts_ (x.ghosts_, f, this),
      language_ (x.language_, f, this),
      visualizable_ (x.visualizable_, f, this),
      comment_ (x.comment_, f, this)
    {
    }

    Layout::
    Layout (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
      name_ (this),
      type_ (this),
      dimensions_ (this),
      global_ (this),
      ghosts_ (this),
      language_ (this),
      visualizable_ (this),
      comment_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void Layout::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (name_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (type_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "dimensions" && n.namespace_ ().empty ())
        {
          this->dimensions_.set (dimensions_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "global" && n.namespace_ ().empty ())
        {
          this->global_.set (global_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "ghosts" && n.namespace_ ().empty ())
        {
          this->ghosts_.set (ghosts_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "language" && n.namespace_ ().empty ())
        {
          this->language_.set (language_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "visualizable" && n.namespace_ ().empty ())
        {
          this->visualizable_.set (visualizable_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "comment" && n.namespace_ ().empty ())
        {
          this->comment_.set (comment_traits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }

      if (!type_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "type",
          "");
      }

      if (!dimensions_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "dimensions",
          "");
      }

      if (!global_.present ())
      {
        this->global_.set (global_default_value ());
      }

      if (!ghosts_.present ())
      {
        this->ghosts_.set (ghosts_default_value ());
      }

      if (!language_.present ())
      {
        this->language_.set (language_default_value ());
      }

      if (!visualizable_.present ())
      {
        this->visualizable_.set (visualizable_default_value ());
      }
    }

    Layout* Layout::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Layout (*this, f, c);
    }

    Layout& Layout::
    operator= (const Layout& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::string& > (*this) = x;
        this->name_ = x.name_;
        this->type_ = x.type_;
        this->dimensions_ = x.dimensions_;
        this->global_ = x.global_;
        this->ghosts_ = x.ghosts_;
        this->language_ = x.language_;
        this->visualizable_ = x.visualizable_;
        this->comment_ = x.comment_;
      }

      return *this;
    }

    Layout::
    ~Layout ()
    {
    }

    // VarType
    //

    VarType::
    VarType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_VarType_convert ();
    }

    VarType::
    VarType (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_VarType_convert ();
    }

    VarType::
    VarType (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_VarType_convert ();
    }

    VarType* VarType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class VarType (*this, f, c);
    }

    VarType::value VarType::
    _xsd_VarType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_VarType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_VarType_indexes_,
                        _xsd_VarType_indexes_ + 10,
                        *this,
                        c));

      if (i == _xsd_VarType_indexes_ + 10 || _xsd_VarType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const VarType::
    _xsd_VarType_literals_[10] =
    {
      "scalar",
      "vector",
      "tensor",
      "symmetric-tensor",
      "material",
      "matspecies",
      "label",
      "array",
      "mesh",
      "curve"
    };

    const VarType::value VarType::
    _xsd_VarType_indexes_[10] =
    {
      ::damaris::model::VarType::array,
      ::damaris::model::VarType::curve,
      ::damaris::model::VarType::label,
      ::damaris::model::VarType::material,
      ::damaris::model::VarType::matspecies,
      ::damaris::model::VarType::mesh,
      ::damaris::model::VarType::scalar,
      ::damaris::model::VarType::symmetric_tensor,
      ::damaris::model::VarType::tensor,
      ::damaris::model::VarType::vector
    };

    // VarCentering
    //

    VarCentering::
    VarCentering (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_VarCentering_convert ();
    }

    VarCentering::
    VarCentering (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_VarCentering_convert ();
    }

    VarCentering::
    VarCentering (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_VarCentering_convert ();
    }

    VarCentering* VarCentering::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class VarCentering (*this, f, c);
    }

    VarCentering::value VarCentering::
    _xsd_VarCentering_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_VarCentering_literals_);
      const value* i (::std::lower_bound (
                        _xsd_VarCentering_indexes_,
                        _xsd_VarCentering_indexes_ + 2,
                        *this,
                        c));

      if (i == _xsd_VarCentering_indexes_ + 2 || _xsd_VarCentering_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const VarCentering::
    _xsd_VarCentering_literals_[2] =
    {
      "nodal",
      "zonal"
    };

    const VarCentering::value VarCentering::
    _xsd_VarCentering_indexes_[2] =
    {
      ::damaris::model::VarCentering::nodal,
      ::damaris::model::VarCentering::zonal
    };

    // Variable
    //

    const Variable::unit_type Variable::unit_default_value_ (
      "");

    const Variable::mesh_type Variable::mesh_default_value_ (
      "#");

    const Variable::type_type Variable::type_default_value_ (
      "scalar");

    const Variable::centering_type Variable::centering_default_value_ (
      "zonal");

    const Variable::store_type Variable::store_default_value_ (
      "#");

    const Variable::script_type Variable::script_default_value_ (
      "#");

    Variable::
    Variable (const name_type& name,
              const layout_type& layout)
    : ::xml_schema::string (),
      name_ (name, this),
      unit_ (unit_default_value (), this),
      layout_ (layout, this),
      enabled_ (enabled_default_value (), this),
      mesh_ (mesh_default_value (), this),
      type_ (type_default_value (), this),
      vectorlength_ (vectorlength_default_value (), this),
      centering_ (centering_default_value (), this),
      visualizable_ (visualizable_default_value (), this),
      time_varying_ (time_varying_default_value (), this),
      store_ (store_default_value (), this),
      script_ (script_default_value (), this),
      comment_ (this)
    {
    }

    Variable::
    Variable (const char* _xsd_string_base,
              const name_type& name,
              const layout_type& layout)
    : ::xml_schema::string (_xsd_string_base),
      name_ (name, this),
      unit_ (unit_default_value (), this),
      layout_ (layout, this),
      enabled_ (enabled_default_value (), this),
      mesh_ (mesh_default_value (), this),
      type_ (type_default_value (), this),
      vectorlength_ (vectorlength_default_value (), this),
      centering_ (centering_default_value (), this),
      visualizable_ (visualizable_default_value (), this),
      time_varying_ (time_varying_default_value (), this),
      store_ (store_default_value (), this),
      script_ (script_default_value (), this),
      comment_ (this)
    {
    }

    Variable::
    Variable (const ::std::string& _xsd_string_base,
              const name_type& name,
              const layout_type& layout)
    : ::xml_schema::string (_xsd_string_base),
      name_ (name, this),
      unit_ (unit_default_value (), this),
      layout_ (layout, this),
      enabled_ (enabled_default_value (), this),
      mesh_ (mesh_default_value (), this),
      type_ (type_default_value (), this),
      vectorlength_ (vectorlength_default_value (), this),
      centering_ (centering_default_value (), this),
      visualizable_ (visualizable_default_value (), this),
      time_varying_ (time_varying_default_value (), this),
      store_ (store_default_value (), this),
      script_ (script_default_value (), this),
      comment_ (this)
    {
    }

    Variable::
    Variable (const ::xml_schema::string& _xsd_string_base,
              const name_type& name,
              const layout_type& layout)
    : ::xml_schema::string (_xsd_string_base),
      name_ (name, this),
      unit_ (unit_default_value (), this),
      layout_ (layout, this),
      enabled_ (enabled_default_value (), this),
      mesh_ (mesh_default_value (), this),
      type_ (type_default_value (), this),
      vectorlength_ (vectorlength_default_value (), this),
      centering_ (centering_default_value (), this),
      visualizable_ (visualizable_default_value (), this),
      time_varying_ (time_varying_default_value (), this),
      store_ (store_default_value (), this),
      script_ (script_default_value (), this),
      comment_ (this)
    {
    }

    Variable::
    Variable (const Variable& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c),
      name_ (x.name_, f, this),
      unit_ (x.unit_, f, this),
      layout_ (x.layout_, f, this),
      enabled_ (x.enabled_, f, this),
      mesh_ (x.mesh_, f, this),
      type_ (x.type_, f, this),
      vectorlength_ (x.vectorlength_, f, this),
      centering_ (x.centering_, f, this),
      visualizable_ (x.visualizable_, f, this),
      time_varying_ (x.time_varying_, f, this),
      store_ (x.store_, f, this),
      script_ (x.script_, f, this),
      comment_ (x.comment_, f, this)
    {
    }

    Variable::
    Variable (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
      name_ (this),
      unit_ (this),
      layout_ (this),
      enabled_ (this),
      mesh_ (this),
      type_ (this),
      vectorlength_ (this),
      centering_ (this),
      visualizable_ (this),
      time_varying_ (this),
      store_ (this),
      script_ (this),
      comment_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void Variable::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (name_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "unit" && n.namespace_ ().empty ())
        {
          this->unit_.set (unit_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "layout" && n.namespace_ ().empty ())
        {
          this->layout_.set (layout_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "enabled" && n.namespace_ ().empty ())
        {
          this->enabled_.set (enabled_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "mesh" && n.namespace_ ().empty ())
        {
          this->mesh_.set (mesh_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (type_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "vectorlength" && n.namespace_ ().empty ())
        {
          this->vectorlength_.set (vectorlength_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "centering" && n.namespace_ ().empty ())
        {
          this->centering_.set (centering_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "visualizable" && n.namespace_ ().empty ())
        {
          this->visualizable_.set (visualizable_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "time-varying" && n.namespace_ ().empty ())
        {
          this->time_varying_.set (time_varying_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "store" && n.namespace_ ().empty ())
        {
          this->store_.set (store_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "script" && n.namespace_ ().empty ())
        {
          this->script_.set (script_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "comment" && n.namespace_ ().empty ())
        {
          this->comment_.set (comment_traits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }

      if (!unit_.present ())
      {
        this->unit_.set (unit_default_value ());
      }

      if (!layout_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "layout",
          "");
      }

      if (!enabled_.present ())
      {
        this->enabled_.set (enabled_default_value ());
      }

      if (!mesh_.present ())
      {
        this->mesh_.set (mesh_default_value ());
      }

      if (!type_.present ())
      {
        this->type_.set (type_default_value ());
      }

      if (!vectorlength_.present ())
      {
        this->vectorlength_.set (vectorlength_default_value ());
      }

      if (!centering_.present ())
      {
        this->centering_.set (centering_default_value ());
      }

      if (!visualizable_.present ())
      {
        this->visualizable_.set (visualizable_default_value ());
      }

      if (!time_varying_.present ())
      {
        this->time_varying_.set (time_varying_default_value ());
      }

      if (!store_.present ())
      {
        this->store_.set (store_default_value ());
      }

      if (!script_.present ())
      {
        this->script_.set (script_default_value ());
      }
    }

    Variable* Variable::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Variable (*this, f, c);
    }

    Variable& Variable::
    operator= (const Variable& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::string& > (*this) = x;
        this->name_ = x.name_;
        this->unit_ = x.unit_;
        this->layout_ = x.layout_;
        this->enabled_ = x.enabled_;
        this->mesh_ = x.mesh_;
        this->type_ = x.type_;
        this->vectorlength_ = x.vectorlength_;
        this->centering_ = x.centering_;
        this->visualizable_ = x.visualizable_;
        this->time_varying_ = x.time_varying_;
        this->store_ = x.store_;
        this->script_ = x.script_;
        this->comment_ = x.comment_;
      }

      return *this;
    }

    Variable::
    ~Variable ()
    {
    }

    // Group
    //

    const Group::store_type Group::store_default_value_ (
      "#");

    Group::
    Group (const name_type& name)
    : ::xml_schema::type (),
      layout_ (this),
      variable_ (this),
      group_ (this),
      mesh_ (this),
      curve_ (this),
      name_ (name, this),
      enabled_ (enabled_default_value (), this),
      store_ (store_default_value (), this)
    {
    }

    Group::
    Group (const Group& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      layout_ (x.layout_, f, this),
      variable_ (x.variable_, f, this),
      group_ (x.group_, f, this),
      mesh_ (x.mesh_, f, this),
      curve_ (x.curve_, f, this),
      name_ (x.name_, f, this),
      enabled_ (x.enabled_, f, this),
      store_ (x.store_, f, this)
    {
    }

    Group::
    Group (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      layout_ (this),
      variable_ (this),
      group_ (this),
      mesh_ (this),
      curve_ (this),
      name_ (this),
      enabled_ (this),
      store_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Group::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // layout
        //
        if (n.name () == "layout" && n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
        {
          ::std::unique_ptr< layout_type > r (
            layout_traits::create (i, f, this));

          this->layout_.push_back (::std::move (r));
          continue;
        }

        // variable
        //
        if (n.name () == "variable" && n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
        {
          ::std::unique_ptr< variable_type > r (
            variable_traits::create (i, f, this));

          this->variable_.push_back (::std::move (r));
          continue;
        }

        // group
        //
        if (n.name () == "group" && n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
        {
          ::std::unique_ptr< group_type > r (
            group_traits::create (i, f, this));

          this->group_.push_back (::std::move (r));
          continue;
        }

        // mesh
        //
        if (n.name () == "mesh" && n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
        {
          ::std::unique_ptr< mesh_type > r (
            mesh_traits::create (i, f, this));

          this->mesh_.push_back (::std::move (r));
          continue;
        }

        // curve
        //
        if (n.name () == "curve" && n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
        {
          ::std::unique_ptr< curve_type > r (
            curve_traits::create (i, f, this));

          this->curve_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (name_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "enabled" && n.namespace_ ().empty ())
        {
          this->enabled_.set (enabled_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "store" && n.namespace_ ().empty ())
        {
          this->store_.set (store_traits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }

      if (!enabled_.present ())
      {
        this->enabled_.set (enabled_default_value ());
      }

      if (!store_.present ())
      {
        this->store_.set (store_default_value ());
      }
    }

    Group* Group::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Group (*this, f, c);
    }

    Group& Group::
    operator= (const Group& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->layout_ = x.layout_;
        this->variable_ = x.variable_;
        this->group_ = x.group_;
        this->mesh_ = x.mesh_;
        this->curve_ = x.curve_;
        this->name_ = x.name_;
        this->enabled_ = x.enabled_;
        this->store_ = x.store_;
      }

      return *this;
    }

    Group::
    ~Group ()
    {
    }

    // Parameter
    //

    Parameter::
    Parameter (const name_type& name,
               const type_type& type,
               const value_type& value)
    : ::xml_schema::string (),
      name_ (name, this),
      type_ (type, this),
      value_ (value, this),
      comment_ (this)
    {
    }

    Parameter::
    Parameter (const char* _xsd_string_base,
               const name_type& name,
               const type_type& type,
               const value_type& value)
    : ::xml_schema::string (_xsd_string_base),
      name_ (name, this),
      type_ (type, this),
      value_ (value, this),
      comment_ (this)
    {
    }

    Parameter::
    Parameter (const ::std::string& _xsd_string_base,
               const name_type& name,
               const type_type& type,
               const value_type& value)
    : ::xml_schema::string (_xsd_string_base),
      name_ (name, this),
      type_ (type, this),
      value_ (value, this),
      comment_ (this)
    {
    }

    Parameter::
    Parameter (const ::xml_schema::string& _xsd_string_base,
               const name_type& name,
               const type_type& type,
               const value_type& value)
    : ::xml_schema::string (_xsd_string_base),
      name_ (name, this),
      type_ (type, this),
      value_ (value, this),
      comment_ (this)
    {
    }

    Parameter::
    Parameter (const Parameter& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c),
      name_ (x.name_, f, this),
      type_ (x.type_, f, this),
      value_ (x.value_, f, this),
      comment_ (x.comment_, f, this)
    {
    }

    Parameter::
    Parameter (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
      name_ (this),
      type_ (this),
      value_ (this),
      comment_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void Parameter::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (name_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (type_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "value" && n.namespace_ ().empty ())
        {
          this->value_.set (value_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "comment" && n.namespace_ ().empty ())
        {
          this->comment_.set (comment_traits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }

      if (!type_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "type",
          "");
      }

      if (!value_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "value",
          "");
      }
    }

    Parameter* Parameter::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Parameter (*this, f, c);
    }

    Parameter& Parameter::
    operator= (const Parameter& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::string& > (*this) = x;
        this->name_ = x.name_;
        this->type_ = x.type_;
        this->value_ = x.value_;
        this->comment_ = x.comment_;
      }

      return *this;
    }

    Parameter::
    ~Parameter ()
    {
    }

    // MeshType
    //

    MeshType::
    MeshType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_MeshType_convert ();
    }

    MeshType::
    MeshType (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_MeshType_convert ();
    }

    MeshType::
    MeshType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_MeshType_convert ();
    }

    MeshType* MeshType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeshType (*this, f, c);
    }

    MeshType::value MeshType::
    _xsd_MeshType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_MeshType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_MeshType_indexes_,
                        _xsd_MeshType_indexes_ + 7,
                        *this,
                        c));

      if (i == _xsd_MeshType_indexes_ + 7 || _xsd_MeshType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const MeshType::
    _xsd_MeshType_literals_[7] =
    {
      "unknown",
      "rectilinear",
      "curvilinear",
      "unstructured",
      "point",
      "csg",
      "amr"
    };

    const MeshType::value MeshType::
    _xsd_MeshType_indexes_[7] =
    {
      ::damaris::model::MeshType::amr,
      ::damaris::model::MeshType::csg,
      ::damaris::model::MeshType::curvilinear,
      ::damaris::model::MeshType::point,
      ::damaris::model::MeshType::rectilinear,
      ::damaris::model::MeshType::unknown,
      ::damaris::model::MeshType::unstructured
    };

    // Coord
    //

    const Coord::unit_type Coord::unit_default_value_ (
      "#");

    const Coord::label_type Coord::label_default_value_ (
      "#");

    Coord::
    Coord (const name_type& name)
    : ::xml_schema::type (),
      name_ (name, this),
      unit_ (unit_default_value (), this),
      label_ (label_default_value (), this),
      comment_ (this)
    {
    }

    Coord::
    Coord (const Coord& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      name_ (x.name_, f, this),
      unit_ (x.unit_, f, this),
      label_ (x.label_, f, this),
      comment_ (x.comment_, f, this)
    {
    }

    Coord::
    Coord (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      name_ (this),
      unit_ (this),
      label_ (this),
      comment_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void Coord::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (name_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "unit" && n.namespace_ ().empty ())
        {
          this->unit_.set (unit_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "label" && n.namespace_ ().empty ())
        {
          this->label_.set (label_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "comment" && n.namespace_ ().empty ())
        {
          this->comment_.set (comment_traits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }

      if (!unit_.present ())
      {
        this->unit_.set (unit_default_value ());
      }

      if (!label_.present ())
      {
        this->label_.set (label_default_value ());
      }
    }

    Coord* Coord::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Coord (*this, f, c);
    }

    Coord& Coord::
    operator= (const Coord& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->name_ = x.name_;
        this->unit_ = x.unit_;
        this->label_ = x.label_;
        this->comment_ = x.comment_;
      }

      return *this;
    }

    Coord::
    ~Coord ()
    {
    }

    // VertexGID
    //

    VertexGID::
    VertexGID (const name_type& name)
    : ::xml_schema::type (),
      name_ (name, this),
      offset_ (offset_default_value (), this),
      comment_ (this)
    {
    }

    VertexGID::
    VertexGID (const VertexGID& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      name_ (x.name_, f, this),
      offset_ (x.offset_, f, this),
      comment_ (x.comment_, f, this)
    {
    }

    VertexGID::
    VertexGID (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      name_ (this),
      offset_ (this),
      comment_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void VertexGID::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (name_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "offset" && n.namespace_ ().empty ())
        {
          this->offset_.set (offset_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "comment" && n.namespace_ ().empty ())
        {
          this->comment_.set (comment_traits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }

      if (!offset_.present ())
      {
        this->offset_.set (offset_default_value ());
      }
    }

    VertexGID* VertexGID::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class VertexGID (*this, f, c);
    }

    VertexGID& VertexGID::
    operator= (const VertexGID& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->name_ = x.name_;
        this->offset_ = x.offset_;
        this->comment_ = x.comment_;
      }

      return *this;
    }

    VertexGID::
    ~VertexGID ()
    {
    }

    // SectionVTKTypes
    //

    SectionVTKTypes::
    SectionVTKTypes (const name_type& name)
    : ::xml_schema::type (),
      name_ (name, this),
      comment_ (this)
    {
    }

    SectionVTKTypes::
    SectionVTKTypes (const SectionVTKTypes& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      name_ (x.name_, f, this),
      comment_ (x.comment_, f, this)
    {
    }

    SectionVTKTypes::
    SectionVTKTypes (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      name_ (this),
      comment_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void SectionVTKTypes::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (name_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "comment" && n.namespace_ ().empty ())
        {
          this->comment_.set (comment_traits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }
    }

    SectionVTKTypes* SectionVTKTypes::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SectionVTKTypes (*this, f, c);
    }

    SectionVTKTypes& SectionVTKTypes::
    operator= (const SectionVTKTypes& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->name_ = x.name_;
        this->comment_ = x.comment_;
      }

      return *this;
    }

    SectionVTKTypes::
    ~SectionVTKTypes ()
    {
    }

    // SectionSizes
    //

    SectionSizes::
    SectionSizes (const name_type& name)
    : ::xml_schema::type (),
      name_ (name, this),
      comment_ (this)
    {
    }

    SectionSizes::
    SectionSizes (const SectionSizes& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      name_ (x.name_, f, this),
      comment_ (x.comment_, f, this)
    {
    }

    SectionSizes::
    SectionSizes (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      name_ (this),
      comment_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void SectionSizes::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (name_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "comment" && n.namespace_ ().empty ())
        {
          this->comment_.set (comment_traits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }
    }

    SectionSizes* SectionSizes::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SectionSizes (*this, f, c);
    }

    SectionSizes& SectionSizes::
    operator= (const SectionSizes& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->name_ = x.name_;
        this->comment_ = x.comment_;
      }

      return *this;
    }

    SectionSizes::
    ~SectionSizes ()
    {
    }

    // SectionConnectivity
    //

    SectionConnectivity::
    SectionConnectivity (const name_type& name)
    : ::xml_schema::type (),
      name_ (name, this),
      comment_ (this)
    {
    }

    SectionConnectivity::
    SectionConnectivity (const SectionConnectivity& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      name_ (x.name_, f, this),
      comment_ (x.comment_, f, this)
    {
    }

    SectionConnectivity::
    SectionConnectivity (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      name_ (this),
      comment_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void SectionConnectivity::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (name_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "comment" && n.namespace_ ().empty ())
        {
          this->comment_.set (comment_traits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }
    }

    SectionConnectivity* SectionConnectivity::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SectionConnectivity (*this, f, c);
    }

    SectionConnectivity& SectionConnectivity::
    operator= (const SectionConnectivity& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->name_ = x.name_;
        this->comment_ = x.comment_;
      }

      return *this;
    }

    SectionConnectivity::
    ~SectionConnectivity ()
    {
    }

    // Mesh
    //

    Mesh::
    Mesh (const name_type& name,
          const type_type& type)
    : ::xml_schema::type (),
      coord_ (this),
      vertex_global_id_ (this),
      section_types_ (this),
      section_sizes_ (this),
      section_connectivity_ (this),
      name_ (name, this),
      type_ (type, this),
      topology_ (topology_default_value (), this),
      time_varying_ (time_varying_default_value (), this),
      comment_ (this)
    {
    }

    Mesh::
    Mesh (const Mesh& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      coord_ (x.coord_, f, this),
      vertex_global_id_ (x.vertex_global_id_, f, this),
      section_types_ (x.section_types_, f, this),
      section_sizes_ (x.section_sizes_, f, this),
      section_connectivity_ (x.section_connectivity_, f, this),
      name_ (x.name_, f, this),
      type_ (x.type_, f, this),
      topology_ (x.topology_, f, this),
      time_varying_ (x.time_varying_, f, this),
      comment_ (x.comment_, f, this)
    {
    }

    Mesh::
    Mesh (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      coord_ (this),
      vertex_global_id_ (this),
      section_types_ (this),
      section_sizes_ (this),
      section_connectivity_ (this),
      name_ (this),
      type_ (this),
      topology_ (this),
      time_varying_ (this),
      comment_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Mesh::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // coord
        //
        if (n.name () == "coord" && n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
        {
          ::std::unique_ptr< coord_type > r (
            coord_traits::create (i, f, this));

          this->coord_.push_back (::std::move (r));
          continue;
        }

        // vertex_global_id
        //
        if (n.name () == "vertex_global_id" && n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
        {
          ::std::unique_ptr< vertex_global_id_type > r (
            vertex_global_id_traits::create (i, f, this));

          if (!this->vertex_global_id_)
          {
            this->vertex_global_id_.set (::std::move (r));
            continue;
          }
        }

        // section_types
        //
        if (n.name () == "section_types" && n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
        {
          ::std::unique_ptr< section_types_type > r (
            section_types_traits::create (i, f, this));

          if (!this->section_types_)
          {
            this->section_types_.set (::std::move (r));
            continue;
          }
        }

        // section_sizes
        //
        if (n.name () == "section_sizes" && n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
        {
          ::std::unique_ptr< section_sizes_type > r (
            section_sizes_traits::create (i, f, this));

          if (!this->section_sizes_)
          {
            this->section_sizes_.set (::std::move (r));
            continue;
          }
        }

        // section_connectivity
        //
        if (n.name () == "section_connectivity" && n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
        {
          ::std::unique_ptr< section_connectivity_type > r (
            section_connectivity_traits::create (i, f, this));

          if (!this->section_connectivity_)
          {
            this->section_connectivity_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (name_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (type_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "topology" && n.namespace_ ().empty ())
        {
          this->topology_.set (topology_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "time-varying" && n.namespace_ ().empty ())
        {
          this->time_varying_.set (time_varying_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "comment" && n.namespace_ ().empty ())
        {
          this->comment_.set (comment_traits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }

      if (!type_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "type",
          "");
      }

      if (!topology_.present ())
      {
        this->topology_.set (topology_default_value ());
      }

      if (!time_varying_.present ())
      {
        this->time_varying_.set (time_varying_default_value ());
      }
    }

    Mesh* Mesh::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Mesh (*this, f, c);
    }

    Mesh& Mesh::
    operator= (const Mesh& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->coord_ = x.coord_;
        this->vertex_global_id_ = x.vertex_global_id_;
        this->section_types_ = x.section_types_;
        this->section_sizes_ = x.section_sizes_;
        this->section_connectivity_ = x.section_connectivity_;
        this->name_ = x.name_;
        this->type_ = x.type_;
        this->topology_ = x.topology_;
        this->time_varying_ = x.time_varying_;
        this->comment_ = x.comment_;
      }

      return *this;
    }

    Mesh::
    ~Mesh ()
    {
    }

    // Curve
    //

    Curve::
    Curve (const name_type& name)
    : ::xml_schema::type (),
      coord_ (this),
      name_ (name, this)
    {
    }

    Curve::
    Curve (const Curve& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      coord_ (x.coord_, f, this),
      name_ (x.name_, f, this)
    {
    }

    Curve::
    Curve (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      coord_ (this),
      name_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Curve::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // coord
        //
        if (n.name () == "coord" && n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
        {
          ::std::unique_ptr< coord_type > r (
            coord_traits::create (i, f, this));

          this->coord_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (name_traits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }
    }

    Curve* Curve::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Curve (*this, f, c);
    }

    Curve& Curve::
    operator= (const Curve& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->coord_ = x.coord_;
        this->name_ = x.name_;
      }

      return *this;
    }

    Curve::
    ~Curve ()
    {
    }

    // Data
    //

    Data::
    Data ()
    : ::xml_schema::type (),
      parameter_ (this),
      layout_ (this),
      variable_ (this),
      group_ (this),
      mesh_ (this),
      curve_ (this)
    {
    }

    Data::
    Data (const Data& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      parameter_ (x.parameter_, f, this),
      layout_ (x.layout_, f, this),
      variable_ (x.variable_, f, this),
      group_ (x.group_, f, this),
      mesh_ (x.mesh_, f, this),
      curve_ (x.curve_, f, this)
    {
    }

    Data::
    Data (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      parameter_ (this),
      layout_ (this),
      variable_ (this),
      group_ (this),
      mesh_ (this),
      curve_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Data::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // parameter
        //
        if (n.name () == "parameter" && n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
        {
          ::std::unique_ptr< parameter_type > r (
            parameter_traits::create (i, f, this));

          this->parameter_.push_back (::std::move (r));
          continue;
        }

        // layout
        //
        if (n.name () == "layout" && n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
        {
          ::std::unique_ptr< layout_type > r (
            layout_traits::create (i, f, this));

          this->layout_.push_back (::std::move (r));
          continue;
        }

        // variable
        //
        if (n.name () == "variable" && n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
        {
          ::std::unique_ptr< variable_type > r (
            variable_traits::create (i, f, this));

          this->variable_.push_back (::std::move (r));
          continue;
        }

        // group
        //
        if (n.name () == "group" && n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
        {
          ::std::unique_ptr< group_type > r (
            group_traits::create (i, f, this));

          this->group_.push_back (::std::move (r));
          continue;
        }

        // mesh
        //
        if (n.name () == "mesh" && n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
        {
          ::std::unique_ptr< mesh_type > r (
            mesh_traits::create (i, f, this));

          this->mesh_.push_back (::std::move (r));
          continue;
        }

        // curve
        //
        if (n.name () == "curve" && n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
        {
          ::std::unique_ptr< curve_type > r (
            curve_traits::create (i, f, this));

          this->curve_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    Data* Data::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Data (*this, f, c);
    }

    Data& Data::
    operator= (const Data& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->parameter_ = x.parameter_;
        this->layout_ = x.layout_;
        this->variable_ = x.variable_;
        this->group_ = x.group_;
        this->mesh_ = x.mesh_;
        this->curve_ = x.curve_;
      }

      return *this;
    }

    Data::
    ~Data ()
    {
    }

    // Scope
    //

    Scope::
    Scope (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_Scope_convert ();
    }

    Scope::
    Scope (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_Scope_convert ();
    }

    Scope::
    Scope (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_Scope_convert ();
    }

    Scope* Scope::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Scope (*this, f, c);
    }

    Scope::value Scope::
    _xsd_Scope_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_Scope_literals_);
      const value* i (::std::lower_bound (
                        _xsd_Scope_indexes_,
                        _xsd_Scope_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_Scope_indexes_ + 3 || _xsd_Scope_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const Scope::
    _xsd_Scope_literals_[3] =
    {
      "core",
      "group",
      "bcast"
    };

    const Scope::value Scope::
    _xsd_Scope_indexes_[3] =
    {
      ::damaris::model::Scope::bcast,
      ::damaris::model::Scope::core,
      ::damaris::model::Scope::group
    };

    // Exec
    //

    Exec::
    Exec (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_Exec_convert ();
    }

    Exec::
    Exec (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_Exec_convert ();
    }

    Exec::
    Exec (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_Exec_convert ();
    }

    Exec* Exec::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Exec (*this, f, c);
    }

    Exec::value Exec::
    _xsd_Exec_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_Exec_literals_);
      const value* i (::std::lower_bound (
                        _xsd_Exec_indexes_,
                        _xsd_Exec_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_Exec_indexes_ + 3 || _xsd_Exec_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const Exec::
    _xsd_Exec_literals_[3] =
    {
      "local",
      "coupled",
      "remote"
    };

    const Exec::value Exec::
    _xsd_Exec_indexes_[3] =
    {
      ::damaris::model::Exec::coupled,
      ::damaris::model::Exec::local,
      ::damaris::model::Exec::remote
    };

    // Event
    //

    const Event::execution_type Event::execution_default_value_ (
      "remote");

    const Event::library_type Event::library_default_value_ (
      "");

    const Event::scope_type Event::scope_default_value_ (
      "core");

    Event::
    Event (const name_type& name,
           const action_type& action)
    : ::xml_schema::type (),
      name_ (name, this),
      action_ (action, this),
      execution_ (execution_default_value (), this),
      library_ (library_default_value (), this),
      scope_ (scope_default_value (), this),
      external_ (external_default_value (), this)
    {
    }

    Event::
    Event (const Event& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      name_ (x.name_, f, this),
      action_ (x.action_, f, this),
      execution_ (x.execution_, f, this),
      library_ (x.library_, f, this),
      scope_ (x.scope_, f, this),
      external_ (x.external_, f, this)
    {
    }

    Event::
    Event (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      name_ (this),
      action_ (this),
      execution_ (this),
      library_ (this),
      scope_ (this),
      external_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void Event::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (name_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "action" && n.namespace_ ().empty ())
        {
          this->action_.set (action_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "execution" && n.namespace_ ().empty ())
        {
          this->execution_.set (execution_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "library" && n.namespace_ ().empty ())
        {
          this->library_.set (library_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "scope" && n.namespace_ ().empty ())
        {
          this->scope_.set (scope_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "external" && n.namespace_ ().empty ())
        {
          this->external_.set (external_traits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }

      if (!action_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "action",
          "");
      }

      if (!execution_.present ())
      {
        this->execution_.set (execution_default_value ());
      }

      if (!library_.present ())
      {
        this->library_.set (library_default_value ());
      }

      if (!scope_.present ())
      {
        this->scope_.set (scope_default_value ());
      }

      if (!external_.present ())
      {
        this->external_.set (external_default_value ());
      }
    }

    Event* Event::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Event (*this, f, c);
    }

    Event& Event::
    operator= (const Event& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->name_ = x.name_;
        this->action_ = x.action_;
        this->execution_ = x.execution_;
        this->library_ = x.library_;
        this->scope_ = x.scope_;
        this->external_ = x.external_;
      }

      return *this;
    }

    Event::
    ~Event ()
    {
    }

    // Script
    //

    const Script::execution_type Script::execution_default_value_ (
      "remote");

    const Script::scope_type Script::scope_default_value_ (
      "core");

    Script::
    Script (const name_type& name,
            const file_type& file,
            const language_type& language)
    : ::xml_schema::type (),
      name_ (name, this),
      file_ (file, this),
      execution_ (execution_default_value (), this),
      language_ (language, this),
      scope_ (scope_default_value (), this),
      external_ (external_default_value (), this),
      frequency_ (frequency_default_value (), this)
    {
    }

    Script::
    Script (const Script& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      name_ (x.name_, f, this),
      file_ (x.file_, f, this),
      execution_ (x.execution_, f, this),
      language_ (x.language_, f, this),
      scope_ (x.scope_, f, this),
      external_ (x.external_, f, this),
      frequency_ (x.frequency_, f, this)
    {
    }

    Script::
    Script (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      name_ (this),
      file_ (this),
      execution_ (this),
      language_ (this),
      scope_ (this),
      external_ (this),
      frequency_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void Script::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (name_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "file" && n.namespace_ ().empty ())
        {
          this->file_.set (file_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "execution" && n.namespace_ ().empty ())
        {
          this->execution_.set (execution_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "language" && n.namespace_ ().empty ())
        {
          this->language_.set (language_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "scope" && n.namespace_ ().empty ())
        {
          this->scope_.set (scope_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "external" && n.namespace_ ().empty ())
        {
          this->external_.set (external_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "frequency" && n.namespace_ ().empty ())
        {
          this->frequency_.set (frequency_traits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }

      if (!file_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "file",
          "");
      }

      if (!execution_.present ())
      {
        this->execution_.set (execution_default_value ());
      }

      if (!language_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "language",
          "");
      }

      if (!scope_.present ())
      {
        this->scope_.set (scope_default_value ());
      }

      if (!external_.present ())
      {
        this->external_.set (external_default_value ());
      }

      if (!frequency_.present ())
      {
        this->frequency_.set (frequency_default_value ());
      }
    }

    Script* Script::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Script (*this, f, c);
    }

    Script& Script::
    operator= (const Script& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->name_ = x.name_;
        this->file_ = x.file_;
        this->execution_ = x.execution_;
        this->language_ = x.language_;
        this->scope_ = x.scope_;
        this->external_ = x.external_;
        this->frequency_ = x.frequency_;
      }

      return *this;
    }

    Script::
    ~Script ()
    {
    }

    // Exception
    //

    Exception::
    Exception ()
    : ::xml_schema::type (),
      event_ (this),
      script_ (this)
    {
    }

    Exception::
    Exception (const Exception& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      event_ (x.event_, f, this),
      script_ (x.script_, f, this)
    {
    }

    Exception::
    Exception (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      event_ (this),
      script_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void Exception::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "event" && n.namespace_ ().empty ())
        {
          this->event_.set (event_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "script" && n.namespace_ ().empty ())
        {
          this->script_.set (script_traits::create (i, f, this));
          continue;
        }
      }
    }

    Exception* Exception::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Exception (*this, f, c);
    }

    Exception& Exception::
    operator= (const Exception& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->event_ = x.event_;
        this->script_ = x.script_;
      }

      return *this;
    }

    Exception::
    ~Exception ()
    {
    }

    // VisitParam
    //

    VisitParam::
    VisitParam ()
    : ::xml_schema::type (),
      path_ (this),
      options_ (this),
      update_frequency_ (update_frequency_default_value (), this)
    {
    }

    VisitParam::
    VisitParam (const VisitParam& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      path_ (x.path_, f, this),
      options_ (x.options_, f, this),
      update_frequency_ (x.update_frequency_, f, this)
    {
    }

    VisitParam::
    VisitParam (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      path_ (this),
      options_ (this),
      update_frequency_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void VisitParam::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // path
        //
        if (n.name () == "path" && n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
        {
          ::std::unique_ptr< path_type > r (
            path_traits::create (i, f, this));

          if (!this->path_)
          {
            this->path_.set (::std::move (r));
            continue;
          }
        }

        // options
        //
        if (n.name () == "options" && n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
        {
          ::std::unique_ptr< options_type > r (
            options_traits::create (i, f, this));

          if (!this->options_)
          {
            this->options_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "update-frequency" && n.namespace_ ().empty ())
        {
          this->update_frequency_.set (update_frequency_traits::create (i, f, this));
          continue;
        }
      }

      if (!update_frequency_.present ())
      {
        this->update_frequency_.set (update_frequency_default_value ());
      }
    }

    VisitParam* VisitParam::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class VisitParam (*this, f, c);
    }

    VisitParam& VisitParam::
    operator= (const VisitParam& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->path_ = x.path_;
        this->options_ = x.options_;
        this->update_frequency_ = x.update_frequency_;
      }

      return *this;
    }

    VisitParam::
    ~VisitParam ()
    {
    }

    // ParaViewParam
    //

    ParaViewParam::
    ParaViewParam ()
    : ::xml_schema::type (),
      script_ (this),
      update_frequency_ (update_frequency_default_value (), this),
      realtime_timestep_ (realtime_timestep_default_value (), this),
      end_iteration_ (end_iteration_default_value (), this)
    {
    }

    ParaViewParam::
    ParaViewParam (const ParaViewParam& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      script_ (x.script_, f, this),
      update_frequency_ (x.update_frequency_, f, this),
      realtime_timestep_ (x.realtime_timestep_, f, this),
      end_iteration_ (x.end_iteration_, f, this)
    {
    }

    ParaViewParam::
    ParaViewParam (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      script_ (this),
      update_frequency_ (this),
      realtime_timestep_ (this),
      end_iteration_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ParaViewParam::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // script
        //
        if (n.name () == "script" && n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
        {
          ::std::unique_ptr< script_type > r (
            script_traits::create (i, f, this));

          this->script_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "update-frequency" && n.namespace_ ().empty ())
        {
          this->update_frequency_.set (update_frequency_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "realtime-timestep" && n.namespace_ ().empty ())
        {
          this->realtime_timestep_.set (realtime_timestep_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "end-iteration" && n.namespace_ ().empty ())
        {
          this->end_iteration_.set (end_iteration_traits::create (i, f, this));
          continue;
        }
      }

      if (!update_frequency_.present ())
      {
        this->update_frequency_.set (update_frequency_default_value ());
      }

      if (!realtime_timestep_.present ())
      {
        this->realtime_timestep_.set (realtime_timestep_default_value ());
      }

      if (!end_iteration_.present ())
      {
        this->end_iteration_.set (end_iteration_default_value ());
      }
    }

    ParaViewParam* ParaViewParam::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ParaViewParam (*this, f, c);
    }

    ParaViewParam& ParaViewParam::
    operator= (const ParaViewParam& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->script_ = x.script_;
        this->update_frequency_ = x.update_frequency_;
        this->realtime_timestep_ = x.realtime_timestep_;
        this->end_iteration_ = x.end_iteration_;
      }

      return *this;
    }

    ParaViewParam::
    ~ParaViewParam ()
    {
    }

    // Actions
    //

    Actions::
    Actions ()
    : ::xml_schema::type (),
      event_ (this),
      error_ (this)
    {
    }

    Actions::
    Actions (const Actions& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      event_ (x.event_, f, this),
      error_ (x.error_, f, this)
    {
    }

    Actions::
    Actions (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      event_ (this),
      error_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Actions::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // event
        //
        if (n.name () == "event" && n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
        {
          ::std::unique_ptr< event_type > r (
            event_traits::create (i, f, this));

          this->event_.push_back (::std::move (r));
          continue;
        }

        // error
        //
        if (n.name () == "error" && n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
        {
          ::std::unique_ptr< error_type > r (
            error_traits::create (i, f, this));

          this->error_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    Actions* Actions::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Actions (*this, f, c);
    }

    Actions& Actions::
    operator= (const Actions& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->event_ = x.event_;
        this->error_ = x.error_;
      }

      return *this;
    }

    Actions::
    ~Actions ()
    {
    }

    // Scripts
    //

    Scripts::
    Scripts ()
    : ::xml_schema::type (),
      pyscript_ (this)
    {
    }

    Scripts::
    Scripts (const Scripts& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      pyscript_ (x.pyscript_, f, this)
    {
    }

    Scripts::
    Scripts (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      pyscript_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Scripts::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // pyscript
        //
        if (n.name () == "pyscript" && n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
        {
          ::std::unique_ptr< pyscript_type > r (
            pyscript_traits::create (i, f, this));

          this->pyscript_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    Scripts* Scripts::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Scripts (*this, f, c);
    }

    Scripts& Scripts::
    operator= (const Scripts& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->pyscript_ = x.pyscript_;
      }

      return *this;
    }

    Scripts::
    ~Scripts ()
    {
    }

    // StoreType
    //

    StoreType::
    StoreType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_StoreType_convert ();
    }

    StoreType::
    StoreType (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_StoreType_convert ();
    }

    StoreType::
    StoreType (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_StoreType_convert ();
    }

    StoreType* StoreType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StoreType (*this, f, c);
    }

    StoreType::value StoreType::
    _xsd_StoreType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_StoreType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_StoreType_indexes_,
                        _xsd_StoreType_indexes_ + 2,
                        *this,
                        c));

      if (i == _xsd_StoreType_indexes_ + 2 || _xsd_StoreType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const StoreType::
    _xsd_StoreType_literals_[2] =
    {
      "null",
      "HDF5"
    };

    const StoreType::value StoreType::
    _xsd_StoreType_indexes_[2] =
    {
      ::damaris::model::StoreType::HDF5,
      ::damaris::model::StoreType::null
    };

    // Store
    //

    Store::
    Store (const name_type& name,
           const type_type& type)
    : ::xml_schema::type (),
      option_ (this),
      name_ (name, this),
      type_ (type, this),
      frequency_ (frequency_default_value (), this)
    {
    }

    Store::
    Store (const Store& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      option_ (x.option_, f, this),
      name_ (x.name_, f, this),
      type_ (x.type_, f, this),
      frequency_ (x.frequency_, f, this)
    {
    }

    Store::
    Store (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      option_ (this),
      name_ (this),
      type_ (this),
      frequency_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Store::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // option
        //
        if (n.name () == "option" && n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
        {
          ::std::unique_ptr< option_type > r (
            option_traits::create (i, f, this));

          this->option_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (name_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (type_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "frequency" && n.namespace_ ().empty ())
        {
          this->frequency_.set (frequency_traits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }

      if (!type_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "type",
          "");
      }

      if (!frequency_.present ())
      {
        this->frequency_.set (frequency_default_value ());
      }
    }

    Store* Store::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Store (*this, f, c);
    }

    Store& Store::
    operator= (const Store& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->option_ = x.option_;
        this->name_ = x.name_;
        this->type_ = x.type_;
        this->frequency_ = x.frequency_;
      }

      return *this;
    }

    Store::
    ~Store ()
    {
    }

    // Storage
    //

    Storage::
    Storage ()
    : ::xml_schema::type (),
      store_ (this)
    {
    }

    Storage::
    Storage (const Storage& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      store_ (x.store_, f, this)
    {
    }

    Storage::
    Storage (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      store_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Storage::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // store
        //
        if (n.name () == "store" && n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
        {
          ::std::unique_ptr< store_type > r (
            store_traits::create (i, f, this));

          this->store_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    Storage* Storage::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Storage (*this, f, c);
    }

    Storage& Storage::
    operator= (const Storage& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->store_ = x.store_;
      }

      return *this;
    }

    Storage::
    ~Storage ()
    {
    }

    // LogLevelType
    //

    LogLevelType::
    LogLevelType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_LogLevelType_convert ();
    }

    LogLevelType::
    LogLevelType (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_LogLevelType_convert ();
    }

    LogLevelType::
    LogLevelType (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_LogLevelType_convert ();
    }

    LogLevelType* LogLevelType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LogLevelType (*this, f, c);
    }

    LogLevelType::value LogLevelType::
    _xsd_LogLevelType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_LogLevelType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_LogLevelType_indexes_,
                        _xsd_LogLevelType_indexes_ + 6,
                        *this,
                        c));

      if (i == _xsd_LogLevelType_indexes_ + 6 || _xsd_LogLevelType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const LogLevelType::
    _xsd_LogLevelType_literals_[6] =
    {
      "trace",
      "debug",
      "info",
      "warning",
      "error",
      "fatal"
    };

    const LogLevelType::value LogLevelType::
    _xsd_LogLevelType_indexes_[6] =
    {
      ::damaris::model::LogLevelType::debug,
      ::damaris::model::LogLevelType::error,
      ::damaris::model::LogLevelType::fatal,
      ::damaris::model::LogLevelType::info,
      ::damaris::model::LogLevelType::trace,
      ::damaris::model::LogLevelType::warning
    };

    // Log
    //

    const Log::LogLevel_type Log::LogLevel_default_value_ (
      "warning");

    Log::
    Log (const FileName_type& FileName,
         const RotationSize_type& RotationSize,
         const LogFormat_type& LogFormat)
    : ::xml_schema::type (),
      FileName_ (FileName, this),
      RotationSize_ (RotationSize, this),
      LogFormat_ (LogFormat, this),
      LogLevel_ (LogLevel_default_value (), this),
      Flush_ (Flush_default_value (), this)
    {
    }

    Log::
    Log (const Log& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      FileName_ (x.FileName_, f, this),
      RotationSize_ (x.RotationSize_, f, this),
      LogFormat_ (x.LogFormat_, f, this),
      LogLevel_ (x.LogLevel_, f, this),
      Flush_ (x.Flush_, f, this)
    {
    }

    Log::
    Log (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      FileName_ (this),
      RotationSize_ (this),
      LogFormat_ (this),
      LogLevel_ (this),
      Flush_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void Log::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "FileName" && n.namespace_ ().empty ())
        {
          this->FileName_.set (FileName_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "RotationSize" && n.namespace_ ().empty ())
        {
          this->RotationSize_.set (RotationSize_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "LogFormat" && n.namespace_ ().empty ())
        {
          this->LogFormat_.set (LogFormat_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "LogLevel" && n.namespace_ ().empty ())
        {
          this->LogLevel_.set (LogLevel_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "Flush" && n.namespace_ ().empty ())
        {
          this->Flush_.set (Flush_traits::create (i, f, this));
          continue;
        }
      }

      if (!FileName_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "FileName",
          "");
      }

      if (!RotationSize_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "RotationSize",
          "");
      }

      if (!LogFormat_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "LogFormat",
          "");
      }

      if (!LogLevel_.present ())
      {
        this->LogLevel_.set (LogLevel_default_value ());
      }

      if (!Flush_.present ())
      {
        this->Flush_.set (Flush_default_value ());
      }
    }

    Log* Log::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Log (*this, f, c);
    }

    Log& Log::
    operator= (const Log& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->FileName_ = x.FileName_;
        this->RotationSize_ = x.RotationSize_;
        this->LogFormat_ = x.LogFormat_;
        this->LogLevel_ = x.LogLevel_;
        this->Flush_ = x.Flush_;
      }

      return *this;
    }

    Log::
    ~Log ()
    {
    }

    // Simulation
    //

    const Simulation::language_type Simulation::language_default_value_ (
      "unknown");

    Simulation::
    Simulation (const architecture_type& architecture,
                const data_type& data,
                const name_type& name)
    : ::xml_schema::type (),
      architecture_ (architecture, this),
      data_ (data, this),
      storage_ (this),
      actions_ (this),
      scripts_ (this),
      visit_ (this),
      paraview_ (this),
      log_ (this),
      name_ (name, this),
      language_ (language_default_value (), this)
    {
    }

    Simulation::
    Simulation (::std::unique_ptr< architecture_type > architecture,
                ::std::unique_ptr< data_type > data,
                const name_type& name)
    : ::xml_schema::type (),
      architecture_ (std::move (architecture), this),
      data_ (std::move (data), this),
      storage_ (this),
      actions_ (this),
      scripts_ (this),
      visit_ (this),
      paraview_ (this),
      log_ (this),
      name_ (name, this),
      language_ (language_default_value (), this)
    {
    }

    Simulation::
    Simulation (const Simulation& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      architecture_ (x.architecture_, f, this),
      data_ (x.data_, f, this),
      storage_ (x.storage_, f, this),
      actions_ (x.actions_, f, this),
      scripts_ (x.scripts_, f, this),
      visit_ (x.visit_, f, this),
      paraview_ (x.paraview_, f, this),
      log_ (x.log_, f, this),
      name_ (x.name_, f, this),
      language_ (x.language_, f, this)
    {
    }

    Simulation::
    Simulation (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      architecture_ (this),
      data_ (this),
      storage_ (this),
      actions_ (this),
      scripts_ (this),
      visit_ (this),
      paraview_ (this),
      log_ (this),
      name_ (this),
      language_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Simulation::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // architecture
        //
        if (n.name () == "architecture" && n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
        {
          ::std::unique_ptr< architecture_type > r (
            architecture_traits::create (i, f, this));

          if (!architecture_.present ())
          {
            this->architecture_.set (::std::move (r));
            continue;
          }
        }

        // data
        //
        if (n.name () == "data" && n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
        {
          ::std::unique_ptr< data_type > r (
            data_traits::create (i, f, this));

          if (!data_.present ())
          {
            this->data_.set (::std::move (r));
            continue;
          }
        }

        // storage
        //
        if (n.name () == "storage" && n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
        {
          ::std::unique_ptr< storage_type > r (
            storage_traits::create (i, f, this));

          if (!this->storage_)
          {
            this->storage_.set (::std::move (r));
            continue;
          }
        }

        // actions
        //
        if (n.name () == "actions" && n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
        {
          ::std::unique_ptr< actions_type > r (
            actions_traits::create (i, f, this));

          if (!this->actions_)
          {
            this->actions_.set (::std::move (r));
            continue;
          }
        }

        // scripts
        //
        if (n.name () == "scripts" && n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
        {
          ::std::unique_ptr< scripts_type > r (
            scripts_traits::create (i, f, this));

          if (!this->scripts_)
          {
            this->scripts_.set (::std::move (r));
            continue;
          }
        }

        // visit
        //
        if (n.name () == "visit" && n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
        {
          ::std::unique_ptr< visit_type > r (
            visit_traits::create (i, f, this));

          if (!this->visit_)
          {
            this->visit_.set (::std::move (r));
            continue;
          }
        }

        // paraview
        //
        if (n.name () == "paraview" && n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
        {
          ::std::unique_ptr< paraview_type > r (
            paraview_traits::create (i, f, this));

          if (!this->paraview_)
          {
            this->paraview_.set (::std::move (r));
            continue;
          }
        }

        // log
        //
        if (n.name () == "log" && n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
        {
          ::std::unique_ptr< log_type > r (
            log_traits::create (i, f, this));

          if (!this->log_)
          {
            this->log_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!architecture_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "architecture",
          "http://damaris.gforge.inria.fr/damaris/model");
      }

      if (!data_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "data",
          "http://damaris.gforge.inria.fr/damaris/model");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (name_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "language" && n.namespace_ ().empty ())
        {
          this->language_.set (language_traits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }

      if (!language_.present ())
      {
        this->language_.set (language_default_value ());
      }
    }

    Simulation* Simulation::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Simulation (*this, f, c);
    }

    Simulation& Simulation::
    operator= (const Simulation& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->architecture_ = x.architecture_;
        this->data_ = x.data_;
        this->storage_ = x.storage_;
        this->actions_ = x.actions_;
        this->scripts_ = x.scripts_;
        this->visit_ = x.visit_;
        this->paraview_ = x.paraview_;
        this->log_ = x.log_;
        this->name_ = x.name_;
        this->language_ = x.language_;
      }

      return *this;
    }

    Simulation::
    ~Simulation ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace damaris
{
  namespace model
  {
    ::std::unique_ptr< ::damaris::model::Simulation >
    simulation (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::damaris::model::Simulation > (
        ::damaris::model::simulation (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    ::std::unique_ptr< ::damaris::model::Simulation >
    simulation (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::damaris::model::Simulation > (
        ::damaris::model::simulation (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    ::std::unique_ptr< ::damaris::model::Simulation >
    simulation (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::damaris::model::Simulation > (
        ::damaris::model::simulation (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    ::std::unique_ptr< ::damaris::model::Simulation >
    simulation (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::damaris::model::simulation (isrc, f, p);
    }

    ::std::unique_ptr< ::damaris::model::Simulation >
    simulation (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::damaris::model::simulation (isrc, h, f, p);
    }

    ::std::unique_ptr< ::damaris::model::Simulation >
    simulation (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::damaris::model::simulation (isrc, h, f, p);
    }

    ::std::unique_ptr< ::damaris::model::Simulation >
    simulation (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::damaris::model::simulation (isrc, f, p);
    }

    ::std::unique_ptr< ::damaris::model::Simulation >
    simulation (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::damaris::model::simulation (isrc, h, f, p);
    }

    ::std::unique_ptr< ::damaris::model::Simulation >
    simulation (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::damaris::model::simulation (isrc, h, f, p);
    }

    ::std::unique_ptr< ::damaris::model::Simulation >
    simulation (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::damaris::model::Simulation > (
        ::damaris::model::simulation (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    ::std::unique_ptr< ::damaris::model::Simulation >
    simulation (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::damaris::model::Simulation > (
        ::damaris::model::simulation (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    ::std::unique_ptr< ::damaris::model::Simulation >
    simulation (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::damaris::model::Simulation > (
        ::damaris::model::simulation (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    ::std::unique_ptr< ::damaris::model::Simulation >
    simulation (const ::xercesc::DOMDocument& doc,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::damaris::model::Simulation > (
          ::damaris::model::simulation (
            std::move (d), f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "simulation" &&
          n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
      {
        ::std::unique_ptr< ::damaris::model::Simulation > r (
          ::xsd::cxx::tree::traits< ::damaris::model::Simulation, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "simulation",
        "http://damaris.gforge.inria.fr/damaris/model");
    }

    ::std::unique_ptr< ::damaris::model::Simulation >
    simulation (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "simulation" &&
          n.namespace_ () == "http://damaris.gforge.inria.fr/damaris/model")
      {
        ::std::unique_ptr< ::damaris::model::Simulation > r (
          ::xsd::cxx::tree::traits< ::damaris::model::Simulation, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "simulation",
        "http://damaris.gforge.inria.fr/damaris/model");
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

