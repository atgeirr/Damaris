# syntax=docker/dockerfile:1
## Usage of this file (standalone or automated via gitlab CI): 
# The gitlab.inria.fr/Damaris/damaris repo should build without the secret setup.
# 
# To build the damaris repo (no password needed):
# export TAG=v1.5.0
# export PV_VERSION=v5.9.0
# export PVSHORT=$(echo $PV_VERSION | sed 's|\.||g')
# sudo  DOCKER_BUILDKIT=1 docker build -t \
#            registry.gitlab.inria.fr/damaris/damaris:${TAG}-ubu20-p${PVSHORT} \
#            --build-arg INPUT_pv_ver=${PV_VERSION} \
#                -f ./Dockerfile.ubuntu20.paraview .
# 
# mpirun -np 4 singularity exec ubuntu20_paraview58  /usr/local/damaris/examples/paraview/image /usr/local/damaris/examples/paraview/image.xml
###################
#
## To test the created docker image:
# 1/ Log in to the gitlab repository 
# N.B. You may need a ~/.docker/config.json file configured with an access token
# > docker login registry.gitlab.inria.fr
# 
# 2/ Use docker run as it does not leave the container running on exit and run Damaris tests:
#    Map the shared memory filesystem and the Paraview Catalyst port
# 
# > docker run --rm -v /dev/shm:/dev/shm -p 22222:22222 -it registry.gitlab.inria.fr/damaris/damaris:<branch>-<OS>-<Paraview_version> /bin/bash
# <container prompt> ctest
#
# > sudo docker run --rm -v /dev/shm:/dev/shm -p 22222:22222 -it registry.gitlab.inria.fr/damaris/damaris:v1.5.0-ubu20-pv590 /bin/bash
# > cd /home/docker/local/examples/storage/
# > mpirun -np 4 ./3dmesh 3dmesh.xml
######################################################################################

########################################
## Stage 1 of build
########################################
FROM ubuntu:20.04 AS builder
SHELL ["/bin/bash", "-c"]

USER root

RUN useradd docker \
	&& mkdir /home/docker \
	&& chown docker:docker /home/docker \
	&& addgroup docker staff

# RUN yes docker | passwd --stdin root
RUN echo 'root:docker' | chpasswd

RUN apt-get update -y \
  && echo "debconf debconf/frontend select Noninteractive" | debconf-set-selections \
  && apt-get install -y --no-install-recommends \
    apt-utils \
    pkg-config \
    git-core \
    cmake \
    wget unzip nano \
	libhdf5-openmpi-dev \
    libboost-all-dev \
	libpython3-dev  \
	libxerces-c-dev  \
	xsdcxx \
    libcppunit-dev \
	hdf5-tools \
  && apt-get clean \
  && ln -s /usr/bin/xsdcxx /usr/bin/xsd


RUN  apt-get install -y --no-install-recommends \
	software-properties-common \
    build-essential \
    gfortran \
  && apt-get clean



# Extras for visit install
RUN apt-get install -y --no-install-recommends \
    hostname patch \
    x11proto-dev   \
    xz-utils libtool m4 automake \
    libx11-dev xorg-dev  libx11-xcb-dev libxcb-dri2-0-dev  \
    libxcb-xfixes0-dev \
    libffi-dev \
  && apt-get clean




ENV INSTALL_PREFIX=/home/docker/local
ENV PATH=${INSTALL_PREFIX}/bin:${PATH}
ENV LD_LIBRARY_PATH=${INSTALL_PREFIX}/lib:${INSTALL_PREFIX}/lib64:${LD_LIBRARY_PATH}

ENV INSTALLTMDIR=/home/docker/installdir
ENV CMAKE_BUILD_TYPE=Release
ENV NUMCORES=4

# N.B. MPI_ROOT=/usr/lib64/openmpi/bin has to be on the PATH
ENV MPI_ROOT=/usr
ENV MPICXX=$MPI_ROOT/bin/mpicxx
ENV MPICC=$MPI_ROOT/bin/mpicc
ENV MPIFORT=$MPI_ROOT/bin/mpifort

ENV GCC=/usr/bin/gcc
ENV GPP=/usr/bin/g++

USER docker

COPY --chown=docker:docker *.tar.gz ${INSTALLTMDIR}/
COPY --chown=docker:docker *.tar.xz ${INSTALLTMDIR}/
COPY --chown=docker:docker *.tgz ${INSTALLTMDIR}/
COPY --chown=docker:docker build_visit* ${INSTALLTMDIR}/


# N.B. Could set: --arch "" as it would remove the "linux-x86_64_gcc-X.Y"
ENV VISIT_PYTHON3=${INSTALL_PREFIX}/python/3.7.7/linux-x86_64_gcc-9.4
ENV PATH=${VISIT_PYTHON3}/bin:${PATH}
ENV LD_LIBRARY_PATH=${VISIT_PYTHON3}/lib:${VISIT_PYTHON3}/lib64:${LD_LIBRARY_PATH}

ENV PAR_COMPILER=${MPICC}
ENV PAR_COMPILER_CXX=${MPICXX}
ENV HOSTNAME_DOCKER=buildkitsandbox

# Define INPUT_visit_ver with a default
ARG INPUT_visit_ver
ENV VISIT_VERSION=$INPUT_visit_ver


# This only modifies the visit_build script
# The following is needed to fix how the build_visit script finds Python on Ubuntu 20
RUN export VISIT_VER_UNDERSCORE=${VISIT_VERSION//./_} \
    && cd ${INSTALLTMDIR} \
    && mkdir ./third_party \
    && chmod +x build_visit${VISIT_VER_UNDERSCORE} \
    && sed -i 's|error "python library was not found, cannot configure python"|PYTHON_LIBRARY=$(pkg-config --libs python3-embed);  PYTHON_LIBRARY="lib${PYTHON_LIBRARY:2}.so" ; if [ ! -e "${PYTHON_LIBRARY_DIR}/${PYTHON_LIBRARY}" ] ; then  error "python library was not found, cannot configure python" ; fi|g' ./build_visit${VISIT_VER_UNDERSCORE} \
    && sed -i 's|vopts="${vopts} -DPYTHON_EXTRA_LIBS:STRING=${VTK_PY_LIBS}"|vopts="${vopts} -DPYTHON_EXTRA_LIBS:STRING=\\\"${VTK_PY_LIBS}\\\""|g' ./build_visit${VISIT_VER_UNDERSCORE} \
    && yes yes | ./build_visit${VISIT_VER_UNDERSCORE}  --thirdparty-path ${INSTALL_PREFIX} --mesagl --llvm --server-components-only --stdout  --cc ${GCC}  --cxx ${GPP}  --cflags "-I${INSTALL_PREFIX}/include" --cxxflags "-I${INSTALL_PREFIX}/include"  --makeflags -j${NUMCORES} --system-cmake --cxxflag "-Wno-class-memaccess -Wno-cast-function-type" --parallel --prefix $INSTALL_PREFIX/visit  \
    || echo "We will try again 1" \
    && ln -s ${VISIT_PYTHON3}/bin/python3 ${VISIT_PYTHON3}/bin/python \
    && yes yes | ./build_visit${VISIT_VER_UNDERSCORE} --thirdparty-path ${INSTALL_PREFIX} --mesagl --llvm --server-components-only --stdout  --cc ${GCC}  --cxx ${GPP}  --cflags "-I${INSTALL_PREFIX}/include" --cxxflags "-I${INSTALL_PREFIX}/include"  --makeflags -j${NUMCORES} --system-cmake --cxxflag "-Wno-class-memaccess -Wno-cast-function-type" --parallel --prefix $INSTALL_PREFIX/visit  \
    || echo "We will try again 2" \
    && rm -fr ${INSTALLTMDIR}/visit${VISIT_VERSION}/build \
    && mkdir -p ${INSTALLTMDIR}/visit${VISIT_VERSION}/build \
    && cd ${INSTALLTMDIR}/visit${VISIT_VERSION}/build \
    && sed -i "s|VISIT_OPTION_DEFAULT(VISIT_C_COMPILER ${GCC}|VISIT_OPTION_DEFAULT(VISIT_C_COMPILER ${MPICC}|g" ${INSTALLTMDIR}/$HOSTNAME_DOCKER.cmake \
    && sed -i "s|VISIT_OPTION_DEFAULT(VISIT_CXX_COMPILER ${GPP}|VISIT_OPTION_DEFAULT(VISIT_CXX_COMPILER ${MPICXX}|g" ${INSTALLTMDIR}/$HOSTNAME_DOCKER.cmake \
    && /usr/bin/cmake -DVISIT_CONFIG_SITE:FILEPATH=/home/docker/installdir/buildkitsandbox.cmake -DVISIT_INSTALL_THIRD_PARTY:BOOL=ON -DVISIT_PARALLEL:BOOL=ON -DCMAKE_BUILD_TYPE:STRING=Release -DVISIT_C_COMPILER:FILEPATH=${MPICC} -DVISIT_CXX_COMPILER:FILEPATH=${MPICXX}  -DVISIT_C_FLAGS:STRING=" -m64 -fPIC -I${INSTALL_PREFIX}/include" -DVISIT_CXX_FLAGS:STRING=" -m64 -fPIC -I${INSTALL_PREFIX}/include -Wno-class-memaccess -Wno-cast-function-type" -DCMAKE_INSTALL_PREFIX:PATH=${INSTALL_PREFIX}/visit -DCPACK_INSTALL_PREFIX:PATH=${INSTALL_PREFIX}/visit -DCPACK_PACKAGING_INSTALL_PREFIX:PATH=${INSTALL_PREFIX}/visit -DVISIT_SERVER_COMPONENTS_ONLY:BOOL=ON ../src  \
    && make -j${NUMCORES} \
    && touch ./resources/help/en_US/manual \
    && make install \
    || echo "We will try again 3" \
    && rm -fr ${INSTALLTMDIR} 
    
ENV PATH=${INSTALL_PREFIX}/visit/bin:${PATH}

RUN visit -env -engine > ~/tmp.txt \
   && sed -i 's|^|export |g' ~/tmp.txt \
   && sed -i 's|^export LD_LIBRARY_PATH.*|&$LD_LIBRARY_PATH|' ~/tmp.txt  \
   && cat ~/tmp.txt >> ~/.bashrc

CMD ["/bin/bash"]
