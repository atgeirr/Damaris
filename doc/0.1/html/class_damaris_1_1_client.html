<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Damaris: Damaris::Client Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_damaris.html">Damaris</a>::<a class="el" href="class_damaris_1_1_client.html">Client</a>
  </div>
</div>
<div class="contents">
<h1>Damaris::Client Class Reference</h1><!-- doxytag: class="Damaris::Client" -->
<p><code>#include &lt;<a class="el" href="_client_8hpp_source.html">Client.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for Damaris::Client:</div>
<div class="dynsection">
<div class="center"><img src="class_damaris_1_1_client__coll__graph.png" border="0" usemap="#_damaris_1_1_client_coll__map" alt="Collaboration graph"/></div>
<map name="_damaris_1_1_client_coll__map" id="_damaris_1_1_client_coll__map">
<area shape="rect" href="class_damaris_1_1_configuration.html" title="Damaris::Configuration" alt="" coords="5,5,157,35"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_damaris_1_1_client-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_damaris_1_1_client.html#a946ec9f1f78175a3f7323940535d5959">Client</a> (std::string *config, int32_t id)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. Initializes the client given the name of a configuration file and an ID. <a class="el" href="namespace_damaris.html">Damaris</a> won't check if two clients have the same ID so the user shoud be careful with that.  <a href="#a946ec9f1f78175a3f7323940535d5959"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_damaris_1_1_client.html#ae70b78cefbcbacd565f067cb0f51e5ed">write</a> (std::string *varname, int32_t iteration, const void *data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes some data. Writes a variable into shared memory and sends a message notifying the write to the dedicated core running on the same node. If the memory segment is full, this function will fail. If the message queue is full, this function will block.  <a href="#ae70b78cefbcbacd565f067cb0f51e5ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_damaris_1_1_client.html#a8e15db901b20c183684722bcf59b0334">signal</a> (std::string *signame, int32_t iteration)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends an event. Sends en event to the dedicated core running on the dedicated core. If the message queue is full, this function will block until it can send the event. If the event is not explicitely defined in the configuration file, it will be sent to the dedicated core but the dedicated core will ignore it.  <a href="#a8e15db901b20c183684722bcf59b0334"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_damaris_1_1_client.html#a9186fcaf05d953b364447565f145af1f">alloc</a> (std::string *varname, int32_t iteration)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">THIS FUNCTION IS NOT SUPPORTED YET. Allocates a buffer in shared memory so it can be written after by the simulation. Requires a call to commit to notify the dedicated core that the variable has been written.  <a href="#a9186fcaf05d953b364447565f145af1f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_damaris_1_1_client.html#a97fc61008e1f163ba448bf4d2a99794a">commit</a> (std::string *varname, int32_t iteration)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">THIS FUNCTION IS NOT SUPPORTED YET. Notifies the dedicated core that the previously allocated buffer has been written Blocks if the message queue is full.  <a href="#a97fc61008e1f163ba448bf4d2a99794a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_damaris_1_1_client.html#a36c3cd04f31e6dae81faa817830617e3">getParameter</a> (std::string *paramName, void *buffer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a parameter's value.  <a href="#a36c3cd04f31e6dae81faa817830617e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_damaris_1_1_client.html#afaf4b36790add7cd8a01913d26795bc0">~Client</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. To be called at the end of the before stopping the client program.  <a href="#afaf4b36790add7cd8a01913d26795bc0"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The <a class="el" href="class_damaris_1_1_client.html">Client</a> object represents a single core running the simulation. It is characterized by an ID and is initialized with the name of an XML configuration file. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a946ec9f1f78175a3f7323940535d5959"></a><!-- doxytag: member="Damaris::Client::Client" ref="a946ec9f1f78175a3f7323940535d5959" args="(std::string *config, int32_t id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Damaris::Client::Client </td>
          <td>(</td>
          <td class="paramtype">std::string *&nbsp;</td>
          <td class="paramname"> <em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. Initializes the client given the name of a configuration file and an ID. <a class="el" href="namespace_damaris.html">Damaris</a> won't check if two clients have the same ID so the user shoud be careful with that. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>config</em>&nbsp;</td><td>: name of an XML configuration file. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>id</em>&nbsp;</td><td>: id of the client (should be unique). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afaf4b36790add7cd8a01913d26795bc0"></a><!-- doxytag: member="Damaris::Client::~Client" ref="afaf4b36790add7cd8a01913d26795bc0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Damaris::Client::~Client </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. To be called at the end of the before stopping the client program. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a9186fcaf05d953b364447565f145af1f"></a><!-- doxytag: member="Damaris::Client::alloc" ref="a9186fcaf05d953b364447565f145af1f" args="(std::string *varname, int32_t iteration)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * Damaris::Client::alloc </td>
          <td>(</td>
          <td class="paramtype">std::string *&nbsp;</td>
          <td class="paramname"> <em>varname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>iteration</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>THIS FUNCTION IS NOT SUPPORTED YET. Allocates a buffer in shared memory so it can be written after by the simulation. Requires a call to commit to notify the dedicated core that the variable has been written. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>varname</em>&nbsp;</td><td>: name of the variable to write (must be defined in the configuration file). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>iteration</em>&nbsp;</td><td>: iteration at which the variable is written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the allocated memory in case of success, NULL in case of failure (variable not defined, allocation error). </dd></dl>

</div>
</div>
<a class="anchor" id="a97fc61008e1f163ba448bf4d2a99794a"></a><!-- doxytag: member="Damaris::Client::commit" ref="a97fc61008e1f163ba448bf4d2a99794a" args="(std::string *varname, int32_t iteration)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Damaris::Client::commit </td>
          <td>(</td>
          <td class="paramtype">std::string *&nbsp;</td>
          <td class="paramname"> <em>varname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>iteration</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>THIS FUNCTION IS NOT SUPPORTED YET. Notifies the dedicated core that the previously allocated buffer has been written Blocks if the message queue is full. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>varname</em>&nbsp;</td><td>: name of the variable to notify (must have been previously allocated). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>iteration</em>&nbsp;</td><td>: iteration of the associated variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 in case of success, -1 in case of failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a36c3cd04f31e6dae81faa817830617e3"></a><!-- doxytag: member="Damaris::Client::getParameter" ref="a36c3cd04f31e6dae81faa817830617e3" args="(std::string *paramName, void *buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Damaris::Client::getParameter </td>
          <td>(</td>
          <td class="paramtype">std::string *&nbsp;</td>
          <td class="paramname"> <em>paramName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves a parameter's value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>paramName</em>&nbsp;</td><td>: name of the parameter to retrieve. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>buffer</em>&nbsp;</td><td>: pointer to the memory where to copy the parameter's value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 in case of success, -1 if the parameter is not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a8e15db901b20c183684722bcf59b0334"></a><!-- doxytag: member="Damaris::Client::signal" ref="a8e15db901b20c183684722bcf59b0334" args="(std::string *signame, int32_t iteration)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Damaris::Client::signal </td>
          <td>(</td>
          <td class="paramtype">std::string *&nbsp;</td>
          <td class="paramname"> <em>signame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>iteration</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends an event. Sends en event to the dedicated core running on the dedicated core. If the message queue is full, this function will block until it can send the event. If the event is not explicitely defined in the configuration file, it will be sent to the dedicated core but the dedicated core will ignore it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>signam</em>&nbsp;</td><td>: name of the event to send. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>iteration</em>&nbsp;</td><td>: iteration associated to the event.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 in case of success, -1 in case of failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ae70b78cefbcbacd565f067cb0f51e5ed"></a><!-- doxytag: member="Damaris::Client::write" ref="ae70b78cefbcbacd565f067cb0f51e5ed" args="(std::string *varname, int32_t iteration, const void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Damaris::Client::write </td>
          <td>(</td>
          <td class="paramtype">std::string *&nbsp;</td>
          <td class="paramname"> <em>varname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>iteration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes some data. Writes a variable into shared memory and sends a message notifying the write to the dedicated core running on the same node. If the memory segment is full, this function will fail. If the message queue is full, this function will block. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>varname</em>&nbsp;</td><td>: name of the variable to write. This variable should be defined in the XML configuration. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>iteration</em>&nbsp;</td><td>: iteration number for this write. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>: pointer to the data to be copied to the shared memory buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 in case of success, -1 if the layout or the variable has not been defined, -2 if the layout has a bad size (0 or &lt; 0), -3 if the allocation of memory failed (not enough memory). </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>client/<a class="el" href="_client_8hpp_source.html">Client.hpp</a></li>
<li>client/<a class="el" href="_client_8cpp.html">Client.cpp</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address style="text-align: right;"><small>Generated on Thu Jul 7 12:32:04 2011 for Damaris by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
