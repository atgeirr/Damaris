<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Damaris: Damaris::Client Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_damaris.html">Damaris</a>::<a class="el" href="class_damaris_1_1_client.html">Client</a>
  </div>
</div>
<div class="contents">
<h1>Damaris::Client Class Reference</h1><!-- doxytag: class="Damaris::Client" -->
<p><code>#include &lt;<a class="el" href="_client_8hpp_source.html">Client.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for Damaris::Client:</div>
<div class="dynsection">
<div class="center"><img src="class_damaris_1_1_client__coll__graph.png" border="0" usemap="#_damaris_1_1_client_coll__map" alt="Collaboration graph"/></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_damaris_1_1_client-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_damaris_1_1_client.html#a9191482c0cb126869fb282a00cd30ad9">Client</a> (const std::string &amp;config, int32_t id)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. Initializes the client given the name of a configuration file and an ID. <a class="el" href="namespace_damaris.html">Damaris</a> won't check if two clients have the same ID so the user shoud be careful with that.  <a href="#a9191482c0cb126869fb282a00cd30ad9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_damaris_1_1_client.html#a2b517559def36005141b3a0ce7011474">Client</a> (<a class="el" href="class_damaris_1_1_configuration.html">Configuration</a> *config, <a class="el" href="class_damaris_1_1_environment.html">Environment</a> *env)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. This constructor is used to start a client using <a class="el" href="namespace_damaris.html#ab0fceafc984fa211276586249e37565c">Damaris::start_mpi_entity</a>.  <a href="#a2b517559def36005141b3a0ce7011474"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_damaris_1_1_client.html#a21cfc7b0548194d5d5cc46ceb55aa787">write</a> (const std::string &amp;varname, int32_t iteration, const void *data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a full variable. Writes a variable into shared memory and sends a message notifying the write to the dedicated core running on the same node. If the memory segment is full, this function will fail. If the message queue is full, this function will block.  <a href="#a21cfc7b0548194d5d5cc46ceb55aa787"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_damaris_1_1_client.html#a28b90f5c8cb30cc31c2a0e1c25fcb2cc">chunk_write</a> (<a class="el" href="class_damaris_1_1_chunk_handle.html">chunk_h</a> chunkh, const std::string &amp;varname, int32_t iteration, const void *data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a chunk of a variable. Checks that the chunk is within the bound of the variable's layout first.  <a href="#a28b90f5c8cb30cc31c2a0e1c25fcb2cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_damaris_1_1_client.html#aff5625c658fe30bebd51d35dc22c0b4a">signal</a> (const std::string &amp;signame, int32_t iteration)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends an event. Sends en event to the dedicated core running on the dedicated core. If the message queue is full, this function will block until it can send the event. If the event is not explicitely defined in the configuration file, it will be ignored.  <a href="#aff5625c658fe30bebd51d35dc22c0b4a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_damaris_1_1_client.html#acb4206815b0157ea6676848701887833">alloc</a> (const std::string &amp;varname, int32_t iteration)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a buffer directly in shared memory for future writing. Allocates a buffer in shared memory so it can be written after by the simulation. Requires a call to commit to notify the dedicated core that the variable has been written.  <a href="#acb4206815b0157ea6676848701887833"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_damaris_1_1_client.html#a220b1de2724dedd6c4ee8f82b858cc87">commit</a> (const std::string &amp;varname, int32_t iteration)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Commit a variable. Notifies the dedicated core that the previously allocated buffer has been written Blocks if the message queue is full.  <a href="#a220b1de2724dedd6c4ee8f82b858cc87"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_damaris_1_1_chunk_handle.html">chunk_h</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_damaris_1_1_client.html#a7a398af375324c3e9a817b4b5147b450">chunk_set</a> (unsigned int dimensions, const std::vector&lt; int &gt; &amp;startIndices, const std::vector&lt; int &gt; &amp;endIndices)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Defines a chunk. The representation of the chunk is as in Fortran, given boundaries.  <a href="#a7a398af375324c3e9a817b4b5147b450"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_damaris_1_1_client.html#a5499e536cbd3bd15eac957049e8267b1">chunk_free</a> (<a class="el" href="class_damaris_1_1_chunk_handle.html">chunk_h</a> chunkh)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a chunk handle.  <a href="#a5499e536cbd3bd15eac957049e8267b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_damaris_1_1_client.html#af7293db04eeccc10b4bfe6eebbaa8989">get_parameter</a> (const std::string &amp;paramName, void *buffer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a parameter's value. Not implemented yet.  <a href="#af7293db04eeccc10b4bfe6eebbaa8989"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_damaris_1_1_client.html#a862597d7257db6aa108f643bfdbcd452">kill_server</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_damaris_1_1_client.html#afaf4b36790add7cd8a01913d26795bc0">~Client</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. To be called at the end of the before stopping the client program.  <a href="#afaf4b36790add7cd8a01913d26795bc0"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The <a class="el" href="class_damaris_1_1_client.html">Client</a> object represents a single core running the simulation. It is characterized by an ID and is initialized with the name of an XML configuration file. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9191482c0cb126869fb282a00cd30ad9"></a><!-- doxytag: member="Damaris::Client::Client" ref="a9191482c0cb126869fb282a00cd30ad9" args="(const std::string &amp;config, int32_t id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Damaris::Client::Client </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. Initializes the client given the name of a configuration file and an ID. <a class="el" href="namespace_damaris.html">Damaris</a> won't check if two clients have the same ID so the user shoud be careful with that. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>config</em>&nbsp;</td><td>: name of an XML configuration file. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>id</em>&nbsp;</td><td>: id of the client (should be unique). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2b517559def36005141b3a0ce7011474"></a><!-- doxytag: member="Damaris::Client::Client" ref="a2b517559def36005141b3a0ce7011474" args="(Configuration *config, Environment *env)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Damaris::Client::Client </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_damaris_1_1_configuration.html">Configuration</a> *&nbsp;</td>
          <td class="paramname"> <em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_damaris_1_1_environment.html">Environment</a> *&nbsp;</td>
          <td class="paramname"> <em>env</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. This constructor is used to start a client using <a class="el" href="namespace_damaris.html#ab0fceafc984fa211276586249e37565c">Damaris::start_mpi_entity</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>config</em>&nbsp;</td><td>: <a class="el" href="class_damaris_1_1_configuration.html">Configuration</a> object (initialized). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>env</em>&nbsp;</td><td>: <a class="el" href="class_damaris_1_1_environment.html">Environment</a> object (initialized). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afaf4b36790add7cd8a01913d26795bc0"></a><!-- doxytag: member="Damaris::Client::~Client" ref="afaf4b36790add7cd8a01913d26795bc0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Damaris::Client::~Client </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. To be called at the end of the before stopping the client program. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="acb4206815b0157ea6676848701887833"></a><!-- doxytag: member="Damaris::Client::alloc" ref="acb4206815b0157ea6676848701887833" args="(const std::string &amp;varname, int32_t iteration)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * Damaris::Client::alloc </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>varname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>iteration</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a buffer directly in shared memory for future writing. Allocates a buffer in shared memory so it can be written after by the simulation. Requires a call to commit to notify the dedicated core that the variable has been written. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>varname</em>&nbsp;</td><td>: name of the variable to write (must be defined in the configuration file). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>iteration</em>&nbsp;</td><td>: iteration at which the variable is written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the allocated memory in case of success, NULL in case of failure (variable not defined, allocation error). </dd></dl>

</div>
</div>
<a class="anchor" id="a5499e536cbd3bd15eac957049e8267b1"></a><!-- doxytag: member="Damaris::Client::chunk_free" ref="a5499e536cbd3bd15eac957049e8267b1" args="(chunk_h chunkh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Damaris::Client::chunk_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_damaris_1_1_chunk_handle.html">chunk_h</a>&nbsp;</td>
          <td class="paramname"> <em>chunkh</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free a chunk handle. </p>

</div>
</div>
<a class="anchor" id="a7a398af375324c3e9a817b4b5147b450"></a><!-- doxytag: member="Damaris::Client::chunk_set" ref="a7a398af375324c3e9a817b4b5147b450" args="(unsigned int dimensions, const std::vector&lt; int &gt; &amp;startIndices, const std::vector&lt; int &gt; &amp;endIndices)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_damaris_1_1_chunk_handle.html">chunk_h</a> Damaris::Client::chunk_set </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>startIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>endIndices</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Defines a chunk. The representation of the chunk is as in Fortran, given boundaries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>: type of the chunk. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dimensions</em>&nbsp;</td><td>: number of dimensions. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>startIndices</em>&nbsp;</td><td>: start indices. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>endIndices</em>&nbsp;</td><td>: end indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A chunk handle. Call chunk_free to free the chunk handle. </dd></dl>

</div>
</div>
<a class="anchor" id="a28b90f5c8cb30cc31c2a0e1c25fcb2cc"></a><!-- doxytag: member="Damaris::Client::chunk_write" ref="a28b90f5c8cb30cc31c2a0e1c25fcb2cc" args="(chunk_h chunkh, const std::string &amp;varname, int32_t iteration, const void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Damaris::Client::chunk_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_damaris_1_1_chunk_handle.html">chunk_h</a>&nbsp;</td>
          <td class="paramname"> <em>chunkh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>varname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>iteration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes a chunk of a variable. Checks that the chunk is within the bound of the variable's layout first. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>varname</em>&nbsp;</td><td>: name of the variable to write in. This variable should be defined in the XML configuration. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>iteration</em>&nbsp;</td><td>: iteration number for this write. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>chunkh</em>&nbsp;</td><td>: handle of a pre-defined chunk. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>: pointer to the data to be written in the shared memory buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the amount of bytes written in case of success, -1 if the variable has not been defined, -2 if the allocation of memory failed, -3 if the chunk has an inapropriate shape. </dd></dl>

</div>
</div>
<a class="anchor" id="a220b1de2724dedd6c4ee8f82b858cc87"></a><!-- doxytag: member="Damaris::Client::commit" ref="a220b1de2724dedd6c4ee8f82b858cc87" args="(const std::string &amp;varname, int32_t iteration)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Damaris::Client::commit </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>varname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>iteration</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Commit a variable. Notifies the dedicated core that the previously allocated buffer has been written Blocks if the message queue is full. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>varname</em>&nbsp;</td><td>: name of the variable to notify (must have been previously allocated). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>iteration</em>&nbsp;</td><td>: iteration of the associated variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 in case of success, -1 if the variable hasn't been allocated. </dd></dl>

</div>
</div>
<a class="anchor" id="af7293db04eeccc10b4bfe6eebbaa8989"></a><!-- doxytag: member="Damaris::Client::get_parameter" ref="af7293db04eeccc10b4bfe6eebbaa8989" args="(const std::string &amp;paramName, void *buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Damaris::Client::get_parameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>paramName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves a parameter's value. Not implemented yet. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>paramName</em>&nbsp;</td><td>: name of the parameter to retrieve. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>buffer</em>&nbsp;</td><td>: pointer to the memory where to copy the parameter's value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 in case of success, -1 if the parameter is not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a862597d7257db6aa108f643bfdbcd452"></a><!-- doxytag: member="Damaris::Client::kill_server" ref="a862597d7257db6aa108f643bfdbcd452" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Damaris::Client::kill_server </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sends a signal to the server to shut it down (all clients in node need to call this function before the server is actually killed. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 in case of success, -1 in case of failure. </dd></dl>

</div>
</div>
<a class="anchor" id="aff5625c658fe30bebd51d35dc22c0b4a"></a><!-- doxytag: member="Damaris::Client::signal" ref="aff5625c658fe30bebd51d35dc22c0b4a" args="(const std::string &amp;signame, int32_t iteration)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Damaris::Client::signal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>signame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>iteration</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends an event. Sends en event to the dedicated core running on the dedicated core. If the message queue is full, this function will block until it can send the event. If the event is not explicitely defined in the configuration file, it will be ignored. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>signam</em>&nbsp;</td><td>: name of the event to send. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>iteration</em>&nbsp;</td><td>: iteration associated to the event.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 in case of success, -1 in case of failure when sending the message, -2 in case the event is not defined. </dd></dl>

</div>
</div>
<a class="anchor" id="a21cfc7b0548194d5d5cc46ceb55aa787"></a><!-- doxytag: member="Damaris::Client::write" ref="a21cfc7b0548194d5d5cc46ceb55aa787" args="(const std::string &amp;varname, int32_t iteration, const void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Damaris::Client::write </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>varname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>iteration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes a full variable. Writes a variable into shared memory and sends a message notifying the write to the dedicated core running on the same node. If the memory segment is full, this function will fail. If the message queue is full, this function will block. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>varname</em>&nbsp;</td><td>: name of the variable to write. This variable should be defined in the XML configuration. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>iteration</em>&nbsp;</td><td>: iteration number for this write. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>: pointer to the data to be copied to the shared memory buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the amount of bytes written in case of success, -1 if the variable has not been defined, -2 if the allocation of memory failed. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_client_8hpp_source.html">Client.hpp</a></li>
<li><a class="el" href="_client_8cpp.html">Client.cpp</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address style="text-align: right;"><small>Generated on Thu Oct 27 16:03:13 2011 for Damaris by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
