Writing data to \Damaris{} is cool, but what should the server do with that? For now the shared memory
buffer will simply get quickly filled and future write operations will fail. The role of processing data
(and removing them from the shared memory) is delegated to plugins, which are triggered by events
sent by the simulation to the servers.
This section explains how to program a plugin for \Damaris{} and how to trigger it from the simulation.

%==============================================================================%
%==============================================================================%
\section{Describing actions}

The interactions between the simulation processes and the dedicated cores are based on events.
These events are sent by simulation processes to the servers.
Like other \Damaris{} objects, these events have to be described in the XML configuration file,
more specifically within the \texttt{<actions>} section.
Listing~\ref{actionXML} presents the description of such an \texttt{event}.
An \texttt{event} is described by a unique \texttt{name}, and an \texttt{action}, which corresponds to
the name of a C++ function. If this function is located in a shared \texttt{library} (.so file), the name
of the library has to be provided. \Damaris{} will look for shared libraries within the directories
specified by the LD\_LIBRARY\_PATH environment variable. If no library is specified, \Damaris{}
will look for the function within its own binary code.
Finally one important characteristic of events is the \texttt{scope}:
\begin{itemize}
	\item \textbf{``core''} indicates that every time a simulation process sends the event, the
	corresponding action is triggered by the the server receiving the event. If 15 clients 
	in a 16-cores node send the same event to their server running on a dedicated core, 
	the corresponding action is triggered 16 times within the server.
	\item \textbf{``group''} indicates that a server has to wait for all its clients to have sent
	the same event (at the same iteration) before triggering the action. If the 15 clients
	send the event, the action is triggered only once. If one of the processes does not send the
	event, the corresponding action is never triggered.
	\item \textbf{``bcast''} indicates that if one client sends this signal, then all the servers 
	will perform the corresponding action, not only the server responsible for this
	client. MPI communications can safely be used within an action triggered by such an event.
	It is thus the right type of event to use if the plugin is collective across servers.
\end{itemize}

\noindent\begin{minipage}{\textwidth}
\vspace{0.5cm}
\lstset{language=XML,caption={Actions description},label=actionXML}
\lstinputlisting[language=XML]{listings/action.xml}
\end{minipage}

The semantics of these scopes with respect to the order of triggered actions is the following.
\begin{itemize}
\item Two ``core'' events sent by the same process will be received in the same order by the dedicated core.
\item If an event (whatever the scope) is sent after writing or committing a variable, it is ensured that the
server has received the variable before triggering the event's action.
\item Two ``group'' events sent by all the clients of a group in the same order will trigger their actions in
the same order in the server. No particular order should be assumed if different processes send the
same event in a different order.
\item Two ``bcast'' events sent by the same client will trigger their actions
in the same order in all the servers. No particular order should be assumed if different processes send
the a ``bcast'' event.
\item If a client sends two events $e_1$ and $e_2$, if $e_1$ has a ``core'' scope 
then it is ensured that its corresponding action will be executed before the action of 
$e_2$. 
\item However, if $e_1$ has another scope than ``core'', no ordering can be assumed.
\item To force an ordered execution of $e_1$ and $e_2$ where the scope of $e_1$ is not ``core'',
global synchronization barriers can be used in the simulation before sending $e_2$.
\end{itemize}

%==============================================================================%
%==============================================================================%
\section{\emph{Hello World!} plugin example}

Now let's take a look at a C++ function that can be called by \Damaris. An example of such a function
is provided in Listing~\ref{PluginCPP}. Note the use of \texttt{extern "C"} to prevent C++ name mangling.

\noindent\begin{minipage}{\textwidth}
\vspace{0.5cm}
\lstset{language=C++,caption={Example \Damaris{} plugin},label=PluginCPP}
\lstinputlisting[language=C++]{listings/plugin.cpp}
\end{minipage}

The first argument of such a function is a string representing the name of the event that triggered
the action (since several events can be connected to the same action). The second parameter
corresponds to the iteration at which the event has been sent. The third parameter is the rank
of the client that sent the event. For ``group'' actions, this source is set to $-1$.
Finally the last argument is only used by external plugins to send their own commands.

This first example only helps you start with plugins, more consideration on how to
access the data written by clients will be provided in Section~\ref{sec:internalAPI}.

%==============================================================================%
%==============================================================================%
\section{Compiling and linking C/C++ plugins}

To compile a plugin within a shared library, 
you need to create an object file from your source file with the -fPIC option,
then create a shared library:
\begin{verbatim}
g++ -fPIC -c something.cpp -I/path/to/damaris/include -I/path/to/damaris/dependencies/include
gcc -shared -Wl,-soname,libsomething.so -o libsomething.so something.o
\end{verbatim}

If you want to integrate your plugin in the application's code (for instance to avoid
loading the .so file from many processes at the same time, which could result in performance
degradation at large scale), simply compile the source of your plugin with your application. You must
dynamically link your simulation when compiling it.

%==============================================================================%
%==============================================================================%

\section{Sending events from the simulation}

To send events from the simulation, use the \function{damaris\_signal} function (in C) or \function{damaris\_signal\_f}
(in Fortran). These functions take the name of an event as parameter; this name should correspond to
an event described in the configuration file.

\noindent\begin{minipage}{\textwidth}
\vspace{0.5cm}
\lstset{language=C,caption={Sending events from a C program},label=EventC}
\lstinputlisting[language=C]{listings/event.c}
\end{minipage}

\noindent\begin{minipage}{\textwidth}
%\vspace{0.5cm}
\lstset{language=fortran,caption={Sending events from a Fortran program},label=EventF90}
\lstinputlisting[language=fortran]{listings/event.f90}
\end{minipage}

The prototype of these two functions are summarized in Table~\ref{tab:signalFunctions}. The returned
value (or the \emph{ierr} value in Fortran) is 0 in case of success, -1 in case of failure when sending the
event through the shared memory, and -2 if the name does not correspond to a defined event.

\begin{table}[h]
\centering
\begin{tabular}{|l|}
	\hline
   \textbf{C function} \\
   \hline
   \hline
   \function{int damaris\_signal(const char* event)}  \\
   \hline
   \hline
   \textbf{Fortran function} \\
   \hline
   \hline
   \function{damaris\_signal\_f(character* event, integer ierr)} \\
   \hline
\end{tabular}\caption{\Damaris{} signal functions}\label{tab:signalFunctions}
\end{table}

\section{Binding simulation's functions to events}

On some platforms, the \texttt{dlopen} function does not properly work, which prevents \Damaris{} from
being able to retrieve the plugin. In this case, another solution consists of providing the function's pointer
at run time.

To do so, \emph{all} the processes must call \texttt{damaris\_bind\_function(``event name'',function\_ptr)} \emph{before}
calling \texttt{damaris\_start} (so that both clients and servers are aware of the event), 
and in the \emph{same order} if multiple events are defined this way. 
The first argument to this function is the name of the event to define,
the second one is the pointer to a function that has the following signature, defined in Damaris.h:
\begin{verbatim}
typedef (*signal_t)(const char*,int32_t,int32_t,const char*);	
\end{verbatim}

This method is experimental, currently only available in C, and allows only a ``core'' scope. 
Besides, the event \emph{should not} be already defined in the configuration file.

%==============================================================================%
%==============================================================================%
\section{The internal \Damaris{} API}\label{sec:internalAPI}

In order to access the data from within a plugin, you will have to used \Damaris' data structures.
The main structure is the \texttt{VariableManager}, which can be used to access \texttt{Variable} instances
and, from there, \texttt{Block} instances (which correspond to our notion of ``domains''), and \texttt{DataSpace}
instances, which hold data.
We invite the reader to refer to the Doxygen documentation of
\Damaris, which we hope is complete enough to understand how to retrieve data,
and to post requests on the \Damaris{} mailing list if you need any help.

\vspace{0.5cm}

\noindent\textbf{Note:} To use the internal structures and objects of \Damaris, it is necessary
to include the proper header files. These header files have been installed in a \texttt{damaris} folder
in the \texttt{include} folder where \Damaris{} was installed.

\section{Error handling through events}

If the simulation did not manage to write all its data for a
given iteration, a special signal is send to all the servers to ask them not to update
visualization backends and to erase all remaining data for this iteration and all past iterations.
This behavior can be overwritten by attaching an error handler to an event,
as exemplified in the following XML codes. The event \emph{must} have a \textbf{``core''} scope,
and the event or script must be defined somewhere in the configuration file.

\noindent\begin{minipage}{\textwidth}
\vspace{0.5cm}
\lstset{language=XML,caption={XML information to attach an event to errors.},label=errorXML}
\lstinputlisting[language=XML]{listings/errorevent.xml}
\end{minipage}